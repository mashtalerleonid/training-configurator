if (! R2D) R2D = {};

R2D.PlannerCore = function() {

    console.printModule('designer');

    if( !R2D.detectWebGL() ) { // "WebGL is not supported"
        throw new Error('WebGL is not supported');
    }

    var me = this;

    R2D.config = new R2D.Config();

    var width = 800;
    var height = 600;
    var viewersContainer = document.createElement('div');
    viewersContainer.style.display = 'inline-block';
    viewersContainer.style.position = 'absolute';
    viewersContainer.style.padding = '0';

    viewersContainer.addEventListener('wheel', function(event){
        event.stopPropagation();
        event.preventDefault();
    }, false);

    R2D.DimensionSystem.setSystem(R2D.DimensionSystem.METRIC_CM);

    R2D.createPlannerAPI(me); // me.apiScene, me.apiView2d, me.apiView3d, me.apiViewWalk, me.apiConstr

    R2D.Viewers.init(viewersContainer, true);

    R2D.default = new R2D.Default();
    R2D.scene = R2D.Scene.init(me.apiScene);
    R2D.controller = new R2D.Controller(R2D.scene, me.apiScene);
    R2D.scene3d = new R2D.Scene3D(me.apiScene);
    R2D.sharedRenderer = new R2D.Renderer3D(R2D.scene3d);
    R2D.commonSceneObject = new R2D.CommonSceneObject(R2D.scene, R2D.scene3d);
    R2D.commonSceneHelper = new R2D.CommonSceneHelper(R2D.commonSceneObject);
    R2D.mouseInteractionHelper = R2D.MouseInteractionHelper.init(R2D.commonSceneObject, R2D.commonSceneHelper, me.apiScene);
    R2D.keyboardInteractionHelper = new R2D.KeyboardInteractionHelper(R2D.commonSceneObject, R2D.commonSceneHelper, me.apiScene);
    R2D.viewConstructor = WC.WallsEditor.init(new R2D.ViewerData(null /*was icon*/, document.createElement('div'), 'HINT_BUTTON_CONSTRUCTOR'), R2D.scene, me.apiConstr);
    R2D.view2d = R2D.ViewerScene2D.init(R2D.sharedRenderer, R2D.commonSceneHelper, R2D.mouseInteractionHelper, R2D.keyboardInteractionHelper, me.apiScene);
    R2D.view3d = new R2D.ViewerScene3D(R2D.sharedRenderer, R2D.commonSceneHelper, R2D.mouseInteractionHelper, R2D.keyboardInteractionHelper);
    R2D.viewWalk = new R2D.ViewerSceneWalk(R2D.sharedRenderer, R2D.commonSceneHelper, R2D.mouseInteractionHelper, R2D.keyboardInteractionHelper);

    R2D.catalogMaterials = null;
    R2D.catalogProducts = null;
    R2D.customRegistration = null;



    R2D.setCatalogMaterials = catalog => R2D.catalogMaterials = catalog;
    R2D.getCatalogMaterials = () => R2D.catalogMaterials;

    R2D.setCatalogProducts = products => R2D.catalogProducts = products;
    R2D.getCatalogProducts = () => R2D.catalogProducts;

    R2D.setCustomRegistration = customRegistration => R2D.customRegistration = customRegistration;
    R2D.getCustomRegistration = () => R2D.customRegistration;

    R2D.loadCustomRegistration = async () => {
        return new Promise(resolve => {
            var url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_GET_CUSTOM_REGISTRATION);

            loader = new R2D.XHRLoader();

            loader.addEventListener(Event.COMPLETE, loaderGetListener);
            loader.addEventListener(Event.ERROR, loaderGetListener);
            loader.load(url, null, 'GET', null, null, true);

            function loaderGetListener(e) {

                loader.removeEventListener(Event.COMPLETE, loaderGetListener);
                loader.removeEventListener(Event.ERROR, loaderGetListener);

                var data = e.data.data;
                var object = null;

                try {
                    object = JSON.parse(data);
                } catch ( error ) {
                    console.error('Error parse JSON string!');
                    console.log(data);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }

                if ( !object.hasOwnProperty('status') ) {
                    console.error('Error! Received data has no property "status"!');
                    console.log(object);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }
                if ( object['status'] != 'success' ) {
                    console.error('Error! Received data status is not "success"!');
                    console.log(object);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }
                if ( !object.hasOwnProperty('data') ) {
                    console.error('Error! Received data has no property "list"!');
                    console.log(object);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }

                R2D.setCustomRegistration(object.data);

                resolve(object);
            }

        })
    };

    R2D.sendRequestToCalc = async formData => {
        return new Promise(resolve => {
            
            var planData = R2D.controller.getObjData().plan ? R2D.controller.getObjData() : { plan: R2D.controller.getObjData() };
            var sendObj = {json: JSON.stringify({...planData, register: formData})};

            var params = R2D.XHRLoader.makeParamsString(sendObj);
            var loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_SEND_PROJECT_CALC), params, null, null, true);

            loader.addEventListener(Event.COMPLETE, sendCompleteListener);
            loader.addEventListener(Event.ERROR, sendErrorListener);
        
            function sendCompleteListener(e) {
                
                var dataObj;
                try {
                    dataObj = JSON.parse(e.data.data);
                } catch ( error ) {
                    console.error('Error parse JSON string!');
                    console.log(e.data.data);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }
                if ( !dataObj.hasOwnProperty('status') ) {
                    console.error('Error! Received data has no property "status"!');
                    console.log(dataObj);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }
                if ( dataObj['status'] != 'success' ) {
                    console.error('Error! Received data status is not "success"!');
                    console.log(dataObj);
                    return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
                }
                resolve(dataObj);
            }

            function sendErrorListener(e) {
                console.error(e);
                return resolve({type: "error", data: "TEXT_ERROR_LOAD_DATA"});
            }
        })
    };

    R2D.Viewers.add(R2D.viewConstructor);
    R2D.Viewers.add(R2D.view2d);
    R2D.Viewers.add(R2D.view3d);
    R2D.Viewers.add(R2D.viewWalk);
    R2D.Viewers.enableViewer(2);
    
    console.printModule('designer55');

    me.init = function()
    {
        return new Promise((resolve, reject) => {
            R2D.config.update(() => {
                if(R2D.config.data.default_materials) {
                    R2D.default.setDefaultMaterials(R2D.config.data.default_materials);

                    R2D.scene.getConstructor().cap.materialID = R2D.default.getDefaultMaterialByKey("cap");
                    R2D.scene.getConstructor().cap.addMaterialID = R2D.default.getDefaultAddMaterialByKey("cap");

                    R2D.scene.getConstructor().cap.build3D();

                    WC.plinthCreator = new PlinthCreator();
                }
                resolve();
            });
        })
    };

    me.setSize = function(width, height)
    {
        R2D.Viewers.setSize(width, height);
        viewersContainer.style.width = width + 'px';
        viewersContainer.style.height = height + 'px';

        if ( R2D.mouseInteractionHelper )
        {
            R2D.mouseInteractionHelper.setSize(width, height);
        }
    };

    me.getDomElement = function()
    {
        return viewersContainer;
    };
};

R2D.CustomUploader = function()
{
    var me = this;
    EventDispatcher.call(me);

    me.uploadPoster = function(srcFile, srcPrev, width, height, categoryId, callback)
    {
        var posterCreator;
        var srcScaledPrev;

        cratePreview();

        function cratePreview()
        {
            var prevSize = 240;
            var image = new Image();
            image.onload = function() {
                var w, h;
                if (image.width > image.height)
                {
                    w = prevSize;
                    h = prevSize / image.width * image.height;
                }
                else
                {
                    h = prevSize;
                    w = prevSize / image.height * image.width;
                }

                var canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(image, 0, 0, w, h);

                srcScaledPrev = canvas.toDataURL();

                startCreateData();
            };
            image.src = srcPrev
        }

        function startCreateData()
        {
            posterCreator = new R2D.PosterCreator();
            posterCreator.addEventListener(Event.READY, creatorReadyListener);

            posterCreator.addEventListener(Event.ERROR, errorListener);
            posterCreator.addEventListener(R2D.PosterCreator.ERROR_CREATING_IN_PROCESS, errorInProcessListener);
            posterCreator.addEventListener(R2D.PosterCreator.ERROR_EMPTY_POSTER, errorEmptyListener);
            posterCreator.addEventListener(R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE, packageCompleteListener);
        }

        function creatorReadyListener()
        {
            posterCreator.removeEventListener(Event.READY, creatorReadyListener);
            posterCreator.addEventListener(Event.UPDATE, updateListener);
            posterCreator.setMaterialSizeCM(width, height);
            posterCreator.diffuse = srcFile;
        }
        function updateListener()
        {
            posterCreator.removeEventListener(Event.UPDATE, updateListener);
            posterCreator.createData();

        }
        function errorListener(e)
        {
            console.log('Error: ', e);
        }
        function errorInProcessListener(e)
        {
            console.log('Error in process: ', e);
        }
        function errorEmptyListener(e)
        {
            console.log('Error empty: ', e);
        }
        function packageCompleteListener(e)
        {
            var reader = new FileReader();
            reader.addEventListener("load", fileReaderLoadListener);
            reader.readAsDataURL(e.data.package);
        }

        function fileReaderLoadListener(e)
        {
            var params = R2D.XHRLoader.makeParamsString({
                category_id: categoryId,
                type_id: R2D.CustomUploader.UPLOAD_POSTER,
                source: e.target.result.split(',')[1],
                preview: srcScaledPrev.split(',')[1],
                width: width,
                height: height,
                depth: 2
            });

            var loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_PRIVATE), params, null, null, true);

            loader.addEventListener(Event.COMPLETE, loaderEventHandler);
            loader.addEventListener(Event.ERROR, loaderEventHandler);
        }

        function loaderEventHandler(e)
        {
            if (e.type == Event.COMPLETE)
            {
                if (callback) callback(e.data.data);
            }
        }
    };

    me.uploadCarpet = function(srcFile, srcPrev, width, height, categoryId, callback)
    {
        var creator;
        var srcScaledPrev;

        cratePreview();

        function cratePreview()
        {
            var prevSize = 240;
            var image = new Image();
            image.onload = function() {
                var w, h;
                if (image.width > image.height)
                {
                    w = prevSize;
                    h = prevSize / image.width * image.height;
                }
                else
                {
                    h = prevSize;
                    w = prevSize / image.height * image.width;
                }

                var canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(image, 0, 0, w, h);

                srcScaledPrev = canvas.toDataURL();

                startCreateData();
            };
            image.src = srcPrev
        }

        function startCreateData()
        {
            creator = new R2D.CarpetCreator();
            creator.addEventListener(Event.READY, creatorReadyListener);

            creator.addEventListener(Event.ERROR, errorListener);
            creator.addEventListener(R2D.CarpetCreator.ERROR_CREATING_IN_PROCESS, errorInProcessListener);
            creator.addEventListener(R2D.CarpetCreator.ERROR_EMPTY_CARPET, errorEmptyListener);
            creator.addEventListener(R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE, packageCompleteListener);
        }

        function creatorReadyListener()
        {
            creator.removeEventListener(Event.READY, creatorReadyListener);
            creator.addEventListener(Event.UPDATE, updateListener);
            creator.setMaterialSizeCM(width, height);
            creator.diffuse = srcFile;
        }
        function updateListener()
        {
            creator.removeEventListener(Event.UPDATE, updateListener);
            creator.createData();
        }
        function errorListener(e)
        {
            console.log('Error: ', e);
        }
        function errorInProcessListener(e)
        {
            console.log('Error in process: ', e);
        }
        function errorEmptyListener(e)
        {
            console.log('Error empty: ', e);
        }
        function packageCompleteListener(e)
        {
            var reader = new FileReader();
            reader.addEventListener("load", fileReaderLoadListener);
            reader.readAsDataURL(e.data.package);
        }

        function fileReaderLoadListener(e)
        {
            var coverHeight = Math.round(Math.min(width, height) / 60);
            // if (coverHeight < 2) coverHeight = 2;
            coverHeight = 1;

            var params = R2D.XHRLoader.makeParamsString({
                category_id: categoryId,
                type_id: R2D.CustomUploader.UPLOAD_CARPET,
                source: e.target.result.split(',')[1],
                preview: srcScaledPrev.split(',')[1],
                width: width,
                height: coverHeight,
                depth: height
            });

            var loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_PRIVATE), params, null, null, true);

            loader.addEventListener(Event.COMPLETE, loaderEventHandler);
            loader.addEventListener(Event.ERROR, loaderEventHandler);
        }

        function loaderEventHandler(e)
        {
            console.log(e);
            if (e.type == Event.COMPLETE)
            {
                if (callback) callback(e.data.data);
            }
        }
    };

    me.uploadMaterial = function(srcFile, srcPrev, width, height, categoryId, callback, uploadType, toBank)
    {
        var creator;
        var srcScaledPrev;

        cratePreview();

        function cratePreview()
        {
            var prevSize = 240;
            var image = new Image();
            image.onload = function() {
                var w, h;
                if (image.width > image.height)
                {
                    w = prevSize;
                    h = prevSize / image.width * image.height;
                }
                else
                {
                    h = prevSize;
                    w = prevSize / image.height * image.width;
                }

                var canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(image, 0, 0, w, h);

                srcScaledPrev = canvas.toDataURL();

                startCreateData();
            };
            image.src = srcPrev
        }

        function startCreateData()
        {
            creator = new R2D.MaterialCreator();
            creator.addEventListener(Event.READY, creatorReadyListener);

            creator.addEventListener(Event.ERROR, errorListener);
            creator.addEventListener(R2D.MaterialCreator.ERROR_CREATING_IN_PROCESS, errorInProcessListener);
            creator.addEventListener(R2D.MaterialCreator.ERROR_EMPTY_MATERIAL, errorEmptyListener);
            creator.addEventListener(R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE, packageCompleteListener);
        }
        function creatorReadyListener()
        {
            creator.removeEventListener(Event.READY, creatorReadyListener);
            creator.addEventListener(Event.UPDATE, updateListener);
            creator.setMaterialSizeCM(width, height);
            creator.diffuse = srcFile;
        }
        function updateListener()
        {
            creator.removeEventListener(Event.UPDATE, updateListener);
            creator.createData();
        }
        function errorListener(e)
        {
            console.log('Error: ', e);
        }
        function errorInProcessListener(e)
        {
            console.log('Error in process: ', e);
        }
        function errorEmptyListener(e)
        {
            console.log('Error empty: ', e);
        }
        function packageCompleteListener(e)
        {
            var reader = new FileReader();
            reader.addEventListener("load", fileReaderLoadListener);
            reader.readAsDataURL(e.data.package);
        }

        function fileReaderLoadListener(e)
        {
            var params = {
                category_id: '',
                material_bank_category_id: '',
                type_id: uploadType,
                source: e.target.result.split(',')[1],
                preview: srcScaledPrev.split(',')[1],
                width: width,
                height: height
            };

            if (toBank)
            {
                params['material_bank_category_id'] = '' + categoryId;
            }
            else
            {
                params['category_id'] = '' + categoryId;
            }

            params = R2D.XHRLoader.makeParamsString(params);

            var loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_PRIVATE), params, null, null, true);

            loader.addEventListener(Event.COMPLETE, loaderEventHandler);
            loader.addEventListener(Event.ERROR, loaderEventHandler);
        }

        function loaderEventHandler(e)
        {
            console.log(e);
            if (e.type == Event.COMPLETE)
            {
                if (callback) callback(e.data.data);
            }
        }
    };
};

//R2D.extend(R2D.CustomUploader, EventDispatcher);

R2D.CustomUploader.UPLOAD_WALL_MATERIAL = '1';
R2D.CustomUploader.UPLOAD_FLOOR_MATERIAL = '5';
R2D.CustomUploader.UPLOAD_POSTER = '3';
R2D.CustomUploader.UPLOAD_CARPET = '4';
R2D.CustomUploader.COLOR_PICKER = '6';
R2D.CustomUploader.UPLOAD_MODEL_MATERIAL = '7';
R2D.createPlannerAPI = function(planner)
{
    planner.scene = planner.apiScene = new EventDispatcher();
    planner.view3d = planner.apiView3d = {};
    planner.view2d = planner.apiView2d = {};
    planner.viewWalk = planner.apiViewWalk = {};
    planner.constr = planner.apiConstr = new EventDispatcher();
    planner.units = {};
    planner.renders = {};

    planner.mih = () => R2D.MouseInteractionHelper._instance;
    
    planner.view3d.activate = function() {R2D.Viewers.enableViewer(2)};
    planner.view3d.isActive = function() {return R2D.Viewers.getCurrentViewer() == R2D.view3d};
    planner.view2d.activate = function() {R2D.Viewers.enableViewer(1)};
    planner.view2d.isActive = function() {return R2D.Viewers.getCurrentViewer() == R2D.view2d};
    planner.viewWalk.activate = function() {R2D.Viewers.enableViewer(3)};
    planner.viewWalk.isActive = function() {return R2D.Viewers.getCurrentViewer() == R2D.viewWalk};
    planner.constr.activate = function() {R2D.Viewers.enableViewer(0)};
    planner.constr.isActive = function() {return R2D.Viewers.getCurrentViewer() == R2D.viewConstructor};


    planner.zoomIn = () => {
        if(planner.getCurrentViewerType() == "2d" || planner.getCurrentViewerType() == "constructor") {
            WC.WallsEditor._instance.cameraZoom(-1);
            R2D.ViewerScene2D._instance.cameraZoom(-1);
        }

        else R2D.Viewers.clickOnButton("zoomIn");
    }
    planner.zoomOut = () => {
        if(planner.getCurrentViewerType() == "2d" || planner.getCurrentViewerType() == "constructor") {
            WC.WallsEditor._instance.cameraZoom(1);
            R2D.ViewerScene2D._instance.cameraZoom(1);
        }
        else R2D.Viewers.clickOnButton("zoomOut");
    }

    planner.fullscreen = () => R2D.Viewers.clickOnButton("fullscreen");
    planner.toCenter = () => R2D.Viewers.clickOnButton("toCenter");
    planner.addRuler = () => R2D.Viewers.clickOnButton("addRuler");
    planner.getCurrentViewerType = () => R2D.Viewers.getCurrentViewerType();

    planner.renders.activeIntId = null;

    planner.renders.inProgressIds = [];

    planner.setCatalogMaterials = catalog => R2D.setCatalogMaterials(catalog);
    planner.getCatalogMaterials = () => R2D.getCatalogMaterials();

    planner.setCatalogProducts = products => R2D.setCatalogProducts(products);
    planner.getCatalogProducts = () => R2D.getCatalogProducts();


    // --- constructor ---
    planner.constr.STATE_MAIN = 'stateMain';
    planner.constr.STATE_SELECTED_POINT = 'stateSelectedPoint';
    planner.constr.STATE_SELECTED_ROOM = 'stateSelectedRoom';
    planner.constr.STATE_SELECTED_COVER = 'stateSelectedCover';
    planner.constr.STATE_SELECTED_LOW_AREA = 'stateSelectedLowArea';
    //planner.constr.STATE_SELECTED_RULER = 'stateSelectedRuler';

    planner.constr.STATE_MAKING_WALL = 'stateMakingWall';
    planner.constr.STATE_MAKING_ROOM = 'stateMakingRoom';
    planner.constr.STATE_MAKING_WALL_SHAPE = 'stateMakingWallShape';
    planner.constr.STATE_MAKING_WALL_CUTOUT = 'stateMakingWallCutout';
    planner.constr.STATE_MAKING_COVER = 'stateMakingCover';
    planner.constr.STATE_MAKING_COVER_CUTOUT = 'stateMakingCoverCutout';
    planner.constr.STATE_MAKING_LOW_AREA = 'stateMakingLowArea';
    //planner.constr.STATE_MAKING_RULER = 'stateMakingRuler';
    planner.constr.STATE_ALIGN_PLAN = 'stateAlignPlan';

    planner.constr.ALIGN_PLAN_ASK_LENGTH = 'alignPlanAskLength';
    planner.constr.ALIGN_PLAN_LENGTH_INCORRECT = 'alignPlanLengthIncorrect';
    planner.constr.HISTORY_UNDO_REDO = "historyUndoRedo";
    planner.constr.WHEEL_ZOOM = "wheelZoom";
    planner.constr.CAMERA_MOVE = "cameraMove";
    planner.constr.ESTIMATION_SEND = "estimationSend";
    planner.constr.SELECTED_COVER_AGAIN = "selectedCoverAgain";
    planner.constr.QUICK_PANELS_HIDE = "quickPanelsHide";
    planner.constr.STATE_CONSTR_STOP = "stateConstrStop";
    planner.constr.USE_TAB_TIP_START = "useTabTipStart";
    planner.constr.USE_TAB_TIP_MOVE = "useTabTipMove";

    planner.constr.USE_ENTER_TIP_START = "useEnterTipStart";
    planner.constr.USE_ENTER_TIP_MOVE = "useEnterTipMove";

    planner.constr.USE_ENTER_TAB_TIP_START = "useEnterTabTipStart";
    planner.constr.USE_ENTER_TAB_TIP_MOVE = "useEnterTabTipMove";

    planner.constr.KEYBOARD_HELPER_SHOW = "keyboardHelperShow";
    planner.constr.KEYBOARD_HELPER_HIDE = "keyboardHelperHide";

    planner.constr.CHANGE_AREA_VALUE = "changeAreaValue";
    planner.constr.SET_AREA_IMAG_PLAN_POPUP = "stopAreaSet";

    planner.constr.CHANGED_TITLE_TEXT = "changedTitleText";

    planner.constr.stateMakeWall = function() {WC.wallsEditor.startMakeWalls()};
    planner.constr.stateMakeRect = function() {WC.wallsEditor.startMakeRect()};
    planner.constr.stateMakeRoom = function() {WC.wallsEditor.startMakeRoom()};
    planner.constr.stateCutRoom = function() {WC.wallsEditor.startCutRoom()};
    planner.constr.stateMakeCover = function() {WC.wallsEditor.startMakeCover()};
    planner.constr.stateCutCover = function() {WC.wallsEditor.startCutCover()};
    planner.constr.stateMakeArea = function() {WC.wallsEditor.startMakeArea()};
    planner.constr.finish = function() {WC.wallsEditor.stopMake()};
    planner.constr.deleteSelected = function () {WC.wallsEditor.quickDelete()};
    //planner.constr.makeRuler = function () {WC.wallsEditor.addRuler()};
    planner.constr.setCeilingVisible = checked => WC.wallsEditor.stateSelectedCover.setCeilingVisible(checked);
    planner.constr.selectedCovers = () => WC.wallsEditor.stateSelectedCover.covers;
    planner.constr.stateSelectedArea = () => WC.wallsEditor.stateSelectedArea.areas;
    planner.constr.stateSetWallHeight = () => WC.wallsEditor.startMakeArea();

    planner.constr.uploadPlan = async preloaderNeed => await WC.wallsEditor.startUploadDrawing(preloaderNeed);
    planner.constr.alignPlan = function() {if (!planner.constr.hasPlan()) return; WC.wallsEditor.startAlignDrawing()};
    planner.constr.stopAlignPlan = function() {WC.wallsEditor.stopAlignDrawing()};
    planner.constr.deletePlan = function() {WC.wallsEditor.delImageDrawing()};
    planner.constr.hasPlan = function() {return Boolean(WC.wallsEditor.imgDrawing)};
    planner.constr.getPlanAlignLength = function() {return WC.wallsEditor.stateAlignDrawing.getAlignerValue()};
    planner.constr.setPlanAlignLength = function(length) {WC.wallsEditor.stateAlignDrawing.setAlignerValue(length)};
    planner.constr.mergeCovers = () => WC.wallsEditor.rebuildCoversByUser();
    
    planner.constr.setWallsHeight = height => WC.wallsEditor.setWallsHeight(height);
    planner.constr.getWallsHeight = () => WC.core.wallsHeight;

    planner.constr.setAreaHeight = height => WC.wallsEditor.setAreaHeight(height);
    planner.constr.setAreaCeilingHeight = height => WC.wallsEditor.setAreaCeilingHeight(height);

    planner.constr.delSelectedAreas = () => WC.wallsEditor.delSelectedAreas();
    planner.constr.setAreaCeilingVisible = isChecked => WC.wallsEditor.setAreaCeilingVisible(isChecked);
    
    planner.constr.undo = function() {WC.wallsEditor.undo()};
    planner.constr.redo = function() {WC.wallsEditor.redo()};
    planner.constr.canUndo = function() {return WC.wallsEditor.canUndo()};
    planner.constr.canRedo = function() {return WC.wallsEditor.canRedo()};
    planner.constr.zoomIn = function() {WC.wallsEditor.cameraZoom(-1)};
    planner.constr.zoomOut = function() {WC.wallsEditor.cameraZoom(1)};

    planner.constr.mousedown = e => WC.events.mousedown(e);
    planner.constr.mouseup = e => WC.events.mouseup(e);
    planner.constr.mousemove = e => WC.events.mousemove(e);
    //planner.constr.dblclick = e => WC.events.dblclick(e);
    //planner.constr.wheel = e => WC.events.wheel(e);

    // --- scene ---

    planner.scene.PROJECT_SAVE_COMPLETE = 'projectSaveComplete';
    planner.scene.PROJECT_SAVE_ERROR = 'projectSaveError';
    planner.scene.HISTORY_UNDO_REDO = "historyUndoRedo";
    planner.scene.WHEEL_ZOOM = "wheelZoom";
    planner.scene.CAMERA_MOVE = "cameraMove";

    planner.scene.setDefaultPanoId = id => R2D.scene.setDefaultPanoId(id);
    planner.scene.getDefaultPanoId = () => R2D.scene.getDefaultPanoId();

    planner.scene.clear = function() {R2D.controller.clearCurrentScene(true)};
    planner.scene.saveProject = async name => await R2D.controller.saveCurrentScene(name);
    planner.scene.loadProject = async id => await R2D.controller.loadScene(id);
    planner.scene.wasSaved = function() {return R2D.controller.wasSaved()};
    planner.scene.renameProject = async name => await R2D.controller.renameCurrentScene(name);
    planner.scene.wasChanged = function() {return R2D.controller.wasChanged()};
    planner.scene.undo = function() {R2D.scene.history.undo()};
    planner.scene.redo = function() {R2D.scene.history.redo()};
    planner.scene.canUndo = function() {return R2D.Scene._instance.history.isUndo};
    planner.scene.canRedo = function() {return R2D.Scene._instance.history.isRedo};
    planner.scene.createNewScene = function() {R2D.controller.createNewScene(true)};

    planner.scene.toggleRightPanelStatus = status => R2D.Viewers.toggleRightPanelStatus(status);
    planner.scene.showRightPanelStatus = () => R2D.Viewers.showRightPanelStatus();
    planner.scene.setRightPanelStatusBefore = () => R2D.Viewers.setRightPanelStatusBefore();
    
    
    planner.scene.mousedown = e => R2D.MouseInteractionHelper.mousedown(e);
    planner.scene.mouseup = e => R2D.MouseInteractionHelper.mouseup(e);
    planner.scene.mousemove = e => R2D.MouseInteractionHelper.mousemove(e);

    planner.scene.delRuler = ruler => R2D.CustomRulers.delRuler(ruler);
    planner.scene.getSelectedRuler = () => R2D.CustomRulers.getSelectedRuler();

    planner.scene.STATE_MAIN = 'stateMain';
    planner.scene.STATE_SELECTED_MODEL = 'stateSelectedModel';
    planner.scene.STATE_SELECTED_GROUP = 'stateSelectedGroup';
    planner.scene.STATE_SELECTED_CONSTR = 'stateSelectedConstr';
    planner.scene.MODEL_CHANGE_SIZE = 'modelChangeSize';
    planner.scene.RULER_3D_SELECTED = 'ruler3dSelected';
    planner.scene.TIPS_SAVE_PROJECT = "tipsSaveProject";
    planner.scene.TIPS_UPLOAD_CUSTOM_MAT = "tipsUploadCustomMat";
    planner.scene.CHANGED_TITLE_TEXT = "changedTitleText";
    planner.scene.SCENE_LOAD_PROGRESS = "sceneLoadProgress";
    planner.scene.SCENE_LOAD_COMPLETE = "sceneLoadComplete";
    planner.scene.PROJECT_LOADED = "projectLoaded";
    planner.scene.RENDERS_UPDATE = "rendersUpdate";
    planner.scene.OBJECT_SMART_MOVE = "objectSmartMove";
    planner.scene.OBJECT_DRAG_OUT_OF_WALL = "objectDragOutOfWall";
    planner.scene.ESTIMATION_SEND = "estimationSend";
    planner.scene.CAMERA_ROTATE = "cameraRotate";
    planner.scene.ELEVATION_OBJECT = "eleavationObject";
    planner.scene.ROTATION_GROUP = "rotationGroup";
    planner.scene.START_ROTATING_OBJECT = "startRotatingObject";
    planner.scene.STOP_ROTATING_OBJECT = "stopRotatingObject";
    planner.scene.ROTATING_OBJECT = "rotatingObject";
    planner.scene.SHOW_OBJECT_QUICK_PANEL = "showObjectQuickPanel";
    planner.scene.HIDE_OBJECT_QUICK_PANEL = "hideObjectQuickPanel";
    planner.scene.OBJECT_ROTATION_AXIS = "objectRotationAxis";
    planner.scene.SET_ACTIVE_GROUP = "setActiveGroup";
    planner.scene.SET_ACTIVE_PRODUCT = "setActiveProduct";
    planner.scene.QUICK_PANELS_HIDE = "quickPanelsHide";

    // --- Transformations of selected objects ---

    planner.scene.removeCurrentModel = function() {R2D.scene.removeCurrentObject()};
    planner.scene.removeCurrentGroup = function() {R2D.scene.removeCurrentObject()};
    planner.scene.clearCurrentConstruction = function() {R2D.mouseInteractionHelper.clearFill()};
    planner.scene.duplicateCurrentModel = function() {R2D.mouseInteractionHelper.duplicateCurrentModel()};
    planner.scene.duplicateCurrentGroup = function() {R2D.mouseInteractionHelper.duplicateCurrentGroup()};
    planner.scene.flipCurrentModelX = function() {R2D.mouseInteractionHelper.flipCurrentModelX()};
    planner.scene.flipCurrentModelZ = function() {R2D.mouseInteractionHelper.flipCurrentModelZ()};
    planner.scene.flipCurrentGroupX = function() {R2D.mouseInteractionHelper.flipCurrentGroupX()};
    planner.scene.flipCurrentGroupZ = function() {R2D.mouseInteractionHelper.flipCurrentGroupZ()};

    planner.scene.getAvailableTools = function() {return R2D.mouseInteractionHelper.getAvailableTools()};

    planner.scene.getCurrentModelRotation = function() {return R2D.scene.currentView3DObject ? R2D.scene.currentView3DObject.sceneObject.rotationY : NaN};
    planner.scene.startRotateCurrentModel = function() {R2D.mouseInteractionHelper.startRotateCurrentModel()};
    planner.scene.rotateCurrentModel = function(degrees) {R2D.mouseInteractionHelper.rotateCurrentModel(degrees)};
    planner.scene.stopRotateCurrentModel = function() {R2D.mouseInteractionHelper.stopRotateCurrentModel()};

    planner.scene.getCurrentModelElevation = function() {return R2D.scene.currentView3DObject ? R2D.scene.currentView3DObject.sceneObject.y : NaN};
    planner.scene.startElevateCurrentModel = function() {R2D.mouseInteractionHelper.startElevateCurrentModel()};
    planner.scene.elevateCurrentModel = function(height) {R2D.mouseInteractionHelper.elevateCurrentModel(height)};
    planner.scene.stopElevateCurrentModel = function() {R2D.mouseInteractionHelper.stopElevateCurrentModel()};

    planner.scene.getCurrentGroupRotation = function() {return R2D.scene.currentGroup ? GEOM.toDeg(R2D.scene.currentGroup.rotation) : NaN};
    planner.scene.startRotateCurrentGroup = function() {R2D.mouseInteractionHelper.startRotateCurrentGroup()};
    planner.scene.rotateCurrentGroup = function(degrees) {R2D.mouseInteractionHelper.rotateCurrentGroup(degrees)};
    planner.scene.stopRotateCurrentGroup = function() {R2D.mouseInteractionHelper.stopRotateCurrentGroup()};

    planner.scene.getCurrentGroupElevation = function() {return R2D.scene.currentGroup ? R2D.scene.currentGroup.y : NaN};
    planner.scene.startElevateCurrentGroup = function() {R2D.mouseInteractionHelper.startElevateCurrentGroup()};
    planner.scene.elevateCurrentGroup = function(height) {R2D.mouseInteractionHelper.elevateCurrentGroup(height)};
    planner.scene.stopElevateCurrentGroup = function() {R2D.mouseInteractionHelper.stopElevateCurrentGroup()};

    planner.scene.currentGroupIsMerged = function() {return R2D.scene.currentGroup ? R2D.scene.currentGroup.merged : null};
    planner.scene.mergeCurrentGroup = function() {R2D.mouseInteractionHelper.mergeCurrentGroup()};
    planner.scene.unmergeCurrentGroup = function() {R2D.mouseInteractionHelper.ungroupCurrentGroup()};

    planner.scene.getCurrentMaterialRotation = function() {return R2D.scene.currentView3DObject ? GEOM.toDeg(R2D.scene.currentView3DObject.getMaterialRotation(R2D.scene.currentPartNum)) : NaN};
    planner.scene.startRotateCurrentMaterial = function() {R2D.mouseInteractionHelper.startRotateCurrentMaterial()};
    planner.scene.rotateCurrentMaterial = function(degrees) {R2D.mouseInteractionHelper.rotateCurrentMaterial(degrees)};
    planner.scene.stopRotateCurrentMaterial = function() {R2D.mouseInteractionHelper.stopRotateCurrentMaterial()};

    planner.scene.startMoveCurrentMaterial = function(x, y) {R2D.mouseInteractionHelper.startMoveCurrentMaterial(x, y)};
    planner.scene.moveCurrentMaterial = function(x, y) {R2D.mouseInteractionHelper.moveCurrentMaterial(x, y)};
    planner.scene.stopMoveCurrentMaterial = function() {R2D.mouseInteractionHelper.stopMoveCurrentMaterial()};

    planner.scene.setCurrentObjectRotation = (degree, axis, isMouseDown) => R2D.mouseInteractionHelper.setCurrentObjectRotation(degree, axis, isMouseDown);

    // --- Changing sizes of selected objects ---

    planner.scene.getCurrentModelSizes = function() {return R2D.mouseInteractionHelper.getCurrentModelSizes()};
    planner.scene.setCurrentModelWidth = function(width, keepRatio, isMouseDown) {R2D.mouseInteractionHelper.setCurrentModelWidth(width, keepRatio, isMouseDown)};
    planner.scene.setCurrentModelHeight = function(height, keepRatio, isMouseDown) {R2D.mouseInteractionHelper.setCurrentModelHeight(height, keepRatio, isMouseDown)};
    planner.scene.setCurrentModelDepth = function(depth, keepRatio, isMouseDown) {R2D.mouseInteractionHelper.setCurrentModelDepth(depth, keepRatio, isMouseDown)};
    planner.scene.setCurrentModelElevation = function(elevation, isMouseDown) {R2D.mouseInteractionHelper.setCurrentModelElevation(elevation, isMouseDown)};

    planner.scene.changeCurrentModelWidth = function(val, keepRatio) {R2D.mouseInteractionHelper.changeCurrentModelWidth(val, keepRatio)};
    planner.scene.changeCurrentModelHeight = function(val, keepRatio) {R2D.mouseInteractionHelper.changeCurrentModelHeight(val, keepRatio)};
    planner.scene.changeCurrentModelDepth = function(val, keepRatio) {R2D.mouseInteractionHelper.changeCurrentModelDepth(val, keepRatio)};
    planner.scene.changeCurrentModelElevation = function(elevation) {R2D.mouseInteractionHelper.changeCurrentModelElevation(elevation)};
    planner.scene.stopChangingModelSizes = function() {R2D.mouseInteractionHelper.stopChangingModelSizes()};

    // --- Materials on selected objects ---

    planner.scene.getCurrentModelMaterials = function() {return R2D.mouseInteractionHelper.getCurrentModelMaterials()};
    planner.scene.setMaterialOnCurrentModel = function(index, matId) {R2D.mouseInteractionHelper.setMaterialOnCurrentModel(index, matId)};
    planner.scene.setAddMaterialOnCurrentModel = function(index, matId) {R2D.mouseInteractionHelper.setAddMaterialOnCurrentModel(index, matId)};
    planner.scene.getCurrentConstrMaterial = function() {return R2D.mouseInteractionHelper.getCurrentConstrMaterial()};
    planner.scene.getCurrentConstrAddMaterial = function() {return R2D.mouseInteractionHelper.getCurrentConstrAddMaterial()};
    planner.scene.setMaterialOnCurrentConstr = function(matId) {return R2D.mouseInteractionHelper.setMaterialOnCurrentConstr(matId)};
    planner.scene.setAddMaterialOnCurrentConstr = function(matId) {return R2D.mouseInteractionHelper.setAddMaterialOnCurrentConstr(matId)};
    planner.scene.setAdditionalColorAt = (index, color) => R2D.mouseInteractionHelper.setAdditionalColorAt(index, matId)

    // --- Dragging from catalog ---

    planner.scene.dragProductFromCatalog = function(id, addMatId) { R2D.mouseInteractionHelper.dragProductFromCatalog(id, addMatId)};

    // --- Project name ---

    planner.scene.setProjectName = function(name) {R2D.scene.updateProjectName(name)};
    planner.scene.getProjectName = function() {R2D.scene.getProjectName()};

    // --- New --- //

    planner.scene.rebuildAllPlinths = () => R2D.scene.getConstructor().rebuildAllPlinths();
    planner.scene.setPlinthToRoom = data => R2D.scene.getConstructor().setPlinthToRoom(data);
    planner.scene.setWallToRoom = data => R2D.scene.getConstructor().setWallToRoom(data);
    planner.scene.runConfigurator = wall => R2D.scene.getConstructor().runConfigurator(wall);
    planner.scene.getConfigurator = () => R2D.scene.getConstructor().getConfigurator();
    planner.scene.getCameraVerAngle = () => R2D.viewWalk.getCameraVerAngle();
    planner.scene.setCameraVerAngleRad = rad => R2D.viewWalk.setCameraVerAngleRad(rad);
    planner.scene.makeScreenShot = prev => R2D.Viewers.makeScreenShot(prev);
    planner.scene.makeRenderScreenShot = () => R2D.Viewers.makeRenderScreenShot();

    // --- Clipping ---

    planner.scene.onClipping = () => R2D.viewWalk.onClipping()
    planner.scene.offClipping = () => R2D.viewWalk.offClipping()
    planner.scene.setDistFromCameraToPlane = dist => R2D.viewWalk.setDistFromCameraToPlane(dist);
    planner.scene.getDistFromCameraToPlane = () => R2D.viewWalk.getDistFromCameraToPlane();


    // --- Measuring system ---

    planner.units.METRIC_CM = R2D.DimensionSystem.METRIC_CM;
    planner.units.METRIC_M = R2D.DimensionSystem.METRIC_M;
    planner.units.METRIC_MM = R2D.DimensionSystem.METRIC_MM;
    planner.units.IMPERIAL_FT = R2D.DimensionSystem.IMPERIAL_FT;

    planner.units.getSystem = function () {return R2D.DimensionSystem.getSystem()};
    planner.units.setSystem = function (system) {R2D.DimensionSystem.setSystem(parseInt(system))};
    planner.units.valueToString = function(value) {return R2D.DimensionSystem.toString(value)};
    planner.units.stringToValue = function(str) {return R2D.DimensionSystem.fromString(str)};
    planner.units.squareToString = function(value) {return R2D.DimensionSystem.squareToString(value)};
    planner.units.getStep = function() {return R2D.DimensionSystem.getStep()};
    planner.units.getName = function() {return R2D.DimensionSystem.getName()};

};

/*
todo: CustomRuler
*/

var RESOURCE_FOLDER = '/src_designer';

R2D.STYLE = {
    CONSTR_FLOOR:RESOURCE_FOLDER + '/images/core/constructor/floor_constr.png',
    CONSTR_FLOOR_SELECTED:RESOURCE_FOLDER + '/images/core/constructor/floor_constr_selected.png',
    CONSTR_POINT:RESOURCE_FOLDER + '/images/core/constructor/constr_point.png',
    CONSTR_COVER_POINT:RESOURCE_FOLDER + '/images/core/constructor/cover_point.png',

    DRAWING_RULER_ICON_UP:RESOURCE_FOLDER + '/images/core/constructor/ruler_up.png',
    DRAWING_RULER_ICON_OVER:RESOURCE_FOLDER + '/images/core/constructor/ruler_over.png',
    DRAWING_RULER_ICON_DOWN:RESOURCE_FOLDER + '/images/core/constructor/ruler_down.png',

    PATH_TO_ENVIRONMENT:RESOURCE_FOLDER + '/images/core/environment'
};

( function () {

	class GLTFExporter {

		constructor() {

			this.pluginCallbacks = [];
			this.register( function ( writer ) {

				return new GLTFLightExtension( writer );

			} );
			this.register( function ( writer ) {

				return new GLTFMaterialsUnlitExtension( writer );

			} );
			this.register( function ( writer ) {

				return new GLTFMaterialsPBRSpecularGlossiness( writer );

			} );

		}

		register( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

				this.pluginCallbacks.push( callback );

			}

			return this;

		}

		unregister( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

				this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

			}

			return this;

		}
		/**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */


		parse( input, onDone, options ) {

			const writer = new GLTFWriter();
			const plugins = [];

			for ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {

				plugins.push( this.pluginCallbacks[ i ]( writer ) );

			}

			writer.setPlugins( plugins );
			writer.write( input, onDone, options );

		}

	} //------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------


	const WEBGL_CONSTANTS = {
		POINTS: 0x0000,
		LINES: 0x0001,
		LINE_LOOP: 0x0002,
		LINE_STRIP: 0x0003,
		TRIANGLES: 0x0004,
		TRIANGLE_STRIP: 0x0005,
		TRIANGLE_FAN: 0x0006,
		UNSIGNED_BYTE: 0x1401,
		UNSIGNED_SHORT: 0x1403,
		FLOAT: 0x1406,
		UNSIGNED_INT: 0x1405,
		ARRAY_BUFFER: 0x8892,
		ELEMENT_ARRAY_BUFFER: 0x8893,
		NEAREST: 0x2600,
		LINEAR: 0x2601,
		NEAREST_MIPMAP_NEAREST: 0x2700,
		LINEAR_MIPMAP_NEAREST: 0x2701,
		NEAREST_MIPMAP_LINEAR: 0x2702,
		LINEAR_MIPMAP_LINEAR: 0x2703,
		CLAMP_TO_EDGE: 33071,
		MIRRORED_REPEAT: 33648,
		REPEAT: 10497
	};
	const THREE_TO_WEBGL = {};
	THREE_TO_WEBGL[ THREE.NearestFilter ] = WEBGL_CONSTANTS.NEAREST;
	THREE_TO_WEBGL[ THREE.NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
	THREE_TO_WEBGL[ THREE.NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
	THREE_TO_WEBGL[ THREE.LinearFilter ] = WEBGL_CONSTANTS.LINEAR;
	THREE_TO_WEBGL[ THREE.LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
	THREE_TO_WEBGL[ THREE.LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
	THREE_TO_WEBGL[ THREE.ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
	THREE_TO_WEBGL[ THREE.RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;
	THREE_TO_WEBGL[ THREE.MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
	const PATH_PROPERTIES = {
		scale: 'scale',
		position: 'translation',
		quaternion: 'rotation',
		morphTargetInfluences: 'weights'
	}; // GLB constants
	// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

	const GLB_HEADER_BYTES = 12;
	const GLB_HEADER_MAGIC = 0x46546C67;
	const GLB_VERSION = 2;
	const GLB_CHUNK_PREFIX_BYTES = 8;
	const GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
	const GLB_CHUNK_TYPE_BIN = 0x004E4942; //------------------------------------------------------------------------------
	// Utility functions
	//------------------------------------------------------------------------------

	/**
 * Compare two arrays
 * @param  {Array} array1 Array 1 to compare
 * @param  {Array} array2 Array 2 to compare
 * @return {Boolean}        Returns true if both arrays are equal
 */

	function equalArray( array1, array2 ) {

		return array1.length === array2.length && array1.every( function ( element, index ) {

			return element === array2[ index ];

		} );

	}
	/**
 * Converts a string to an ArrayBuffer.
 * @param  {string} text
 * @return {ArrayBuffer}
 */


	function stringToArrayBuffer( text ) {

		if ( window.TextEncoder !== undefined ) {

			return new TextEncoder().encode( text ).buffer;

		}

		const array = new Uint8Array( new ArrayBuffer( text.length ) );

		for ( let i = 0, il = text.length; i < il; i ++ ) {

			const value = text.charCodeAt( i ); // Replacing multi-byte character with space(0x20).

			array[ i ] = value > 0xFF ? 0x20 : value;

		}

		return array.buffer;

	}
	/**
 * Is identity matrix
 *
 * @param {Matrix4} matrix
 * @returns {Boolean} Returns true, if parameter is identity matrix
 */


	function isIdentityMatrix( matrix ) {

		return equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );

	}
	/**
 * Get the min and max vectors from the given attribute
 * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
 * @param  {Integer} start
 * @param  {Integer} count
 * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
 */


	function getMinMax( attribute, start, count ) {

		const output = {
			min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
			max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )
		};

		for ( let i = start; i < start + count; i ++ ) {

			for ( let a = 0; a < attribute.itemSize; a ++ ) {

				let value;

				if ( attribute.itemSize > 4 ) {

					// no support for interleaved data for itemSize > 4
					value = attribute.array[ i * attribute.itemSize + a ];

				} else {

					if ( a === 0 ) value = attribute.getX( i ); else if ( a === 1 ) value = attribute.getY( i ); else if ( a === 2 ) value = attribute.getZ( i ); else if ( a === 3 ) value = attribute.getW( i );

				}

				output.min[ a ] = Math.min( output.min[ a ], value );
				output.max[ a ] = Math.max( output.max[ a ], value );

			}

		}

		return output;

	}
	/**
 * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
 *
 * @param {Integer} bufferSize The size the original buffer.
 * @returns {Integer} new buffer size with required padding.
 *
 */


	function getPaddedBufferSize( bufferSize ) {

		return Math.ceil( bufferSize / 4 ) * 4;

	}
	/**
 * Returns a buffer aligned to 4-byte boundary.
 *
 * @param {ArrayBuffer} arrayBuffer Buffer to pad
 * @param {Integer} paddingByte (Optional)
 * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
 */


	function getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {

		const paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

		if ( paddedLength !== arrayBuffer.byteLength ) {

			const array = new Uint8Array( paddedLength );
			array.set( new Uint8Array( arrayBuffer ) );

			if ( paddingByte !== 0 ) {

				for ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

					array[ i ] = paddingByte;

				}

			}

			return array.buffer;

		}

		return arrayBuffer;

	}

	let cachedCanvas = null;
	/**
 * Writer
 */

	class GLTFWriter {

		constructor() {

			this.plugins = [];
			this.options = {};
			this.pending = [];
			this.buffers = [];
			this.byteOffset = 0;
			this.buffers = [];
			this.nodeMap = new Map();
			this.skins = [];
			this.extensionsUsed = {};
			this.uids = new Map();
			this.uid = 0;
			this.json = {
				asset: {
					version: '2.0',
					generator: 'THREE.GLTFExporter'
				}
			};
			this.cache = {
				meshes: new Map(),
				attributes: new Map(),
				attributesNormalized: new Map(),
				materials: new Map(),
				textures: new Map(),
				images: new Map()
			};

		}

		setPlugins( plugins ) {

			this.plugins = plugins;

		}
		/**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */


		write( input, onDone, options ) {

			this.options = Object.assign( {}, {
				// default options
				binary: false,
				trs: false,
				onlyVisible: true,
				truncateDrawRange: true,
				embedImages: true,
				maxTextureSize: Infinity,
				animations: [],
				includeCustomExtensions: false
			}, options );

			if ( this.options.animations.length > 0 ) {

				// Only TRS properties, and not matrices, may be targeted by animation.
				this.options.trs = true;

			}

			this.processInput( input );
			const writer = this;
			Promise.all( this.pending ).then( function () {

				const buffers = writer.buffers;
				const json = writer.json;
				const options = writer.options;
				const extensionsUsed = writer.extensionsUsed; // Merge buffers.

				const blob = new Blob( buffers, {
					type: 'application/octet-stream'
				} ); // Declare extensions.

				const extensionsUsedList = Object.keys( extensionsUsed );
				if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.

				if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

				if ( options.binary === true ) {

					// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification
					const reader = new window.FileReader();
					reader.readAsArrayBuffer( blob );

					reader.onloadend = function () {

						// Binary chunk.
						const binaryChunk = getPaddedArrayBuffer( reader.result );
						const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
						binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
						binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true ); // JSON chunk.

						const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );
						const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
						jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
						jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true ); // GLB header.

						const header = new ArrayBuffer( GLB_HEADER_BYTES );
						const headerView = new DataView( header );
						headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
						headerView.setUint32( 4, GLB_VERSION, true );
						const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
						headerView.setUint32( 8, totalByteLength, true );
						const glbBlob = new Blob( [ header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk ], {
							type: 'application/octet-stream'
						} );
						const glbReader = new window.FileReader();
						glbReader.readAsArrayBuffer( glbBlob );

						glbReader.onloadend = function () {

							onDone( glbReader.result );

						};

					};

				} else {

					if ( json.buffers && json.buffers.length > 0 ) {

						const reader = new window.FileReader();
						reader.readAsDataURL( blob );

						reader.onloadend = function () {

							const base64data = reader.result;
							json.buffers[ 0 ].uri = base64data;
							onDone( json );

						};

					} else {

						onDone( json );

					}

				}

			} );

		}
		/**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */


		serializeUserData( object, objectDef ) {

			if ( Object.keys( object.userData ).length === 0 ) return;
			const options = this.options;
			const extensionsUsed = this.extensionsUsed;

			try {

				const json = JSON.parse( JSON.stringify( object.userData ) );

				if ( options.includeCustomExtensions && json.gltfExtensions ) {

					if ( objectDef.extensions === undefined ) objectDef.extensions = {};

					for ( const extensionName in json.gltfExtensions ) {

						objectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];
						extensionsUsed[ extensionName ] = true;

					}

					delete json.gltfExtensions;

				}

				if ( Object.keys( json ).length > 0 ) objectDef.extras = json;

			} catch ( error ) {

				console.warn( 'THREE.GLTFExporter: userData of \'' + object.name + '\' ' + 'won\'t be serialized because of JSON.stringify error - ' + error.message );

			}

		}
		/**
   * Assign and return a temporal unique id for an object
   * especially which doesn't have .uuid
   * @param  {Object} object
   * @return {Integer}
   */


		getUID( object ) {

			if ( ! this.uids.has( object ) ) this.uids.set( object, this.uid ++ );
			return this.uids.get( object );

		}
		/**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */


		isNormalizedNormalAttribute( normal ) {

			const cache = this.cache;
			if ( cache.attributesNormalized.has( normal ) ) return false;
			const v = new THREE.Vector3();

			for ( let i = 0, il = normal.count; i < il; i ++ ) {

				// 0.0005 is from glTF-validator
				if ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;

			}

			return true;

		}
		/**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */


		createNormalizedNormalAttribute( normal ) {

			const cache = this.cache;
			if ( cache.attributesNormalized.has( normal ) ) return cache.attributesNormalized.get( normal );
			const attribute = normal.clone();
			const v = new THREE.Vector3();

			for ( let i = 0, il = attribute.count; i < il; i ++ ) {

				v.fromBufferAttribute( attribute, i );

				if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

					// if values can't be normalized set (1, 0, 0)
					v.setX( 1.0 );

				} else {

					v.normalize();

				}

				attribute.setXYZ( i, v.x, v.y, v.z );

			}

			cache.attributesNormalized.set( normal, attribute );
			return attribute;

		}
		/**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */


		applyTextureTransform( mapDef, texture ) {

			let didTransform = false;
			const transformDef = {};

			if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {

				transformDef.offset = texture.offset.toArray();
				didTransform = true;

			}

			if ( texture.rotation !== 0 ) {

				transformDef.rotation = texture.rotation;
				didTransform = true;

			}

			if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {

				transformDef.scale = texture.repeat.toArray();
				didTransform = true;

			}

			if ( didTransform ) {

				mapDef.extensions = mapDef.extensions || {};
				mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;
				this.extensionsUsed[ 'KHR_texture_transform' ] = true;

			}

		}
		/**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */


		processBuffer( buffer ) {

			const json = this.json;
			const buffers = this.buffers;
			if ( ! json.buffers ) json.buffers = [ {
				byteLength: 0
			} ]; // All buffers are merged before export.

			buffers.push( buffer );
			return 0;

		}
		/**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */


		processBufferView( attribute, componentType, start, count, target ) {

			const json = this.json;
			if ( ! json.bufferViews ) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it

			let componentSize;

			if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

				componentSize = 1;

			} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

				componentSize = 2;

			} else {

				componentSize = 4;

			}

			const byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );
			const dataView = new DataView( new ArrayBuffer( byteLength ) );
			let offset = 0;

			for ( let i = start; i < start + count; i ++ ) {

				for ( let a = 0; a < attribute.itemSize; a ++ ) {

					let value;

					if ( attribute.itemSize > 4 ) {

						// no support for interleaved data for itemSize > 4
						value = attribute.array[ i * attribute.itemSize + a ];

					} else {

						if ( a === 0 ) value = attribute.getX( i ); else if ( a === 1 ) value = attribute.getY( i ); else if ( a === 2 ) value = attribute.getZ( i ); else if ( a === 3 ) value = attribute.getW( i );

					}

					if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

						dataView.setFloat32( offset, value, true );

					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

						dataView.setUint32( offset, value, true );

					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

						dataView.setUint16( offset, value, true );

					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

						dataView.setUint8( offset, value );

					}

					offset += componentSize;

				}

			}

			const bufferViewDef = {
				buffer: this.processBuffer( dataView.buffer ),
				byteOffset: this.byteOffset,
				byteLength: byteLength
			};
			if ( target !== undefined ) bufferViewDef.target = target;

			if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

				// Only define byteStride for vertex attributes.
				bufferViewDef.byteStride = attribute.itemSize * componentSize;

			}

			this.byteOffset += byteLength;
			json.bufferViews.push( bufferViewDef ); // @TODO Merge bufferViews where possible.

			const output = {
				id: json.bufferViews.length - 1,
				byteLength: 0
			};
			return output;

		}
		/**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */


		processBufferViewImage( blob ) {

			const writer = this;
			const json = writer.json;
			if ( ! json.bufferViews ) json.bufferViews = [];
			return new Promise( function ( resolve ) {

				const reader = new window.FileReader();
				reader.readAsArrayBuffer( blob );

				reader.onloadend = function () {

					const buffer = getPaddedArrayBuffer( reader.result );
					const bufferViewDef = {
						buffer: writer.processBuffer( buffer ),
						byteOffset: writer.byteOffset,
						byteLength: buffer.byteLength
					};
					writer.byteOffset += buffer.byteLength;
					resolve( json.bufferViews.push( bufferViewDef ) - 1 );

				};

			} );

		}
		/**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */


		processAccessor( attribute, geometry, start, count ) {

			const options = this.options;
			const json = this.json;
			const types = {
				1: 'SCALAR',
				2: 'VEC2',
				3: 'VEC3',
				4: 'VEC4',
				16: 'MAT4'
			};
			let componentType; // Detect the component type of the attribute array (float, uint or ushort)

			if ( attribute.array.constructor === Float32Array ) {

				componentType = WEBGL_CONSTANTS.FLOAT;

			} else if ( attribute.array.constructor === Uint32Array ) {

				componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

			} else if ( attribute.array.constructor === Uint16Array ) {

				componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

			} else if ( attribute.array.constructor === Uint8Array ) {

				componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;

			} else {

				throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );

			}

			if ( start === undefined ) start = 0;
			if ( count === undefined ) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet

			if ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {

				const end = start + count;
				const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;
				start = Math.max( start, geometry.drawRange.start );
				count = Math.min( end, end2 ) - start;
				if ( count < 0 ) count = 0;

			} // Skip creating an accessor if the attribute doesn't have data to export


			if ( count === 0 ) return null;
			const minMax = getMinMax( attribute, start, count );
			let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For
			// animation samplers, target must not be set.

			if ( geometry !== undefined ) {

				bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;

			}

			const bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );
			const accessorDef = {
				bufferView: bufferView.id,
				byteOffset: bufferView.byteOffset,
				componentType: componentType,
				count: count,
				max: minMax.max,
				min: minMax.min,
				type: types[ attribute.itemSize ]
			};
			if ( attribute.normalized === true ) accessorDef.normalized = true;
			if ( ! json.accessors ) json.accessors = [];
			return json.accessors.push( accessorDef ) - 1;

		}
		/**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (e.g. THREE.RGBFormat, THREE.RGBAFormat etc)
   * @param  {Boolean} flipY before writing out the image
   * @return {Integer}     Index of the processed texture in the "images" array
   */


		processImage( image, format, flipY ) {

			const writer = this;
			const cache = writer.cache;
			const json = writer.json;
			const options = writer.options;
			const pending = writer.pending;
			if ( ! cache.images.has( image ) ) cache.images.set( image, {} );
			const cachedImages = cache.images.get( image );
			const mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';
			const key = mimeType + ':flipY/' + flipY.toString();
			if ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];
			if ( ! json.images ) json.images = [];
			const imageDef = {
				mimeType: mimeType
			};

			if ( options.embedImages ) {

				const canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );
				canvas.width = Math.min( image.width, options.maxTextureSize );
				canvas.height = Math.min( image.height, options.maxTextureSize );
				const ctx = canvas.getContext( '2d' );

				if ( flipY === true ) {

					ctx.translate( 0, canvas.height );
					ctx.scale( 1, - 1 );

				}

				if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) {

					ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

				} else {

					if ( format !== THREE.RGBAFormat && format !== THREE.RGBFormat ) {

						console.error( 'GLTFExporter: Only RGB and RGBA formats are supported.' );

					}

					if ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {

						console.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );

					}

					const data = new Uint8ClampedArray( image.height * image.width * 4 );

					if ( format === THREE.RGBAFormat ) {

						for ( let i = 0; i < data.length; i += 4 ) {

							data[ i + 0 ] = image.data[ i + 0 ];
							data[ i + 1 ] = image.data[ i + 1 ];
							data[ i + 2 ] = image.data[ i + 2 ];
							data[ i + 3 ] = image.data[ i + 3 ];

						}

					} else {

						for ( let i = 0, j = 0; i < data.length; i += 4, j += 3 ) {

							data[ i + 0 ] = image.data[ j + 0 ];
							data[ i + 1 ] = image.data[ j + 1 ];
							data[ i + 2 ] = image.data[ j + 2 ];
							data[ i + 3 ] = 255;

						}

					}

					ctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );

				}

				if ( options.binary === true ) {

					pending.push( new Promise( function ( resolve ) {

						canvas.toBlob( function ( blob ) {

							writer.processBufferViewImage( blob ).then( function ( bufferViewIndex ) {

								imageDef.bufferView = bufferViewIndex;
								resolve();

							} );

						}, mimeType );

					} ) );

				} else {

					imageDef.uri = canvas.toDataURL( mimeType );

				}

			} else {

				imageDef.uri = image.src;

			}

			const index = json.images.push( imageDef ) - 1;
			cachedImages[ key ] = index;
			return index;

		}
		/**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */


		processSampler( map ) {

			const json = this.json;
			if ( ! json.samplers ) json.samplers = [];
			const samplerDef = {
				magFilter: THREE_TO_WEBGL[ map.magFilter ],
				minFilter: THREE_TO_WEBGL[ map.minFilter ],
				wrapS: THREE_TO_WEBGL[ map.wrapS ],
				wrapT: THREE_TO_WEBGL[ map.wrapT ]
			};
			return json.samplers.push( samplerDef ) - 1;

		}
		/**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */


		processTexture( map ) {

			const cache = this.cache;
			const json = this.json;
			if ( cache.textures.has( map ) ) return cache.textures.get( map );
			if ( ! json.textures ) json.textures = [];
			const textureDef = {
				sampler: this.processSampler( map ),
				source: this.processImage( map.image, map.format, map.flipY )
			};
			if ( map.name ) textureDef.name = map.name;

			this._invokeAll( function ( ext ) {

				ext.writeTexture && ext.writeTexture( map, textureDef );

			} );

			const index = json.textures.push( textureDef ) - 1;
			cache.textures.set( map, index );
			return index;

		}
		/**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */


		processMaterial( material ) {

			const cache = this.cache;
			const json = this.json;
			if ( cache.materials.has( material ) ) return cache.materials.get( material );

			if ( material.isShaderMaterial ) {

				console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
				return null;

			}

			if ( ! json.materials ) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?

			const materialDef = {
				pbrMetallicRoughness: {}
			};

			if ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {

				console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

			} // pbrMetallicRoughness.baseColorFactor


			const color = material.color.toArray().concat( [ material.opacity ] );

			if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

				materialDef.pbrMetallicRoughness.baseColorFactor = color;

			}

			if ( material.isMeshStandardMaterial ) {

				materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
				materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;

			} else {

				materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
				materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;

			} // pbrMetallicRoughness.metallicRoughnessTexture


			if ( material.metalnessMap || material.roughnessMap ) {

				if ( material.metalnessMap === material.roughnessMap ) {

					const metalRoughMapDef = {
						index: this.processTexture( material.metalnessMap )
					};
					this.applyTextureTransform( metalRoughMapDef, material.metalnessMap );
					materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;

				} else {

					console.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );

				}

			} // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture


			if ( material.map ) {

				const baseColorMapDef = {
					index: this.processTexture( material.map )
				};
				this.applyTextureTransform( baseColorMapDef, material.map );
				materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;

			}

			if ( material.emissive ) {

				// note: `emissive` is not scaled by `material.emissiveIntensity` for now to accommodate glTF spec. see #21849.
				const emissive = material.emissive.toArray();

				if ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {

					materialDef.emissiveFactor = emissive;

				} // emissiveTexture


				if ( material.emissiveMap ) {

					const emissiveMapDef = {
						index: this.processTexture( material.emissiveMap )
					};
					this.applyTextureTransform( emissiveMapDef, material.emissiveMap );
					materialDef.emissiveTexture = emissiveMapDef;

				}

			} // normalTexture


			if ( material.normalMap ) {

				const normalMapDef = {
					index: this.processTexture( material.normalMap )
				};

				if ( material.normalScale && material.normalScale.x !== - 1 ) {

					if ( material.normalScale.x !== material.normalScale.y ) {

						console.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );

					}

					normalMapDef.scale = material.normalScale.x;

				}

				this.applyTextureTransform( normalMapDef, material.normalMap );
				materialDef.normalTexture = normalMapDef;

			} // occlusionTexture


			if ( material.aoMap ) {

				const occlusionMapDef = {
					index: this.processTexture( material.aoMap ),
					texCoord: 1
				};

				if ( material.aoMapIntensity !== 1.0 ) {

					occlusionMapDef.strength = material.aoMapIntensity;

				}

				this.applyTextureTransform( occlusionMapDef, material.aoMap );
				materialDef.occlusionTexture = occlusionMapDef;

			} // alphaMode


			if ( material.transparent ) {

				materialDef.alphaMode = 'BLEND';

			} else {

				if ( material.alphaTest > 0.0 ) {

					materialDef.alphaMode = 'MASK';
					materialDef.alphaCutoff = material.alphaTest;

				}

			} // doubleSided


			if ( material.side === THREE.DoubleSide ) materialDef.doubleSided = true;
			if ( material.name !== '' ) materialDef.name = material.name;
			this.serializeUserData( material, materialDef );

			this._invokeAll( function ( ext ) {

				ext.writeMaterial && ext.writeMaterial( material, materialDef );

			} );

			const index = json.materials.push( materialDef ) - 1;
			cache.materials.set( material, index );
			return index;

		}
		/**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */


		processMesh( mesh ) {

			const cache = this.cache;
			const json = this.json;
			const meshCacheKeyParts = [ mesh.geometry.uuid ];

			if ( Array.isArray( mesh.material ) ) {

				for ( let i = 0, l = mesh.material.length; i < l; i ++ ) {

					meshCacheKeyParts.push( mesh.material[ i ].uuid );

				}

			} else {

				meshCacheKeyParts.push( mesh.material.uuid );

			}

			const meshCacheKey = meshCacheKeyParts.join( ':' );
			if ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );
			const geometry = mesh.geometry;
			let mode; // Use the correct mode

			if ( mesh.isLineSegments ) {

				mode = WEBGL_CONSTANTS.LINES;

			} else if ( mesh.isLineLoop ) {

				mode = WEBGL_CONSTANTS.LINE_LOOP;

			} else if ( mesh.isLine ) {

				mode = WEBGL_CONSTANTS.LINE_STRIP;

			} else if ( mesh.isPoints ) {

				mode = WEBGL_CONSTANTS.POINTS;

			} else {

				mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

			}

			if ( geometry.isBufferGeometry !== true ) {

				throw new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );

			}

			const meshDef = {};
			const attributes = {};
			const primitives = [];
			const targets = []; // Conversion between attributes names in threejs and gltf spec

			const nameConversion = {
				uv: 'TEXCOORD_0',
				uv2: 'TEXCOORD_1',
				color: 'COLOR_0',
				skinWeight: 'WEIGHTS_0',
				skinIndex: 'JOINTS_0'
			};
			const originalNormal = geometry.getAttribute( 'normal' );

			if ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {

				console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );
				geometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );

			} // @QUESTION Detect if .vertexColors = true?
			// For every attribute create an accessor


			let modifiedAttribute = null;

			for ( let attributeName in geometry.attributes ) {

				// Ignore morph target attributes, which are exported later.
				if ( attributeName.substr( 0, 5 ) === 'morph' ) continue;
				const attribute = geometry.attributes[ attributeName ];
				attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically
				// listed in the spec; non-spec attributes are considered custom.

				const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
				if ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;

				if ( cache.attributes.has( this.getUID( attribute ) ) ) {

					attributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );
					continue;

				} // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.


				modifiedAttribute = null;
				const array = attribute.array;

				if ( attributeName === 'JOINTS_0' && ! ( array instanceof Uint16Array ) && ! ( array instanceof Uint8Array ) ) {

					console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
					modifiedAttribute = new THREE.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

				}

				const accessor = this.processAccessor( modifiedAttribute || attribute, geometry );

				if ( accessor !== null ) {

					attributes[ attributeName ] = accessor;
					cache.attributes.set( this.getUID( attribute ), accessor );

				}

			}

			if ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal ); // Skip if no exportable attributes found

			if ( Object.keys( attributes ).length === 0 ) return null; // Morph targets

			if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

				const weights = [];
				const targetNames = [];
				const reverseDictionary = {};

				if ( mesh.morphTargetDictionary !== undefined ) {

					for ( const key in mesh.morphTargetDictionary ) {

						reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

					}

				}

				for ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

					const target = {};
					let warned = false;

					for ( const attributeName in geometry.morphAttributes ) {

						// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
						// Three.js doesn't support TANGENT yet.
						if ( attributeName !== 'position' && attributeName !== 'normal' ) {

							if ( ! warned ) {

								console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
								warned = true;

							}

							continue;

						}

						const attribute = geometry.morphAttributes[ attributeName ][ i ];
						const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.
						//
						// glTF 2.0 Specification:
						// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

						const baseAttribute = geometry.attributes[ attributeName ];

						if ( cache.attributes.has( this.getUID( attribute ) ) ) {

							target[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute ) );
							continue;

						} // Clones attribute not to override


						const relativeAttribute = attribute.clone();

						if ( ! geometry.morphTargetsRelative ) {

							for ( let j = 0, jl = attribute.count; j < jl; j ++ ) {

								relativeAttribute.setXYZ( j, attribute.getX( j ) - baseAttribute.getX( j ), attribute.getY( j ) - baseAttribute.getY( j ), attribute.getZ( j ) - baseAttribute.getZ( j ) );

							}

						}

						target[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );
						cache.attributes.set( this.getUID( baseAttribute ), target[ gltfAttributeName ] );

					}

					targets.push( target );
					weights.push( mesh.morphTargetInfluences[ i ] );
					if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );

				}

				meshDef.weights = weights;

				if ( targetNames.length > 0 ) {

					meshDef.extras = {};
					meshDef.extras.targetNames = targetNames;

				}

			}

			const isMultiMaterial = Array.isArray( mesh.material );
			if ( isMultiMaterial && geometry.groups.length === 0 ) return null;
			const materials = isMultiMaterial ? mesh.material : [ mesh.material ];
			const groups = isMultiMaterial ? geometry.groups : [ {
				materialIndex: 0,
				start: undefined,
				count: undefined
			} ];

			for ( let i = 0, il = groups.length; i < il; i ++ ) {

				const primitive = {
					mode: mode,
					attributes: attributes
				};
				this.serializeUserData( geometry, primitive );
				if ( targets.length > 0 ) primitive.targets = targets;

				if ( geometry.index !== null ) {

					let cacheKey = this.getUID( geometry.index );

					if ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {

						cacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;

					}

					if ( cache.attributes.has( cacheKey ) ) {

						primitive.indices = cache.attributes.get( cacheKey );

					} else {

						primitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );
						cache.attributes.set( cacheKey, primitive.indices );

					}

					if ( primitive.indices === null ) delete primitive.indices;

				}

				const material = this.processMaterial( materials[ groups[ i ].materialIndex ] );
				if ( material !== null ) primitive.material = material;
				primitives.push( primitive );

			}

			meshDef.primitives = primitives;
			if ( ! json.meshes ) json.meshes = [];

			this._invokeAll( function ( ext ) {

				ext.writeMesh && ext.writeMesh( mesh, meshDef );

			} );

			const index = json.meshes.push( meshDef ) - 1;
			cache.meshes.set( meshCacheKey, index );
			return index;

		}
		/**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */


		processCamera( camera ) {

			const json = this.json;
			if ( ! json.cameras ) json.cameras = [];
			const isOrtho = camera.isOrthographicCamera;
			const cameraDef = {
				type: isOrtho ? 'orthographic' : 'perspective'
			};

			if ( isOrtho ) {

				cameraDef.orthographic = {
					xmag: camera.right * 2,
					ymag: camera.top * 2,
					zfar: camera.far <= 0 ? 0.001 : camera.far,
					znear: camera.near < 0 ? 0 : camera.near
				};

			} else {

				cameraDef.perspective = {
					aspectRatio: camera.aspect,
					yfov: THREE.MathUtils.degToRad( camera.fov ),
					zfar: camera.far <= 0 ? 0.001 : camera.far,
					znear: camera.near < 0 ? 0 : camera.near
				};

			} // Question: Is saving "type" as name intentional?


			if ( camera.name !== '' ) cameraDef.name = camera.type;
			return json.cameras.push( cameraDef ) - 1;

		}
		/**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */


		processAnimation( clip, root ) {

			const json = this.json;
			const nodeMap = this.nodeMap;
			if ( ! json.animations ) json.animations = [];
			clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );
			const tracks = clip.tracks;
			const channels = [];
			const samplers = [];

			for ( let i = 0; i < tracks.length; ++ i ) {

				const track = tracks[ i ];
				const trackBinding = THREE.PropertyBinding.parseTrackName( track.name );
				let trackNode = THREE.PropertyBinding.findNode( root, trackBinding.nodeName );
				const trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];

				if ( trackBinding.objectName === 'bones' ) {

					if ( trackNode.isSkinnedMesh === true ) {

						trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

					} else {

						trackNode = undefined;

					}

				}

				if ( ! trackNode || ! trackProperty ) {

					console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );
					return null;

				}

				const inputItemSize = 1;
				let outputItemSize = track.values.length / track.times.length;

				if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {

					outputItemSize /= trackNode.morphTargetInfluences.length;

				}

				let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE
				// Detecting glTF cubic spline interpolant by checking factory method's special property
				// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
				// valid value from .getInterpolation().

				if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

					interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9
					// (VEC3 * 3: inTangent, splineVertex, and outTangent)
					// but needs to be stored as VEC3 so dividing by 3 here.

					outputItemSize /= 3;

				} else if ( track.getInterpolation() === THREE.InterpolateDiscrete ) {

					interpolation = 'STEP';

				} else {

					interpolation = 'LINEAR';

				}

				samplers.push( {
					input: this.processAccessor( new THREE.BufferAttribute( track.times, inputItemSize ) ),
					output: this.processAccessor( new THREE.BufferAttribute( track.values, outputItemSize ) ),
					interpolation: interpolation
				} );
				channels.push( {
					sampler: samplers.length - 1,
					target: {
						node: nodeMap.get( trackNode ),
						path: trackProperty
					}
				} );

			}

			json.animations.push( {
				name: clip.name || 'clip_' + json.animations.length,
				samplers: samplers,
				channels: channels
			} );
			return json.animations.length - 1;

		}
		/**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */


		processSkin( object ) {

			const json = this.json;
			const nodeMap = this.nodeMap;
			const node = json.nodes[ nodeMap.get( object ) ];
			const skeleton = object.skeleton;
			if ( skeleton === undefined ) return null;
			const rootJoint = object.skeleton.bones[ 0 ];
			if ( rootJoint === undefined ) return null;
			const joints = [];
			const inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );
			const temporaryBoneInverse = new THREE.Matrix4();

			for ( let i = 0; i < skeleton.bones.length; ++ i ) {

				joints.push( nodeMap.get( skeleton.bones[ i ] ) );
				temporaryBoneInverse.copy( skeleton.boneInverses[ i ] );
				temporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );

			}

			if ( json.skins === undefined ) json.skins = [];
			json.skins.push( {
				inverseBindMatrices: this.processAccessor( new THREE.BufferAttribute( inverseBindMatrices, 16 ) ),
				joints: joints,
				skeleton: nodeMap.get( rootJoint )
			} );
			const skinIndex = node.skin = json.skins.length - 1;
			return skinIndex;

		}
		/**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */


		processNode( object ) {

			const json = this.json;
			const options = this.options;
			const nodeMap = this.nodeMap;
			if ( ! json.nodes ) json.nodes = [];
			const nodeDef = {};

			if ( options.trs ) {

				const rotation = object.quaternion.toArray();
				const position = object.position.toArray();
				const scale = object.scale.toArray();

				if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

					nodeDef.rotation = rotation;

				}

				if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

					nodeDef.translation = position;

				}

				if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

					nodeDef.scale = scale;

				}

			} else {

				if ( object.matrixAutoUpdate ) {

					object.updateMatrix();

				}

				if ( isIdentityMatrix( object.matrix ) === false ) {

					nodeDef.matrix = object.matrix.elements;

				}

			} // We don't export empty strings name because it represents no-name in Three.js.


			if ( object.name !== '' ) nodeDef.name = String( object.name );
			this.serializeUserData( object, nodeDef );

			if ( object.isMesh || object.isLine || object.isPoints ) {

				const meshIndex = this.processMesh( object );
				if ( meshIndex !== null ) nodeDef.mesh = meshIndex;

			} else if ( object.isCamera ) {

				nodeDef.camera = this.processCamera( object );

			}

			if ( object.isSkinnedMesh ) this.skins.push( object );

			if ( object.children.length > 0 ) {

				const children = [];

				for ( let i = 0, l = object.children.length; i < l; i ++ ) {

					const child = object.children[ i ];

					if ( child.visible || options.onlyVisible === false ) {

						const nodeIndex = this.processNode( child );
						if ( nodeIndex !== null ) children.push( nodeIndex );

					}

				}

				if ( children.length > 0 ) nodeDef.children = children;

			}

			this._invokeAll( function ( ext ) {

				ext.writeNode && ext.writeNode( object, nodeDef );

			} );

			const nodeIndex = json.nodes.push( nodeDef ) - 1;
			nodeMap.set( object, nodeIndex );
			return nodeIndex;

		}
		/**
   * Process THREE.Scene
   * @param  {Scene} node THREE.Scene to process
   */


		processScene( scene ) {

			const json = this.json;
			const options = this.options;

			if ( ! json.scenes ) {

				json.scenes = [];
				json.scene = 0;

			}

			const sceneDef = {};
			if ( scene.name !== '' ) sceneDef.name = scene.name;
			json.scenes.push( sceneDef );
			const nodes = [];

			for ( let i = 0, l = scene.children.length; i < l; i ++ ) {

				const child = scene.children[ i ];

				if ( child.visible || options.onlyVisible === false ) {

					const nodeIndex = this.processNode( child );
					if ( nodeIndex !== null ) nodes.push( nodeIndex );

				}

			}

			if ( nodes.length > 0 ) sceneDef.nodes = nodes;
			this.serializeUserData( scene, sceneDef );

		}
		/**
   * Creates a THREE.Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */


		processObjects( objects ) {

			const scene = new THREE.Scene();
			scene.name = 'AuxScene';

			for ( let i = 0; i < objects.length; i ++ ) {

				// We push directly to children instead of calling `add` to prevent
				// modify the .parent and break its original scene and hierarchy
				scene.children.push( objects[ i ] );

			}

			this.processScene( scene );

		}
		/**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */


		processInput( input ) {

			const options = this.options;
			input = input instanceof Array ? input : [ input ];

			this._invokeAll( function ( ext ) {

				ext.beforeParse && ext.beforeParse( input );

			} );

			const objectsWithoutScene = [];

			for ( let i = 0; i < input.length; i ++ ) {

				if ( input[ i ] instanceof THREE.Scene ) {

					this.processScene( input[ i ] );

				} else {

					objectsWithoutScene.push( input[ i ] );

				}

			}

			if ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );

			for ( let i = 0; i < this.skins.length; ++ i ) {

				this.processSkin( this.skins[ i ] );

			}

			for ( let i = 0; i < options.animations.length; ++ i ) {

				this.processAnimation( options.animations[ i ], input[ 0 ] );

			}

			this._invokeAll( function ( ext ) {

				ext.afterParse && ext.afterParse( input );

			} );

		}

		_invokeAll( func ) {

			for ( let i = 0, il = this.plugins.length; i < il; i ++ ) {

				func( this.plugins[ i ] );

			}

		}

	}
	/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */


	class GLTFLightExtension {

		constructor( writer ) {

			this.writer = writer;
			this.name = 'KHR_lights_punctual';

		}

		writeNode( light, nodeDef ) {

			if ( ! light.isLight ) return;

			if ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {

				console.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );
				return;

			}

			const writer = this.writer;
			const json = writer.json;
			const extensionsUsed = writer.extensionsUsed;
			const lightDef = {};
			if ( light.name ) lightDef.name = light.name;
			lightDef.color = light.color.toArray();
			lightDef.intensity = light.intensity;

			if ( light.isDirectionalLight ) {

				lightDef.type = 'directional';

			} else if ( light.isPointLight ) {

				lightDef.type = 'point';
				if ( light.distance > 0 ) lightDef.range = light.distance;

			} else if ( light.isSpotLight ) {

				lightDef.type = 'spot';
				if ( light.distance > 0 ) lightDef.range = light.distance;
				lightDef.spot = {};
				lightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;
				lightDef.spot.outerConeAngle = light.angle;

			}

			if ( light.decay !== undefined && light.decay !== 2 ) {

				console.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.' );

			}

			if ( light.target && ( light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== - 1 ) ) {

				console.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.' );

			}

			if ( ! extensionsUsed[ this.name ] ) {

				json.extensions = json.extensions || {};
				json.extensions[ this.name ] = {
					lights: []
				};
				extensionsUsed[ this.name ] = true;

			}

			const lights = json.extensions[ this.name ].lights;
			lights.push( lightDef );
			nodeDef.extensions = nodeDef.extensions || {};
			nodeDef.extensions[ this.name ] = {
				light: lights.length - 1
			};

		}

	}
	/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */


	class GLTFMaterialsUnlitExtension {

		constructor( writer ) {

			this.writer = writer;
			this.name = 'KHR_materials_unlit';

		}

		writeMaterial( material, materialDef ) {

			if ( ! material.isMeshBasicMaterial ) return;
			const writer = this.writer;
			const extensionsUsed = writer.extensionsUsed;
			materialDef.extensions = materialDef.extensions || {};
			materialDef.extensions[ this.name ] = {};
			extensionsUsed[ this.name ] = true;
			materialDef.pbrMetallicRoughness.metallicFactor = 0.0;
			materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;

		}

	}
	/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */


	class GLTFMaterialsPBRSpecularGlossiness {

		constructor( writer ) {

			this.writer = writer;
			this.name = 'KHR_materials_pbrSpecularGlossiness';

		}

		writeMaterial( material, materialDef ) {

			if ( ! material.isGLTFSpecularGlossinessMaterial ) return;
			const writer = this.writer;
			const extensionsUsed = writer.extensionsUsed;
			const extensionDef = {};

			if ( materialDef.pbrMetallicRoughness.baseColorFactor ) {

				extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;

			}

			const specularFactor = [ 1, 1, 1 ];
			material.specular.toArray( specularFactor, 0 );
			extensionDef.specularFactor = specularFactor;
			extensionDef.glossinessFactor = material.glossiness;

			if ( materialDef.pbrMetallicRoughness.baseColorTexture ) {

				extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;

			}

			if ( material.specularMap ) {

				const specularMapDef = {
					index: writer.processTexture( material.specularMap )
				};
				writer.applyTextureTransform( specularMapDef, material.specularMap );
				extensionDef.specularGlossinessTexture = specularMapDef;

			}

			materialDef.extensions = materialDef.extensions || {};
			materialDef.extensions[ this.name ] = extensionDef;
			extensionsUsed[ this.name ] = true;

		}

	}
	/**
 * Static utility functions
 */


	GLTFExporter.Utils = {
		insertKeyframe: function ( track, time ) {

			const tolerance = 0.001; // 1ms

			const valueSize = track.getValueSize();
			const times = new track.TimeBufferType( track.times.length + 1 );
			const values = new track.ValueBufferType( track.values.length + valueSize );
			const interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );
			let index;

			if ( track.times.length === 0 ) {

				times[ 0 ] = time;

				for ( let i = 0; i < valueSize; i ++ ) {

					values[ i ] = 0;

				}

				index = 0;

			} else if ( time < track.times[ 0 ] ) {

				if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;
				times[ 0 ] = time;
				times.set( track.times, 1 );
				values.set( interpolant.evaluate( time ), 0 );
				values.set( track.values, valueSize );
				index = 0;

			} else if ( time > track.times[ track.times.length - 1 ] ) {

				if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {

					return track.times.length - 1;

				}

				times[ times.length - 1 ] = time;
				times.set( track.times, 0 );
				values.set( track.values, 0 );
				values.set( interpolant.evaluate( time ), track.values.length );
				index = times.length - 1;

			} else {

				for ( let i = 0; i < track.times.length; i ++ ) {

					if ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;

					if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {

						times.set( track.times.slice( 0, i + 1 ), 0 );
						times[ i + 1 ] = time;
						times.set( track.times.slice( i + 1 ), i + 2 );
						values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );
						values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );
						values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );
						index = i + 1;
						break;

					}

				}

			}

			track.times = times;
			track.values = values;
			return index;

		},
		mergeMorphTargetTracks: function ( clip, root ) {

			const tracks = [];
			const mergedTracks = {};
			const sourceTracks = clip.tracks;

			for ( let i = 0; i < sourceTracks.length; ++ i ) {

				let sourceTrack = sourceTracks[ i ];
				const sourceTrackBinding = THREE.PropertyBinding.parseTrackName( sourceTrack.name );
				const sourceTrackNode = THREE.PropertyBinding.findNode( root, sourceTrackBinding.nodeName );

				if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {

					// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
					tracks.push( sourceTrack );
					continue;

				}

				if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {

					if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

						// This should never happen, because glTF morph target animations
						// affect all targets already.
						throw new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );

					}

					console.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );
					sourceTrack = sourceTrack.clone();
					sourceTrack.setInterpolation( THREE.InterpolateLinear );

				}

				const targetCount = sourceTrackNode.morphTargetInfluences.length;
				const targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];

				if ( targetIndex === undefined ) {

					throw new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );

				}

				let mergedTrack; // If this is the first time we've seen this object, create a new
				// track to store merged keyframe data for each morph target.

				if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {

					mergedTrack = sourceTrack.clone();
					const values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );

					for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

						values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];

					} // We need to take into consideration the intended target node
					// of our original un-merged morphTarget animation.


					mergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';
					mergedTrack.values = values;
					mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;
					tracks.push( mergedTrack );
					continue;

				}

				const sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );
				mergedTrack = mergedTracks[ sourceTrackNode.uuid ]; // For every existing keyframe of the merged track, write a (possibly
				// interpolated) value from the source track.

				for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

					mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );

				} // For every existing keyframe of the source track, write a (possibly
				// new) keyframe to the merged track. Values from the previous loop may
				// be written again, but keyframes are de-duplicated.


				for ( let j = 0; j < sourceTrack.times.length; j ++ ) {

					const keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );
					mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];

				}

			}

			clip.tracks = tracks;
			return clip;

		}
	};

	THREE.GLTFExporter = GLTFExporter;

} )();

( function () {

	class GLTFLoader extends THREE.Loader {

		constructor( manager ) {

			super( manager );
			this.dracoLoader = null;
			this.ktx2Loader = null;
			this.meshoptDecoder = null;
			this.pluginCallbacks = [];
			this.register( function ( parser ) {

				return new GLTFMaterialsClearcoatExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFTextureBasisUExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFTextureWebPExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFMaterialsTransmissionExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFLightsExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFMeshoptCompression( parser );

			} );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;
			let resourcePath;

			if ( this.resourcePath !== '' ) {

				resourcePath = this.resourcePath;

			} else if ( this.path !== '' ) {

				resourcePath = this.path;

			} else {

				resourcePath = THREE.LoaderUtils.extractUrlBase( url );

			} // Tells the LoadingManager to track an extra item, which resolves after
			// the model is fully loaded. This means the count of items loaded will
			// be incorrect, but ensures manager.onLoad() does not fire early.


			this.manager.itemStart( url );

			const _onError = function ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			};

			const loader = new THREE.FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( data ) {

				try {

					scope.parse( data, resourcePath, function ( gltf ) {

						onLoad( gltf );
						scope.manager.itemEnd( url );

					}, _onError );

				} catch ( e ) {

					_onError( e );

				}

			}, onProgress, _onError );

		}

		setDRACOLoader( dracoLoader ) {

			this.dracoLoader = dracoLoader;
			return this;

		}

		setDDSLoader() {

			throw new Error( 'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".' );

		}

		setKTX2Loader( ktx2Loader ) {

			this.ktx2Loader = ktx2Loader;
			return this;

		}

		setMeshoptDecoder( meshoptDecoder ) {

			this.meshoptDecoder = meshoptDecoder;
			return this;

		}

		register( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

				this.pluginCallbacks.push( callback );

			}

			return this;

		}

		unregister( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

				this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

			}

			return this;

		}

		parse( data, path, onLoad, onError ) {

			let content;
			const extensions = {};
			const plugins = {};

			if ( typeof data === 'string' ) {

				content = data;

			} else {

				const magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

				if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

					try {

						extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

					} catch ( error ) {

						if ( onError ) onError( error );
						return;

					}

					content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

				} else {

					content = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );

				}

			}

			const json = JSON.parse( content );

			if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

				if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
				return;

			}

			const parser = new GLTFParser( json, {
				path: path || this.resourcePath || '',
				crossOrigin: this.crossOrigin,
				requestHeader: this.requestHeader,
				manager: this.manager,
				ktx2Loader: this.ktx2Loader,
				meshoptDecoder: this.meshoptDecoder
			} );
			parser.fileLoader.setRequestHeader( this.requestHeader );

			for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

				const plugin = this.pluginCallbacks[ i ]( parser );
				plugins[ plugin.name ] = plugin; // Workaround to avoid determining as unknown extension
				// in addUnknownExtensionsToUserData().
				// Remove this workaround if we move all the existing
				// extension handlers to plugin system

				extensions[ plugin.name ] = true;

			}

			if ( json.extensionsUsed ) {

				for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

					const extensionName = json.extensionsUsed[ i ];
					const extensionsRequired = json.extensionsRequired || [];

					switch ( extensionName ) {

						case EXTENSIONS.KHR_MATERIALS_UNLIT:
							extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
							break;

						case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
							extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
							break;

						case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
							extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
							break;

						case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
							extensions[ extensionName ] = new GLTFTextureTransformExtension();
							break;

						case EXTENSIONS.KHR_MESH_QUANTIZATION:
							extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
							break;

						default:
							if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

								console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

							}

					}

				}

			}

			parser.setExtensions( extensions );
			parser.setPlugins( plugins );
			parser.parse( onLoad, onError );

		}

	}
	/* GLTFREGISTRY */


	function GLTFRegistry() {

		let objects = {};
		return {
			get: function ( key ) {

				return objects[ key ];

			},
			add: function ( key, object ) {

				objects[ key ] = object;

			},
			remove: function ( key ) {

				delete objects[ key ];

			},
			removeAll: function () {

				objects = {};

			}
		};

	}
	/*********************************/

	/********** EXTENSIONS ***********/

	/*********************************/


	const EXTENSIONS = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
		KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
		KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
		KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
		KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
		EXT_TEXTURE_WEBP: 'EXT_texture_webp',
		EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
	};
	/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */

	class GLTFLightsExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // THREE.Object3D instance caches

			this.cache = {
				refs: {},
				uses: {}
			};

		}

		_markDefs() {

			const parser = this.parser;
			const nodeDefs = this.parser.json.nodes || [];

			for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				const nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.extensions && nodeDef.extensions[ this.name ] && nodeDef.extensions[ this.name ].light !== undefined ) {

					parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

				}

			}

		}

		_loadLight( lightIndex ) {

			const parser = this.parser;
			const cacheKey = 'light:' + lightIndex;
			let dependency = parser.cache.get( cacheKey );
			if ( dependency ) return dependency;
			const json = parser.json;
			const extensions = json.extensions && json.extensions[ this.name ] || {};
			const lightDefs = extensions.lights || [];
			const lightDef = lightDefs[ lightIndex ];
			let lightNode;
			const color = new THREE.Color( 0xffffff );
			if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );
			const range = lightDef.range !== undefined ? lightDef.range : 0;

			switch ( lightDef.type ) {

				case 'directional':
					lightNode = new THREE.DirectionalLight( color );
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				case 'point':
					lightNode = new THREE.PointLight( color );
					lightNode.distance = range;
					break;

				case 'spot':
					lightNode = new THREE.SpotLight( color );
					lightNode.distance = range; // Handle spotlight properties.

					lightDef.spot = lightDef.spot || {};
					lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
					lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
					lightNode.angle = lightDef.spot.outerConeAngle;
					lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				default:
					throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

			} // Some lights (e.g. spot) default to a position other than the origin. Reset the position
			// here, because node-level parsing will only override position if explicitly specified.


			lightNode.position.set( 0, 0, 0 );
			lightNode.decay = 2;
			if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;
			lightNode.name = parser.createUniqueName( lightDef.name || 'light_' + lightIndex );
			dependency = Promise.resolve( lightNode );
			parser.cache.add( cacheKey, dependency );
			return dependency;

		}

		createNodeAttachment( nodeIndex ) {

			const self = this;
			const parser = this.parser;
			const json = parser.json;
			const nodeDef = json.nodes[ nodeIndex ];
			const lightDef = nodeDef.extensions && nodeDef.extensions[ this.name ] || {};
			const lightIndex = lightDef.light;
			if ( lightIndex === undefined ) return null;
			return this._loadLight( lightIndex ).then( function ( light ) {

				return parser._getNodeRef( self.cache, lightIndex, light );

			} );

		}

	}
	/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */


	class GLTFMaterialsUnlitExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

		}

		getMaterialType() {

			return THREE.MeshBasicMaterial;

		}

		extendParams( materialParams, materialDef, parser ) {

			const pending = [];
			materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;
			const metallicRoughness = materialDef.pbrMetallicRoughness;

			if ( metallicRoughness ) {

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					const array = metallicRoughness.baseColorFactor;
					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

				}

			}

			return Promise.all( pending );

		}

	}
	/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */


	class GLTFMaterialsClearcoatExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];
			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;
			return THREE.MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];
			const extension = materialDef.extensions[ this.name ];

			if ( extension.clearcoatFactor !== undefined ) {

				materialParams.clearcoat = extension.clearcoatFactor;

			}

			if ( extension.clearcoatTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

			}

			if ( extension.clearcoatRoughnessFactor !== undefined ) {

				materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

			}

			if ( extension.clearcoatRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

			}

			if ( extension.clearcoatNormalTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

				if ( extension.clearcoatNormalTexture.scale !== undefined ) {

					const scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995

					materialParams.clearcoatNormalScale = new THREE.Vector2( scale, - scale );

				}

			}

			return Promise.all( pending );

		}

	}
	/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */


	class GLTFMaterialsTransmissionExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];
			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;
			return THREE.MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];
			const extension = materialDef.extensions[ this.name ];

			if ( extension.transmissionFactor !== undefined ) {

				materialParams.transmission = extension.transmissionFactor;

			}

			if ( extension.transmissionTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

			}

			return Promise.all( pending );

		}

	}
	/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */


	class GLTFTextureBasisUExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

		}

		loadTexture( textureIndex ) {

			const parser = this.parser;
			const json = parser.json;
			const textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

				return null;

			}

			const extension = textureDef.extensions[ this.name ];
			const source = json.images[ extension.source ];
			const loader = parser.options.ktx2Loader;

			if ( ! loader ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

				} else {

					// Assumes that the extension is optional and that a fallback texture is present
					return null;

				}

			}

			return parser.loadTextureImage( textureIndex, source, loader );

		}

	}
	/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */


	class GLTFTextureWebPExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
			this.isSupported = null;

		}

		loadTexture( textureIndex ) {

			const name = this.name;
			const parser = this.parser;
			const json = parser.json;
			const textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

				return null;

			}

			const extension = textureDef.extensions[ name ];
			const source = json.images[ extension.source ];
			let loader = parser.textureLoader;

			if ( source.uri ) {

				const handler = parser.options.manager.getHandler( source.uri );
				if ( handler !== null ) loader = handler;

			}

			return this.detectSupport().then( function ( isSupported ) {

				if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

				} // Fall back to PNG or JPEG.


				return parser.loadTexture( textureIndex );

			} );

		}

		detectSupport() {

			if ( ! this.isSupported ) {

				this.isSupported = new Promise( function ( resolve ) {

					const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all
					// WebP images, unfortunately.

					image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

					image.onload = image.onerror = function () {

						resolve( image.height === 1 );

					};

				} );

			}

			return this.isSupported;

		}

	}
	/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */


	class GLTFMeshoptCompression {

		constructor( parser ) {

			this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
			this.parser = parser;

		}

		loadBufferView( index ) {

			const json = this.parser.json;
			const bufferView = json.bufferViews[ index ];

			if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

				const extensionDef = bufferView.extensions[ this.name ];
				const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
				const decoder = this.parser.options.meshoptDecoder;

				if ( ! decoder || ! decoder.supported ) {

					if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

						throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

					} else {

						// Assumes that the extension is optional and that fallback buffer data is present
						return null;

					}

				}

				return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

					const byteOffset = extensionDef.byteOffset || 0;
					const byteLength = extensionDef.byteLength || 0;
					const count = extensionDef.count;
					const stride = extensionDef.byteStride;
					const result = new ArrayBuffer( count * stride );
					const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );
					decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
					return result;

				} );

			} else {

				return null;

			}

		}

	}
	/* BINARY EXTENSION */


	const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
	const BINARY_EXTENSION_HEADER_LENGTH = 12;
	const BINARY_EXTENSION_CHUNK_TYPES = {
		JSON: 0x4E4F534A,
		BIN: 0x004E4942
	};

	class GLTFBinaryExtension {

		constructor( data ) {

			this.name = EXTENSIONS.KHR_BINARY_GLTF;
			this.content = null;
			this.body = null;
			const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
			this.header = {
				magic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
				version: headerView.getUint32( 4, true ),
				length: headerView.getUint32( 8, true )
			};

			if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

				throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

			} else if ( this.header.version < 2.0 ) {

				throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

			}

			const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
			const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
			let chunkIndex = 0;

			while ( chunkIndex < chunkContentsLength ) {

				const chunkLength = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;
				const chunkType = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;

				if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

					const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
					this.content = THREE.LoaderUtils.decodeText( contentArray );

				} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

					const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
					this.body = data.slice( byteOffset, byteOffset + chunkLength );

				} // Clients must ignore chunks with unknown types.


				chunkIndex += chunkLength;

			}

			if ( this.content === null ) {

				throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

			}

		}

	}
	/**
 * DRACO THREE.Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */


	class GLTFDracoMeshCompressionExtension {

		constructor( json, dracoLoader ) {

			if ( ! dracoLoader ) {

				throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

			}

			this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
			this.json = json;
			this.dracoLoader = dracoLoader;
			this.dracoLoader.preload();

		}

		decodePrimitive( primitive, parser ) {

			const json = this.json;
			const dracoLoader = this.dracoLoader;
			const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
			const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
			const threeAttributeMap = {};
			const attributeNormalizedMap = {};
			const attributeTypeMap = {};

			for ( const attributeName in gltfAttributeMap ) {

				const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();
				threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

			}

			for ( const attributeName in primitive.attributes ) {

				const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

				if ( gltfAttributeMap[ attributeName ] !== undefined ) {

					const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
					const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
					attributeTypeMap[ threeAttributeName ] = componentType;
					attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

				}

			}

			return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

				return new Promise( function ( resolve ) {

					dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

						for ( const attributeName in geometry.attributes ) {

							const attribute = geometry.attributes[ attributeName ];
							const normalized = attributeNormalizedMap[ attributeName ];
							if ( normalized !== undefined ) attribute.normalized = normalized;

						}

						resolve( geometry );

					}, threeAttributeMap, attributeTypeMap );

				} );

			} );

		}

	}
	/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */


	class GLTFTextureTransformExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

		}

		extendTexture( texture, transform ) {

			if ( transform.texCoord !== undefined ) {

				console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

			}

			if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

				// See https://github.com/mrdoob/three.js/issues/21819.
				return texture;

			}

			texture = texture.clone();

			if ( transform.offset !== undefined ) {

				texture.offset.fromArray( transform.offset );

			}

			if ( transform.rotation !== undefined ) {

				texture.rotation = transform.rotation;

			}

			if ( transform.scale !== undefined ) {

				texture.repeat.fromArray( transform.scale );

			}

			texture.needsUpdate = true;
			return texture;

		}

	}
	/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */

	/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */


	class GLTFMeshStandardSGMaterial extends THREE.MeshStandardMaterial {

		constructor( params ) {

			super();
			this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing

			const specularMapParsFragmentChunk = [ '#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif' ].join( '\n' );
			const glossinessMapParsFragmentChunk = [ '#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif' ].join( '\n' );
			const specularMapFragmentChunk = [ 'vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif' ].join( '\n' );
			const glossinessMapFragmentChunk = [ 'float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif' ].join( '\n' );
			const lightPhysicalFragmentChunk = [ 'PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;' ].join( '\n' );
			const uniforms = {
				specular: {
					value: new THREE.Color().setHex( 0xffffff )
				},
				glossiness: {
					value: 1
				},
				specularMap: {
					value: null
				},
				glossinessMap: {
					value: null
				}
			};
			this._extraUniforms = uniforms;

			this.onBeforeCompile = function ( shader ) {

				for ( const uniformName in uniforms ) {

					shader.uniforms[ uniformName ] = uniforms[ uniformName ];

				}

				shader.fragmentShader = shader.fragmentShader.replace( 'uniform float roughness;', 'uniform vec3 specular;' ).replace( 'uniform float metalness;', 'uniform float glossiness;' ).replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk ).replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk ).replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk ).replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk ).replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

			};

			Object.defineProperties( this, {
				specular: {
					get: function () {

						return uniforms.specular.value;

					},
					set: function ( v ) {

						uniforms.specular.value = v;

					}
				},
				specularMap: {
					get: function () {

						return uniforms.specularMap.value;

					},
					set: function ( v ) {

						uniforms.specularMap.value = v;

						if ( v ) {

							this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

						} else {

							delete this.defines.USE_SPECULARMAP;

						}

					}
				},
				glossiness: {
					get: function () {

						return uniforms.glossiness.value;

					},
					set: function ( v ) {

						uniforms.glossiness.value = v;

					}
				},
				glossinessMap: {
					get: function () {

						return uniforms.glossinessMap.value;

					},
					set: function ( v ) {

						uniforms.glossinessMap.value = v;

						if ( v ) {

							this.defines.USE_GLOSSINESSMAP = '';
							this.defines.USE_UV = '';

						} else {

							delete this.defines.USE_GLOSSINESSMAP;
							delete this.defines.USE_UV;

						}

					}
				}
			} );
			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;
			this.setValues( params );

		}

		copy( source ) {

			super.copy( source );
			this.specularMap = source.specularMap;
			this.specular.copy( source.specular );
			this.glossinessMap = source.glossinessMap;
			this.glossiness = source.glossiness;
			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;
			return this;

		}

	}

	class GLTFMaterialsPbrSpecularGlossinessExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
			this.specularGlossinessParams = [ 'color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio' ];

		}

		getMaterialType() {

			return GLTFMeshStandardSGMaterial;

		}

		extendParams( materialParams, materialDef, parser ) {

			const pbrSpecularGlossiness = materialDef.extensions[ this.name ];
			materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;
			const pending = [];

			if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

				const array = pbrSpecularGlossiness.diffuseFactor;
				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

			}

			materialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );
			materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
			materialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );

			if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

				materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

			}

			if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

				const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
				pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
				pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

			}

			return Promise.all( pending );

		}

		createMaterial( materialParams ) {

			const material = new GLTFMeshStandardSGMaterial( materialParams );
			material.fog = true;
			material.color = materialParams.color;
			material.map = materialParams.map === undefined ? null : materialParams.map;
			material.lightMap = null;
			material.lightMapIntensity = 1.0;
			material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
			material.aoMapIntensity = 1.0;
			material.emissive = materialParams.emissive;
			material.emissiveIntensity = 1.0;
			material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
			material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
			material.bumpScale = 1;
			material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
			material.normalMapType = THREE.TangentSpaceNormalMap;
			if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;
			material.displacementMap = null;
			material.displacementScale = 1;
			material.displacementBias = 0;
			material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
			material.specular = materialParams.specular;
			material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
			material.glossiness = materialParams.glossiness;
			material.alphaMap = null;
			material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
			material.envMapIntensity = 1.0;
			material.refractionRatio = 0.98;
			return material;

		}

	}
	/**
 * THREE.Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */


	class GLTFMeshQuantizationExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

		}

	}
	/*********************************/

	/********** INTERPOLATION ********/

	/*********************************/
	// Spline Interpolation
	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


	class GLTFCubicSplineInterpolant extends THREE.Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		copySampleValue_( index ) {

			// Copies a sample value to the result buffer. See description of glTF
			// CUBICSPLINE values layout in interpolate_() function below.
			const result = this.resultBuffer,
				values = this.sampleValues,
				valueSize = this.valueSize,
				offset = index * valueSize * 3 + valueSize;

			for ( let i = 0; i !== valueSize; i ++ ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		}

	}

	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

	GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;
		const stride2 = stride * 2;
		const stride3 = stride * 3;
		const td = t1 - t0;
		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;
		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;
		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k

			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)

			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1

			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	};
	/*********************************/

	/********** INTERNALS ************/

	/*********************************/

	/* CONSTANTS */


	const WEBGL_CONSTANTS = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	};
	const WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	};
	const WEBGL_FILTERS = {
		9728: THREE.NearestFilter,
		9729: THREE.LinearFilter,
		9984: THREE.NearestMipmapNearestFilter,
		9985: THREE.LinearMipmapNearestFilter,
		9986: THREE.NearestMipmapLinearFilter,
		9987: THREE.LinearMipmapLinearFilter
	};
	const WEBGL_WRAPPINGS = {
		33071: THREE.ClampToEdgeWrapping,
		33648: THREE.MirroredRepeatWrapping,
		10497: THREE.RepeatWrapping
	};
	const WEBGL_TYPE_SIZES = {
		'SCALAR': 1,
		'VEC2': 2,
		'VEC3': 3,
		'VEC4': 4,
		'MAT2': 4,
		'MAT3': 9,
		'MAT4': 16
	};
	const ATTRIBUTES = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		TEXCOORD_0: 'uv',
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex'
	};
	const PATH_PROPERTIES = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	};
	const INTERPOLATION = {
		CUBICSPLINE: undefined,
		// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		// keyframe track will be initialized with a default interpolation type, then modified.
		LINEAR: THREE.InterpolateLinear,
		STEP: THREE.InterpolateDiscrete
	};
	const ALPHA_MODES = {
		OPAQUE: 'OPAQUE',
		MASK: 'MASK',
		BLEND: 'BLEND'
	};
	/* UTILITY FUNCTIONS */

	function resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return ''; // Host Relative URL

		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		} // Absolute URL http://,https://,//


		if ( /^(https?:)?\/\//i.test( url ) ) return url; // Data URI

		if ( /^data:.*,.*$/i.test( url ) ) return url; // Blob URL

		if ( /^blob:.*$/i.test( url ) ) return url; // Relative URL

		return path + url;

	}
	/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */


	function createDefaultMaterial( cache ) {

		if ( cache[ 'DefaultMaterial' ] === undefined ) {

			cache[ 'DefaultMaterial' ] = new THREE.MeshStandardMaterial( {
				color: 0xFFFFFF,
				emissive: 0x000000,
				metalness: 1,
				roughness: 1,
				transparent: false,
				depthTest: true,
				side: THREE.FrontSide
			} );

		}

		return cache[ 'DefaultMaterial' ];

	}

	function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

		// Add unknown glTF extensions to an object's userData.
		for ( const name in objectDef.extensions ) {

			if ( knownExtensions[ name ] === undefined ) {

				object.userData.gltfExtensions = object.userData.gltfExtensions || {};
				object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

			}

		}

	}
	/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */


	function assignExtrasToUserData( object, gltfDef ) {

		if ( gltfDef.extras !== undefined ) {

			if ( typeof gltfDef.extras === 'object' ) {

				Object.assign( object.userData, gltfDef.extras );

			} else {

				console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

			}

		}

	}
	/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */


	function addMorphTargets( geometry, targets, parser ) {

		let hasMorphPosition = false;
		let hasMorphNormal = false;

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];
			if ( target.POSITION !== undefined ) hasMorphPosition = true;
			if ( target.NORMAL !== undefined ) hasMorphNormal = true;
			if ( hasMorphPosition && hasMorphNormal ) break;

		}

		if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );
		const pendingPositionAccessors = [];
		const pendingNormalAccessors = [];

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( hasMorphPosition ) {

				const pendingAccessor = target.POSITION !== undefined ? parser.getDependency( 'accessor', target.POSITION ) : geometry.attributes.position;
				pendingPositionAccessors.push( pendingAccessor );

			}

			if ( hasMorphNormal ) {

				const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency( 'accessor', target.NORMAL ) : geometry.attributes.normal;
				pendingNormalAccessors.push( pendingAccessor );

			}

		}

		return Promise.all( [ Promise.all( pendingPositionAccessors ), Promise.all( pendingNormalAccessors ) ] ).then( function ( accessors ) {

			const morphPositions = accessors[ 0 ];
			const morphNormals = accessors[ 1 ];
			if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
			if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
			geometry.morphTargetsRelative = true;
			return geometry;

		} );

	}
	/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */


	function updateMorphTargets( mesh, meshDef ) {

		mesh.updateMorphTargets();

		if ( meshDef.weights !== undefined ) {

			for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

				mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

			}

		} // .extras has user-defined data, so check that .extras.targetNames is an array.


		if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

			const targetNames = meshDef.extras.targetNames;

			if ( mesh.morphTargetInfluences.length === targetNames.length ) {

				mesh.morphTargetDictionary = {};

				for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

					mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

			}

		}

	}

	function createPrimitiveKey( primitiveDef ) {

		const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
		let geometryKey;

		if ( dracoExtension ) {

			geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey( dracoExtension.attributes );

		} else {

			geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

		}

		return geometryKey;

	}

	function createAttributesKey( attributes ) {

		let attributesKey = '';
		const keys = Object.keys( attributes ).sort();

		for ( let i = 0, il = keys.length; i < il; i ++ ) {

			attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

		}

		return attributesKey;

	}

	function getNormalizedComponentScale( constructor ) {

		// Reference:
		// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
		switch ( constructor ) {

			case Int8Array:
				return 1 / 127;

			case Uint8Array:
				return 1 / 255;

			case Int16Array:
				return 1 / 32767;

			case Uint16Array:
				return 1 / 65535;

			default:
				throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

		}

	}
	/* GLTF PARSER */


	class GLTFParser {

		constructor( json = {}, options = {} ) {

			this.json = json;
			this.extensions = {};
			this.plugins = {};
			this.options = options; // loader object cache

			this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements

			this.associations = new Map(); // THREE.BufferGeometry caching

			this.primitiveCache = {}; // THREE.Object3D instance caches

			this.meshCache = {
				refs: {},
				uses: {}
			};
			this.cameraCache = {
				refs: {},
				uses: {}
			};
			this.lightCache = {
				refs: {},
				uses: {}
			};
			this.textureCache = {}; // Track node names, to ensure no duplicates

			this.nodeNamesUsed = {}; // Use an THREE.ImageBitmapLoader if imageBitmaps are supported. Moves much of the
			// expensive work of uploading a texture to the GPU off the main thread.

			if ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {

				this.textureLoader = new THREE.ImageBitmapLoader( this.options.manager );

			} else {

				this.textureLoader = new THREE.TextureLoader( this.options.manager );

			}

			this.textureLoader.setCrossOrigin( this.options.crossOrigin );
			this.textureLoader.setRequestHeader( this.options.requestHeader );
			this.fileLoader = new THREE.FileLoader( this.options.manager );
			this.fileLoader.setResponseType( 'arraybuffer' );

			if ( this.options.crossOrigin === 'use-credentials' ) {

				this.fileLoader.setWithCredentials( true );

			}

		}

		setExtensions( extensions ) {

			this.extensions = extensions;

		}

		setPlugins( plugins ) {

			this.plugins = plugins;

		}

		parse( onLoad, onError ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions; // Clear the loader cache

			this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

			this._invokeAll( function ( ext ) {

				return ext._markDefs && ext._markDefs();

			} );

			Promise.all( this._invokeAll( function ( ext ) {

				return ext.beforeRoot && ext.beforeRoot();

			} ) ).then( function () {

				return Promise.all( [ parser.getDependencies( 'scene' ), parser.getDependencies( 'animation' ), parser.getDependencies( 'camera' ) ] );

			} ).then( function ( dependencies ) {

				const result = {
					scene: dependencies[ 0 ][ json.scene || 0 ],
					scenes: dependencies[ 0 ],
					animations: dependencies[ 1 ],
					cameras: dependencies[ 2 ],
					asset: json.asset,
					parser: parser,
					userData: {}
				};
				addUnknownExtensionsToUserData( extensions, result, json );
				assignExtrasToUserData( result, json );
				Promise.all( parser._invokeAll( function ( ext ) {

					return ext.afterRoot && ext.afterRoot( result );

				} ) ).then( function () {

					onLoad( result );

				} );

			} ).catch( onError );

		}
		/**
   * Marks the special nodes/meshes in json for efficient parse.
   */


		_markDefs() {

			const nodeDefs = this.json.nodes || [];
			const skinDefs = this.json.skins || [];
			const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a THREE.Bone or an
			// THREE.Object3D. Use the skins' joint references to mark bones.

			for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

				const joints = skinDefs[ skinIndex ].joints;

				for ( let i = 0, il = joints.length; i < il; i ++ ) {

					nodeDefs[ joints[ i ] ].isBone = true;

				}

			} // Iterate over all nodes, marking references to shared resources,
			// as well as skeleton joints.


			for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				const nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.mesh !== undefined ) {

					this._addNodeRef( this.meshCache, nodeDef.mesh ); // Nothing in the mesh definition indicates whether it is
					// a THREE.SkinnedMesh or THREE.Mesh. Use the node's mesh reference
					// to mark THREE.SkinnedMesh if node has skin.


					if ( nodeDef.skin !== undefined ) {

						meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

					}

				}

				if ( nodeDef.camera !== undefined ) {

					this._addNodeRef( this.cameraCache, nodeDef.camera );

				}

			}

		}
		/**
   * Counts references to shared node / THREE.Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. THREE.Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */


		_addNodeRef( cache, index ) {

			if ( index === undefined ) return;

			if ( cache.refs[ index ] === undefined ) {

				cache.refs[ index ] = cache.uses[ index ] = 0;

			}

			cache.refs[ index ] ++;

		}
		/** Returns a reference to a shared resource, cloning it if necessary. */


		_getNodeRef( cache, index, object ) {

			if ( cache.refs[ index ] <= 1 ) return object;
			const ref = object.clone();
			ref.name += '_instance_' + cache.uses[ index ] ++;
			return ref;

		}

		_invokeOne( func ) {

			const extensions = Object.values( this.plugins );
			extensions.push( this );

			for ( let i = 0; i < extensions.length; i ++ ) {

				const result = func( extensions[ i ] );
				if ( result ) return result;

			}

			return null;

		}

		_invokeAll( func ) {

			const extensions = Object.values( this.plugins );
			extensions.unshift( this );
			const pending = [];

			for ( let i = 0; i < extensions.length; i ++ ) {

				const result = func( extensions[ i ] );
				if ( result ) pending.push( result );

			}

			return pending;

		}
		/**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */


		getDependency( type, index ) {

			const cacheKey = type + ':' + index;
			let dependency = this.cache.get( cacheKey );

			if ( ! dependency ) {

				switch ( type ) {

					case 'scene':
						dependency = this.loadScene( index );
						break;

					case 'node':
						dependency = this.loadNode( index );
						break;

					case 'mesh':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMesh && ext.loadMesh( index );

						} );
						break;

					case 'accessor':
						dependency = this.loadAccessor( index );
						break;

					case 'bufferView':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadBufferView && ext.loadBufferView( index );

						} );
						break;

					case 'buffer':
						dependency = this.loadBuffer( index );
						break;

					case 'material':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMaterial && ext.loadMaterial( index );

						} );
						break;

					case 'texture':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadTexture && ext.loadTexture( index );

						} );
						break;

					case 'skin':
						dependency = this.loadSkin( index );
						break;

					case 'animation':
						dependency = this.loadAnimation( index );
						break;

					case 'camera':
						dependency = this.loadCamera( index );
						break;

					default:
						throw new Error( 'Unknown type: ' + type );

				}

				this.cache.add( cacheKey, dependency );

			}

			return dependency;

		}
		/**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */


		getDependencies( type ) {

			let dependencies = this.cache.get( type );

			if ( ! dependencies ) {

				const parser = this;
				const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];
				dependencies = Promise.all( defs.map( function ( def, index ) {

					return parser.getDependency( type, index );

				} ) );
				this.cache.add( type, dependencies );

			}

			return dependencies;

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */


		loadBuffer( bufferIndex ) {

			const bufferDef = this.json.buffers[ bufferIndex ];
			const loader = this.fileLoader;

			if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

				throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

			} // If present, GLB container is required to be the first buffer.


			if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

				return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

			}

			const options = this.options;
			return new Promise( function ( resolve, reject ) {

				loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

					reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

				} );

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */


		loadBufferView( bufferViewIndex ) {

			const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];
			return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

				const byteLength = bufferViewDef.byteLength || 0;
				const byteOffset = bufferViewDef.byteOffset || 0;
				return buffer.slice( byteOffset, byteOffset + byteLength );

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */


		loadAccessor( accessorIndex ) {

			const parser = this;
			const json = this.json;
			const accessorDef = this.json.accessors[ accessorIndex ];

			if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

				// Ignore empty accessors, which may be used to declare runtime
				// information about attributes coming from another source (e.g. Draco
				// compression extension).
				return Promise.resolve( null );

			}

			const pendingBufferViews = [];

			if ( accessorDef.bufferView !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

			} else {

				pendingBufferViews.push( null );

			}

			if ( accessorDef.sparse !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

			}

			return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

				const bufferView = bufferViews[ 0 ];
				const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
				const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

				const elementBytes = TypedArray.BYTES_PER_ELEMENT;
				const itemBytes = elementBytes * itemSize;
				const byteOffset = accessorDef.byteOffset || 0;
				const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
				const normalized = accessorDef.normalized === true;
				let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

				if ( byteStride && byteStride !== itemBytes ) {

					// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own THREE.InterleavedBuffer
					// This makes sure that IBA.count reflects accessor.count properly
					const ibSlice = Math.floor( byteOffset / byteStride );
					const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
					let ib = parser.cache.get( ibCacheKey );

					if ( ! ib ) {

						array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes ); // Integer parameters to IB/IBA are in array elements, not bytes.

						ib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );
						parser.cache.add( ibCacheKey, ib );

					}

					bufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset % byteStride / elementBytes, normalized );

				} else {

					if ( bufferView === null ) {

						array = new TypedArray( accessorDef.count * itemSize );

					} else {

						array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

					}

					bufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );

				} // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


				if ( accessorDef.sparse !== undefined ) {

					const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
					const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];
					const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
					const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
					const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
					const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

					if ( bufferView !== null ) {

						// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
						bufferAttribute = new THREE.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

					}

					for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

						const index = sparseIndices[ i ];
						bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
						if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
						if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
						if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
						if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.' );

					}

				}

				return bufferAttribute;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */


		loadTexture( textureIndex ) {

			const json = this.json;
			const options = this.options;
			const textureDef = json.textures[ textureIndex ];
			const source = json.images[ textureDef.source ];
			let loader = this.textureLoader;

			if ( source.uri ) {

				const handler = options.manager.getHandler( source.uri );
				if ( handler !== null ) loader = handler;

			}

			return this.loadTextureImage( textureIndex, source, loader );

		}

		loadTextureImage( textureIndex, source, loader ) {

			const parser = this;
			const json = this.json;
			const options = this.options;
			const textureDef = json.textures[ textureIndex ];
			const cacheKey = ( source.uri || source.bufferView ) + ':' + textureDef.sampler;

			if ( this.textureCache[ cacheKey ] ) {

				// See https://github.com/mrdoob/three.js/issues/21559.
				return this.textureCache[ cacheKey ];

			}

			const URL = self.URL || self.webkitURL;
			let sourceURI = source.uri || '';
			let isObjectURL = false;
			let hasAlpha = true;
			const isJPEG = sourceURI.search( /\.jpe?g($|\?)/i ) > 0 || sourceURI.search( /^data\:image\/jpeg/ ) === 0;
			if ( source.mimeType === 'image/jpeg' || isJPEG ) hasAlpha = false;

			if ( source.bufferView !== undefined ) {

				// Load binary image data from bufferView, if provided.
				sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

					if ( source.mimeType === 'image/png' ) {

						// Inspect the PNG 'IHDR' chunk to determine whether the image could have an
						// alpha channel. This check is conservative  the image could have an alpha
						// channel with all values == 1, and the indexed type (colorType == 3) only
						// sometimes contains alpha.
						//
						// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
						const colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );
						hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;

					}

					isObjectURL = true;
					const blob = new Blob( [ bufferView ], {
						type: source.mimeType
					} );
					sourceURI = URL.createObjectURL( blob );
					return sourceURI;

				} );

			} else if ( source.uri === undefined ) {

				throw new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );

			}

			const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

				return new Promise( function ( resolve, reject ) {

					let onLoad = resolve;

					if ( loader.isImageBitmapLoader === true ) {

						onLoad = function ( imageBitmap ) {

							resolve( new THREE.CanvasTexture( imageBitmap ) );

						};

					}

					loader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

				} );

			} ).then( function ( texture ) {

				// Clean up resources and configure Texture.
				if ( isObjectURL === true ) {

					URL.revokeObjectURL( sourceURI );

				}

				texture.flipY = false;
				if ( textureDef.name ) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set THREE.RGBFormat to save space.

				if ( ! hasAlpha ) texture.format = THREE.RGBFormat;
				const samplers = json.samplers || {};
				const sampler = samplers[ textureDef.sampler ] || {};
				texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;
				texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipmapLinearFilter;
				texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;
				texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;
				parser.associations.set( texture, {
					type: 'textures',
					index: textureIndex
				} );
				return texture;

			} );
			this.textureCache[ cacheKey ] = promise;
			return promise;

		}
		/**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise}
   */


		assignTexture( materialParams, mapName, mapDef ) {

			const parser = this;
			return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

				// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
				// However, we will copy UV set 0 to UV set 1 on demand for aoMap
				if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

					console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

				}

				if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

					const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

					if ( transform ) {

						const gltfReference = parser.associations.get( texture );
						texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
						parser.associations.set( texture, gltfReference );

					}

				}

				materialParams[ mapName ] = texture;

			} );

		}
		/**
   * Assigns final material to a THREE.Mesh, THREE.Line, or THREE.Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh THREE.Mesh, THREE.Line, or THREE.Points instance.
   */


		assignFinalMaterial( mesh ) {

			const geometry = mesh.geometry;
			let material = mesh.material;
			const useVertexTangents = geometry.attributes.tangent !== undefined;
			const useVertexColors = geometry.attributes.color !== undefined;
			const useFlatShading = geometry.attributes.normal === undefined;
			const useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
			const useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

			if ( mesh.isPoints ) {

				const cacheKey = 'PointsMaterial:' + material.uuid;
				let pointsMaterial = this.cache.get( cacheKey );

				if ( ! pointsMaterial ) {

					pointsMaterial = new THREE.PointsMaterial();
					THREE.Material.prototype.copy.call( pointsMaterial, material );
					pointsMaterial.color.copy( material.color );
					pointsMaterial.map = material.map;
					pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

					this.cache.add( cacheKey, pointsMaterial );

				}

				material = pointsMaterial;

			} else if ( mesh.isLine ) {

				const cacheKey = 'LineBasicMaterial:' + material.uuid;
				let lineMaterial = this.cache.get( cacheKey );

				if ( ! lineMaterial ) {

					lineMaterial = new THREE.LineBasicMaterial();
					THREE.Material.prototype.copy.call( lineMaterial, material );
					lineMaterial.color.copy( material.color );
					this.cache.add( cacheKey, lineMaterial );

				}

				material = lineMaterial;

			} // Clone the material if it will be modified


			if ( useVertexTangents || useVertexColors || useFlatShading || useMorphTargets ) {

				let cacheKey = 'ClonedMaterial:' + material.uuid + ':';
				if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
				if ( useVertexTangents ) cacheKey += 'vertex-tangents:';
				if ( useVertexColors ) cacheKey += 'vertex-colors:';
				if ( useFlatShading ) cacheKey += 'flat-shading:';
				if ( useMorphTargets ) cacheKey += 'morph-targets:';
				if ( useMorphNormals ) cacheKey += 'morph-normals:';
				let cachedMaterial = this.cache.get( cacheKey );

				if ( ! cachedMaterial ) {

					cachedMaterial = material.clone();
					if ( useVertexColors ) cachedMaterial.vertexColors = true;
					if ( useFlatShading ) cachedMaterial.flatShading = true;
					if ( useMorphTargets ) cachedMaterial.morphTargets = true;
					if ( useMorphNormals ) cachedMaterial.morphNormals = true;

					if ( useVertexTangents ) {

						cachedMaterial.vertexTangents = true; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995

						if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
						if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

					}

					this.cache.add( cacheKey, cachedMaterial );
					this.associations.set( cachedMaterial, this.associations.get( material ) );

				}

				material = cachedMaterial;

			} // workarounds for mesh and geometry


			if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

				geometry.setAttribute( 'uv2', geometry.attributes.uv );

			}

			mesh.material = material;

		}

		getMaterialType( ) {

			return THREE.MeshStandardMaterial;

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */


		loadMaterial( materialIndex ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;
			const materialDef = json.materials[ materialIndex ];
			let materialType;
			const materialParams = {};
			const materialExtensions = materialDef.extensions || {};
			const pending = [];

			if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

				const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
				materialType = sgExtension.getMaterialType();
				pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

			} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

				const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
				materialType = kmuExtension.getMaterialType();
				pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

			} else {

				// Specification:
				// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
				const metallicRoughness = materialDef.pbrMetallicRoughness || {};
				materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
				materialParams.opacity = 1.0;

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					const array = metallicRoughness.baseColorFactor;
					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

				}

				materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
				materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

				if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
					pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

				}

				materialType = this._invokeOne( function ( ext ) {

					return ext.getMaterialType && ext.getMaterialType( materialIndex );

				} );
				pending.push( Promise.all( this._invokeAll( function ( ext ) {

					return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

				} ) ) );

			}

			if ( materialDef.doubleSided === true ) {

				materialParams.side = THREE.DoubleSide;

			}

			const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

			if ( alphaMode === ALPHA_MODES.BLEND ) {

				materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706

				materialParams.depthWrite = false;

			} else {

				materialParams.transparent = false;

				if ( alphaMode === ALPHA_MODES.MASK ) {

					materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

				}

			}

			if ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) ); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995

				materialParams.normalScale = new THREE.Vector2( 1, - 1 );

				if ( materialDef.normalTexture.scale !== undefined ) {

					materialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );

				}

			}

			if ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

				if ( materialDef.occlusionTexture.strength !== undefined ) {

					materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

				}

			}

			if ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				materialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );

			}

			if ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

			}

			return Promise.all( pending ).then( function () {

				let material;

				if ( materialType === GLTFMeshStandardSGMaterial ) {

					material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

				} else {

					material = new materialType( materialParams );

				}

				if ( materialDef.name ) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

				if ( material.map ) material.map.encoding = THREE.sRGBEncoding;
				if ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;
				assignExtrasToUserData( material, materialDef );
				parser.associations.set( material, {
					type: 'materials',
					index: materialIndex
				} );
				if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );
				return material;

			} );

		}
		/** When THREE.Object3D instances are targeted by animation, they need unique names. */


		createUniqueName( originalName ) {

			const sanitizedName = THREE.PropertyBinding.sanitizeNodeName( originalName || '' );
			let name = sanitizedName;

			for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

				name = sanitizedName + '_' + i;

			}

			this.nodeNamesUsed[ name ] = true;
			return name;

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */


		loadGeometries( primitives ) {

			const parser = this;
			const extensions = this.extensions;
			const cache = this.primitiveCache;

			function createDracoPrimitive( primitive ) {

				return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ].decodePrimitive( primitive, parser ).then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

			}

			const pending = [];

			for ( let i = 0, il = primitives.length; i < il; i ++ ) {

				const primitive = primitives[ i ];
				const cacheKey = createPrimitiveKey( primitive ); // See if we've already created this geometry

				const cached = cache[ cacheKey ];

				if ( cached ) {

					// Use the cached geometry if it exists
					pending.push( cached.promise );

				} else {

					let geometryPromise;

					if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

						// Use DRACO geometry if available
						geometryPromise = createDracoPrimitive( primitive );

					} else {

						// Otherwise create a new geometry
						geometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );

					} // Cache this geometry


					cache[ cacheKey ] = {
						primitive: primitive,
						promise: geometryPromise
					};
					pending.push( geometryPromise );

				}

			}

			return Promise.all( pending );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */


		loadMesh( meshIndex ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;
			const meshDef = json.meshes[ meshIndex ];
			const primitives = meshDef.primitives;
			const pending = [];

			for ( let i = 0, il = primitives.length; i < il; i ++ ) {

				const material = primitives[ i ].material === undefined ? createDefaultMaterial( this.cache ) : this.getDependency( 'material', primitives[ i ].material );
				pending.push( material );

			}

			pending.push( parser.loadGeometries( primitives ) );
			return Promise.all( pending ).then( function ( results ) {

				const materials = results.slice( 0, results.length - 1 );
				const geometries = results[ results.length - 1 ];
				const meshes = [];

				for ( let i = 0, il = geometries.length; i < il; i ++ ) {

					const geometry = geometries[ i ];
					const primitive = primitives[ i ]; // 1. create THREE.Mesh

					let mesh;
					const material = materials[ i ];

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined ) {

						// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
						mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh( geometry, material ) : new THREE.Mesh( geometry, material );

						if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

							// we normalize floating point skin weight array to fix malformed assets (see #15319)
							// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
							mesh.normalizeSkinWeights();

						}

						if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleStripDrawMode );

						} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleFanDrawMode );

						}

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

						mesh = new THREE.LineSegments( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

						mesh = new THREE.Line( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

						mesh = new THREE.LineLoop( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

						mesh = new THREE.Points( geometry, material );

					} else {

						throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

					}

					if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

						updateMorphTargets( mesh, meshDef );

					}

					mesh.name = parser.createUniqueName( meshDef.name || 'mesh_' + meshIndex );
					assignExtrasToUserData( mesh, meshDef );
					if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );
					parser.assignFinalMaterial( mesh );
					meshes.push( mesh );

				}

				if ( meshes.length === 1 ) {

					return meshes[ 0 ];

				}

				const group = new THREE.Group();

				for ( let i = 0, il = meshes.length; i < il; i ++ ) {

					group.add( meshes[ i ] );

				}

				return group;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */


		loadCamera( cameraIndex ) {

			let camera;
			const cameraDef = this.json.cameras[ cameraIndex ];
			const params = cameraDef[ cameraDef.type ];

			if ( ! params ) {

				console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
				return;

			}

			if ( cameraDef.type === 'perspective' ) {

				camera = new THREE.PerspectiveCamera( THREE.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

			} else if ( cameraDef.type === 'orthographic' ) {

				camera = new THREE.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

			}

			if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );
			assignExtrasToUserData( camera, cameraDef );
			return Promise.resolve( camera );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */


		loadSkin( skinIndex ) {

			const skinDef = this.json.skins[ skinIndex ];
			const skinEntry = {
				joints: skinDef.joints
			};

			if ( skinDef.inverseBindMatrices === undefined ) {

				return Promise.resolve( skinEntry );

			}

			return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

				skinEntry.inverseBindMatrices = accessor;
				return skinEntry;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */


		loadAnimation( animationIndex ) {

			const json = this.json;
			const animationDef = json.animations[ animationIndex ];
			const pendingNodes = [];
			const pendingInputAccessors = [];
			const pendingOutputAccessors = [];
			const pendingSamplers = [];
			const pendingTargets = [];

			for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

				const channel = animationDef.channels[ i ];
				const sampler = animationDef.samplers[ channel.sampler ];
				const target = channel.target;
				const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

				const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
				const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;
				pendingNodes.push( this.getDependency( 'node', name ) );
				pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
				pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
				pendingSamplers.push( sampler );
				pendingTargets.push( target );

			}

			return Promise.all( [ Promise.all( pendingNodes ), Promise.all( pendingInputAccessors ), Promise.all( pendingOutputAccessors ), Promise.all( pendingSamplers ), Promise.all( pendingTargets ) ] ).then( function ( dependencies ) {

				const nodes = dependencies[ 0 ];
				const inputAccessors = dependencies[ 1 ];
				const outputAccessors = dependencies[ 2 ];
				const samplers = dependencies[ 3 ];
				const targets = dependencies[ 4 ];
				const tracks = [];

				for ( let i = 0, il = nodes.length; i < il; i ++ ) {

					const node = nodes[ i ];
					const inputAccessor = inputAccessors[ i ];
					const outputAccessor = outputAccessors[ i ];
					const sampler = samplers[ i ];
					const target = targets[ i ];
					if ( node === undefined ) continue;
					node.updateMatrix();
					node.matrixAutoUpdate = true;
					let TypedKeyframeTrack;

					switch ( PATH_PROPERTIES[ target.path ] ) {

						case PATH_PROPERTIES.weights:
							TypedKeyframeTrack = THREE.NumberKeyframeTrack;
							break;

						case PATH_PROPERTIES.rotation:
							TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
							break;

						case PATH_PROPERTIES.position:
						case PATH_PROPERTIES.scale:
						default:
							TypedKeyframeTrack = THREE.VectorKeyframeTrack;
							break;

					}

					const targetName = node.name ? node.name : node.uuid;
					const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;
					const targetNames = [];

					if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

						// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.
						node.traverse( function ( object ) {

							if ( object.isMesh === true && object.morphTargetInfluences ) {

								targetNames.push( object.name ? object.name : object.uuid );

							}

						} );

					} else {

						targetNames.push( targetName );

					}

					let outputArray = outputAccessor.array;

					if ( outputAccessor.normalized ) {

						const scale = getNormalizedComponentScale( outputArray.constructor );
						const scaled = new Float32Array( outputArray.length );

						for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

							scaled[ j ] = outputArray[ j ] * scale;

						}

						outputArray = scaled;

					}

					for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

						const track = new TypedKeyframeTrack( targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ], inputAccessor.array, outputArray, interpolation ); // Override interpolation with custom factory method.

						if ( sampler.interpolation === 'CUBICSPLINE' ) {

							track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

								// A CUBICSPLINE keyframe in glTF has three output values for each input value,
								// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
								// must be divided by three to get the interpolant's sampleSize argument.
								return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

							}; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


							track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

						}

						tracks.push( track );

					}

				}

				const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
				return new THREE.AnimationClip( name, undefined, tracks );

			} );

		}

		createNodeMesh( nodeIndex ) {

			const json = this.json;
			const parser = this;
			const nodeDef = json.nodes[ nodeIndex ];
			if ( nodeDef.mesh === undefined ) return null;
			return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

				const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh ); // if weights are provided on the node, override weights on the mesh.


				if ( nodeDef.weights !== undefined ) {

					node.traverse( function ( o ) {

						if ( ! o.isMesh ) return;

						for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

							o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

						}

					} );

				}

				return node;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */


		loadNode( nodeIndex ) {

			const json = this.json;
			const extensions = this.extensions;
			const parser = this;
			const nodeDef = json.nodes[ nodeIndex ]; // reserve node's name before its dependencies, so the root has the intended name.

			const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';
			return function () {

				const pending = [];

				const meshPromise = parser._invokeOne( function ( ext ) {

					return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

				} );

				if ( meshPromise ) {

					pending.push( meshPromise );

				}

				if ( nodeDef.camera !== undefined ) {

					pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

						return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

					} ) );

				}

				parser._invokeAll( function ( ext ) {

					return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

				} ).forEach( function ( promise ) {

					pending.push( promise );

				} );

				return Promise.all( pending );

			}().then( function ( objects ) {

				let node; // .isBone isn't in glTF spec. See ._markDefs

				if ( nodeDef.isBone === true ) {

					node = new THREE.Bone();

				} else if ( objects.length > 1 ) {

					node = new THREE.Group();

				} else if ( objects.length === 1 ) {

					node = objects[ 0 ];

				} else {

					node = new THREE.Object3D();

				}

				if ( node !== objects[ 0 ] ) {

					for ( let i = 0, il = objects.length; i < il; i ++ ) {

						node.add( objects[ i ] );

					}

				}

				if ( nodeDef.name ) {

					node.userData.name = nodeDef.name;
					node.name = nodeName;

				}

				assignExtrasToUserData( node, nodeDef );
				if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

				if ( nodeDef.matrix !== undefined ) {

					const matrix = new THREE.Matrix4();
					matrix.fromArray( nodeDef.matrix );
					node.applyMatrix4( matrix );

				} else {

					if ( nodeDef.translation !== undefined ) {

						node.position.fromArray( nodeDef.translation );

					}

					if ( nodeDef.rotation !== undefined ) {

						node.quaternion.fromArray( nodeDef.rotation );

					}

					if ( nodeDef.scale !== undefined ) {

						node.scale.fromArray( nodeDef.scale );

					}

				}

				parser.associations.set( node, {
					type: 'nodes',
					index: nodeIndex
				} );
				return node;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */


		loadScene( sceneIndex ) {

			const json = this.json;
			const extensions = this.extensions;
			const sceneDef = this.json.scenes[ sceneIndex ];
			const parser = this; // THREE.Loader returns THREE.Group, not Scene.
			// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172

			const scene = new THREE.Group();
			if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );
			assignExtrasToUserData( scene, sceneDef );
			if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );
			const nodeIds = sceneDef.nodes || [];
			const pending = [];

			for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

				pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

			}

			return Promise.all( pending ).then( function () {

				return scene;

			} );

		}

	}

	function buildNodeHierachy( nodeId, parentObject, json, parser ) {

		const nodeDef = json.nodes[ nodeId ];
		return parser.getDependency( 'node', nodeId ).then( function ( node ) {

			if ( nodeDef.skin === undefined ) return node; // build skeleton here as well

			let skinEntry;
			return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

				skinEntry = skin;
				const pendingJoints = [];

				for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

					pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

				}

				return Promise.all( pendingJoints );

			} ).then( function ( jointNodes ) {

				node.traverse( function ( mesh ) {

					if ( ! mesh.isMesh ) return;
					const bones = [];
					const boneInverses = [];

					for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

						const jointNode = jointNodes[ j ];

						if ( jointNode ) {

							bones.push( jointNode );
							const mat = new THREE.Matrix4();

							if ( skinEntry.inverseBindMatrices !== undefined ) {

								mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

							}

							boneInverses.push( mat );

						} else {

							console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

						}

					}

					mesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );

				} );
				return node;

			} );

		} ).then( function ( node ) {

			// build node hierachy
			parentObject.add( node );
			const pending = [];

			if ( nodeDef.children ) {

				const children = nodeDef.children;

				for ( let i = 0, il = children.length; i < il; i ++ ) {

					const child = children[ i ];
					pending.push( buildNodeHierachy( child, node, json, parser ) );

				}

			}

			return Promise.all( pending );

		} );

	}
	/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */


	function computeBounds( geometry, primitiveDef, parser ) {

		const attributes = primitiveDef.attributes;
		const box = new THREE.Box3();

		if ( attributes.POSITION !== undefined ) {

			const accessor = parser.json.accessors[ attributes.POSITION ];
			const min = accessor.min;
			const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

			if ( min !== undefined && max !== undefined ) {

				box.set( new THREE.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ), new THREE.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );

				if ( accessor.normalized ) {

					const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
					box.min.multiplyScalar( boxScale );
					box.max.multiplyScalar( boxScale );

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );
				return;

			}

		} else {

			return;

		}

		const targets = primitiveDef.targets;

		if ( targets !== undefined ) {

			const maxDisplacement = new THREE.Vector3();
			const vector = new THREE.Vector3();

			for ( let i = 0, il = targets.length; i < il; i ++ ) {

				const target = targets[ i ];

				if ( target.POSITION !== undefined ) {

					const accessor = parser.json.accessors[ target.POSITION ];
					const min = accessor.min;
					const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

					if ( min !== undefined && max !== undefined ) {

						// we need to get max of absolute components because target weight is [-1,1]
						vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
						vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
						vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );

						if ( accessor.normalized ) {

							const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
							vector.multiplyScalar( boxScale );

						} // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
						// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
						// are used to implement key-frame animations and as such only two are active at a time - this results in very large
						// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.


						maxDisplacement.max( vector );

					} else {

						console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

					}

				}

			} // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.


			box.expandByVector( maxDisplacement );

		}

		geometry.boundingBox = box;
		const sphere = new THREE.Sphere();
		box.getCenter( sphere.center );
		sphere.radius = box.min.distanceTo( box.max ) / 2;
		geometry.boundingSphere = sphere;

	}
	/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */


	function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

		const attributes = primitiveDef.attributes;
		const pending = [];

		function assignAttributeAccessor( accessorIndex, attributeName ) {

			return parser.getDependency( 'accessor', accessorIndex ).then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

		}

		for ( const gltfAttributeName in attributes ) {

			const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

			if ( threeAttributeName in geometry.attributes ) continue;
			pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

		}

		if ( primitiveDef.indices !== undefined && ! geometry.index ) {

			const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

				geometry.setIndex( accessor );

			} );
			pending.push( accessor );

		}

		assignExtrasToUserData( geometry, primitiveDef );
		computeBounds( geometry, primitiveDef, parser );
		return Promise.all( pending ).then( function () {

			return primitiveDef.targets !== undefined ? addMorphTargets( geometry, primitiveDef.targets, parser ) : geometry;

		} );

	}
	/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */


	function toTrianglesDrawMode( geometry, drawMode ) {

		let index = geometry.getIndex(); // generate index if not present

		if ( index === null ) {

			const indices = [];
			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		} //


		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === THREE.TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN
			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP
			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( newIndices.length / 3 !== numberOfTriangles ) {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		} // build final geometry


		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		return newGeometry;

	}

	THREE.GLTFLoader = GLTFLoader;

} )();

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){"object"===typeof exports&&"undefined"!==typeof module?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
    u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>=g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
    1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
    b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});
// hgen

var HGen = {
    __idsMap:new Map(),
    __htmlMap:new Map(),
    assignAttributes(htmlDomElement, attributes) {
        if ( attributes ) {
            for ( var attribute in attributes ) {
                htmlDomElement.setAttribute(attribute, attributes[attribute]);
            }
        }

        return htmlDomElement;
    },
    render(tagName, attributes) {
        return this.assignAttributes(document.createElement(tagName || "div"), attributes);
    },
    element(id, label, tagName, attributes, text, htmlElement) {
        if ( label ) {
            attributes["data-label"] = label;
        } else if ( attributes && attributes.hasOwnProperty("data-label") ) {
            label = attributes["data-label"];
        }
        if ( htmlElement ) {
            htmlElement = this.assignAttributes(htmlElement, attributes);
        } else {
            htmlElement = this.render(tagName, attributes)
        }

        return new this.Element(id, label, htmlElement, text);
    },
    input(id, label, attributes, htmlElement) {
        if ( label ) {
            attributes["data-label"] = label;
        } else if ( attributes && attributes.hasOwnProperty("data-label") ) {
            label = attributes["data-label"];
        }
        if ( htmlElement ) {
            htmlElement = this.assignAttributes(htmlElement, attributes);
        } else {
            htmlElement = this.render('input', attributes);
        }

        return new this.ElementInput(id, label, htmlElement);
    },
    container(id, label, tagName, attributes, htmlElement) {
        if ( label ) {
            attributes["data-label"] = label;
        } else if ( attributes && attributes.hasOwnProperty("data-label") ) {
            label = attributes["data-label"];
        }
        if ( htmlElement ) {
            htmlElement = this.assignAttributes(htmlElement, attributes);
        } else {
            htmlElement = this.render(tagName, attributes)
        }

        return new this.ElementContainer(id, label, htmlElement);
    },
    wrap(id, htmlElement) {
        return new this.ElementContainer(id, null, htmlElement);
    },
    fromModel(model, htmlElement) {
        var scope = this;

        function make(model, htmlElement) {
            switch ( model.type ) {
                case "container":
                    return scope.container(model.id, model.label, model.tagName, model.attributes, htmlElement);

                case "element":
                    return scope.element(model.id, model.label, model.tagName, model.attributes, model.text, htmlElement);
                    break;

                case "input":
                    return scope.input(model.id, model.label, model.attributes, model.value, htmlElement);
                    break;

                default:
                    throw "Type error!"
            }
        }
        function hasChildren(model) {
            return !(
                model.type != "container"
                || !model.hasOwnProperty("children")
                || !Array.isArray(model.children)
                || model.children.length == 0
            );
        }
        function gen(parent, model, htmlElement) {
            var element = make(model, htmlElement);

            if ( parent ) {
                parent.add(element);
            }
            if ( hasChildren(model) ) {
                for ( var i = 0, l = model.children.length; i < l; i++ ) {
                    for ( var j = 0, jl = model.children[i].amount || 1; j < jl; j++ ) {
                        gen(element, model.children[i]);
                    }
                }
            }

            return element;
        }

        return gen(null, model, htmlElement);
    },
    id(id) {
        return this.__idsMap.get(id);
    },
    domId(id) {
        return document.getElementById(id);
    },
    byHTML(element) {
        return this.__htmlMap.get(element)
    },
    extend(target, parent) {
        var obj = Object.assign({}, parent);

        if ( obj.hasOwnProperty("attributes") ) {
            obj["attributes"] = Object.assign({}, obj["attributes"]);
        } else {
            obj["attributes"] = {};
        }

        if ( target.hasOwnProperty("label") ) obj["label"] = target["label"];
        if ( target.hasOwnProperty("amount") ) obj["amount"] = target["label"];
        if ( target.hasOwnProperty("text") ) obj["text"] = target["text"];
        if ( target.hasOwnProperty("attributes") ) {
            Object.assign(obj["attributes"], target["attributes"]);
        }
        if ( target.hasOwnProperty("children") ) {
            obj["children"] = target["children"];
        }

        return obj;
    }
};
// hgen

HGen.ElementMouseEventDispatcher = function () {
    //-
};

Object.assign(HGen.ElementMouseEventDispatcher.prototype, {
    addEventListener(type, callback) {
        this.domElement.addEventListener(type, callback);
    },
    removeEventListener(type, callback) {
        this.domElement.removeEventListener(type, callback);
    },
    event(type, callback) {
        this.addEventListener(type, callback);
    },
    removeEvent(type, callback) {
        this.removeEventListener(type, callback);
    },
    click(callback) {
        this.addEventListener('click', callback);
    },
    removeClick(callback) {
        this.removeEventListener('click', callback);
    }
});
// hgen

HGen.ElementBase = function(id, label, htmlElement) {
    if ( !htmlElement ) throw "Error! Needs HTML element";

    var scope = this;
    var hidden = {
        entityId:(++HGen.ElementBase.__entityId),
        id:id,
        label:label,
        domElement:htmlElement,
        parent:null
    };

    Object.defineProperties(scope, {
        hidden:{
            get() { return hidden; }
        },
        id:{
            get() { return hidden.id; }
        },
        label:{
            get() { return hidden.label; }
        },
        domElement:{
            get() { return hidden.domElement; }
        },
        parent:{
            get() { return hidden.parent; }
        },
        style:{
            get() { return hidden.domElement.style; }
        },
        className:{
            get() { return hidden.domElement.className; },
            set(value) {
                hidden.domElement.className = value;
            }
        }
    });

    if ( id !== undefined && id !== null && id !== false ) {
        HGen.__idsMap.set(id, scope);
    }

    HGen.__htmlMap.set(htmlElement, scope);
};

Object.assign(HGen.ElementBase.prototype, {
    setStyle(rules) {
        for ( var rule in rules ) {
            this.style[rule] = rules[rule];
        }
    },
    setAttribute(name, value) {
        this.hidden.domElement.setAttribute(name, value);
    },
    dispose() {
        HGen.__htmlMap.delete(this.domElement);
    }
});

Object.assign(HGen.ElementBase.prototype, HGen.ElementMouseEventDispatcher.prototype);

HGen.ElementBase.__entityId = 0;
// hgen

HGen.ElementContainer = function(id, label, htmlElement) {
    HGen.ElementBase.call(this, id, label, htmlElement);

    var scope = this;

    scope.hidden.labels = {};
    scope.hidden.children = [];

    Object.defineProperties(this, {
        numChildren:{
            get() { return scope.hidden.children.length; }
        }
    });
};

Object.assign(HGen.ElementContainer.prototype, HGen.ElementBase.prototype);
Object.assign(HGen.ElementContainer.prototype, {
    ___addLabel(child) {
        if ( !child.hasOwnProperty("label") || child.label == undefined || child.label == null ) return;

        this.hidden.labels[child.label] = child;
    },
    ___removeLabel(child) {
        if ( !child.hasOwnProperty("label") || child.label == undefined || child.label == null ) return;

        delete this.hidden.labels[child.label];
    },
    ___add(child) {
        this.hidden.children.push(child);
        this.hidden.domElement.appendChild(child.domElement);

        child.hidden.parent = this;

        this.___addLabel(child);
    },
    ___remove(index, child) {
        this.hidden.domElement.removeChild(child.domElement);
        this.hidden.children.splice(index, 1);

        child.hidden.parent = null;

        this.___removeLabel(child);
    },
    byLabel(label) {
        // change lbl() too!
        return this.hidden.labels.hasOwnProperty(label) ? this.hidden.labels[label] : null;
    },
    lbl(label) {
        // change byLabel() too!
        return this.hidden.labels.hasOwnProperty(label) ? this.hidden.labels[label] : null;
    },
    contains(child){
        return this.hidden.children.indexOf(child) >= 0;
    },
    add(child){
        var index = this.hidden.children.indexOf(child);

        if ( index != -1 ) this.___remove(index, child);

        this.___add(child);

        return child;
    },
    remove(child) {
        var index = this.hidden.children.indexOf(child);

        if ( index < 0 ) throw "Remove child error!";

        this.___remove(index, child);

        return child;
    },
    addAt(index, child) {
        var i, l;

        if ( index < 0 || index > this.hidden.children.length ) {
            throw "Index is not in bounds!";
        }
        if ( this.hidden.children.indexOf(child) >= 0 ) {
            throw "Error! Remove before add it!";
        }

        for ( i = index, l = this.hidden.children.length; i < l; i++ ) {
            this.hidden.domElement.removeChild(this.hidden.children[i].domElement);
        }

        this.hidden.children.splice(index, 0, child);

        for ( i = index, l = this.hidden.children.length; i < l; i++ ) {
            this.hidden.domElement.appendChild(this.hidden.children[i].domElement);
        }

        child.hidden.parent = this;

        this.___addLabel(child);
    },
    addBefore(target, child) {
        var index = this.hidden.children.indexOf(target);

        if ( index < 0 ) {
            throw "Target error!";
        }

        this.addAt(index, child);
    },
    addAfter(target, child) {
        var index = this.hidden.children.indexOf(target);

        if ( index < 0 ) {
            throw "Target error!";
        }

        this.addAt(index + 1, child);
    }
});
// hgen

HGen.Element = function(id, label, htmlElement, text) {
    HGen.ElementBase.call(this, id, label, htmlElement);

    var scope = this;

    Object.defineProperties(scope, {
        innerText:{
            get() { return scope.hidden.domElement.innerText; },
            set(value) {
                if ( value == scope.hidden.domElement.innerText ) return;

                scope.hidden.domElement.innerText = value;
            }
        },
        innerHTML:{
            get() { return scope.hidden.domElement.innerHTML; },
            set(value) {
                scope.hidden.domElement.innerHTML = value;
            }
        }
    });

    if ( text ) scope.hidden.domElement.innerText = text;
};

Object.assign(HGen.Element.prototype, HGen.ElementBase.prototype);
Object.assign(HGen.Element.prototype, {
    text(value) {
        this.innerText = value;
    },
    html(value) {
        this.innerHTML = value;
    }
});
// hgen

HGen.ElementInput = function(id, label, htmlElement) {
    HGen.ElementBase.call(this, id, label, htmlElement);

    var scope = this;

    Object.defineProperties(scope, {
        value:{
            configurable:true,
            get() { return scope.hidden.domElement.value; },
            set(value) {
                if ( value == scope.hidden.domElement.value ) return;

                scope.hidden.domElement.value = value;
            }
        },
        checked:{
            get() { return scope.hidden.domElement.checked; },
            set(value) {
                scope.hidden.domElement.checked = value;
            }
        }
    });
};

Object.assign(HGen.ElementInput.prototype, HGen.ElementBase.prototype);
Object.assign(HGen.ElementInput.prototype, {
    val(v) { this.value = v; }
});
Number.isFinite = Number.isFinite || function(value) {
        return typeof value === 'number' && isFinite(value);
    };

Number.isInteger = Number.isInteger || function(value) {
        return typeof value === 'number' && Number.isFinite(value) && !(value % 1);
    };
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/* global define */

;(function ($) {
  'use strict'

  /*
  * Add integers, wrapping at 2^32. This uses 16-bit operations internally
  * to work around bugs in some JS interpreters.
  */
  function safeAdd (x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF)
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
    return (msw << 16) | (lsw & 0xFFFF)
  }

  /*
  * Bitwise rotate a 32-bit number to the left.
  */
  function bitRotateLeft (num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt))
  }

  /*
  * These functions implement the four basic operations the algorithm uses.
  */
  function md5cmn (q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
  }
  function md5ff (a, b, c, d, x, s, t) {
    return md5cmn((b & c) | ((~b) & d), a, b, x, s, t)
  }
  function md5gg (a, b, c, d, x, s, t) {
    return md5cmn((b & d) | (c & (~d)), a, b, x, s, t)
  }
  function md5hh (a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t)
  }
  function md5ii (a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | (~d)), a, b, x, s, t)
  }

  /*
  * Calculate the MD5 of an array of little-endian words, and a bit length.
  */
  function binlMD5 (x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << (len % 32)
    x[(((len + 64) >>> 9) << 4) + 14] = len

    var i
    var olda
    var oldb
    var oldc
    var oldd
    var a = 1732584193
    var b = -271733879
    var c = -1732584194
    var d = 271733878

    for (i = 0; i < x.length; i += 16) {
      olda = a
      oldb = b
      oldc = c
      oldd = d

      a = md5ff(a, b, c, d, x[i], 7, -680876936)
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)

      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)
      b = md5gg(b, c, d, a, x[i], 20, -373897302)
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)

      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)
      d = md5hh(d, a, b, c, x[i], 11, -358537222)
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)

      a = md5ii(a, b, c, d, x[i], 6, -198630844)
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)

      a = safeAdd(a, olda)
      b = safeAdd(b, oldb)
      c = safeAdd(c, oldc)
      d = safeAdd(d, oldd)
    }
    return [a, b, c, d]
  }

  /*
  * Convert an array of little-endian words to a string
  */
  function binl2rstr (input) {
    var i
    var output = ''
    var length32 = input.length * 32
    for (i = 0; i < length32; i += 8) {
      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)
    }
    return output
  }

  /*
  * Convert a raw string to an array of little-endian words
  * Characters >255 have their high-byte silently ignored.
  */
  function rstr2binl (input) {
    var i
    var output = []
    output[(input.length >> 2) - 1] = undefined
    for (i = 0; i < output.length; i += 1) {
      output[i] = 0
    }
    var length8 = input.length * 8
    for (i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)
    }
    return output
  }

  /*
  * Calculate the MD5 of a raw string
  */
  function rstrMD5 (s) {
    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))
  }

  /*
  * Calculate the HMAC-MD5, of a key and some data (raw strings)
  */
  function rstrHMACMD5 (key, data) {
    var i
    var bkey = rstr2binl(key)
    var ipad = []
    var opad = []
    var hash
    ipad[15] = opad[15] = undefined
    if (bkey.length > 16) {
      bkey = binlMD5(bkey, key.length * 8)
    }
    for (i = 0; i < 16; i += 1) {
      ipad[i] = bkey[i] ^ 0x36363636
      opad[i] = bkey[i] ^ 0x5C5C5C5C
    }
    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))
  }

  /*
  * Convert a raw string to a hex string
  */
  function rstr2hex (input) {
    var hexTab = '0123456789abcdef'
    var output = ''
    var x
    var i
    for (i = 0; i < input.length; i += 1) {
      x = input.charCodeAt(i)
      output += hexTab.charAt((x >>> 4) & 0x0F) +
      hexTab.charAt(x & 0x0F)
    }
    return output
  }

  /*
  * Encode a string as utf-8
  */
  function str2rstrUTF8 (input) {
    return unescape(encodeURIComponent(input))
  }

  /*
  * Take string arguments and return either raw or hex encoded strings
  */
  function rawMD5 (s) {
    return rstrMD5(str2rstrUTF8(s))
  }
  function hexMD5 (s) {
    return rstr2hex(rawMD5(s))
  }
  function rawHMACMD5 (k, d) {
    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
  }
  function hexHMACMD5 (k, d) {
    return rstr2hex(rawHMACMD5(k, d))
  }

  function md5 (string, key, raw) {
    if (!key) {
      if (!raw) {
        return hexMD5(string)
      }
      return rawMD5(string)
    }
    if (!raw) {
      return hexHMACMD5(key, string)
    }
    return rawHMACMD5(key, string)
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return md5
    })
  } else if (typeof module === 'object' && module.exports) {
    module.exports = md5
  } else {
    $.md5 = md5
  }
}(this))

// utils

function extend(child, parent) {
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
}
// utils

var ByteArray = function() {
    var scope = this;
    var bufferLength = 1024;
    var bytesCapacity = 0;
    var bytesLength = 0;
    var bytesOffset = 0;
    var currentArrayBuffer = new ArrayBuffer();
    var currentDataView = new DataView(currentArrayBuffer);

    function makeNew(times) {
        var newCapacity = bytesCapacity + bufferLength * times;
        var oldUint8Array = new Uint8Array(currentArrayBuffer);
        var newArrayBuffer = new ArrayBuffer(newCapacity);
        var newUint8Array = new Uint8Array(newArrayBuffer);
        var newDataView = new DataView(newArrayBuffer);

        newUint8Array.set(oldUint8Array, 0);

        currentArrayBuffer = newArrayBuffer;
        currentDataView = newDataView;
        bytesCapacity = newCapacity;
    }
    function checkAvailable(fill) {
        if ( bytesOffset + fill >= bytesCapacity ) {
            makeNew(Math.ceil((bytesOffset + fill) / bufferLength));
        }
    }
    function offsetBytesBySet(offset) {
        bytesOffset += offset;
        bytesLength = Math.max(bytesLength, bytesOffset);
    }

    Object.defineProperties(scope, {
        'length':{
            get() {
                return bytesLength;
            }
        }
    });

    scope.getOffset = function() {
        return bytesOffset;
    };
    scope.getInt8 = function() {
        var value = currentDataView.getInt8(bytesOffset);

        bytesOffset += 1;

        return value;
    };
    scope.getUint8 = function() {
        var value = currentDataView.getUint8(bytesOffset);

        bytesOffset += 1;

        return value;
    };
    scope.getInt16 = function() {
        var value = currentDataView.getInt16(bytesOffset);

        bytesOffset += 2;

        return value;
    };
    scope.getUint16 = function() {
        var value = currentDataView.getUint16(bytesOffset);

        bytesOffset += 2;

        return value;
    };
    scope.getInt32 = function() {
        var value = currentDataView.getInt32(bytesOffset);

        bytesOffset += 4;

        return value;
    };
    scope.getUint32 = function() {
        var value = currentDataView.getUint32(bytesOffset);

        bytesOffset += 4;

        return value;
    };
    scope.getFloat32 = function() {
        var value = currentDataView.getFloat32(bytesOffset);

        bytesOffset += 4;

        return value;
    };
    scope.getFloat64 = function() {
        var value = currentDataView.getFloat64(bytesOffset);

        bytesOffset += 8;

        return value;
    };
    scope.getBytes = function(length) {
        var bytes = currentArrayBuffer.slice(bytesOffset, bytesOffset + length);

        bytesOffset += length;

        return bytes;
    };
    scope.getBytesRange = function(start, length) {
        start = start == undefined ? 0 : start;
        length = length == undefined ? bytesLength : length;

        return currentArrayBuffer.slice(start, start + length);
    };
    scope.getUint8Array = function() {
        return new Uint8Array(scope.getBytesRange(0, bytesLength));
    };
    scope.readUint8Array = function(length) {
        var array = new Uint8Array(currentArrayBuffer.slice(bytesOffset, bytesOffset + length));

        bytesOffset += length;

        return array;
    };
    /*scope.readUTF = function() {
        //
    };*/

    //set
    scope.setOffset = function(offset) {
        if ( offset < 0 ) bytesOffset = 0;
        else if ( offset >= bytesLength ) bytesOffset = bytesLength;
        else bytesOffset = offset;
    };
    scope.setInt8 = function(value) {
        checkAvailable(1);
        currentDataView.setInt8(bytesOffset, value);
        offsetBytesBySet(1);
    };
    scope.setUint8 = function(value) {
        checkAvailable(1);
        currentDataView.setUint8(bytesOffset, value);
        offsetBytesBySet(1);
    };
    scope.setInt16 = function(value) {
        checkAvailable(2);
        currentDataView.setInt16(bytesOffset, value);
        offsetBytesBySet(2);
    };
    scope.setUint16 = function(value) {
        checkAvailable(2);
        currentDataView.setUint16(bytesOffset, value);
        offsetBytesBySet(2);
    };
    scope.setInt32 = function(value) {
        checkAvailable(4);
        currentDataView.setInt32(bytesOffset, value);
        offsetBytesBySet(4);
    };
    scope.setUint32 = function(value) {
        checkAvailable(4);
        currentDataView.setInt32(bytesOffset, value);
        offsetBytesBySet(4);
    };
    scope.setFloat32 = function(value) {
        checkAvailable(4);
        currentDataView.setFloat32(bytesOffset, value);
        offsetBytesBySet(4);
    };
    scope.setFloat64 = function(value) {
        checkAvailable(8);
        currentDataView.setFloat64(bytesOffset, value);
        offsetBytesBySet(8);
    };
    scope.setBytes = function(bytesBuffer) {
        var length = bytesBuffer.byteLength;
        var newArray = null;
        var currentArray = null;

        checkAvailable(length);

        newArray = new Uint8Array(bytesBuffer);
        currentArray = new Uint8Array(currentArrayBuffer);

        currentArray.set(newArray, bytesOffset);
        offsetBytesBySet(length);
    };
    scope.writeUint8Array = function(array) {
        checkAvailable(array.length);

        for ( var i = 0, l = array.length; i < l; i++ ) {
            currentDataView.setUint8(bytesOffset + i, array[i]);
        }

        offsetBytesBySet(array.length);
    };

    makeNew(1);
};
// utils

var FILE = {};

FILE.openImage = function(callback, accept, preloaderNeed) {
    if ( !callback ) {
        console.error('Needs callback!');
        return;
    }
    FILE.openFile(function(file) { 
        FILE.loadFileAsImage(file, callback);
    }, preloaderNeed, accept);
};

FILE.loadFileAs = function(method, file, callback) {
    if ( !method ) {
        console.error('Needs method!');
        return;
    }
    if ( !file ) {
        console.error('Needs file!');
        return;
    }
    if ( !callback ) {
        console.error('Needs callback!');
        return;
    }

    var fileReader = new FileReader();

    function fileReaderLoadHandler(event) {
        callback(event.currentTarget.result);

        fileReader.removeEventListener("load", fileReaderLoadHandler);
        fileReader = null;
    }

    fileReader.addEventListener("load", fileReaderLoadHandler);
    fileReader[method](file);
};

FILE.loadFileAsDataURL = function(file, callback) {
    FILE.loadFileAs('readAsDataURL', file, callback);
};
FILE.loadFileAsImage = FILE.loadFileAsDataURL;
FILE.loadFileAsArrayBuffer = function(file, callback) {
    FILE.loadFileAs('readAsArrayBuffer', file, callback);
};
FILE.loadFileAsBinaryString = function(file, callback) {
    FILE.loadFileAs('readAsBinaryString', file, callback);
};

FILE.openFile = function(callback, preloaderNeed, accept, multiple) {
    if ( !callback ) {
        console.error('Needs callback!');
        return;
    }

    var inputFile = document.createElement('input');

    async function inputFileChangeEventHandler(event) {
        
        if(preloaderNeed) {
            let preloader = document.createElement('div');
            preloader.classList.add("preloader-grey");
            let preloaderCube = document.createElement('div');
            preloaderCube.classList.add("preloader-cube");
            preloader.append(preloaderCube);
            document.querySelector('body').append(preloader);
        }
        

        if ( multiple && event.currentTarget.files.length > 0 ) {
            callback(event.currentTarget.files);
        } else if ( event.currentTarget.files.length == 1 ) {
            let files = event.currentTarget.files[0];
            if( event.currentTarget.files[0].type == "application/pdf" ) files = await pdfPlanConvert(event.currentTarget.files[0]);
            callback(files);
        }

        inputFile.removeEventListener('change', inputFileChangeEventHandler);
        inputFile = null;
    }

    inputFile.setAttribute('type', 'file');

    if ( accept ) {
        inputFile.setAttribute('accept', accept);
    }
    if ( multiple ) {
        inputFile.setAttribute('multiple', '');
    }

    inputFile.addEventListener('change', inputFileChangeEventHandler);
    inputFile.click();
};
FILE.readArrayAsFile = function (data, type) {
    return type ? new Blob([data], {type:type}) : new Blob([data]);
};
FILE.saveFile = function(blob, name) {
    var downloadLink = document.createElement("a");

    downloadLink.download = name;
    downloadLink.innerHTML = "Download File";

    downloadLink.href = window.URL.createObjectURL(blob);
    downloadLink.style.display = "none";

    document.body.appendChild(downloadLink);
    downloadLink.click();
};
/**
 * Saving a data to HDD
 * @param data some data
 * @param type type of data: plain/text, application/json, binary/octet-stream
 * @param name name of a file
 */
FILE.saveData = function(data, type, name) {
    FILE.saveFile(new Blob([data], {type:type}), name);
};
FILE.saveBase64 = function(string, type, name) {
    var data = window.atob(string);
    var bin = new Uint8Array(data.length);

    for( var i = 0, len = bin.length; i < len; ++i ) {
        bin[i] = data.charCodeAt(i);
    }

    FILE.saveData(bin.buffer, type, name);
};

//
FILE.dataByURL = function(url, onComplete, onError, onProgress, responseType) {
    if ( !onComplete ) throw "FILE.fileByURL: Add callback on complete action!";
    if ( !responseType ) throw "FILE.fileByURL: Set response type of data!";

    function loadEvent(event) {
        if ( event.currentTarget.status == 200 ) {
            onComplete(event.currentTarget.response);
        } else if ( onError ) {
            onError();
        }
    }
    function progressEvent(event) {
        onProgress(event.loaded / event.total, event.loaded, event.total);
    }
    function errorEvent(event) {
        onError();
    }

    var xhr = new XMLHttpRequest();

    xhr.withCredentials = true;

    xhr.responseType = responseType;

    if ( onComplete ) xhr.addEventListener('load', loadEvent);
    if ( onProgress ) xhr.addEventListener('progress', progressEvent);
    if ( onError ) xhr.addEventListener('error', errorEvent);

    xhr.open('GET', url, true);
    xhr.send();
};
FILE.blobByURL = function(url, onComplete, onError, onProgress) {
    FILE.dataByURL(url, onComplete, onError, onProgress, "blob");
};
FILE.arraybufferByURL = function(url, onComplete, onError, onProgress) {
    FILE.dataByURL(url, onComplete, onError, onProgress, "arraybuffer");
};

async function pdfPlanConvert(pdf) {
    let params = new FormData();
    params.append("floor_plan", pdf, pdf.name);
    var requestOptions = {
        method: 'POST',
        body: params,
        redirect: 'follow'
      };
      let responce = await fetch(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_PLAN_PDF_CONVERT), requestOptions);
      let responceBlob = await responce.blob();
      return responceBlob;
}
// utils

Object.assign(String.prototype, {
    format(value) {
        var args = arguments;
        var index = 0;

        return this.replace(/%s/g, function() {
            if ( index >= args ) return "%s";

            return args[index++];
        });
    }
});
//utils

var IMAGE = {};

IMAGE.create = function(src) {
    var image = document.createElement("img");

    image.src = src;

    return image;
};
IMAGE.loadImage = function(src, callback) {
    var image = IMAGE.create(src);

    image.addEventListener("load", function() {
        callback(image);
    });
    image.addEventListener("error", function() {
        callback(null);
    });
};

IMAGE._callCallback = function(canvas, callback, mimeType, qualityArgument) {
    canvas.toBlob(function(blob) {
        callback(blob, canvas.toDataURL(mimeType, qualityArgument), canvas.width, canvas.height);
    }, mimeType, qualityArgument);
};

IMAGE.resizeImage = function(url, scaleX, scaleY, callback, mimeType, qualityArgument) {
    var image = document.createElement("img");

    function loadComplete(event) {
        var image = event.currentTarget;
        var canvas;
        var context;

        image.removeEventListener("load", loadComplete);

        if ( Math.ceil(image.width * scaleX) < 1 || Math.ceil(image.height * scaleY) < 1 ) {
            callback(image);
        } else {
            canvas = document.createElement("canvas");
            context = canvas.getContext("2d");

            canvas.width = Math.ceil(image.width * scaleX);
            canvas.height = Math.ceil(image.height * scaleY);

            context.scale(scaleX, scaleY);
            context.drawImage(image, 0, 0);

            IMAGE._callCallback(canvas, callback, mimeType, qualityArgument);

            canvas = null;
            context = null;
        }

        image = null;
    }

    image.addEventListener("load", loadComplete);
    image.setAttribute("src", url);

    image = null;
};
IMAGE.fillImageInSizes = function (image, width, height, callback, mimeType, qualityArgument) {
    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");

    canvas.width = width;
    canvas.height = height;

    context.drawImage(image, 0, 0, width, height);

    IMAGE._callCallback(canvas, function(blob, dataURL) {
        IMAGE.loadImage(dataURL, function(image) {
            callback(image, blob, dataURL)
        });
    }, mimeType, qualityArgument);

    canvas = null;
    context = null;
};

IMAGE.cropBorders = function(src, callback, mimeType, qualityArgument) {
    var image = document.createElement('img');

    function loadComplete(event) {
        var image = event.currentTarget;
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        var width = image.width;
        var height = image.height;
        var imageData, channels;
        var left, top, right, bottom;
        var stop = false;
        var i, j;
        var index;
        var r, g, b, a;

        image.removeEventListener("load", loadComplete);

        canvas.width = width;
        canvas.height = height;

        context.drawImage(image, 0, 0);

        imageData = context.getImageData(0, 0, width, height);
        channels = imageData.data;

        //left
        for ( i = 0; i < width; i++ ) {
            stop = false;

            for ( j = 0; j < height; j++ ) {
                index = (i + j * width) * 4;
                r = channels[index];
                g = channels[index + 1];
                b = channels[index + 2];
                a = channels[index + 3];

                if ( a > 0 ) {
                    left = i;
                    stop = true;
                    break;
                }
            }

            if ( stop ) {
                break;
            }
        }
        //right
        for ( i = width - 1; i >= 0; i-- ) {
            stop = false;

            for ( j = 0; j < height; j++ ) {
                index = (i + j * width) * 4;
                r = channels[index];
                g = channels[index + 1];
                b = channels[index + 2];
                a = channels[index + 3];

                if ( a > 0 ) {
                    right = i;
                    stop = true;
                    break;
                }
            }

            if ( stop ) {
                break;
            }
        }
        //top
        for ( i = 0; i < height; i++ ) {
            stop = false;

            for ( j = 0; j < width; j++ ) {
                index = (i * width + j) * 4;
                r = channels[index];
                g = channels[index + 1];
                b = channels[index + 2];
                a = channels[index + 3];

                if ( a > 0 ) {
                    top = i;
                    stop = true;
                    break;
                }
            }

            if ( stop ) {
                break;
            }
        }
        //bottom
        for ( i = height - 1; i >= 0; i-- ) {
            stop = false;

            for ( j = 0; j < width; j++ ) {
                index = (i * width + j) * 4;
                r = channels[index];
                g = channels[index + 1];
                b = channels[index + 2];
                a = channels[index + 3];

                if ( a > 0 ) {
                    bottom = i;
                    stop = true;
                    break;
                }
            }

            if ( stop ) {
                break;
            }
        }

        if ( left < right || top < bottom ) {
            imageData = context.getImageData(left, top, right - left, bottom - top);

            context.clearRect(0, 0, width, height);

            canvas.width = imageData.width;
            canvas.height = imageData.height;

            context.putImageData(imageData, 0, 0);
        }

        IMAGE._callCallback(canvas, callback, mimeType, qualityArgument);

        image = null;
        canvas = null;
        context = null;
        imageData = null;
        channels = null;
    }

    image.addEventListener("load", loadComplete);
    image.setAttribute("src", src);

    image = null;
};
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-41183375-1', 'auto');
ga('send', 'pageview');

//event

var EventItem = function(type, listener) {
    var scope = this;

    scope.type = type;
    scope.listener = listener;
    scope.dispose = function () {
        scope.type = null;
        scope.listener = null;
    };
};

//--
var Event = function(type, data) {
    if ( type == null || type == undefined || type == "undefined" || type == "" ) {
        throw "Error type of event! Type is " + type;
    }

    this.type = type;
    this.data = data;
    this.stopPropagation = false;
};

Event.READY = "ready";
Event.START = "start";
Event.PROGRESS = "progress";
Event.FINISH = "finish";
Event.COMPLETE = "complete";
Event.ERROR = "error";
Event.UPDATE = "update";
Event.CHANGE_START = "changeStart";
Event.CHANGE = "change";
Event.CHANGE_FINISH = "changeFinish";
Event.SELECT = "select";
Event.CLOSE = "close";
Event.CLEAR = "clear";
Event.ENABLED = "enabled";
Event.DISABLED = "disabled";
Event.RESIZE = "resize";
Event.ON_MOUSE_DOWN = "onMouseDown";
Event.ON_MOUSE_UP = "onMouseUp";
Event.REMOVE = "remove";
Event.ACTION = "action";

//--
var EventDispatcher = function() {
    var scope = this;
    var eventsItems = [];
    var eventsNullCount = 0;

    function clearNullEvents() {
        var currentEventsItems = eventsItems;

        eventsItems = [];

        for ( var i = 0, l = currentEventsItems.length; i < l; i++ ) {
            if ( currentEventsItems[i] != null ) eventsItems.push(currentEventsItems[i]);
        }
    }

    scope.isExist = function(type, listener) {
        for ( var i = 0, l = eventsItems.length; i < l; i++ ) {
            var eventItem = eventsItems[i];

            if ( eventItem != null && eventItem.type == type && eventItem.listener == listener ) return i;
        }

        return -1;
    };
    scope.toEnd = function(index) {
        var eventItem = eventsItems[index];
        var last = eventsItems.length - 1;

        for ( var c = index, n = index + 1; c < last; c++, n++ ) eventsItems[c] = eventsItems[n];

        eventsItems[last] = eventItem;
    };
    scope.hasEventListener = function(type) {
        for ( var i = 0, l = eventsItems.length; i < l; i++ ) {
            if ( eventsItems[i] != null && eventsItems[i].type == type ) {
                return true;
            }
        }

        return false;
    };
    scope.addEventListener = function(type, listener) {
        var index = scope.isExist(type, listener);

        if ( index < 0 ) eventsItems.push(new EventItem(type, listener));
        else scope.toEnd(index);
    };
    scope.removeEventListener = function(type, listener) {
        for ( var i = 0, l = eventsItems.length; i < l; i++ ) {
            var eventItem = eventsItems[i];

            if ( eventItem != null && eventItem.type == type && eventItem.listener == listener ) {
                eventsItems[i] = null;
                eventsNullCount += 1;

                eventItem.dispose();

                if ( eventsNullCount > EventDispatcher._maxEventsNullCount ) clearNullEvents();
                break;
            }
        }
    };
    scope.dispatchEvent = function(event) {
        var localEventsItems = eventsItems.slice();

        event.currentTarget = this;

        for ( var i = 0, l = localEventsItems.length; i < l; i++ ) {
            var eventItem = localEventsItems[i];

            if ( eventItem == null ) continue;
            if ( event.stopPropagation ) break;
            if ( eventItem.type == event.type ) eventItem.listener(event);
        }
    };
    scope.removeAllListeners = function() {
        eventsItems = [];
    };
};

EventDispatcher._maxEventsNullCount = 1000;

EventDispatcher.prototype.dispatchComplete = function(data) {
    this.dispatchEvent(new Event(Event.COMPLETE, data));
};
EventDispatcher.prototype.dispatchUpdate = function(data) {
    this.dispatchEvent(new Event(Event.UPDATE, data));
};
EventDispatcher.prototype.dispatchProgress = function(data) {
    this.dispatchEvent(new Event(Event.PROGRESS, data));
};
/* Trololo by Kostia
EventDispatcher.prototype.dispatchError = function(data) {
    this.dispatchEvent(new Event(Event.UPDATE, data));
};
*/
EventDispatcher.prototype.dispatchError = function(data) {
    this.dispatchEvent(new Event(Event.ERROR, data));
};
EventDispatcher.prototype.onComplete = function(listener) {
    this.addEventListener(Event.COMPLETE, listener);
};
EventDispatcher.prototype.onUpdate = function(listener) {
    this.addEventListener(Event.UPDATE, listener);
};
EventDispatcher.prototype.onProgress = function(listener) {
    this.addEventListener(Event.PROGRESS, listener);
};
EventDispatcher.prototype.onError = function(listener) {
    this.addEventListener(Event.ERROR, listener);
};

EventDispatcher.prototype.removeOnComplete = function(listener) {
    this.removeEventListener(Event.COMPLETE, listener);
};
EventDispatcher.prototype.removeOnUpdate = function(listener) {
    this.removeEventListener(Event.UPDATE, listener);
};
EventDispatcher.prototype.removeOnProgress = function(listener) {
    this.removeEventListener(Event.PROGRESS, listener);
};
EventDispatcher.prototype.removeOnError = function(listener) {
    this.removeEventListener(Event.ERROR, listener);
};

//interface
EventDispatcherConstantInterface = {
    hasEventListener(type) {
        return this.__eventDispatcher.hasEventListener(type);
    },
    dispatchEvent(event) {
        this.__eventDispatcher.dispatchEvent(event);
    },
    addEventListener(type, listener) {
        this.__eventDispatcher.addEventListener(type, listener);
    },
    removeEventListener(type, listener) {
        this.__eventDispatcher.removeEventListener(type, listener);
    },
};
//style

var STYLESHEET = {};

STYLESHEET.__in = function(styleSelectorText, selectorText) {
    return styleSelectorText == selectorText;

    /*
    var array = null;

    if ( styleSelectorText == selectorText ) {
        return true;
    }

    array = styleSelectorText.split(",");

    for ( var i = 0, l = array.length; i < l; i++ ) {
        var str = array[i];

        if ( str[0] == " " ) str = str.substring(1);
        if ( str == selectorText ) return true;
    }

    return false;
    */
};

STYLESHEET.getCSSStyleRule = function (selectorText) {
    var styleSheets = document.styleSheets;
    var styleRules = [];

    for ( var sheet = 0, sheets = styleSheets.length; sheet < sheets; sheet++ ) {
        var styleSheet = styleSheets[sheet];
        var cssRules = styleSheet.cssRules;

        if ( cssRules == null ) continue;

        for ( var rule = 0, rules = cssRules.length; rule < rules; rule++ ) {
            var styleRule = cssRules[rule];

            if ( styleRule.selectorText && STYLESHEET.__in(styleRule.selectorText, selectorText) ) {
                styleRules.push(styleRule);
            }
        }
    }

    return styleRules;
};

STYLESHEET.createStyleSheet = function() {
    var styleSheet = document.createElement('style');
    var head = document.head;

    styleSheet.type = 'text/css';

    head.appendChild(styleSheet);

    return styleSheet;
};

STYLESHEET.appendStyleRule = function(styleSheet, cssPlainText) {
    styleSheet.appendChild(document.createTextNode(cssPlainText));

    return styleSheet;
};

STYLESHEET.createCSS = function(selectorText, properties) {
    var style = STYLESHEET.createStyleSheet();
    var css = selectorText + '{';

    for ( var k in properties ) {
        css += k + ': ' + properties[k] + ';';
    }

    css += '}';

    STYLESHEET.appendStyleRule(style, css);
};

/**
 * Set style for an element.
 * @param selectorText Name of css rule
 * @param properties Object with parameters where parameter as in JavaScript one (background-color is backgroundColor
 */
STYLESHEET.setFor = function (selectorText, properties) {
    var styleRules = STYLESHEET.getCSSStyleRule(selectorText);

    if ( styleRules == null ) return;

    for ( var i = 0, l = styleRules.length; i < l; i++ ) {
        var style = styleRules[i].style;

        for ( var prop in properties ) {
            style[prop] = properties[prop];
        }
    }
};
//geom

var GEOM = {};

GEOM.___ratioPI180 = Math.PI / 180;
GEOM.___ratio180PI = 180 / Math.PI;
GEOM.___RAD360 = Math.PI * 2;

GEOM.point = function(x, y) {
    return new GEOM.Point(x, y);
};
GEOM.line = function(a, b) {
    return new GEOM.Line(a, b);
};
GEOM.box = function(center, width, height, rotation) {
    return new GEOM.Box(center, width, height, rotation);
};
GEOM.shape = function(points) {
    return new GEOM.Shape(points);
};

GEOM.toRad = function(degrees) {
    return degrees * GEOM.___ratioPI180;
};
GEOM.toDeg = function(radians) {
    return radians * GEOM.___ratio180PI;
};
GEOM.pacifyAngleRad = function(value) {
    value = value % GEOM.___RAD360;

    if ( value < 0 ) {
        return Math.PI + value;
    }

    return value;
};
GEOM.pacifyAngleDeg = function(value) {
    value = value % 360;

    if ( value < 0 ) {
        return 360 + value;
    }

    return value;
};

GEOM.nearest = function(point, array) {
    if ( array.length == 0 ) return null;

    var nearest = array[0];
    var distance = point.distance(nearest);

    for ( var i = 1, l = array.length - 1; i < l; i++ ) {
        var p = array[i];
        var d = point.distance(p);

        if ( d < distance ) {
            nearest = p;
            distance = d;
        }
    }

    return nearest;
};
GEOM.farther = function(point, array) {
    if ( array.length == 0 ) return null;

    var farther = array[0];
    var distance = point.distance(farther);

    for ( var i = 1, l = array.length - 1; i < l; i++ ) {
        var p = array[i];
        var d = point.distance(p);

        if ( d > distance ) {
            farther = p;
            distance = d;
        }
    }

    return farther;
};
GEOM.rotatePosition = function(x, y, angle) {
    return {
        x:x * Math.cos(angle) - y * Math.sin(angle),
        y:x * Math.sin(angle) + y * Math.cos(angle)
    };
};
GEOM.getScaleForContain = function(boundWidth, boundHeight, contentWidth, contentHeight) {
    var scale = boundWidth / contentWidth;
    var newHeight = contentHeight * scale;

    if ( newHeight <= boundHeight ) return scale;

    return boundHeight / newHeight * scale;
};
GEOM.angleAtan = function(dx, dy, full) {
    if (dx == 0 && dy == 0) return 0;

    var a = Math.atan(dy / dx);

    if ( !full ) return a;
    if (dx < 0 && dy < 0) return Math.PI + a;
    if (dx < 0) return Math.PI + a;
    if (dy < 0) return Math.PI * 2 + a;

    return a;
};
GEOM.angleLine = function(x1, y1, x2, y2) {
    return GEOM.angleAtan(x2 - x1, y2 - y1, true);
};
GEOM.scalarProjection = function(vectorA, vectorB) {
    var br =  1 / Math.sqrt(vectorB.x * vectorB.x + vectorB.y * vectorB.y);
    var bx = vectorB.x * br;
    var by = vectorB.y * br;

    return vectorA.x * bx + vectorA.y * by;
};
GEOM.projectOnLine = function(point, line) {
    var va = new GEOM.Point(point.x - line.x1, point.y - line.y1);
    var vb = line.vector();
    var vd = vb.length();
    var scalar = GEOM.scalarProjection(va, vb);
    var angle = vb.angle(true);
    var projection = new GEOM.Point(line.x1 + scalar * Math.cos(angle), line.y1 + scalar * Math.sin(angle));

    return {
        point:projection,
        scalar:scalar,
        onSegment:scalar >= 0 && scalar <= vd,
        distance:GEOM.Point.distance(point, projection)
    };
};
GEOM.pointOnLIne = function(point, line) {
    var lv = line.vector();
    var pv = point.subtract(line.a);

    if ( lv.x == 0 ) {
        return pv.x == 0 && ((0 <= pv.y && pv.y <= lv.y) || (lv.y <= pv.y && pv.y <= 0));
    }
    if ( lv.y == 0 ) {
        return pv.y == 0 && ((0 <= pv.x && pv.x <= lv.x) || (lv.x <= pv.x && pv.x <= 0));
    }
    if ( Math.abs(lv.x * pv.y - pv.x * lv.y) < 0.00001 ) {
        return (0 <= pv.x && pv.x <= pv.x) || (pv.x <= pv.x && pv.x <= 0);
    }

    return false;
};
//alias
var G = GEOM;
//geom

GEOM.Point = function(x, y) {
    var scope = this;

    scope.x = 0;
    scope.y = 0;

    scope.set(x, y);
};

GEOM.Point.prototype.set = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};
GEOM.Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};
GEOM.Point.prototype.normalize = function() {
    var len = this.length();

    if ( len == 0 ) {
        this.x = 0;
        this.y = 0;
    } else {
        this.x *= 1 / len;
        this.y *= 1 / len;
    }

    return this;
};
GEOM.Point.prototype.distance = function(point) {
    return GEOM.Point.distance(this, point);
};
GEOM.Point.prototype.angle = function(full) {
    return GEOM.angleAtan(this.x, this.y, full);
};
GEOM.Point.prototype.rotate = function(angle, pivot) {
    var np;

    if ( pivot ) {
        np = GEOM.rotatePosition(this.x - pivot.x, this.y - pivot.y, angle);

        this.x = pivot.x + np.x;
        this.y = pivot.y + np.y;
    } else {
        np = GEOM.rotatePosition(this.x, this.y, angle);

        this.x = np.x;
        this.y = np.y;
    }

    return this;
};
GEOM.Point.prototype.draw = function(context) {
    context.beginPath();
    context.arc(this.x, this.y, 2, 0, Math.PI * 2);
    context.fill();
};
GEOM.Point.prototype.add = function(point) {
    return new GEOM.Point(this.x + point.x, this.y + point.y);
};
GEOM.Point.prototype.subtract = function(point) {
    return new GEOM.Point(this.x - point.x, this.y - point.y);
};
GEOM.Point.prototype.multiply = function(value) {
    return new GEOM.Point(this.x * value, this.y * value);
};
GEOM.Point.prototype.divide = function(value) {
    return new GEOM.Point(this.x / value, this.y / value);
};
GEOM.Point.prototype.invert = function() {
    return new GEOM.Point(-this.x, -this.y);
};
GEOM.Point.prototype.round = function() {
    return new GEOM.Point(Math.round(this.x), Math.round(this.y));
};
GEOM.Point.prototype.clone = function() {
    return new GEOM.Point(this.x, this.y);
};

GEOM.Point.distance = function(a, b) {
    return Math.sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));
};
GEOM.Point.sum = function(a, b) {
    return new GEOM.Point(b.x + a.x, b.y + a.y);
};
GEOM.Point.diff = function(a, b) {
    return new GEOM.Point(b.x - a.x, b.y - a.y);
};
GEOM.Point.rotate = function(pivot, point, angle) {
    var np = GEOM.rotatePosition(point.x - pivot.x, point.y - pivot.y, angle);

    return new GEOM.Point(pivot.x + np.x, pivot.y + np.y);
};
GEOM.Point.pointsCenter = function(points) {
    if ( points.length == 0 ) return null;

    var point = points[0];
    var minX = point.x;
    var minY = point.y;
    var maxX = minX;
    var maxY = minY;

    for ( var i = 1, l = points.length; i < l; i++ ) {
        point = points[i];

        if ( point.x < minX ) minX = point.x;
        if ( point.x > maxX ) maxX = point.x;
        if ( point.y < minY ) minY = point.y;
        if ( point.y > maxY ) maxY = point.y;
    }

    return new GEOM.Point((minX + maxX) / 2, (minY + maxY) / 2);
};
GEOM.Point.contourFromString = function(str)
{
    var nums = str.split(',');
    var res = new Array(nums.length / 2);
    for (var i = 0; i < res.length; i++)
    {
        res[i] = new GEOM.Point(parseFloat(nums[i * 2]), parseFloat(nums[i * 2 + 1]));
    }

    return res;
};
GEOM.Point.getUniquePoints = function(points) {
    var uPoints = [];
    var cache = {};

    for ( var i = 0, l = points.length; i < l; i++ ) {
        var p = points[i];

        if ( cache.hasOwnProperty(p.x) && cache[p.x].hasOwnProperty(p.y) ) continue;
        if ( !cache.hasOwnProperty(p.x) ) cache[p.x] = {};
        cache[p.x][p.y] = true;

        uPoints.push(p);
    }

    return uPoints;
};
GEOM.Point.getPointsBounding = function(points) {
    if ( points.length == 0 ) return null;

    var point = points[0];
    var minX = point.x;
    var maxX = point.x;
    var minY = point.y;
    var maxY = point.y;

    for ( var i = 1, il = points.length; i < il; i++ ) {
        point = points[i];

        if ( point.x < minX ) minX = point.x;
        if ( point.x > maxX ) maxX = point.x;
        if ( point.y < minY ) minY = point.y;
        if ( point.y > maxY ) maxY = point.y;
    }

    return new GEOM.Bounds(minX, minY, maxX, maxY);
};
GEOM.Point.rotatePoint = function(point, angle) {
    return new GEOM.Point(
        point.x * Math.cos(angle) - point.y * Math.sin(angle),
        point.x * Math.sin(angle) + point.y * Math.cos(angle)
    );
};
GEOM.Point.rotatePoints = function(points, angle) {
    var newPoints = new Array(points.length);

    for ( var i = 0, l = points.length; i < l; i++ ) {
        newPoints[i] = GEOM.Point.rotatePoint(points[i], angle);
    }

    return newPoints;
};
GEOM.Point.shiftPoints = function(point, points) {
    var newPoints = new Array(points.length);

    for ( var i = 0, l = points.length; i < l; i++ ) {
        newPoints[i] = new GEOM.Point(point.x + points[i].x, point.y + points[i].y);
    }

    return newPoints;
};
GEOM.Point.scalePoints = function(sx, sy, points) {
    var newPoints = new Array(points.length);

    for ( var i = 0, l = points.length; i < l; i++ ) {
        newPoints[i] = new GEOM.Point(points[i].x * sx, points[i].y * sy);
    }

    return newPoints;
};

//alias
GEOM.P = GEOM.Point;

//geom

GEOM.Vector = function(x, y, z) {
    var scope = this;

    scope.x = 0;
    scope.y = 0;
    scope.z = 0;

    scope.set(x, y, z);
};

GEOM.Vector.prototype.set = function(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};
GEOM.Vector.prototype.distance = function(vector) {
    return GEOM.Vector.distance(this, vector);
};
GEOM.Vector.prototype.rotateByX = function(angle) {
    var np = GEOM.rotatePosition(this.y, this.z, angle);

    this.y = np.x;
    this.z = np.y;

    return this;
};
GEOM.Vector.prototype.rotateByY = function(angle) {
    var np = GEOM.rotatePosition(this.z, this.x, angle);

    this.z = np.x;
    this.x = np.y;

    return this;
};
GEOM.Vector.prototype.rotateByZ = function(angle) {
    var np = GEOM.rotatePosition(this.x, this.y, angle);

    this.x = np.x;
    this.y = np.y;

    return this;
};

//static
GEOM.Vector.distance = function(a, b) {
    return Math.sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y) + (b.z - a.z) * (b.z - a.z));
};
GEOM.Vector.sum = function(a, b) {
    return new GEOM.Vector(b.x + a.x, b.y + a.y, b.z + a.z);
};
GEOM.Vector.diff = function(a, b) {
    return new GEOM.Vector(b.x - a.x, b.y - a.y, b.z - a.z);
};

//alias
GEOM.V = GEOM.Vector;
// geom

GEOM.Line = function(a, b) {
    this.a = null;
    this.b = null;

    this.set(a, b);
};

Object.defineProperties(GEOM.Line.prototype, {
    "x1":{
        get() { return this.a.x; },
        set(v) { this.a.x = v; }
    },
    "y1":{
        get() { return this.a.y; },
        set(v) { this.a.y = v; }
    },
    "x2":{
        get() { return this.b.x; },
        set(v) { this.b.x = v; }
    },
    "y2":{
        get() { return this.b.y; },
        set(v) { this.b.y = v; }
    },
});

GEOM.Line.prototype.set = function(a, b) {
    this.a = a || new GEOM.Point();
    this.b = b || new GEOM.Point();
};
GEOM.Line.prototype.vector = function() {
    return new GEOM.Point(this.b.x - this.a.x, this.b.y - this.a.y);
};
GEOM.Line.prototype.normal = function() {
    return new GEOM.Point(this.a.y - this.b.y, this.b.x - this.a.x);
};
GEOM.Line.prototype.angle = function() {
    return GEOM.angleAtan(this.b.x - this.a.x, this.b.y - this.a.y, true);
};
GEOM.Line.prototype.onLine = function(point) {
    return GEOM.pointOnLIne(point, this);
};
GEOM.Line.prototype.center = function() {
    return new GEOM.Point.pointsCenter([this.a, this.b]);
};
GEOM.Line.prototype.length = function () {
    return this.vector().length();
};
GEOM.Line.prototype.draw = function(context) {
    context.beginPath();
    context.moveTo(this.a.x, this.a.y);
    context.lineTo(this.b.x, this.b.y);
    context.stroke();
};

GEOM.Line.make = function(x1, y1, x2, y2) {
    return new GEOM.Line(new GEOM.Point(x1, y1), new GEOM.Point(x2, y2));
};
GEOM.Line.parallels = function(a, b) {
    var adx = a.b.x - a.a.x;
    var ady = a.b.y - a.a.y;
    var bdx = b.b.x - b.a.x;
    var bdy = b.b.y - b.a.y;

    if ( adx == 0 && bdx == 0 ) return true;
    if ( ady == 0 && bdy == 0 ) return true;

    return adx / ady == bdx / bdy;
};
GEOM.Line.angleBetween = function(lineA, lineB) {
    var adx = lineA.b.x - lineA.a.x;
    var ady = lineA.b.y - lineA.a.y;
    var al = Math.sqrt(adx * adx + ady * ady);
    var bdx = lineB.b.x - lineB.a.x;
    var bdy = lineB.b.y - lineB.a.y;
    var bl = Math.sqrt(bdx * bdx + bdy * bdy);

    return Math.acos((adx * bdx + ady * bdy) / (al * bl));
};
GEOM.Line.intersection = function(a, b) {
    if(!a || !b) return;
    var aa = a.a;
    var ab = a.b;
    var ba = b.a;
    var bb = b.b;
    var ix, iy;
    var denominator = ((bb.y - ba.y) * (ab.x - aa.x)) - ((bb.x - ba.x) * (ab.y - aa.y));

    if ( denominator == 0 ) return null;

    var va = aa.y - ba.y;
    var vb = aa.x - ba.x;
    var numerator1 = ((bb.x - ba.x) * va) - ((bb.y - ba.y) * vb);
    var numerator2 = ((ab.x - aa.x) * va) - ((ab.y - aa.y) * vb);

    va = numerator1 / denominator;
    vb = numerator2 / denominator;
    ix = aa.x + (va * (ab.x - aa.x));
    iy = aa.y + (va * (ab.y - aa.y));

    return {
        point:new GEOM.Point(ix, iy),
        va:va,
        vb:vb,
        onA:va > 0 && va < 1,
        onB:vb > 0 && vb < 1
    }
};
//geom

GEOM.Bounds = function(left, top, right, bottom) {
    var scope = this;

    scope.width = 0;
    scope.height = 0;
    scope.centerX = 0;
    scope.centerY = 0;
    scope.left = left || 0;
    scope.top = top || 0;
    scope.right = right || 0;
    scope.bottom = bottom || 0;

    scope.update();
};
GEOM.Bounds.prototype.update =function() {
    this.width = this.right - this.left;
    this.height = this.bottom - this.top;
    this.centerX = this.left + this.width / 2;
    this.centerY = this.top + this.height / 2;
};
GEOM.Bounds.prototype.getLeft = function() {
    return this.left;
};
GEOM.Bounds.prototype.getTop = function() {
    return this.top;
};
GEOM.Bounds.prototype.getRight = function() {
    return this.right;
};
GEOM.Bounds.prototype.getBottom = function() {
    return this.bottom;
};
GEOM.Bounds.prototype.getCenterX = function() {
    return this.centerX;
};
GEOM.Bounds.prototype.getCenterY = function() {
    return this.centerY;
};
GEOM.Bounds.prototype.getWidth = function() {
    return this.width;
};
GEOM.Bounds.prototype.getHeight = function() {
    return this.height;
};
GEOM.Bounds.prototype.updateBounds = function (l, t, r, b) {
    this.left = l;
    this.top = t;
    this.right = r;
    this.bottom = b;

    this.update();
};
GEOM.Bounds.prototype.toString = function() {
    return this.left + ', ' + this.top + ', ' + this.right + ', ' + this.bottom;
};
GEOM.Bounds.prototype.clone = function() {
    return new GEOM.Bounds(this.getLeft(), this.getTop(), this.getRight(), this.getBottom());
};

/**
 *
 * @param {Array} bounds
 * @returns {*}
 */
GEOM.Bounds.getMaxBounds = function(bounds) {
    if ( bounds.length == 0 ) return null;
    if ( bounds.length == 1 ) return bounds[0];

    var maxBounds = bounds[0].clone();

    for ( var i = 1, l = bounds.length; i < l; i++ ) {
        var b = bounds[i];

        if ( b.left < maxBounds.left ) maxBounds.left = b.left;
        if ( b.top < maxBounds.top ) maxBounds.top = b.top;
        if ( b.right > maxBounds.right ) maxBounds.right = b.right;
        if ( b.bottom > maxBounds.bottom ) maxBounds.bottom = b.bottom;
    }

    maxBounds.update();

    return maxBounds;
};
// geom

GEOM.Box = function(center, width, height, rotation) {
    this.a = null;
    this.b = null;
    this.c = null;
    this.d = null;
    this.width = 0;
    this.height = 0;
    this.rotation = 0;

    this.set(center, width, height, rotation);
};
GEOM.Box.prototype.set = function(center, width, height, rotation) {
    this.center = center;
    this.a = new GEOM.Point(center.x - width / 2, center.y - height / 2);
    this.b = new GEOM.Point(center.x + width / 2, center.y - height / 2);
    this.c = new GEOM.Point(center.x + width / 2, center.y + height / 2);
    this.d = new GEOM.Point(center.x - width / 2, center.y + height / 2);
    this.width = width;
    this.height = height;
    this.rotation = rotation || 0;
};
GEOM.Box.prototype.setCenter = function(center) {
    this.set(center, this.width, this.height, this.rotation);
};
GEOM.Box.prototype.realPoints = function() {
    var a = this.a.clone().rotate(this.rotation, this.center);
    var b = this.b.clone().rotate(this.rotation, this.center);
    var c = this.c.clone().rotate(this.rotation, this.center);
    var d = this.d.clone().rotate(this.rotation, this.center);

    return [a, b, c, d];
};
GEOM.Box.prototype.realLines = function () {
    var points = this.realPoints();

    return [
        new GEOM.Line(points[0], points[1]),
        new GEOM.Line(points[1], points[2]),
        new GEOM.Line(points[2], points[3]),
        new GEOM.Line(points[3], points[0])
    ];
};
GEOM.Box.prototype.draw = function(context, real) {
    var a, b, c, d;

    if ( real ) {
        var points = this.realPoints();

        a = points[0];
        b = points[1];
        c = points[2];
        d = points[3];
    } else {
        a = this.a;
        b = this.b;
        c = this.c;
        d = this.d;
    }

    context.beginPath();
    context.moveTo(a.x, a.y);
    context.lineTo(b.x, b.y);
    context.lineTo(c.x, c.y);
    context.lineTo(d.x, d.y);
    context.lineTo(a.x, a.y);
    context.stroke();
};

//geom

GEOM.Shape = function(points) {
    if ( points.length < 3 ) throw "Count of points must be more than 2.";

    Object.defineProperties(this, {
        "points":{
            get() { return points; },
            set(value) { points = value; }
        }
    });
};

GEOM.Shape.prototype.realLines = function() {
    var last = this.points.length - 1;
    var array = [GEOM.line(this.points[0], this.points[1])];

    for ( let i = 1; i < last; i++ ) {
        array.push(GEOM.line(this.points[i], this.points[i + 1]));
    }

    array.push(GEOM.line(this.points[last], this.points[0]));

    return array;
};
GEOM.Shape.prototype.draw = function(context) {
    context.beginPath();
    context.moveTo(this.points[0].x, this.points[0].y);

    for ( let i = 1, l = this.points.length; i < l; i++ ) {
        context.lineTo(this.points[i].x, this.points[i].y);
    }

    context.lineTo(this.points[0].x, this.points[0].y);
    context.stroke();
};
//geom

GEOM.shiftVectors = function(center, normal, vectors)
{
    var minProj = Infinity;

    for (var i = 0; i < vectors.length; i++)
    {
        var cVec = new G.V(vectors[i].x, vectors[i].y, vectors[i].z);
        var proj = cVec.x * normal.x + cVec.y * normal.y + cVec.z * normal.z;

        if ( proj < minProj ) {
            minProj = proj;
        }
    }

    return new G.V(-normal.x * minProj, -normal.y * minProj, -normal.z * minProj);
};
var COLOR = {

};

COLOR.getColorChannels = function(intColor) {
    var r = (intColor >> 16) & 255;
    var g = (intColor >> 8) & 255;
    var b = intColor & 255;

    return {
        r:r,
        g:g,
        b:b
    };
};
COLOR.hexToInt = function(hexColor) {
    if ( hexColor.substring(0, 1) != '#' ) return 0;
    
    return parseInt('0x' + hexColor.substring(1, 7))
};
COLOR.intToHex = function(intColor) {
    var channels = COLOR.getColorChannels(intColor);
    var r = String(channels.r.toString(16));
    var g = String(channels.g.toString(16));
    var b = String(channels.b.toString(16));

    if ( r.length == 1 ) r = "0" + r;
    if ( g.length == 1 ) g = "0" + g;
    if ( b.length == 1 ) b = "0" + b;

    return "#" + r + g + b;
};
COLOR.hexToRGBA = function(hexColor, alpha) {
    var r = parseInt('0x' + hexColor.substr(1, 2));
    var g = parseInt('0x' + hexColor.substr(3, 2));
    var b = parseInt('0x' + hexColor.substr(5, 2));
    var rgba = "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";

    return rgba;
};
COLOR.intToRGBA = function(intColor, alpha) {
    var channels = COLOR.getColorChannels(intColor);

    return "rgba(" + channels.r + ", " + channels.g + ", " + channels.b + ", " + alpha + ")";
};
//animation

/*
var prop = {
    x:{
        from:10,
        to:20,
        unit:"px",
        easing:easing
    }
};*/

var Animation = function (target, properties, frames) {
    EventDispatcher.call(this);

    var scope = this;
    var currentFrame = 0;
    var stop = false;
    var property, time, moveFrom, moveTo, currentValue, unit, easing, totalValue, asFunction;

    if ( frames < 3 ) {
        throw "Frames of Animation must be equal to 3 or more!";
    }

    function animateEvent() {
        if ( currentFrame == 0 ) {
            scope.dispatchEvent(new Event(Event.START, scope));
            scope.dispatchEvent(new Event(Event.PROGRESS, scope));
        } else if ( currentFrame == frames ) {
            scope.dispatchEvent(new Event(Event.PROGRESS, scope));
            scope.dispatchEvent(new Event(Event.FINISH, scope));
        } else {
            scope.dispatchEvent(new Event(Event.PROGRESS, scope));
        }
    }
    function animate() {
        if ( stop ) return;

        currentFrame += 1;
        time = currentFrame / frames;
        
        for ( var prop in properties ) {
            property = properties[prop];
            moveFrom = property["from"];
            moveTo = property["to"];
            unit = property["unit"];
            easing = property["easing"];
            asFunction = property["asFunction"];
            currentValue = moveFrom + (moveTo - moveFrom) * easing(time);

            if ( unit ) totalValue = String(currentValue) + String(unit);
            else totalValue = currentValue;

            if ( asFunction ) target[prop](totalValue);
            else target[prop] = totalValue;
        }

        if ( currentFrame < frames ) {
            requestAnimationFrame(animate);
        }

        animateEvent();
    }

    scope.getTarget = function() {
        return target;
    };
    scope.getFrame = function() {
        return currentFrame;
    };
    scope.getFrames = function() {
        return frames;
    };
    scope.getProgress = function() {
        return currentFrame / frames;
    };
    scope.start = function() {
        animateEvent();
        animate();
    };
    scope.stop = function() {
        stop = true;
    };
    scope.dispose = function() {
        target = null;
        properties = null;
    };
    scope.reverse = function() {
        var temp;

        for ( var prop in properties ) {
            property = properties[prop];
            temp = property["from"];
            property["from"] = property["to"];
            property["to"] = temp;
        }

        currentFrame = frames - currentFrame;
    };
};

extend(Animation, EventDispatcher);

Animation.createProperty = function(from, to, unit, easing, asFunction) {
    return {
        from:from,
        to:to,
        unit:unit,
        easing:easing,
        asFunction:asFunction
    }
};
//animation

Animation.Ease = function() {
    throw "Pass static function of Ease to Animation constructor!";
};

Animation.Ease.linear = function(t) {
    return t;
};
Animation.Ease.easeIn = function(t) {
    return 1 - Math.cos(Math.PI / 2 * t);
};
Animation.Ease.easeOut = function(t) {
    return Math.sin(Math.PI / 2 * t);
};
Animation.Ease.easeInOut = function(t) {
    return Math.sin(t * Math.PI - Math.PI / 2) / 2 + .5;
};
// snap

var SNAP = {};
// snap

SNAP.Snap2D = function () {
    this._distance = 10;
    this._points = [];
    this._boxes = [];
    this._lines = [];
};

SNAP.Box = function(points, h)
{
    var me = this;
    me.points = points;
    me.height = h;
    me.area = TR.contourArea(me.points);
};

SNAP.Snap2D.prototype.updateDistance = function(distance){
    this._distance = distance;
};
SNAP.Snap2D.prototype.updatePoints = function(points) {
    this._points = points;
};
SNAP.Snap2D.prototype.updateLines = function(lines) {
    this._lines = lines;
};
SNAP.Snap2D.prototype.updateBoxes = function(boxes) {
    this._boxes = boxes;
};
SNAP.Snap2D.prototype.findPoint = function(point) {
    if ( this._points.length == 0 ) {
        return new GEOM.Point(Infinity, Infinity);
    }

    var distance = GEOM.Point.distance(point, this._points[0]);
    var nearPoint = this._points[0];

    for ( var i = 1, l = this._points.length; i < l; i++ ) {
        var p = this._points[i];
        var d = GEOM.Point.distance(point, p);

        if ( d < distance ) {
            distance = d;
            nearPoint = p;
        }
    }

    return new GEOM.Point(point.x - nearPoint.x, point.y - nearPoint.y);
};
SNAP.Snap2D.prototype.findLine = function(point) {
    if ( this._lines.length == 0 ) {
        return new GEOM.Point(Infinity, Infinity);
    }

    var project = null;

    for ( var i = 0, l = this._lines.length; i < l; i++ ) {
        var pr = GEOM.projectOnLine(point, this._lines[i]);

        if ( pr.onSegment ) {
            if ( project == null || (project && Math.abs(pr.distance) < Math.abs(project.distance)) ) {
                project = pr;
            }
        }
    }

    if ( project ) {
        return new GEOM.Point(point.x - project.point.x, point.y - project.point.y);
    }

    return new GEOM.Point(Infinity, Infinity);
};
SNAP.Snap2D.prototype.findShiftPoints = function(points) {
    if ( points.length == 0 ) return new GEOM.Point(0, 0);

    var i, l;
    var nearShift = this.findPoint(points[0]);
    var nearLine = null;

    for ( i = 1, l = points.length; i < l; i++ ) {
        var ns = this.findPoint(points[i]);

        if ( ns.length() < nearShift.length() ) nearShift = ns;
    }

    if ( nearShift.length() < this._distance ) {
        return nearShift;
    }

    nearLine = this.findLine(points[0]);

    for ( i = 1, l = points.length; i < l; i++ ) {
        var nl = this.findLine(points[i]);

        if ( nl.length() < nearLine.length() ) nearLine = nl;
    }

    if ( nearLine.length() < this._distance ) {
        return nearLine;
    }

    return new GEOM.Point(0, 0);
};

SNAP.Snap2D.prototype.snapPolygonToIntersectLine = function(points, lines, distance)
{
    var res = {
        dx: 0,
        dy: 0,
        angle: 0,
        snap: false,
        linesData: []
    };

    if (lines.length == 0) return res;

    var minDist = Infinity;
    var closestProj = null;
    var projLine = null;

    var intersectingLines = [];
    for (var i = 0; i < lines.length; i++)
    {
        var intersect = false;
        var a = lines[i].a;
        var b = lines[i].b;

        for (j = 0; j < points.length; j++)
        {
            var p1 = points[j];
            var p2;
            if (j == points.length - 1) p2 = points[0]; else p2 = points[j + 1];
            if (TR.lineIntersectLine(a, b, p1, p2, true,false))
            {
                intersectingLines.push(lines[i]);
                intersect = true;
                break;
            }
        }
    }

    var centerPt = new GEOM.Point(0, 0);
    for (var j = 0; j < points.length; j++)
    {
        centerPt.x += points[j].x;
        centerPt.y += points[j].y;
    }
    centerPt.x /= points.length;
    centerPt.y /= points.length;

    for (i = 0; i < intersectingLines.length; i++)
    {
        a = intersectingLines[i].a;
        b = intersectingLines[i].b;
        var proj = TR.projectionPointOnLine(centerPt, a, b, true);
        if (proj)
        {
            var dist = TR. euclDistP(centerPt, proj);
            if (dist < minDist)
            {
                minDist = dist;
                closestProj = proj;
                projLine = intersectingLines[i];
            }
            res.linesData.push({line: intersectingLines[i], proj: proj, dist: dist});
        }
    }

    if (! closestProj) return res;

    var signedDist = TR.distanceBetweenPointAndLine(centerPt, projLine.a, projLine.b);
    if (signedDist < 0) return res;

    var farPt = new GEOM.Point(closestProj.x - (centerPt.x - closestProj.x) * 1000, closestProj.y - (centerPt.y - closestProj.y) * 1000);


    var shiftLen = 0;
    for (i = 0; i < points.length; i++)
    {
        proj = TR.projectionPointOnLine(points[i], closestProj, farPt, true);
        if (! proj) continue;
        var sh = TR.euclDistP(proj, closestProj);
        if (sh > shiftLen) shiftLen = sh;
    }

    res.dx = (closestProj.x - centerPt.x) / TR.euclDistP(closestProj, centerPt) * shiftLen;
    res.dy = (closestProj.y - centerPt.y) / TR.euclDistP(closestProj, centerPt) * shiftLen;
    res.angle = Math.atan2(projLine.a.x - projLine.b.x, projLine.a.y - projLine.b.y);
    res.snap = true;

    return res;
};

SNAP.Snap2D.prototype.snapPolygonToIntersectLineInOneDirection = function(points, linesData, distance, pointsShift, directionAngle)
{
    var res = {
        dx: 0,
        dy: 0,
        snap: false
    };

    var minDist = Infinity;
    var closestLine = null;
    for (var i = 0; i < linesData.length; i++)
    {
        var line = linesData[i].line;
        var proj = linesData[i].proj; // Projection of model center
        var dist = linesData[i].dist; // distance from center to its projection

        var a = line.a;
        var b = line.b;
        var deltaAng = Math.atan2(a.x - b.x, a.y - b.y) - directionAngle;
        if ((deltaAng >= 0 && deltaAng <= 0.2) ||
            (deltaAng <= 0 && deltaAng >= -0.2) ||
            (deltaAng >= Math.PI - 0.2 && deltaAng <= Math.PI + 0.2) ||
            (deltaAng >= -Math.PI - 0.2 && deltaAng <= -Math.PI + 0.2)) continue;

        if (dist < minDist)
        {
            minDist = dist;
            closestLine = line;
        }
    }

    if (! closestLine) return res;

    var centerPt = new GEOM.Point(0, 0);
    for (var j = 0; j < points.length; j++)
    {
        centerPt.x += points[j].x;
        centerPt.y += points[j].y;
    }
    centerPt.x /= points.length;
    centerPt.y /= points.length;

    var shiftLen = 0;
    var shiftPt = null;
    var shiftInt = null;
    for (j = 0; j < points.length; j++)
    {
        var pt0 = new GEOM.Point(points[j].x - pointsShift.x, points[j].y - pointsShift.y);
        if (TR.distanceBetweenPointAndLine(pt0, closestLine.a, closestLine.b) *
            TR.distanceBetweenPointAndLine(centerPt, closestLine.a, closestLine.b) > 0) continue;

        var ang = directionAngle;
        var pt1 = new GEOM.Point(pt0.x + 1000 * Math.sin(ang), pt0.y + 1000 * Math.cos(ang));
        var pt2 = new GEOM.Point(pt0.x + 1000 * Math.sin(ang + Math.PI), pt0.y + 1000 * Math.cos(ang + Math.PI));

        var int = TR.lineIntersectLine(pt1, pt2, closestLine.a, closestLine.b, false);
        if (! int) continue;
        var sh = TR.euclDistP(pt0, int);
        if (sh > shiftLen)
        {
            shiftLen = sh;
            shiftPt = pt0;
            shiftInt = int;
        }
    }

    if (! shiftPt || ! shiftInt) return res;

    res.dx = (shiftPt.x - shiftInt.x) / TR.euclDistP(shiftPt, shiftInt) * shiftLen;
    res.dy = (shiftPt.y - shiftInt.y) / TR.euclDistP(shiftPt, shiftInt) * shiftLen;
    res.snap = true;

    return res;
};

SNAP.Snap2D.prototype.snapPolygonToNearestLine = function(points, lines, distance, pointsShift)
{
    var res = {
        dx: 0,
        dy: 0,
        angle: 0,
        snap: false
    };

    if (lines.length == 0) return res;

    var minDist = Infinity;
    var closestProj = null;
    var projLine = null;
    var projPoint = null;
    var dx = pointsShift.x;
    var dy = pointsShift.y;

    var cx = 0;
    var cy = 0;
    for (var j = 0; j < points.length; j++)
    {
        cx += points[j].x;
        cy += points[j].y;
    }
    cx /= points.length;
    cy /= points.length;

    for (j = 0; j < points.length; j++)
    {
        var pt0 = new GEOM.Point(points[j].x - dx, points[j].y - dy);

        for (var i = 0; i < lines.length; i++)
        {
            var a = lines[i].a;
            var b = lines[i].b;

            var distCenter = TR.distanceBetweenPointAndLine(new TR.Point(cx, cy), a, b);
            if (distCenter < 0) continue;

            var proj = TR.projectionPointOnLine(pt0, a, b, true, true);
            if (proj)
            {
                var dist = TR.euclDistP(pt0, proj);

                if (Math.abs(dist) < minDist)
                {
                    minDist = Math.abs(dist);
                    closestProj = proj;
                    projLine = lines[i];
                    projPoint = points[j]
                }
            }
        }
    }

    if (!closestProj || Math.abs(minDist) > distance) return res;

    res.dx = projPoint.x - closestProj.x - dx;
    res.dy = projPoint.y - closestProj.y - dy;
    res.angle = Math.atan2(projLine.a.x - projLine.b.x, projLine.a.y - projLine.b.y);
    res.snap = true;
    return res;
};

SNAP.Snap2D.prototype.snapPolygonToNearestLineInOneDirection = function(points, lines, distance, pointsShift, directionAngle)
{
    var res = {
        dx: 0,
        dy: 0,
        snap: false
    };

    var minDist = Infinity;
    var closestInt = null;
    var intPoint = null;
    var dx = pointsShift.x;
    var dy = pointsShift.y;

    var cx = 0;
    var cy = 0;
    for (var j = 0; j < points.length; j++)
    {
        cx += points[j].x;
        cy += points[j].y;
    }
    cx /= points.length;
    cy /= points.length;

    for (j = 0; j < points.length; j++)
    {
        var pt0 = new GEOM.Point(points[j].x - dx, points[j].y - dy);
        var ang = directionAngle;
        var pt1 = new GEOM.Point(pt0.x + distance * Math.sin(ang), pt0.y + distance * Math.cos(ang));
        var pt2 = new GEOM.Point(pt0.x + distance * Math.sin(ang + Math.PI), pt0.y + distance * Math.cos(ang + Math.PI));

        for (var i = 0; i < lines.length; i++)
        {
            var a = lines[i].a;
            var b = lines[i].b;

            var distCenter = TR.distanceBetweenPointAndLine(new TR.Point(cx, cy), a, b);
            if (distCenter < 0) continue;

            var deltaAng = Math.atan2(lines[i].a.x - lines[i].b.x, lines[i].a.y - lines[i].b.y) - directionAngle;
            if ((deltaAng >= 0 && deltaAng <= 0.2) ||
                (deltaAng <= 0 && deltaAng >= -0.2) ||
                (deltaAng >= Math.PI - 0.2 && deltaAng <= Math.PI + 0.2) ||
                (deltaAng >= -Math.PI - 0.2 && deltaAng <= -Math.PI + 0.2)) continue;

            var int = TR.lineIntersectLine(a, b, pt1, pt2, true, true, 1);
            if (int)
            {
                var dist = TR.euclDistP(pt0, int);
                if (Math.abs(dist) < minDist)
                {
                    minDist = Math.abs(dist);
                    closestInt = int;
                    intPoint = pt0;
                }
            }
        }
    }

    if (!closestInt || Math.abs(minDist) > distance) return res;

    res.dx = intPoint.x - closestInt.x;
    res.dy = intPoint.y - closestInt.y;
    res.snap = true;
    return res;
};

SNAP.Snap2D.prototype.snapPolygonToPoint = function(polygon, points, distance, polygonShift, directionAngle)
{
    var res = {
        dx: 0,
        dy: 0,
        snap: false
    };

    if (points.length == 0) return res;

    var nearestPt = null;
    var snappingPt = null;
    var minDist = Infinity;

    var dx = 0;
    var dy = 0;
    if (polygonShift)
    {
        dx = polygonShift.x;
        dy = polygonShift.y;
    }

    for (var j = 0; j < polygon.length; j++)
    {
        var pt0 = new GEOM.Point(polygon[j].x - dx, polygon[j].y - dy);

        for (var i = 0; i < points.length; i++)
        {
            var dist = TR.euclDistP(points[i], pt0);
            if (dist < minDist)
            {
                minDist = dist;
                nearestPt = points[i];
                snappingPt = pt0;
            }
        }
    }

    if (minDist > distance) return res;

    dx = snappingPt.x - nearestPt.x;
    dy = snappingPt.y - nearestPt.y;

    if (typeof directionAngle == 'undefined')
    {
        res.dx = dx;
        res.dy = dy;
        res.snap = true;

        return res;
    }
    else
    {
        var dotProd = dx * Math.sin(directionAngle) + dy * Math.cos(directionAngle);

        res.dx = dotProd * Math.sin(directionAngle);
        res.dy = dotProd * Math.cos(directionAngle);
        res.snap = true;

        return res;
    }
};

SNAP.Snap2D.prototype.snapPolygonToBox = function(polygon, boxes, distance, polygonShift, directionAngle, height)
{
    var res = {
        dx: 0,
        dy: 0,
        snap: false
    };

    if (boxes.length == 0) return res;

    var nearestPt = null;
    var snappingPt = null;
    var minDist = Infinity;

    var dx = 0;
    var dy = 0;
    if (polygonShift)
    {
        dx = polygonShift.x;
        dy = polygonShift.y;
    }

    var area = TR.contourArea(polygon);
    for (var i = 0; i < polygon.length; i++)
    {
        var pt0 = new GEOM.Point(polygon[i].x - dx, polygon[i].y - dy);

        for (var j = 0; j < boxes.length; j++)
        {
            if (height / boxes[j].height > 5) continue;
            if (area / boxes[j].area > 25) continue;

            for (var k = 0; k < boxes[j].points.length; k++)
            {
                var dist = TR.euclDistP(boxes[j].points[k], pt0);
                if (dist < minDist)
                {
                    minDist = dist;
                    nearestPt = boxes[j].points[k];
                    snappingPt = pt0;
                }
            }
        }
    }

    if (minDist > distance) return res;

    dx = snappingPt.x - nearestPt.x;
    dy = snappingPt.y - nearestPt.y;

    if (typeof directionAngle == 'undefined' || directionAngle === null)
    {
        res.dx = dx;
        res.dy = dy;
        res.snap = true;

        return res;
    }
    else
    {
        var dotProd = dx * Math.sin(directionAngle) + dy * Math.cos(directionAngle);

        res.dx = dotProd * Math.sin(directionAngle);
        res.dy = dotProd * Math.cos(directionAngle);
        res.snap = true;

        return res;
    }
};
/*
SNAP.Snap2D.prototype.snapPolygon = function(points)
{
    var snapToInt = SNAP.Snap2D.prototype.snapPolygonToIntersectLine(points, this._lines);

    if (snapToInt.snap)
    {
        var snapToInt1d =
            SNAP.Snap2D.prototype.snapPolygonToIntersectLineInOneDirection(points, snapToInt.linesData, this._distance,
                {x: snapToInt.dx, y: snapToInt.dy}, snapToInt.angle);

        if (snapToInt1d.snap) return new GEOM.Point(snapToInt.dx + snapToInt1d.dx, snapToInt.dy + snapToInt1d.dy);

        var snapToLine1d = SNAP.Snap2D.prototype.snapPolygonToNearestLineInOneDirection(points, this._lines, this._distance,
            {x: snapToInt.dx, y: snapToInt.dy}, snapToInt.angle);

        if (snapToLine1d.snap) return new GEOM.Point(snapToInt.dx + snapToLine1d.dx, snapToInt.dy + snapToLine1d.dy);

        var snapToPoint = SNAP.Snap2D.prototype.snapPolygonToPoint(points, this._points, this._distance,
            {x: snapToInt.dx, y: snapToInt.dy}, snapToInt.angle);

        if (snapToPoint.snap) return new GEOM.Point(snapToInt.dx + snapToPoint.dx, snapToInt.dy + snapToPoint.dy);

        return new GEOM.Point(snapToInt.dx, snapToInt.dy);
    }

    var snapToLine = SNAP.Snap2D.prototype.snapPolygonToNearestLine(points, this._lines, this._distance);

    if (snapToLine.snap)
    {
        snapToLine1d = SNAP.Snap2D.prototype.snapPolygonToNearestLineInOneDirection(points, this._lines, this._distance,
            {x: snapToLine.dx, y: snapToLine.dy}, snapToLine.angle);

        if (snapToLine1d.snap) return new GEOM.Point(snapToLine.dx + snapToLine1d.dx, snapToLine.dy + snapToLine1d.dy);

        snapToPoint = SNAP.Snap2D.prototype.snapPolygonToPoint(points, this._points, this._distance,
            {x: snapToLine.dx, y: snapToLine.dy}, snapToLine.angle);

        if (snapToPoint.snap) return new GEOM.Point(snapToLine.dx + snapToPoint.dx, snapToLine.dy + snapToPoint.dy);

        return new GEOM.Point(snapToLine.dx, snapToLine.dy);
    }

    snapToPoint = SNAP.Snap2D.prototype.snapPolygonToPoint(points, this._points, this._distance, {x: 0, y:0});

    if (snapToPoint.snap) return new GEOM.Point(snapToPoint.dx, snapToPoint.dy);

    return new GEOM.Point(0, 0);
};
*/
/* // 2020.12.07
SNAP.Snap2D.prototype.snapPolygon = function(points, shift, height)
{
    var snapToLine = SNAP.Snap2D.prototype.snapPolygonToNearestLine(points, this._lines, this._distance, {x: shift.x, y: shift.y});
    var snapToPoint = SNAP.Snap2D.prototype.snapPolygonToPoint(points, this._points, this._distance, {x: shift.x, y:shift.y});
    var snapToBox = SNAP.Snap2D.prototype.snapPolygonToBox(points, this._boxes, this._distance, {x: shift.x, y:shift.y}, null, height);

    if (snapToLine.snap)
    {
        if (snapToBox.snap || snapToPoint.snap)
        {
            var snapData = snapToPoint;
            if (snapToBox.snap) snapData = snapToBox;

            var shpx = snapData.dx;
            var shpy = snapData.dy;
            var dotProd = shpx * Math.sin(snapToLine.angle) + shpy * Math.cos(snapToLine.angle);
            shpx = dotProd * Math.sin(snapToLine.angle);
            shpy = dotProd * Math.cos(snapToLine.angle);

            return new GEOM.Point(shift.x + snapToLine.dx + shpx, shift.y + snapToLine.dy + shpy);
        }
        else
        {
            return new GEOM.Point(shift.x + snapToLine.dx, shift.y + snapToLine.dy);
        }
    }
    else if (snapToBox.snap)
    {
        return new GEOM.Point(shift.x + snapToBox.dx, shift.y + snapToBox.dy);
    }
    else if (snapToPoint.snap)
    {
        return new GEOM.Point(shift.x + snapToPoint.dx, shift.y + snapToPoint.dy);
    }

    return new GEOM.Point(shift.x, shift.y);
};
*/

SNAP.Snap2D.prototype.snapPolygon = function(points, shift, height)
{
    var snapToLine = SNAP.Snap2D.prototype.snapPolygonToNearestLine(points, this._lines, this._distance, {x: shift.x, y: shift.y}, NaN);

    if (! snapToLine.snap)
    {
        var snapToBox = SNAP.Snap2D.prototype.snapPolygonToBox(points, this._boxes, this._distance, {x: shift.x, y:shift.y}, null, height);
        if (snapToBox.snap)
        {
            return new GEOM.Point(shift.x + snapToBox.dx, shift.y + snapToBox.dy);
        }
        else
        {
            return new GEOM.Point(shift.x, shift.y);
        }
    }

    var ang = snapToLine.angle;
    if (ang <= 0) ang += Math.PI;

    var snapPerp = SNAP.Snap2D.prototype.snapPolygonToNearestLineInOneDirection(
        points, this._lines, this._distance, {x: shift.x + snapToLine.dx, y: shift.y + snapToLine.dy}, ang);

    if (! snapPerp.snap) snapPerp = SNAP.Snap2D.prototype.snapPolygonToBox(
        points, this._boxes, this._distance, {x: shift.x + snapToLine.dx, y: shift.y + snapToLine.dy}, ang, height);

    if (! snapPerp.snap) return new GEOM.Point(shift.x + snapToLine.dx, shift.y + snapToLine.dy);

    return new GEOM.Point(shift.x + snapToLine.dx + snapPerp.dx, shift.y + snapToLine.dy + snapPerp.dy);

    /*
    var snapPerp = SNAP.Snap2D.prototype.snapPolygonToNearestLine(points, this._lines, this._distance, {x: shift.x, y: shift.y}, ang);
    //if (! snapPerp.snap) snapPerp = SNAP.Snap2D.prototype.snapPolygonToBox(points, this._boxes, this._distance, {x: shift.x, y:shift.y}, null, height);
    if (! snapPerp.snap) return new GEOM.Point(shift.x + snapToLine.dx, shift.y + snapToLine.dy);

    var shpx = snapPerp.dx;
    var shpy = snapPerp.dy;
    var dotProd = shpx * Math.sin(snapToLine.angle) + shpy * Math.cos(snapToLine.angle);
    shpx = dotProd * Math.sin(snapToLine.angle);
    shpy = dotProd * Math.cos(snapToLine.angle);

    return new GEOM.Point(shift.x + snapToLine.dx + shpx, shift.y + snapToLine.dy + shpy);
    */
};

SNAP.Snap2D.prototype.moveInFrontOfLines = function(points, dataWalls, viewPt, intPt, panAng)
{
    var viewPtPerp = TR.perpendicularPoint(viewPt, intPt, 10);
    var viewDist = TR.euclDistP(viewPt, intPt);

    var maxDist = 0;
    var pointToMove = null;
    var pointTarget = null;
    var deltaAngle = Math.PI * 0.2;

    var centerPt = new GEOM.Point(0, 0);
    for (var i = 0; i < points.length; i++)
    {
        centerPt.x += points[i].x;
        centerPt.y += points[i].y;
    }
    centerPt.x /= points.length;
    centerPt.y /= points.length;

    var camAng = (panAng + Math.PI * 100) % Math.PI;
    for (i = 0; i < points.length; i++)
    {
        var pt0 = points[i];

        for (var j = 0; j < dataWalls.length; j++)
        {
            var dw = dataWalls[j];
            if (! dw.visible) continue;

            var wallAng = (Math.atan2(dw.point2.x - dw.point1.x, dw.point2.y - dw.point1.y) + Math.PI) % Math.PI;
            if (Math.abs(wallAng - camAng) < Math.PI * 0.4) continue;

            if (Math.abs(TR.distanceBetweenPointAndLine(dw.point1, viewPt, viewPtPerp)) < viewDist + TR.B_EPS &&
                Math.abs(TR.distanceBetweenPointAndLine(dw.point2, viewPt, viewPtPerp)) < viewDist + TR.B_EPS) continue;

            var pt1 = new GEOM.Point(viewPt.x, viewPt.y);
            pt1.x = pt1.x - centerPt.x + pt0.x;
            pt1.y = pt1.y - centerPt.y + pt0.y;

            var int = TR.lineIntersectLine(pt0, pt1, dataWalls[j].point1, dataWalls[j].point2, true);
            if (! int) continue;
            var dist = TR.euclDistP(pt0, int);
            if (dist > maxDist)
            {
                maxDist = dist;
                pointToMove = pt0;
                pointTarget = int;
            }
        }
    }

    if (pointToMove) return new GEOM.Point(-pointTarget.x + pointToMove.x, -pointTarget.y + pointToMove.y);

    return new GEOM.Point(0, 0);
};

SNAP.Snap2D.prototype.findFreeSpace = function(pts)
{
    var margin = 1.5;

    var sideLines = [
        [new GEOM.Line(pts[0], new GEOM.Point(pts[0].x - (pts[3].x - pts[0].x) * 2, pts[0].y - (pts[3].y - pts[0].y) * 2)),
         new GEOM.Line(pts[1], new GEOM.Point(pts[1].x - (pts[2].x - pts[1].x) * 2, pts[1].y - (pts[2].y - pts[1].y) * 2))],

        [new GEOM.Line(pts[1], new GEOM.Point(pts[1].x - (pts[0].x - pts[1].x) * 2, pts[1].y - (pts[0].y - pts[1].y) * 2)),
         new GEOM.Line(pts[2], new GEOM.Point(pts[2].x - (pts[3].x - pts[2].x) * 2, pts[2].y - (pts[3].y - pts[2].y) * 2))],

        [new GEOM.Line(pts[2], new GEOM.Point(pts[2].x - (pts[1].x - pts[2].x) * 2, pts[2].y - (pts[1].y - pts[2].y) * 2)),
         new GEOM.Line(pts[3], new GEOM.Point(pts[3].x - (pts[0].x - pts[3].x) * 2, pts[3].y - (pts[0].y - pts[3].y) * 2))],

        [new GEOM.Line(pts[3], new GEOM.Point(pts[3].x - (pts[2].x - pts[3].x) * 2, pts[3].y - (pts[2].y - pts[3].y) * 2)),
         new GEOM.Line(pts[0], new GEOM.Point(pts[0].x - (pts[1].x - pts[0].x) * 2, pts[0].y - (pts[1].y - pts[0].y) * 2))]
    ];

    var allLines = [].concat(this._lines);
    for (var i = 0; i < this._boxes.length; i++)
    {
        var b = this._boxes[i];
        allLines = allLines.concat([new GEOM.Line(b.points[0], b.points[1]),
                                    new GEOM.Line(b.points[1], b.points[2]),
                                    new GEOM.Line(b.points[2], b.points[3]),
                                    new GEOM.Line(b.points[3], b.points[0])]);
    }

    var freeDistances = [];

    for (i = 0; i < sideLines.length; i++)
    {
        var sideLine1 = sideLines[i][0];
        var sideLine2 = sideLines[i][1];

        var minDist = TR.euclDistP(sideLine1.a, sideLine1.b);
        for (var j = 0; j < allLines.length; j++)
        {
            var line = allLines[j];
            var int1 = TR.lineIntersectLine(line.a, line.b, sideLine1.a, sideLine1.b, true, true, margin);
            var int2 = TR.lineIntersectLine(line.a, line.b, sideLine2.a, sideLine2.b, true, true, margin);
            var checkPts = [];

            if (int1 && int2)
            {
                checkPts = checkPts.concat([int1, int2]);
            }
            else if (int1)
            {
                var proj = TR.projectionPointOnLine(line.a, sideLine1.a, sideLine2.a, true);
                if (proj) checkPts = checkPts.concat([int1, line.a]);
            }
            else if (int2)
            {
                proj = TR.projectionPointOnLine(line.b, sideLine1.a, sideLine2.a, true);
                if (proj) checkPts = checkPts.concat([int2, line.b]);
            }

            for (var k = 0; k < checkPts.length; k++)
            {
                var dist = TR.distanceBetweenPointAndLine(checkPts[k], sideLine1.a, sideLine2.a);
                if (dist < minDist) minDist = dist;
            }

        }

        freeDistances.push(minDist);
    }

    return freeDistances;
};
//core
R2D = R2D || {};

R2D.extend = extend;
R2D.domParser = (() => {
    var domParser = new DOMParser();

    return html => {
        let body = domParser.parseFromString(html, 'text/html').body;
        let children = body.children;
        let removed = [];

        for ( let i = 0, l = children.length; i < l; i++ ) {
            removed.push(children[i]);
            body.removeChild(children[i]);
        }

        return removed;
    }
})();

R2D.addAsUnique = function(array, value) {
    for ( var i = 0, l = array.length; i < l; i++ ) {
        if ( array[i] == value ) return false;
    }

    array.push(value);

    return true;
};
R2D.postMessageToParent = function(string) {
    if ( window.parent == window ) return;

    window.parent.postMessage(string, '*');
};

//-
R2D.RenderUpdater = function() {
    var frames = 5;
    var frame = 0;
    var onStart = null;
    var onProgress = null;
    var onFinish = null;

    function update()
    {
        if ( frame <= 0 )
        {
            if ( onFinish ) {
                onFinish();
            }
            return;
        }

        frame -= 1;

        if (onProgress) {
            onProgress();
        }

        requestAnimationFrame(update);
    }

    this.setFrames = function(number) {
        frames = number;
    };
    this.needsUpdate = function()
    {
        if ( frame > 0 )
        {
            frame = frames;
        } else {
            frame = frames;

            if ( onStart ) {
                onStart();
            }

            update();
        }
    };
    this.onStart = function(callback) {
        onStart = callback;
    };
    this.onProgress = function(callback) {
        onProgress = callback;
    };
    this.onFinish = function(callback) {
        onFinish = callback;
    };
    this.isRunning = function()
    {
        //console.log(frame);
        return frame > 0;
    }
};

R2D.protocols = ['http://', 'https://'];
R2D.makeURL = function(domain, path) {
    for ( var i = 0, l = R2D.protocols.length; i < l; i++ ) {
        if ( path.substring(0, R2D.protocols[i].length) == R2D.protocols[i] ) {
            return path;
        }
    }

    return domain + path;
};
R2D.detectWebGL = function() {
    var canvas = document.createElement('canvas');

    if ( !canvas ) return false;

    return !!(canvas.getContext('webgl') || canvas.getContext("experimental-webgl"));
};


//console
console.printModule = function(name) {
    console.log('%c' + name, 'background: #000000; color: #ffffff; padding: 3px;');
};
console.printError = function(text) {
    console.log('%c' + text, 'background: #ffcccc; color: #CF0019; padding: 3px;');
};
console.printWarn = function(text) {
    console.log('%c' + text, 'background: #FFF992; color: #585300; padding: 3px;');
};
console.printDone = function(text) {
    console.log('%c' + text, 'background: #69FF40; color: #444444; padding: 3px;');
};
//core

R2D.DomElement = function(domElement) {
    EventDispatcher.call(this);

    var scope = this;
    var body = domElement || document.createElement('div');
    var posX = 0;
    var posY = 0;
    var width = 0;
    var height = 0;
    var children = [];
    var visible = true;

    var hintKey = null;
    var hintTimer = null;

    Object.defineProperty(scope, 'domElement', {
        get() {
            return body;
        }
    });

    scope.addChild = function(child) {
        var index = children.indexOf(child);

        if ( index >= 0 ) {
            children.splice(index, 1);
        }

        children.push(child);
        body.appendChild(child.getDomElement());

        return child;
    };
    scope.removeChild = function(child) {
        var index = children.indexOf(child);

        if ( index < 0 ) {
            throw "Error!";
        }

        children.splice(index, 1);
        body.removeChild(child.getDomElement());

        return child;
    };
    scope.getChildren = function() {
        return children;
    };
    scope.getDomElement = function() {
        return body;
    };
    scope.getX = function() {
        return posX;
    };
    scope.setX = function(value) {
        if ( value == posX ) return;
        posX = value;
        body.style.left = posX + 'px';
    };
    scope.getY = function() {
        return posY;
    };
    scope.setY = function(value) {
        if ( value == posY ) return;
        posY = value;
        body.style.top = posY + 'px';
    };
    scope.setPosition = function(x, y) {
        posX = x;
        posY = y;

        body.style.left = posX + 'px';
        body.style.top = posY + 'px';
    };
    scope.getWidth = function() {
        return width;
    };
    scope.setWidth = function(value) {
        if ( value == width ) return;
        width = value;
        body.style.width = width + 'px';
    };
    scope.getHeight = function() {
        return height;
    };
    scope.setHeight = function(value) {
        if ( value == height ) return;
        height = value;
        body.style.height = height + 'px';
    };
    scope.clearSize = function() {
        body.style.width = 'auto';
        body.style.height = 'auto';
    };
    scope.setSize = function(w, h) {
        width = w;
        height = h;

        body.style.width = width + 'px';
        body.style.height = height + 'px';
    };
    scope.getVisible = function() {
        return visible;
    };
    scope.setVisible = function(value) {
        if ( value == visible ) return;

        visible = value;
        body.style.visibility = visible ? 'visible' : 'hidden';
    };
    scope.setHint = function(key) {
        if ( hintKey != null ) {
            R2D.MouseEventController.removeListener(scope, body, R2D.MouseEventController.MOUSE_ENTER, mouseEnterForHint);
            R2D.MouseEventController.removeListener(scope, body, R2D.MouseEventController.MOUSE_LEAVE, mouseLeaveForHint);
            R2D.MouseEventController.removeListener(scope, body, R2D.MouseEventController.LEFT_MOUSE_DOWN, mouseDownForHint);
            R2D.MouseEventController.removeListener(scope, body, R2D.MouseEventController.RIGHT_MOUSE_DOWN, mouseDownForHint);
        }

        hintKey = key;

        if ( hintKey != null ) {
            R2D.MouseEventController.addListener(scope, body, R2D.MouseEventController.MOUSE_ENTER, mouseEnterForHint);
            R2D.MouseEventController.addListener(scope, body, R2D.MouseEventController.MOUSE_LEAVE, mouseLeaveForHint);
            R2D.MouseEventController.addListener(scope, body, R2D.MouseEventController.LEFT_MOUSE_DOWN, mouseDownForHint);
            R2D.MouseEventController.addListener(scope, body, R2D.MouseEventController.RIGHT_MOUSE_DOWN, mouseDownForHint);
        }
    };
};

R2D.extend(R2D.DomElement, EventDispatcher);

R2D.DomElement.prototype.inDOM = function() {
    function inDom(node) {
        if ( node.tagName == 'HTML' ) {
            return true;
        } else if ( node.parentNode ) {
            return inDom(node.parentNode);
        } else {
            return false;
        }
    }

    return inDom(this.getDomElement());
};

R2D.DomElement.makeDomElement = function(elementName, className) {
    var element = document.createElement(elementName);

    if ( className ) element.setAttribute('class', className);

    return element;
};

R2D.DomElement.makeSpan = function(className) {
    return R2D.DomElement.makeDomElement('span', className);
};
R2D.DomElement.makeBR = function(className) {
    return R2D.DomElement.makeDomElement('br', className);
};
R2D.DomElement.makeDiv = function(className) {
    return R2D.DomElement.makeDomElement('div', className);
};
R2D.DomElement.makeImage = function(src, className) {
    var img = R2D.DomElement.makeDomElement('img', className);

    if ( src ) img.setAttribute('src', src);

    return img;
};
// ui

R2D.MaterialDragPreview = function() {
    R2D.DomElement.call(this);

    var scope = this;
    var body = scope.getDomElement();
    var preview = null;
    var superSetPosition = scope.setPosition;
    var sizePreview = 28;
    let image = null;
    let overlayer = document.createElement('div');
    overlayer.setAttribute('class', 'product-preview-overlayer');

    Object.defineProperties(scope, {
        "productId":{
            get() { return preview ? preview.productId : null; }
        }
    });

    scope.updatePreview = async function(productId, color) {
        if ( image ) {
            if(body.contains(image)) body.removeChild(image);
            if(body.contains(overlayer)) body.removeChild(overlayer);
            image = null;
        }

        //preview = new R2D.ProductPreview(productId);
        //preview.load();

        //preview.setSize(sizePreview, sizePreview);
        //body.appendChild(preview.getDomElement());

        var productsDataLoader;
        var productData = R2D.Pool.getProductData(productId);

        if (~productId.indexOf('#')) {
            createIfColor();
        } else {
            if (productData) {
                if(color) {
                    
                    let canvas = await R2D.Tool.getMatPrevFromMatIdAndColor(productId, color);
                    image = document.createElement('img');
                    image.src = canvas.toDataURL();
                    document.getElementsByTagName("body")[0].append(image);
                    body.appendChild(image);
                    body.appendChild(overlayer);
                } else processProductData(productData);
            }
            else {
                productsDataLoader = new R2D.ProductsDataLoader();
                productsDataLoader.addEventListener(Event.COMPLETE, productsDataLoaderEventHandler);
                productsDataLoader.load([productId]);
            }
        }
        
        function productsDataLoaderEventHandler(event) {
            if ( event.type == Event.COMPLETE )
            {
                productsDataLoader.removeEventListener(Event.COMPLETE, productsDataLoaderEventHandler);
                productsDataLoader.dispose();
                productsDataLoader = null;

                productData = R2D.Pool.getProductData(productId);
                processProductData(productData);
            }
        }

        var imageUrlLoader;
        
        function processProductData(data)
        {
            imageUrlLoader = new R2D.ImageUrlLoader();

            imageUrlLoader.addEventListener(Event.COMPLETE, imageUrlLoaderEventHandler);
            imageUrlLoader.addEventListener(Event.ERROR, imageUrlLoaderEventHandler);
            imageUrlLoader.load(R2D.makeURL(R2D.URL.DOMAIN, data['source']['images']['preview']));
        }

        function imageUrlLoaderEventHandler()
        {
            image = document.createElement('img');
            //image.addEventListener('load', imageEventHandler);
            //image.addEventListener('error', imageEventHandler);
            image.src = imageUrlLoader.getImage().src;
            body.appendChild(image);
            body.appendChild(overlayer);

            imageUrlLoader.removeEventListener(Event.COMPLETE, imageUrlLoaderEventHandler);
            imageUrlLoader.removeEventListener(Event.ERROR, imageUrlLoaderEventHandler);
            imageUrlLoader.close();
            imageUrlLoader = null;
        }


        function createIfColor()
        {
            
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            let imageWidth = 240;
            let imageHeight = 240;

            canvas.width = imageWidth;
            canvas.height = imageHeight;
            context.fillStyle = productId;
            context.fillRect(0, 0, canvas.width, canvas.height);

            image = document.createElement('img');
            image.addEventListener('load', colorImageListener);
            image.src = canvas.toDataURL('image/png');
        }

        function colorImageListener()
        {
            image.className = 'product-preview-image';
            image.removeEventListener('load', colorImageListener);

            //reposition();

            body.appendChild(image);
            body.appendChild(overlayer);

            //scope.dispatchEvent(new Event(Event.COMPLETE, scope));

            // if ( shadow ) {
            //     makeImageWidthShadow();
            // }
        }


    };



    scope.getProductId = function() {
        if ( !preview ) return null;

        return preview.getProductId();
    };
    scope.setPosition = function(x, y) {
        superSetPosition(x - sizePreview / 2, y - sizePreview - 2)
    };

    body.style['position'] = 'absolute';
    body.style['display'] = 'inline-block';
    body.style['border-radius'] = '5px';
    body.style['background-color'] = '#e9e9e9';
    body.style['box-shadow'] = '1px 1px 2px #9a9a9a';
    body.style['overflow'] = 'hidden';
    body.style['width'] = '28px';
    body.style['height'] = '28px';
    body.style['-webkit-user-select'] = 'none';
    body.style['-ms-user-select'] = 'none';
    body.style['-moz-user-select'] = 'none';
};

R2D.extend(R2D.MaterialDragPreview, R2D.DomElement);
R2D.RenderFrame = function() {
    R2D.DomElement.call(this, R2D.RenderFrame.HTML.frame());

    var scope = this;
    var superSetSize = scope.setSize;
    var width = 800;
    var height = 600;
    var borderX = 50;
    var borderY = 50;
    var ratioWidth = 16;
    var ratioHeight = 9;
    var frameWidth = 0;
    var frameHeight = 0;
    var body = scope.getDomElement();
    var left = body.querySelector('div.render-frame-strip[data-type="l"]');
    var top = body.querySelector('div.render-frame-strip[data-type="t"]');
    var right = body.querySelector('div.render-frame-strip[data-type="r"]');
    var bottom = body.querySelector('div.render-frame-strip[data-type="b"]');

    function resize() {
        let currentSizeWidth = width - borderX * 2;
        let currentSizeHeight = height - borderY * 2;
        let ratio = currentSizeWidth / ratioWidth;

        if ( ratioHeight * ratio > currentSizeHeight ) {
            ratio = currentSizeHeight / ratioHeight;
        }

        let frWidth = (ratioWidth  * ratio);
        let frHeight = ratioHeight * ratio;
        let restWidth = width - frWidth;
        let restHeight = height - frHeight;

        left.style.width = `${restWidth / 2}px`;
        left.style.height = `${height}px`;

        top.style.left = `${restWidth / 2}px`;
        top.style.width = `${frWidth}px`;
        top.style.height = `${restHeight / 2}px`;

        right.style.left = `${width - (restWidth / 2)}px`;
        right.style.width = `${(restWidth / 2)}px`;
        right.style.height = `${height}px`;

        bottom.style.left = `${restWidth / 2}px`;
        bottom.style.top = `${height - restHeight / 2}px`;
        bottom.style.width = `${frWidth}px`;
        bottom.style.height = `${restHeight / 2}px`;

        frameWidth = frWidth;
        frameHeight = frHeight;

        // superSetSize(width, height);
    }

    scope.setSize = function (w, h) {
        width = w;
        height = h;

        resize();
    };
    scope.getData = function () {
        return {
            screenWidth:width,
            screenHeight:height,
            frameWidth:frameWidth,
            frameHeight:frameHeight,
            ratioWidth:ratioWidth,
            ratioHeight:ratioHeight
        }
    };
};

R2D.extend(R2D.RenderFrame, R2D.DomElement);

R2D.RenderFrame.HTML = {
    frame() {
        var html =
            `<div class="render-frame">
                <div data-type="l" class="render-frame-strip"></div>
                <div data-type="t" class="render-frame-strip"></div>
                <div data-type="r" class="render-frame-strip"></div>
                <div data-type="b" class="render-frame-strip"></div>
            </div>`;

        return R2D.domParser(html)[0];
    }
};
// core

R2D.ErrorReporting = function() {
    //-
};

R2D.ErrorReporting._send = function(string) {
    console.warn("Needs send!");
    console.log(string);
};
R2D.ErrorReporting.report = function(message) {
    var string = "";
    var date = new Date();

    string += date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate() + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds() + "\r\n";
    string += "User id: " + R2D.User.getId() + "\r\n";
    string += "User key: " + R2D.User.getKey() + "\r\n";
    string += "Project id: " + R2D.controller.getProjectId() + "\r\n";
    string += "Project key: " + R2D.controller.getProjectUserKey() + "\r\n";

    string += message;

    R2D.ErrorReporting._send(string);
};
R2D.ErrorReporting.errorReport = function(error) {
    R2D.ErrorReporting.report(error.stack);
};
// core

R2D.DimensionSystem = function() {
    throw "Use static methods!";
};

R2D.DimensionSystem.METRIC_CM = 0;
R2D.DimensionSystem.IMPERIAL_FT = 1;
R2D.DimensionSystem.METRIC_MM = 2;
R2D.DimensionSystem.METRIC_M = 3;

R2D.DimensionSystem._eventDispatcher = new EventDispatcher();
R2D.DimensionSystem._currentSystem = null;
R2D.DimensionSystem._currentSystemInterface = null;

R2D.DimensionSystem.getSystem = function() {
    return R2D.DimensionSystem._currentSystem;
};
R2D.DimensionSystem.setSystem = function(system) {
    if ( R2D.DimensionSystem._currentSystem == system ) return;

    switch ( system ) {
        case R2D.DimensionSystem.METRIC_CM:
            R2D.DimensionSystem._currentSystem = R2D.DimensionSystem.METRIC_CM;
            R2D.DimensionSystem._currentSystemInterface = R2D.DimensionSystem.MetricCM;
            break;

        case R2D.DimensionSystem.IMPERIAL_FT:
            R2D.DimensionSystem._currentSystem = R2D.DimensionSystem.IMPERIAL_FT;
            R2D.DimensionSystem._currentSystemInterface = R2D.DimensionSystem.ImperialFT;
            break;

        case R2D.DimensionSystem.METRIC_M:
            R2D.DimensionSystem._currentSystem = R2D.DimensionSystem.METRIC_M;
            R2D.DimensionSystem._currentSystemInterface = R2D.DimensionSystem.MetricM;
            break;

        case R2D.DimensionSystem.METRIC_MM:
            R2D.DimensionSystem._currentSystem = R2D.DimensionSystem.METRIC_MM;
            R2D.DimensionSystem._currentSystemInterface = R2D.DimensionSystem.MetricMM;
            break;

        default:
            throw "Unknown dimension system!";
    }

    R2D.DimensionSystem._eventDispatcher.dispatchEvent(new Event(Event.CHANGE, null));
};
R2D.DimensionSystem.addEventListener = function(type, listener) {
    R2D.DimensionSystem._eventDispatcher.addEventListener(type, listener);
};
R2D.DimensionSystem.removeEventListener = function(type, listener) {
    R2D.DimensionSystem._eventDispatcher.removeEventListener(type, listener);
};
R2D.DimensionSystem.getName = function() {
    return R2D.DimensionSystem._currentSystemInterface._name;
};
R2D.DimensionSystem.getStep = function() {
    return R2D.DimensionSystem._currentSystemInterface._step;
};
R2D.DimensionSystem.isMetric = function() {
    return R2D.DimensionSystem._currentSystemInterface._isMetric;
};
R2D.DimensionSystem.fromString = function(string) {
    return R2D.DimensionSystem._currentSystemInterface.fromString(string);
};
R2D.DimensionSystem.toString = function(value) {
    return R2D.DimensionSystem._currentSystemInterface.toString(value);
};
R2D.DimensionSystem.squareToString = function(value) {
    return R2D.DimensionSystem._currentSystemInterface.squareToString(value);
};
R2D.DimensionSystem.squareFromString = function(value) {
    return R2D.DimensionSystem._currentSystemInterface.squareFromString(value);
};
// core

R2D.DimensionSystem.MetricCM = function() {
    throw "Use static methods!";
};

R2D.DimensionSystem.MetricCM._name = R2D.TRANSLATION ? R2D.TRANSLATION.TEXT_DIMENSION_SYSTEM_NAME_METRIC : 'cm';
R2D.DimensionSystem.MetricCM._isMetric = true;
R2D.DimensionSystem.MetricCM._step = 1;

R2D.DimensionSystem.MetricCM.fromString = function(string) {
    //if ( String(string) == '0' ) return 0;
    //if ( String(string).match(/[^0-9\-]/g) ) return NaN;
    if(string && string.replaceAll) string = string.replaceAll(",", '.');
    return parseFloat(string);
};
R2D.DimensionSystem.MetricCM.toString = function(value) {
    var str = String(Number(parseFloat(value)).toFixed(1));
    if (str[str.length - 1] == '0') str = str.slice(0, str.length - 1);
    if (str[str.length - 1] == '.') str = str.slice(0, str.length - 1);
    return str;
};
R2D.DimensionSystem.MetricCM.squareToString = function(value) {
    return Number(Math.pow(Math.sqrt(parseFloat(value)) / 100, 2)).toFixed(2) + " m";
};
R2D.DimensionSystem.MetricCM.squareFromString = function(value) {
    return Math.round(parseFloat(value) * 10000);
};
// core

R2D.DimensionSystem.MetricM = function() {
    throw "Use static methods!";
};

R2D.DimensionSystem.MetricM._name = R2D.TRANSLATION ? R2D.TRANSLATION.TEXT_DIMENSION_SYSTEM_NAME_METRIC_METER : 'm';
if (! R2D.DimensionSystem.MetricM._name) R2D.DimensionSystem.MetricM._name = 'm';
R2D.DimensionSystem.MetricM._isMetric = true;
R2D.DimensionSystem.MetricM._step = 1;

R2D.DimensionSystem.MetricM.fromString = function(string) {
    //if ( String(string) == '0' ) return 0;
    //if ( String(string).match(/[^0-9\-]/g) ) return NaN;

    if(string && string.replaceAll) string = string.replaceAll(",", '.');
    return parseFloat(string) * 100;
};
R2D.DimensionSystem.MetricM.toString = function(value) {
    var str = String(Number(parseFloat(value) / 100).toFixed(3));
    if (str[str.length - 1] == '0') str = str.slice(0, str.length - 1);
    if (str[str.length - 1] == '0') str = str.slice(0, str.length - 1);
    if (str[str.length - 1] == '0') str = str.slice(0, str.length - 1);
    if (str[str.length - 1] == '.') str = str.slice(0, str.length - 1);
    return str;
};
R2D.DimensionSystem.MetricM.squareToString = function(value) {
    return Number(parseFloat(value) / 10000).toFixed(2) + " m";
};

R2D.DimensionSystem.MetricM.squareFromString = function(value) {
    return Math.round(parseFloat(value) * 10000);
};
// core

R2D.DimensionSystem.MetricMM = function() {
    throw "Use static methods!";
};

R2D.DimensionSystem.MetricMM._name = R2D.TRANSLATION ? R2D.TRANSLATION.TEXT_DIMENSION_SYSTEM_NAME_METRIC_MILIMETER : 'mm';
if (! R2D.DimensionSystem.MetricMM._name) R2D.DimensionSystem.MetricMM._name = 'mm';
R2D.DimensionSystem.MetricMM._isMetric = true;
R2D.DimensionSystem.MetricMM._step = 0.1;

R2D.DimensionSystem.MetricMM.fromString = function(string) {
    //if ( String(string) == '0' ) return 0;
    //if ( String(string).match(/[^0-9\-]/g) ) return NaN;

    if(string && string.replaceAll) string = string.replaceAll(",", '.');
    return parseFloat(string) / 10;
};
R2D.DimensionSystem.MetricMM.toString = function(value) {
    return String(Math.round(parseFloat(value) * 10));
};
R2D.DimensionSystem.MetricMM.squareToString = function(value) {
    return Number(parseFloat(value) / 10000).toFixed(2) + " m";
};

R2D.DimensionSystem.MetricMM.squareFromString = function(value) {
    return Math.round(parseFloat(value) * 10000);
};
// core

R2D.DimensionSystem.ImperialFT = function() {
    throw "Use static methods!";
};

R2D.DimensionSystem.ImperialFT._name = R2D.TRANSLATION ? R2D.TRANSLATION.TEXT_DIMENSION_SYSTEM_NAME_IMPERIAL : 'ft';
R2D.DimensionSystem.ImperialFT._isMetric = false;
R2D.DimensionSystem.ImperialFT._step = 1.27;

// R2D.DimensionSystem.ImperialFT._approximate = 0.5;
R2D.DimensionSystem.ImperialFT._approximate = 0.0625; // 1/16

R2D.DimensionSystem.ImperialFT._SYMBOL_FT = '\'';//'';
R2D.DimensionSystem.ImperialFT._SYMBOL_IN = '"';//'';

R2D.DimensionSystem.ImperialFT._FOOT_TO_M = 0.3048;
R2D.DimensionSystem.ImperialFT._FOOT_TO_CM = 30.48;
R2D.DimensionSystem.ImperialFT._INCH_TO_CM = 2.54;
R2D.DimensionSystem.ImperialFT._SQ_FOOT_TO_M = 0.0929;

// R2D.DimensionSystem.ImperialFT._REG_EXP_TEST = /[! 0-9\/]/;
// R2D.DimensionSystem.ImperialFT._REG_EXP_FT_IN_FR = /^\d+' ?\d+ \d+\/\d+"$/;
// R2D.DimensionSystem.ImperialFT._REG_EXP_FT_IN = /^\d+' ?\d+"$/;
// R2D.DimensionSystem.ImperialFT._REG_EXP_FT = /^\d+'$/;
// R2D.DimensionSystem.ImperialFT._REG_EXP_IN = /^\d+"$/;

R2D.DimensionSystem.ImperialFT._REG_EXP_FT = /^\d+\'$/;
R2D.DimensionSystem.ImperialFT._REG_EXP_IN = /^\d+((\'{2})|(\"))$/;
R2D.DimensionSystem.ImperialFT._REG_EXP_NUM = /^\d+$/;
R2D.DimensionSystem.ImperialFT._REG_EXP_FRAC = /^\d+\/\d+((\'{2})|(\"))$/;

R2D.DimensionSystem.ImperialFT._getDecimalLength = function(value) {
    var len = 0;

    value = value || 0;

    for ( ; ; ) {
        if ( value - Math.floor(value) == 0 ) return len;

        value *= 10;
        len += 1;
    }
};
R2D.DimensionSystem.ImperialFT._getGCD = function(m, n) {
    if ( m == n ) return m;
    if ( m == 0 ) return n;
    if ( n == 0 ) return m;
    if ( m == 1 || n == 1 ) return 1;
    if ( m % 2 == 0 && n % 2 == 0 ) return 2 * R2D.DimensionSystem.ImperialFT._getGCD(m / 2, n / 2);
    if ( m % 2 == 0 ) return R2D.DimensionSystem.ImperialFT._getGCD(m / 2, n);
    if ( n % 2 == 0 ) return R2D.DimensionSystem.ImperialFT._getGCD(m, n / 2);
    if ( m < n ) return R2D.DimensionSystem.ImperialFT._getGCD((n - m) / 2, m);
    else return R2D.DimensionSystem.ImperialFT._getGCD((m - n) / 2, n);
};
R2D.DimensionSystem.ImperialFT._getFractionString = function(value) {
    var decimalLen = R2D.DimensionSystem.ImperialFT._getDecimalLength(value);
    var denominator = Math.pow(10, decimalLen);
    var numerator = value * denominator;
    var divisor = R2D.DimensionSystem.ImperialFT._getGCD(numerator, denominator);

    numerator = numerator / divisor;
    denominator = denominator / divisor;

    return numerator.toString() + '/' + denominator.toString();
};
R2D.DimensionSystem.ImperialFT._normalizeString = function(string) {
    if(!string || typeof string.replace !== "function") return;
    string = string.replace(/^ +/, '');
    string = string.replace(/ +$/, '');
    string = string.replace(/ +/g, ' ');
    string = string.replace(//g, '\'');
    string = string.replace(/''||/g, '"');

    return string;
};
R2D.DimensionSystem.ImperialFT._parseFraction = function(string) {
    var elements = string.split('/');

    return parseInt(elements[0]) / parseInt(elements[1]);
};
R2D.DimensionSystem.ImperialFT._parseFtInFr = function(string) {
    var clear = string.replace(/\'\d+/,'\' ').replace(/\'|"/g, '');
    var elements = clear.split(' ');
    var feet = parseInt(elements[0]) * R2D.DimensionSystem.ImperialFT._FOOT_TO_CM;
    var inches = parseInt(elements[1]) * R2D.DimensionSystem.ImperialFT._INCH_TO_CM;
    var fraction = R2D.DimensionSystem.ImperialFT._parseFraction(elements[2]) * R2D.DimensionSystem.ImperialFT._INCH_TO_CM;

    return feet + inches + fraction;
};
R2D.DimensionSystem.ImperialFT._parseFtIn = function(string) {
    var clear = string.replace(/\'\d+/,'\' ').replace(/\'|"/g, '');
    var elements = clear.split(' ');
    var feet = parseInt(elements[0]) * R2D.DimensionSystem.ImperialFT._FOOT_TO_CM;
    var inches = parseInt(elements[1]) * R2D.DimensionSystem.ImperialFT._INCH_TO_CM;

    return feet + inches;
};
R2D.DimensionSystem.ImperialFT._parseFt = function(string) {
    var clear = string.replace(/\'|"/g, '');
    var feet = parseInt(clear) * R2D.DimensionSystem.ImperialFT._FOOT_TO_CM;

    return feet;
};
R2D.DimensionSystem.ImperialFT._parseIn = function(string) {
    var clear = string.replace(/\'|"/g, '');
    var inches = parseInt(clear) * R2D.DimensionSystem.ImperialFT._INCH_TO_CM;

    return inches;
};
R2D.DimensionSystem.ImperialFT._parseImperial = function (string) {
    if (!string) return NaN;

    let feet = 0;
    let inches = 0;
    let fraction = 0;

    const elements = string.split(" ");

    elements.forEach((el) => {
        if (R2D.DimensionSystem.ImperialFT._REG_EXP_FT.test(el)) {
            feet = parseInt(el) * R2D.DimensionSystem.ImperialFT._FOOT_TO_CM;
        } else if (
            R2D.DimensionSystem.ImperialFT._REG_EXP_IN.test(el) ||
            R2D.DimensionSystem.ImperialFT._REG_EXP_NUM.test(el)
        ) {
            inches = parseInt(el) * R2D.DimensionSystem.ImperialFT._INCH_TO_CM;
        } else if (R2D.DimensionSystem.ImperialFT._REG_EXP_FRAC.test(el)) {
            fraction =
                R2D.DimensionSystem.ImperialFT._parseFraction(el) *
                R2D.DimensionSystem.ImperialFT._INCH_TO_CM;
        }
    });

    return feet + inches + fraction;
};
R2D.DimensionSystem.ImperialFT.fromString = function(string) {
    string = R2D.DimensionSystem.ImperialFT._normalizeString(string);
    return R2D.DimensionSystem.ImperialFT._parseImperial(string);

    // console.log("string, ", string);

    // if ( R2D.DimensionSystem.ImperialFT._REG_EXP_FT_IN_FR.test(string) ) {
    //     return R2D.DimensionSystem.ImperialFT._parseFtInFr(string);
    // }
    // if ( R2D.DimensionSystem.ImperialFT._REG_EXP_FT_IN.test(string) ) {
    //     return R2D.DimensionSystem.ImperialFT._parseFtIn(string);
    // }
    // if ( R2D.DimensionSystem.ImperialFT._REG_EXP_FT.test(string) ||  /^\d+' \d+\/\d+"$/.test(string)) {
    //     return R2D.DimensionSystem.ImperialFT._parseFt(string);
    // }
    // if ( R2D.DimensionSystem.ImperialFT._REG_EXP_IN.test(string) ) {
    //     return R2D.DimensionSystem.ImperialFT._parseIn(string);
    // }

    // return NaN;
};
R2D.DimensionSystem.ImperialFT.toString = function(value) {
    var sFT = R2D.DimensionSystem.ImperialFT._SYMBOL_FT;
    var sIN = R2D.DimensionSystem.ImperialFT._SYMBOL_IN;
    var feet = Math.floor(value / R2D.DimensionSystem.ImperialFT._FOOT_TO_CM);
    var inches = Math.floor((value - feet * R2D.DimensionSystem.ImperialFT._FOOT_TO_CM) / R2D.DimensionSystem.ImperialFT._INCH_TO_CM);
    var fraction = (value - ((feet * R2D.DimensionSystem.ImperialFT._FOOT_TO_CM) + (inches * R2D.DimensionSystem.ImperialFT._INCH_TO_CM))) / R2D.DimensionSystem.ImperialFT._INCH_TO_CM;

    fraction -= fraction - Math.round(fraction / R2D.DimensionSystem.ImperialFT._approximate) * R2D.DimensionSystem.ImperialFT._approximate;

    if ( 1 - fraction < 0.001 ) {
        fraction = 0;
        inches += 1;

        feet += Math.floor(inches / 12);
        inches = inches % 12;
    }

    if ( feet == 0 && inches == 0 && fraction == 0 ) { //0 0 0
        return '0' + sFT;
    }

    if ( feet == 0 ) {
        if ( inches == 0 ) {
            return R2D.DimensionSystem.ImperialFT._getFractionString(fraction) + sIN; // 0 0 1
        }
        if ( fraction == 0 ) {
            return inches + sIN; // 0 1 0
        }

        return inches + ' ' + R2D.DimensionSystem.ImperialFT._getFractionString(fraction) + sIN; // 0 1 1
    } else {
        if ( inches == 0 && fraction == 0 ) {
            return feet + sFT; // 1 0 0
        }
        if ( inches == 0 ) {
            return feet + sFT + ' ' + R2D.DimensionSystem.ImperialFT._getFractionString(fraction) + sIN; // 1 0 1
        }
        if ( fraction == 0 ) {
            return feet + sFT + ' ' + inches + sIN; // 1 1 0
        }

        return feet + sFT + ' ' + inches + ' ' + R2D.DimensionSystem.ImperialFT._getFractionString(fraction) + sIN; // 1 1 1
    }
};
R2D.DimensionSystem.ImperialFT.squareToString = function(value) {
    return  Number(value / 10000 / R2D.DimensionSystem.ImperialFT._SQ_FOOT_TO_M).toFixed(2) + " sq. ft.";
};
R2D.DimensionSystem.ImperialFT.squareFromString = function(value) {
    return parseFloat(value) * 10000 * R2D.DimensionSystem.ImperialFT._SQ_FOOT_TO_M;
};
//core

R2D.SceneObject = function(data) {
    EventDispatcher.call(this);

    R2D.SceneObject.__counter += 1;

    var scope = this;
    var _objectId = R2D.SceneObject.__counter;
    var _type = data.type;
    var _target = data.target;
    var _objectData = data;
    var _defaultWidth = data.property.sizes.width;
    var _defaultHeight = data.property.sizes.height;
    var _defaultDepth = data.property.sizes.depth;

    // scope.x = data.property.position.x;
    // scope.y = data.property.position.y;
    // scope.z = data.property.position.z;
    scope.x = 3000;
    scope.y = data.property.position.y;
    scope.z = 3000;
    scope.rotationX = 0;
    scope.rotationY = 0;
    scope.rotationZ = 0;
    scope.scaleX = 1;
    scope.scaleY = 1;
    scope.scaleZ = 1;
    scope.flipX = false;
    scope.flipY = false;
    scope.flipZ = false;

    scope.isAddScaleChanged = false;
    scope.isLoaded = false;
    scope.isFirstLoading = true;
    scope.scaleDir = "All";

    scope.isLockedOnScene = false;

    scope.configurationAppId = data.configurationAppId;
    scope.configAppFileRaw = data.configAppFile;
    scope.configAppFile = R2D.makeURL(R2D.URL.DOMAIN, data.configAppFile);
    scope.originalEntityId = data.originalEntityId;
    scope.isOriginalModel = data.isOriginalModel;

    function checkValues() {
        if ( scope.x < R2D.SceneObject.OBJECT_X_MIN ) {
            scope.x = R2D.SceneObject.OBJECT_X_MIN;
        } else if ( scope.x > R2D.SceneObject.OBJECT_X_MAX ) {
            scope.x = R2D.SceneObject.OBJECT_X_MAX;
        }
        if ( scope.y < R2D.SceneObject.OBJECT_Y_MIN ) {
            scope.y = R2D.SceneObject.OBJECT_Y_MIN;
        } else if ( scope.y > R2D.SceneObject.OBJECT_Y_MAX ) {
            scope.y = R2D.SceneObject.OBJECT_Y_MAX;
        }
        if ( scope.z < R2D.SceneObject.OBJECT_Z_MIN ) {
            scope.z = R2D.SceneObject.OBJECT_Z_MIN;
        } else if ( scope.z > R2D.SceneObject.OBJECT_Z_MAX ) {
            scope.z = R2D.SceneObject.OBJECT_Z_MAX;
        }

        scope.scaleX = R2D.SceneObject.__getCorrectScale(scope.scaleX, _defaultWidth);
        scope.scaleY = R2D.SceneObject.__getCorrectScale(scope.scaleY, _defaultHeight);
        scope.scaleZ = R2D.SceneObject.__getCorrectScale(scope.scaleZ, _defaultDepth);
    }

    Object.defineProperties(scope, {
        "objectId":{
            get() { return _objectId }
        },
        "productId":{
            get() { return _objectData.productId; }
        },
        "objectData":{
            get() { return _objectData }
        },
        "type":{
            get() { return _type }
        },
        "userKey":{
            get() { return _objectData.user_key }
        },
        "target":{
            get() { return _target }
        },
        "defaultWidth":{
            get() { return _defaultWidth; }
        },
        "defaultHeight":{
            get() { return _defaultHeight; }
        },
        "defaultDepth":{
            get() { return _defaultDepth; }
        },
        "width":{
            get() { return _defaultWidth * scope.scaleX; },
            set(value) { scope.scaleX = value / _defaultWidth; }
        },
        "height":{
            get() { return _defaultHeight * scope.scaleY; },
            set(value) { scope.scaleY = value / _defaultHeight; }
        },
        "depth":{
            get() { return _defaultDepth * scope.scaleZ },
            set(value) { scope.scaleZ = value / _defaultDepth; }
        },
        "volume":{
            get() { return scope.width * scope.height * scope.depth; },
            set(value) {
                console.warn("SceneObject.volume.set(): TODO");
            }
        }
    });

    scope.getObjectId = function() { return scope.objectId; };
    scope.getProductId = function() { return _objectData.productId };
    scope.getType = function() { return scope.type };
    scope.getObjectData = function() { return _objectData };
    scope.getName = function() { return _objectData['name'] };
    scope.getIsFixedSizeEnabled = function() { return _objectData['fixed_size'] };
    scope.getDefaultWidth = function() { return _defaultWidth };
    scope.getDefaultHeight = function() { return _defaultHeight };
    scope.getDefaultDepth = function() { return _defaultDepth };
    scope.getWidth = function() { return scope.width };
    scope.getHeight = function() { return scope.height };
    scope.getDepth = function() {
        return scope.depth
    };

    scope.setIsLockedOnScene = status => scope.isLockedOnScene = status;

    scope.historyUpdate = function() {
        scope.dispatchEvent(new Event(R2D.SceneObject.HISTORY_UPDATE, scope));
    };

    scope.setWidth = function (value, keepRatio) {
        scope.isAddScaleChanged = true;
        if (keepRatio) {
            scope.scaleDir = "All";
        } else {
            scope.scaleDir = "X";
        }
        scope.scaleX = value / _defaultWidth;
    };
    scope.setHeight = function (value, keepRatio) {
        scope.isAddScaleChanged = true;
        if (keepRatio) {
            scope.scaleDir = "All";
        } else {
            scope.scaleDir = "Y";
        }
        scope.scaleY = value / _defaultHeight;
    };
    scope.setDepth = function (value, keepRatio) {
        scope.isAddScaleChanged = true;
        if (keepRatio) {
            scope.scaleDir = "All";
        } else {
            scope.scaleDir = "Z";
        }
        scope.scaleZ = value / _defaultDepth;
    };

    scope.setSize = function (width, height, depth) {
        scope.isAddScaleChanged = true;
        scope.scaleDir = "All";

        scope.scaleX = width / _defaultWidth;
        scope.scaleY = height / _defaultHeight;
        scope.scaleZ = depth / _defaultDepth;
    };
    scope.update = function() {
        checkValues();
        scope.dispatchEvent(new Event(Event.UPDATE, scope));
    };
    scope.clone = function() {
        throw "TODO";
    }
};

R2D.extend(R2D.SceneObject, EventDispatcher);

R2D.SceneObject.HISTORY_UPDATE = 'historyUpdate';
R2D.SceneObject.OBJECT_SIZE_MIN = 1;
R2D.SceneObject.OBJECT_SIZE_MAX = 1000;
R2D.SceneObject.OBJECT_X_MIN = -Infinity;
R2D.SceneObject.OBJECT_X_MAX = Infinity;
R2D.SceneObject.OBJECT_Y_MIN = 0;
R2D.SceneObject.OBJECT_Y_MAX = 400;
R2D.SceneObject.OBJECT_Z_MIN = -Infinity;
R2D.SceneObject.OBJECT_Z_MAX = Infinity;

R2D.SceneObject.APPOINTMENT_SCENE = "scene";
R2D.SceneObject.APPOINTMENT_WALL = "wall";

R2D.SceneObject.__counter = 0;

R2D.SceneObject.__getCorrectScale = function(scale, size) {
    if ( scale * size < R2D.SceneObject.OBJECT_SIZE_MIN ) {
        return R2D.SceneObject.OBJECT_SIZE_MIN / size;
    }
    if ( scale * size > R2D.SceneObject.OBJECT_SIZE_MAX ) {
        return R2D.SceneObject.OBJECT_SIZE_MAX / size;
    }

    return scale;
};

R2D.SceneObject.prototype.get2DRectPoints = function() {
    var w2 = this.getWidth() / 2;
    var d2 = this.getDepth() / 2;

    return [
        new GEOM.Point(-w2, -d2),
        new GEOM.Point( w2, -d2),
        new GEOM.Point( w2,  d2),
        new GEOM.Point(-w2,  d2)
    ];
};

R2D.SceneObject.get2DBounds = function(sceneObject) {
    if(!sceneObject) return;
    var rectPoints = sceneObject.get2DRectPoints && sceneObject.get2DRectPoints();
    var rotation = -GEOM.toRad(sceneObject.rotationY);
    var minX =  Infinity;
    var maxX = -Infinity;
    var minY =  Infinity;
    var maxY = -Infinity;
    
    for ( var i = 0, l = rectPoints.length; i < l; i++ ) {
        var p = rectPoints[i];

        p = GEOM.rotatePosition(p.x, p.y, rotation);

        p.x += sceneObject.x;
        p.y += sceneObject.z;

        if ( p.x > maxX ) maxX = p.x;
        else if ( p.x < minX ) minX = p.x;

        if ( p.y > maxY ) maxY = p.y;
        else if ( p.y < minY ) minY = p.y;
    }
    
    return new GEOM.Bounds(minX, minY, maxX, maxY);
};
// core

R2D.SceneObjectMaterial = function(productData, color) {
    EventDispatcher.call(this);

    var scope = this;
    var objectId = R2D.SceneObject.__counter;

    Object.defineProperties(scope, {
        "objectId":{
            get() { return objectId; }
        },
        "type":{
            get() { return productData.type; }
        },
        "productId":{
            get() { return productData.productId; }
        },
        "productMaterialColor":{
            get() { return color }
        },
        "productData":{
            get() { return productData; }
        }
    });

    this.getObjectId = function() { return objectId };
    this.getProductId = function() { return productData.productId };
    this.getProductMaterialColor = function() { return color };
    this.getType = function() { return productData.type };
    this.getObjectData = function() { return productData };
};

R2D.extend(R2D.SceneObjectMaterial, EventDispatcher);
// core

R2D.SceneObjectModel = function(productData) {
    R2D.SceneObject.call(this, productData);

    var scope = this;
    var materialsObjects = [];
    var materialFrame = 0;
    var addMaterialFrame = 0;
    var materialFrameRotation = 0;
    var materialFrameX = 0;
    var materialFrameY = 0;
    var materialBottom = 0;
    var addMaterialBottom = 0;
    var materialBottomRotation = 0;
    var materialBottomX = 0;
    var materialBottomY = 0;

    productData.isGLTF = productData.source.body.package.endsWith('.glb');
    scope.isGLTF = productData.isGLTF;

    Object.defineProperties(scope, {
        "forWall":{
            get() { return productData['property']['appointment'] == R2D.SceneObject.APPOINTMENT_WALL; }
        }
    });

    scope.getMaterialFrame = function() { return materialFrame; };
    scope.getAddMaterialFrame = function() { return addMaterialFrame; };
    scope.getMaterialFrameRotation = function () { return materialFrameRotation; };
    scope.getMaterialFrameX = function () { return materialFrameX; };
    scope.getMaterialFrameY = function () { return materialFrameY; };

    scope.getMaterialBottom = function() { return materialBottom; };
    scope.getAddMaterialBottom = function() { return addMaterialBottom; };
    scope.getMaterialBottomRotation = function () { return materialBottomRotation; };
    scope.getMaterialBottomX = function () { return materialBottomX; };
    scope.getMaterialBottomY = function () { return materialBottomY; };

    scope.getForWall = function() {
        return scope.forWall;
    };
    scope.setMaterialFrameData = function(id, addId, rotation, x, y) {
        materialFrame = id;
        addMaterialFrame = addId;
        materialFrameRotation = rotation;
        materialFrameX = x;
        materialFrameY = y;
    };
    scope.setMaterialFrame = function(id) {
        materialFrame = id;
    };
    scope.setAddMaterialFrame = function(id) {
        addMaterialFrame = id;
    };
    scope.setMaterialFrameRotation = function(value) {
        materialFrameRotation = value;
    };
    scope.setMaterialFramePosition = function(x, y) {
        materialFrameX = x;
        materialFrameY = y;
    };
    scope.setMaterialBottomData = function(id, addId, rotation, x, y) {
        materialBottom = id;
        addMaterialBottom = addId;
        materialBottomRotation = rotation;
        materialBottomX = x;
        materialBottomY = y;
    };
    scope.setMaterialBottom = function(id) {
        materialBottom = id;
    };
    scope.setAddMaterialBottom = function(id) {
        addMaterialBottom = id;
    };
    scope.setMaterialBottomRotation = function(value) {
        materialBottomRotation = value;
    };
    scope.setMaterialBottomPosition = function(x, y) {
        materialBottomX = x;
        materialBottomY = y;
    };
    scope.getMaterials = function() {
        let materials = [];
        for ( let i = 0, l = materialsObjects.length; i < l; i++ ) {
            let mo = materialsObjects[i];

            materials.push({
                current:mo["current"],
                default:mo["default"],
                hash:mo["hash"],
                name:mo["name"],
                source:mo["source"],
                setId:mo["setId"],
                addMaterial:mo["addMaterial"] ? mo["addMaterial"] : ""
            });
        }

        return materials;
    };
    scope.setMaterials = function(materials) {
        if ( materials.length != materialsObjects.length ) {
            console.warn("New materials set length not equal to inner one!");
            console.log('received:', materials);
            console.log('current:', materialsObjects);
            // throw "Error! New materials set length not equal to inner one!";
            // return;
        }

        for ( let i = 0, l = Math.min(materialsObjects.length, materials.length); i < l; i++ ) {
            materialsObjects[i]['current'] = materials[i]['current'];
            materialsObjects[i]['addMaterial'] = materials[i]["addMaterial"];
        }
        for ( let i = 0, l = materials.length; i < l; i++ ) {
            if ( !materials[i].hasOwnProperty('hash') || !materials[i]['hash'] ) continue;

            for ( let j = 0, k = materialsObjects.length; j < k; j++ ) {
                if ( !materialsObjects[j].hasOwnProperty('hash') || !materialsObjects[j]['hash'] ) continue;
                if ( materialsObjects[j]['hash'] != materials[i]['hash'] ) continue;

                materialsObjects[j]['current'] = materials[i]["current"];
                materialsObjects[j]['addMaterial'] = materials[i]["addMaterial"];
            }
        }
    };
    scope.getMaterialAt = function(index) {
        return materialsObjects[index]['current'];
    };
    scope.getAddMaterialAt = function(index) {
        return materialsObjects[index]['addMaterial'];
    };
    scope.setMaterialAt = function(index, materialId) {
        if(!materialsObjects || !materialsObjects[index]) return;
        materialsObjects[index]['current'] = materialId;
    };
    scope.setAddMaterialAt = function(index, materialId) {
        if(!materialsObjects || !materialsObjects[index]) return;
        materialsObjects[index]['addMaterial'] = materialId;
    };
    scope.clone = function() {
        var object = new R2D.SceneObjectModel(productData);

        object.x = scope.x;
        object.y = scope.y;
        object.z = scope.z;
        object.scaleX = scope.scaleX;
        object.scaleY = scope.scaleY;
        object.scaleZ = scope.scaleZ;
        object.rotationX = scope.rotationX;
        object.rotationY = scope.rotationY;
        object.rotationZ = scope.rotationZ;
        object.flipX = scope.flipX;
        object.flipY = scope.flipY;
        object.flipZ = scope.flipZ;

        object.setMaterials(scope.getMaterials());
        object.setMaterialFrameData(
            scope.getMaterialFrame(),
            scope.getAddMaterialFrame(),
            scope.getMaterialFrameRotation(),
            scope.getMaterialFrameX(),
            scope.getMaterialFrameY()
        );
        object.setMaterialBottomData(
            scope.getMaterialBottom(),
            scope.getAddMaterialBottom(),
            scope.getMaterialBottomRotation(),
            scope.getMaterialBottomX(),
            scope.getMaterialBottomY()
        );
        object.update();

        return object;
    };

    //setup
    materialsObjects = new Array(productData['source']['body']['materials'].length);

    for ( var i = 0, l = materialsObjects.length; i < l; i++ ) {
        let data = productData['source']['body']['materials'][i];

        materialsObjects[i] = {
            'name':data['name'],
            'hash':data['hash'],
            'default':data['default'],
            'current':data['default'],
            'source':data['source'],
            'setId':data["setId"],
            'addMaterial':data["addMaterial"]
        };
    }
    materialsObjects.sort(R2D.SceneObjectModel._sortMaterials);
};

R2D.extend(R2D.SceneObjectModel, R2D.SceneObject);

R2D.SceneObjectModel._sortMaterials = function(a, b) {
    if ( parseInt(a['id']) > parseInt(b['id']) ) return  1;
    if ( parseInt(a['id']) < parseInt(b['id']) ) return -1;

    return 0;
};
// core

R2D.SceneObjectCarpet = function(productData) {
    R2D.SceneObject.call(this, productData);

    productData.isGLTF = productData.source.body.package.endsWith(".glb");
    this.isGLTF = productData.isGLTF;

    var scope = this;

    if (productData.isGLTF) {
        var materialsObjects = [];
        var materialFrame = 0;
        var materialFrameRotation = 0;
        var materialFrameX = 0;
        var materialFrameY = 0;
        var materialBottom = 0;
        var materialBottomRotation = 0;
        var materialBottomX = 0;
        var materialBottomY = 0;

        // productData.isGLTF = productData.source.body.package.endsWith(".glb");
        // scope.isGLTF = productData.isGLTF;

        Object.defineProperties(scope, {
            forWall: {
                get() {
                    return (
                        productData["property"]["appointment"] ==
                        R2D.SceneObject.APPOINTMENT_WALL
                    );
                },
            },
        });

        scope.getMaterialFrame = function () {
            return materialFrame;
        };
        scope.getMaterialFrameRotation = function () {
            return materialFrameRotation;
        };
        scope.getMaterialFrameX = function () {
            return materialFrameX;
        };
        scope.getMaterialFrameY = function () {
            return materialFrameY;
        };

        scope.getMaterialBottom = function () {
            return materialBottom;
        };
        scope.getMaterialBottomRotation = function () {
            return materialBottomRotation;
        };
        scope.getMaterialBottomX = function () {
            return materialBottomX;
        };
        scope.getMaterialBottomY = function () {
            return materialBottomY;
        };

        scope.getForWall = function () {
            return scope.forWall;
        };
        scope.setMaterialFrameData = function (id, rotation, x, y) {
            materialFrame = id;
            materialFrameRotation = rotation;
            materialFrameX = x;
            materialFrameY = y;
        };
        scope.setMaterialFrame = function (id) {
            materialFrame = id;
        };
        scope.setMaterialFrameRotation = function (value) {
            materialFrameRotation = value;
        };
        scope.setMaterialFramePosition = function (x, y) {
            materialFrameX = x;
            materialFrameY = y;
        };
        scope.setMaterialBottomData = function (id, rotation, x, y) {
            materialBottom = id;
            materialBottomRotation = rotation;
            materialBottomX = x;
            materialBottomY = y;
        };
        scope.setMaterialBottom = function (id) {
            materialBottom = id;
        };
        scope.setMaterialBottomRotation = function (value) {
            materialBottomRotation = value;
        };
        scope.setMaterialBottomPosition = function (x, y) {
            materialBottomX = x;
            materialBottomY = y;
        };
        scope.getMaterials = function () {
            let materials = [];

            for (let i = 0, l = materialsObjects.length; i < l; i++) {
                let mo = materialsObjects[i];

                materials.push({
                    current: mo["current"],
                    default: mo["default"],
                    hash: mo["hash"],
                    name: mo["name"],
                    source: mo["source"],
                    setId: mo["setId"],
                    addMaterial:mo["addMaterial"] ? mo["addMaterial"] : ""
                });
            }

            return materials;
        };
        scope.setMaterials = function (materials) {
            if (materials.length != materialsObjects.length) {
                console.warn("New materials set length not equal to inner one!");
                // throw "Error! New materials set length not equal to inner one!";
                // return;
            }

            for (
                let i = 0, l = Math.min(materialsObjects.length, materials.length);
                i < l;
                i++
            ) {
                materialsObjects[i]["current"] = materials[i]["current"];
            }
            for (let i = 0, l = materials.length; i < l; i++) {
                if (!materials[i].hasOwnProperty("hash") || !materials[i]["hash"])
                    continue;

                for (let j = 0, k = materialsObjects.length; j < k; j++) {
                    if (
                        !materialsObjects[j].hasOwnProperty("hash") ||
                        !materialsObjects[j]["hash"]
                    )
                        continue;
                    if (materialsObjects[j]["hash"] != materials[i]["hash"]) continue;

                    materialsObjects[j]["current"] = materials[i]["current"];
                }
            }
        };
        scope.getMaterialAt = function (index) {
            return materialsObjects[index]["current"];
        };
        scope.setMaterialAt = function (index, materialId) {
            materialsObjects[index]["current"] = materialId;
        };
        scope.clone = function () {
            var object = new R2D.SceneObjectModel(productData);

            object.x = scope.x;
            object.y = scope.y;
            object.z = scope.z;
            object.scaleX = scope.scaleX;
            object.scaleY = scope.scaleY;
            object.scaleZ = scope.scaleZ;
            object.rotationX = scope.rotationX;
            object.rotationY = scope.rotationY;
            object.rotationZ = scope.rotationZ;
            object.flipX = scope.flipX;
            object.flipY = scope.flipY;
            object.flipZ = scope.flipZ;

            object.setMaterials(scope.getMaterials());
            object.setMaterialFrameData(
                scope.getMaterialFrame(),
                scope.getMaterialFrameRotation(),
                scope.getMaterialFrameX(),
                scope.getMaterialFrameY()
            );
            object.setMaterialBottomData(
                scope.getMaterialBottom(),
                scope.getMaterialBottomRotation(),
                scope.getMaterialBottomX(),
                scope.getMaterialBottomY()
            );
            object.update();

            return object;
        };

        //setup
        materialsObjects = new Array(productData["source"]["body"]["materials"].length);

        for (var i = 0, l = materialsObjects.length; i < l; i++) {
            let data = productData["source"]["body"]["materials"][i];

            materialsObjects[i] = {
                name: data["name"],
                hash: data["hash"],
                default: data["default"],
                current: data["default"],
                source: data["source"],
                setId: data["setId"],
                addMaterial:data["addMaterial"] ? data["addMaterial"] : ""
            };
        }

        materialsObjects.sort(R2D.SceneObjectModel._sortMaterials);
    }

    else {
        scope.clone = function () {
            var object = new R2D.SceneObjectModel(productData);

            object.x = scope.x;
            object.y = scope.y;
            object.z = scope.z;
            object.scaleX = scope.scaleX;
            object.scaleY = scope.scaleY;
            object.scaleZ = scope.scaleZ;
            object.rotationX = scope.rotationX;
            object.rotationY = scope.rotationY;
            object.rotationZ = scope.rotationZ;
            object.flipX = scope.flipX;
            object.flipY = scope.flipY;
            object.flipZ = scope.flipZ;

            object.update();

            return object;
        };
    }
};

R2D.extend(R2D.SceneObjectCarpet, R2D.SceneObject);
// core

R2D.SceneObjectPoster = function (productData) {
    R2D.SceneObject.call(this, productData);

    productData.isGLTF = productData.source.body.package.endsWith(".glb");
    this.isGLTF = productData.isGLTF;

    var scope = this;

    if (productData.isGLTF) {
        var materialsObjects = [];
        var materialFrame = 0;
        var materialFrameRotation = 0;
        var materialFrameX = 0;
        var materialFrameY = 0;
        var materialBottom = 0;
        var materialBottomRotation = 0;
        var materialBottomX = 0;
        var materialBottomY = 0;

        // productData.isGLTF = productData.source.body.package.endsWith(".glb");
        // scope.isGLTF = productData.isGLTF;

        Object.defineProperties(scope, {
            forWall: {
                get() {
                    return (
                        productData["property"]["appointment"] ==
                        R2D.SceneObject.APPOINTMENT_WALL
                    );
                },
            },
        });

        scope.getMaterialFrame = function () {
            return materialFrame;
        };
        scope.getMaterialFrameRotation = function () {
            return materialFrameRotation;
        };
        scope.getMaterialFrameX = function () {
            return materialFrameX;
        };
        scope.getMaterialFrameY = function () {
            return materialFrameY;
        };

        scope.getMaterialBottom = function () {
            return materialBottom;
        };
        scope.getMaterialBottomRotation = function () {
            return materialBottomRotation;
        };
        scope.getMaterialBottomX = function () {
            return materialBottomX;
        };
        scope.getMaterialBottomY = function () {
            return materialBottomY;
        };

        scope.getForWall = function () {
            return scope.forWall;
        };
        scope.setMaterialFrameData = function (id, rotation, x, y) {
            materialFrame = id;
            materialFrameRotation = rotation;
            materialFrameX = x;
            materialFrameY = y;
        };
        scope.setMaterialFrame = function (id) {
            materialFrame = id;
        };
        scope.setMaterialFrameRotation = function (value) {
            materialFrameRotation = value;
        };
        scope.setMaterialFramePosition = function (x, y) {
            materialFrameX = x;
            materialFrameY = y;
        };
        scope.setMaterialBottomData = function (id, rotation, x, y) {
            materialBottom = id;
            materialBottomRotation = rotation;
            materialBottomX = x;
            materialBottomY = y;
        };
        scope.setMaterialBottom = function (id) {
            materialBottom = id;
        };
        scope.setMaterialBottomRotation = function (value) {
            materialBottomRotation = value;
        };
        scope.setMaterialBottomPosition = function (x, y) {
            materialBottomX = x;
            materialBottomY = y;
        };
        scope.getMaterials = function () {
            let materials = [];

            for (let i = 0, l = materialsObjects.length; i < l; i++) {
                let mo = materialsObjects[i];

                materials.push({
                    current: mo["current"],
                    default: mo["default"],
                    hash: mo["hash"],
                    name: mo["name"],
                    source: mo["source"],
                    setId: mo["setId"],
                    addMaterial:mo["addMaterial"] ? mo["addMaterial"] : ""
                });
            }

            return materials;
        };
        scope.setMaterials = function (materials) {
            if (materials.length != materialsObjects.length) {
                console.warn("New materials set length not equal to inner one!");
                // throw "Error! New materials set length not equal to inner one!";
                // return;
            }

            for (
                let i = 0, l = Math.min(materialsObjects.length, materials.length);
                i < l;
                i++
            ) {
                materialsObjects[i]["current"] = materials[i]["current"];
            }
            for (let i = 0, l = materials.length; i < l; i++) {
                if (!materials[i].hasOwnProperty("hash") || !materials[i]["hash"])
                    continue;

                for (let j = 0, k = materialsObjects.length; j < k; j++) {
                    if (
                        !materialsObjects[j].hasOwnProperty("hash") ||
                        !materialsObjects[j]["hash"]
                    )
                        continue;
                    if (materialsObjects[j]["hash"] != materials[i]["hash"]) continue;

                    materialsObjects[j]["current"] = materials[i]["current"];
                }
            }
        };
        scope.getMaterialAt = function (index) {
            return materialsObjects[index]["current"];
        };
        scope.setMaterialAt = function (index, materialId) {
            materialsObjects[index]["current"] = materialId;
        };
        scope.clone = function () {
            var object = new R2D.SceneObjectModel(productData);

            object.x = scope.x;
            object.y = scope.y;
            object.z = scope.z;
            object.scaleX = scope.scaleX;
            object.scaleY = scope.scaleY;
            object.scaleZ = scope.scaleZ;
            object.rotationX = scope.rotationX;
            object.rotationY = scope.rotationY;
            object.rotationZ = scope.rotationZ;
            object.flipX = scope.flipX;
            object.flipY = scope.flipY;
            object.flipZ = scope.flipZ;

            object.setMaterials(scope.getMaterials());
            object.setMaterialFrameData(
                scope.getMaterialFrame(),
                scope.getMaterialFrameRotation(),
                scope.getMaterialFrameX(),
                scope.getMaterialFrameY()
            );
            object.setMaterialBottomData(
                scope.getMaterialBottom(),
                scope.getMaterialBottomRotation(),
                scope.getMaterialBottomX(),
                scope.getMaterialBottomY()
            );
            object.update();

            return object;
        };

        //setup
        materialsObjects = new Array(productData["source"]["body"]["materials"].length);

        for (var i = 0, l = materialsObjects.length; i < l; i++) {
            let data = productData["source"]["body"]["materials"][i];

            materialsObjects[i] = {
                name: data["name"],
                hash: data["hash"],
                default: data["default"],
                current: data["default"],
                source: data["source"],
                setId: data["setId"],
                addMaterial:data["addMaterial"] ? data["addMaterial"] : ""
            };
        }

        materialsObjects.sort(R2D.SceneObjectModel._sortMaterials);
    }
    else {
        scope.clone = function () {
            var object = new R2D.SceneObjectModel(productData);
            object.x = scope.x;
            object.y = scope.y;
            object.z = scope.z;
            object.scaleX = scope.scaleX;
            object.scaleY = scope.scaleY;
            object.scaleZ = scope.scaleZ;
            object.rotationX = scope.rotationX;
            object.rotationY = scope.rotationY;
            object.rotationZ = scope.rotationZ;
            object.flipX = scope.flipX;
            object.flipY = scope.flipY;
            object.flipZ = scope.flipZ;

            object.update();

            return object;
        };
    }
};

R2D.extend(R2D.SceneObjectPoster, R2D.SceneObject);

// core

R2D.SceneHistory = function(scene) {
    EventDispatcher.call(this);

    let scope = this;
    let maxActions = 100;
    let statesUndo = [];
    let statesRedo = [];
    let isUndo = false;
    let isRedo = false;
    let currentState = null;

    function checkStates() {
        if ( isUndo && statesUndo.length == 0 ) {
            isUndo = false;
            scope.dispatchEvent(new Event(R2D.SceneHistory.UNDO_INACTIVE, scope));
        } else if ( !isUndo && statesUndo.length > 0 ) {
            isUndo = true;
            scope.dispatchEvent(new Event(R2D.SceneHistory.UNDO_ACTIVE, scope));
        }
        if ( isRedo && statesRedo.length == 0 ) {
            isRedo = false;
            scope.dispatchEvent(new Event(R2D.SceneHistory.REDO_INACTIVE, scope));
        } else if ( !isRedo && statesRedo.length > 0 ) {
            isRedo = true;
            scope.dispatchEvent(new Event(R2D.SceneHistory.REDO_ACTIVE, scope));
        }
    }

    Object.defineProperties(scope, {
        "isUndo":{
            get() { return isUndo; }
        },
        "isRedo":{
            get() { return isRedo; }
        }
    });

    scope.getIsUndo = function () {
        return isUndo;
    };
    scope.getIsRedo = function () {
        return isRedo;
    };
    scope.clear = function() {
        statesRedo = [];
        statesUndo = [];
        currentState = null;

        scene.getConstructor().setAllElementsChanged();

        checkStates();
    };
    scope.saveState = function(label = '') {

        statesRedo = [];
        if ( currentState ) {
            if (label !== 'productSizes' || currentState.label !== 'productSizes') statesUndo.push(currentState);
        }

        currentState = R2D.SceneHistory.makeState(scene);
        currentState.label = label;
        

        updatePrevState();

        scene.getConstructor().setAllElementsUnchanged();

        checkStates();

        if (R2D.controller) R2D.controller.savedLastChanges = false;
    };
    scope.setCurrentLabel = function(label)
    {
        if ( currentState ) currentState.label = label;
    };
    scope.undo = function() {
        if ( statesUndo.length == 0 ) {
            console.warn("Undo states are empty!");
            return;
        }

        let newState = statesUndo.pop();

        scope.dispatchEvent(new Event(R2D.SceneHistory.STATE_UPDATE));

        R2D.SceneHistory.setState(scene, currentState, newState, false);
        statesRedo.push(currentState);

        currentState = newState;

        scope.dispatchEvent(new Event(R2D.SceneHistory.STATE_UPDATED));

        checkStates();

        scene.getConstructor().setAllElementsUnchanged();

        R2D.controller.savedLastChanges = false;
    };
    scope.redo = function() {
        if ( statesRedo.length == 0 ) {
            console.warn("Redo states are empty!");
            return;
        }
        let newState = statesRedo.pop();

        scope.dispatchEvent(new Event(R2D.SceneHistory.STATE_UPDATE));

        R2D.SceneHistory.setState(scene, currentState, newState, true);
        statesUndo.push(currentState);

        currentState = newState;

        scope.dispatchEvent(new Event(R2D.SceneHistory.STATE_UPDATED));

        checkStates();

        scene.getConstructor().setAllElementsUnchanged();

        R2D.controller.savedLastChanges = false;
    };

    function updatePrevState()
    {
        if (statesUndo.length == 0) return;
        let prevWalls = statesUndo[statesUndo.length - 1].constructionStateObjects.wallsStateObjects;
        let currWalls = currentState.constructionStateObjects.wallsStateObjects;
        for (let i = 0; i < prevWalls.length; i++)
        {
            prevWalls[i].willBeChanged = currWalls[i]?.wasChanged;
        }
/*
        let prevFrames = statesUndo[statesUndo.length - 1].constructionStateObjects.framesStateObjects;
        let currFrames = currentState.constructionStateObjects.framesStateObjects;
        for (i = 0; i < prevFrames.length; i++)
        {
            prevFrames[i].willBeChanged = currFrames[i].wasChanged;
        }
*/
    }
};

R2D.extend(R2D.SceneHistory, EventDispatcher);

R2D.SceneHistory.STATE_UPDATE = 'stateUpdate';
R2D.SceneHistory.STATE_UPDATED = 'stateUpdated';
R2D.SceneHistory.UNDO_ACTIVE = 'undoActive';
R2D.SceneHistory.UNDO_INACTIVE = 'undoInactive';
R2D.SceneHistory.REDO_ACTIVE = 'redoActive';
R2D.SceneHistory.REDO_INACTIVE = 'redoInactive';

R2D.SceneHistory.__counter = 0;

R2D.SceneHistory.setSceneObjectStateBase = function(stateObjects) {
    let sceneObject = stateObjects.sceneObject;
    let needsUpdate = false;

    if ( sceneObject.x != stateObjects.position.x || sceneObject.y != stateObjects.position.y || sceneObject.z != stateObjects.position.z ) {
        sceneObject.x = stateObjects.position.x;
        sceneObject.y = stateObjects.position.y;
        sceneObject.z = stateObjects.position.z;

        needsUpdate = true;
    }
    if ( sceneObject.rotationX != stateObjects.rotation.x || sceneObject.rotationY != stateObjects.rotation.y || sceneObject.rotationZ != stateObjects.rotation.z ) {
        sceneObject.rotationX = stateObjects.rotation.x;
        sceneObject.rotationY = stateObjects.rotation.y;
        sceneObject.rotationZ = stateObjects.rotation.z;

        needsUpdate = true;
    }
    if ( sceneObject.scaleX != stateObjects.scale.x || sceneObject.scaleY != stateObjects.scale.y || sceneObject.scaleZ != stateObjects.scale.z ) {
        sceneObject.scaleX = stateObjects.scale.x;
        sceneObject.scaleY = stateObjects.scale.y;
        sceneObject.scaleZ = stateObjects.scale.z;

        needsUpdate = true;
    }
    if ( sceneObject.flipX != stateObjects.flip.x || sceneObject.flipY != stateObjects.flip.y || sceneObject.flipZ != stateObjects.flip.z ) {
        sceneObject.flipX = stateObjects.flip.x;
        sceneObject.flipY = stateObjects.flip.y;
        sceneObject.flipZ = stateObjects.flip.z;

        needsUpdate = true;
    }

    if ( needsUpdate ) {
        sceneObject.update();
        sceneObject.historyUpdate();
    }
};
R2D.SceneHistory.setSceneObjectStateModel = function(stateObjects) {
    let sceneObject = stateObjects.sceneObject;
    let sceneObjectMaterials = sceneObject.getMaterials();
    let stateObjectMaterials = stateObjects.materials;
    let needsUpdate = false;

    R2D.SceneHistory.setSceneObjectStateBase(stateObjects);

    for ( let i = 0, il = sceneObjectMaterials.length; i < il; i++ ) {
        if ( sceneObjectMaterials[i] != stateObjectMaterials[i] ) {
            needsUpdate = true;
            break;
        }
    }

    if ( needsUpdate ) {
        sceneObject.setMaterials(stateObjectMaterials);
        sceneObject.update();
    }
};

R2D.SceneHistory.setSceneObjectState = function(stateObject) {
    switch ( parseInt(stateObject.productType) ) {
        case R2D.ProductType.MODEL:
            R2D.SceneHistory.setSceneObjectStateModel(stateObject);
            break;

        default:
            //console.warn("Warning! Unknown type of state object!");
            R2D.SceneHistory.setSceneObjectStateBase(stateObject);
    }
};
R2D.SceneHistory.setSceneState = function(scene, stateOld, stateNew) {
    let oldObjects = stateOld.sceneStateObjects;
    let newObjects = stateNew.sceneStateObjects;
    let oldObject;
    let newObject;
    let i, j, il, jl;
    let action = true;
    let needsAdd = [];
    let needsRemove = [];

    //needs add
    for ( i = 0, il = newObjects.length; i < il; i++ ) {
        newObject = newObjects[i];
        action = true;

        for ( j = 0, jl = oldObjects.length; j < jl; j++ ) {
            oldObject = oldObjects[j];

            if ( newObject.objectId == oldObject.objectId ) {
                action = false;
                break;
            }
        }

        if ( action ) {
            needsAdd.push(newObject);
        }
    }

    //needs remove
    for ( i = 0, il = oldObjects.length; i < il; i++ ) {
        oldObject = oldObjects[i];
        action = true;

        for ( j = 0, jl = newObjects.length; j < jl; j++ ) {
            newObject = newObjects[j];

            if ( oldObject.objectId == newObject.objectId ) {
                action = false;
                break;
            }
        }

        if ( action ) {
            needsRemove.push(oldObject);
        }
    }

    //removing
    for ( i = 0, il = needsRemove.length; i < il; i++ ) {
        scene.remove(needsRemove[i].sceneObject);
    }

    //setup
    for ( i = 0, il = newObjects.length; i < il; i++ ) {
        R2D.SceneHistory.setSceneObjectState(newObjects[i]);
    }

    //adding
    for ( i = 0, il = needsAdd.length; i < il; i++ ) {
        scene.add(needsAdd[i].sceneObject);
    }
};
//construction
R2D.SceneHistory.setConstructionState = function(scene, stateOld, stateNew, forward) {
    let constructionStateObjects = stateNew.constructionStateObjects;
    let wallsStateObjects = constructionStateObjects.wallsStateObjects;
    let coversStateObjects = constructionStateObjects.coversStateObjects;
    let ceilingsStateObjects = constructionStateObjects.ceilingsStateObjects;
    let cutsStateObjects = constructionStateObjects.cutsStateObjects;
    let areasStateObjects = constructionStateObjects.areasStateObjects;
    let framesStateObjects = constructionStateObjects.framesStateObjects;
    let plinthsStateObjects = constructionStateObjects.plinthsStateObjects;
    let capsStateObjects = constructionStateObjects.capsStateObjects;
    let stateObject, constructionObject;

    let oldWallsStateObjects = stateOld.constructionStateObjects.wallsStateObjects;

    //walls
    for ( let i = 0; i < wallsStateObjects.length; i++ ) {
        stateObject = wallsStateObjects[i];
        constructionObject = stateObject.object;

        if (forward)
        {
            if (! stateObject.wasChanged) continue;
        }
        else
        {
            if (! stateObject.willBeChanged) continue;
        }
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.configData = null;
        if (stateObject.configData) constructionObject.configData = stateObject.configData.getData();
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //covers
    for ( let i = 0; i < coversStateObjects.length; i++ ) {
        stateObject = coversStateObjects[i];
        constructionObject = stateObject.object;

        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //ceilings
    for ( let i = 0; i < ceilingsStateObjects.length; i++ ) {
        stateObject = ceilingsStateObjects[i];
        constructionObject = stateObject.object;

        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //cuts
    for ( let i = 0; i < cutsStateObjects.length; i++ ) {
        stateObject = cutsStateObjects[i];
        constructionObject = stateObject.object;

        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //areas
    for ( let i = 0; i < areasStateObjects.length; i++ ) {
        stateObject = areasStateObjects[i];
        constructionObject = stateObject.object;

        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //frames
    for ( let i = 0; i < framesStateObjects.length; i++ ) {
        stateObject = framesStateObjects[i];
        constructionObject = stateObject.object;
/*
        if (forward)
        {
            if (! stateObject.wasChanged) continue;
        }
        else
        {
            if (! stateObject.willBeChanged) continue;
        }
*/
        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //plinths
    for ( let i = 0; i < plinthsStateObjects.length; i++ ) {
        stateObject = plinthsStateObjects[i];
        constructionObject = stateObject.object;

        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.exists = stateObject.exists;
        constructionObject.shapeNum = stateObject.shapeNum;
        constructionObject.d = stateObject.d;
        constructionObject.h = stateObject.h;
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }

    //caps
    for ( let i = 0; i < capsStateObjects.length; i++ ) {
        stateObject = capsStateObjects[i];
        constructionObject = stateObject.object;

        constructionObject.setMaterial(stateObject.materialId);
        constructionObject.setAddMaterial(stateObject.addMaterialID);
        constructionObject.setMaterialRotation(stateObject.materialRotation);
        constructionObject.setMaterialShift(stateObject.materialShift);
        constructionObject.build3D();
        constructionObject.dispatchUpdate();
    }
};
R2D.SceneHistory.removeGroups = function(scene)
{
    let prodHelper = R2D.commonSceneHelper.productHelper;

    while (scene.groups.length > 0)
    {
        scene.groups[0].clearUnchanged();
        prodHelper.removeGroup(scene.groups[0]);
    }
};
R2D.SceneHistory.setGroupState = function(scene, stateOld, stateNew)
{
    let prodHelper = R2D.commonSceneHelper.productHelper;
    let groupData = stateNew.groupStateObjects;

    //while (scene.groups.length > 0)
    //{
    //    scene.groups[0].clearUnchanged();
    //    prodHelper.removeGroup(scene.groups[0]);
    //}

    for (let i = 0; i < groupData.length; i++)
    {
        let gr = prodHelper.addGroup();

        for (let j = 0; j < groupData[i].sceneObjects.length; j++)
        {
            let objView3D = prodHelper.findObjectView3dBySceneObject(groupData[i].sceneObjects[j]);
            gr.addUnchanged(objView3D);
        }

        gr.x = groupData[i].position.x;
        gr.y = groupData[i].position.y;
        gr.z = groupData[i].position.z;

        gr.rotation = groupData[i].rotation;
        gr.fx = groupData[i].flip.x;
        gr.fz = groupData[i].flip.z;

        gr.sx = groupData[i].scale.x;
        gr.sy = groupData[i].scale.y;
        gr.sz = groupData[i].scale.z;
    }
};
R2D.SceneHistory.setState = function(scene, stateOld, stateNew, forward) {
    R2D.SceneHistory.removeGroups(scene);
    R2D.SceneHistory.setSceneState(scene, stateOld, stateNew);
    R2D.SceneHistory.setConstructionState(scene, stateOld, stateNew, forward);
    R2D.SceneHistory.setGroupState(scene, stateOld, stateNew);
    scene.setSkyboxMat(stateNew.skybox.id);
    scene.setSkyboxRotation(stateNew.skybox.r);
};

//crate state
R2D.SceneHistory.makeSceneObjectStateBase = function(sceneObject) {
    return {
        productId:sceneObject.getProductId(),
        productType:sceneObject.getType(),
        objectId:sceneObject.getObjectId(),
        sceneObject:sceneObject,
        position:{
            x:sceneObject.x,
            y:sceneObject.y,
            z:sceneObject.z
        },
        rotation:{
            x:sceneObject.rotationX,
            y:sceneObject.rotationY,
            z:sceneObject.rotationZ
        },
        scale:{
            x:sceneObject.scaleX,
            y:sceneObject.scaleY,
            z:sceneObject.scaleZ
        },
        flip:{
            x:sceneObject.flipX,
            y:sceneObject.flipY,
            z:sceneObject.flipZ
        }
    };
};
R2D.SceneHistory.makeSceneObjectStateModel = function(sceneObject) {
    let base = R2D.SceneHistory.makeSceneObjectStateBase(sceneObject);

    base.materials = sceneObject.getMaterials();

    return base;
};
R2D.SceneHistory.makeSceneObjectState = function(sceneObject) {
    switch ( parseInt(sceneObject.getType()) ) {
        case R2D.ProductType.MODEL:
            return R2D.SceneHistory.makeSceneObjectStateModel(sceneObject);

        default:
            //console.warn("Warning! Unknown type of scene object!");
            return R2D.SceneHistory.makeSceneObjectStateBase(sceneObject);
    }
};
R2D.SceneHistory.makeSceneObjectsStates = function(scene) {
    let sceneObjects = scene.getSceneObjects();
    let sceneStateObjects = [];

    for ( let i = 0, l = sceneObjects.length; i < l; i++ ) {
        sceneStateObjects.push(R2D.SceneHistory.makeSceneObjectState(sceneObjects[i]));
    }

    return sceneStateObjects;
};
//construction
R2D.SceneHistory.makeConstructionObjectsStates = function(scene) {
    let constructionObjects = scene.getConstructor().getObjects();
    let wallsObjects = constructionObjects.walls;
    let coversObjects = constructionObjects.covers;
    let ceilingsObjects = constructionObjects.ceilings;
    let areasObjects = constructionObjects.areas;
    let cutsObjects = constructionObjects.cuts;
    let framesObjects = constructionObjects.frames;
    let plinthsObjects = constructionObjects.plinths;
    let capsObjects = [constructionObjects.cap];
    let wallsStateObjects = [];
    let coversStateObjects = [];
    let ceilingsStateObjects = [];
    let areasStateObjects = [];
    let cutsStateObjects = [];
    let framesStateObjects = [];
    let plinthsStateObjects = [];
    let capsStateObjects = [];
    let constructionObject;

    //walls
    for ( let i = 0; i < wallsObjects.length; i++ ) {
        constructionObject = wallsObjects[i];

        let configData = null;
        if (constructionObject.configData) configData = constructionObject.configData.getData();
        wallsStateObjects.push({
            object: constructionObject,
            materialId: constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation: constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift(),
            configData: configData,
            wasChanged: constructionObject.changed,
            willBeChanged: false
            //pattern: constructionObject.clonePattern()
        });
    }

    //covers
    for ( let i = 0; i < coversObjects.length; i++ ) {
        constructionObject = coversObjects[i];

        coversStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift()
        });
    }

    //ceilings
    for ( let i = 0; i < ceilingsObjects.length; i++ ) {
        constructionObject = ceilingsObjects[i];

        ceilingsStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift()
        });
    }

    //areas
    for ( let i = 0; i < cutsObjects.length; i++ ) {
        constructionObject = cutsObjects[i];

        cutsStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift()
        });
    }

    //cuts
    for ( let i = 0; i < areasObjects.length; i++ ) {
        constructionObject = areasObjects[i];

        areasStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift()
        });
    }

    //frames
    for ( let i = 0; i < framesObjects.length; i++ ) {
        constructionObject = framesObjects[i];

        framesStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift(),
            wasChanged: constructionObject.changed,
            willBeChanged: false
        });
    }

    //plinth
    for ( let i = 0; i < plinthsObjects.length; i++) {
        constructionObject = plinthsObjects[i];

        plinthsStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift(),
            exists:constructionObject.exists,
            shapeNum:constructionObject.shapeNum,
            d:constructionObject.d,
            h:constructionObject.h
        });
    }

    //caps
    for ( let i = 0; i < capsObjects.length; i++ ) {
        constructionObject = capsObjects[i];

        capsStateObjects.push({
            object:constructionObject,
            materialId:constructionObject.getMaterial(),
            addMaterialID: constructionObject.getAddMaterial(),
            materialRotation:constructionObject.getMaterialRotation(),
            materialShift:constructionObject.getMaterialShift()
        });
    }

    return {
        wallsStateObjects,
        coversStateObjects,
        ceilingsStateObjects,
        cutsStateObjects,
        areasStateObjects,
        framesStateObjects,
        plinthsStateObjects,
        capsStateObjects
    };
};

R2D.SceneHistory.makeGroupsStates = function(scene)
{
    let groupsData = [];
    for (let i = 0; i < scene.groups.length; i++)
    {
        let gr = scene.groups[i];
        let objViews = gr.getObjViews();
        let sceneObjects = new Array(objViews.length);
        for (let j = 0; j < objViews.length; j++)
        {
            sceneObjects[j] = objViews[j]?.sceneObject;
        }

        groupsData[i] = {
            sceneObjects: sceneObjects,
            position:{
                x:gr.x,
                y:gr.y,
                z:gr.z
            },
            rotation:gr.rotation,

            flip:{
                x:gr.fx,
                z:gr.fz
            },

            scale:{
                x:gr.sx,
                y:gr.sy,
                z:gr.sz
            }
        }
    }

    return groupsData;
};

R2D.SceneHistory.makeState = function(scene) {

    return {
        stateId:R2D.SceneHistory.__counter++,
        sceneStateObjects: R2D.SceneHistory.makeSceneObjectsStates(scene),
        constructionStateObjects: R2D.SceneHistory.makeConstructionObjectsStates(scene),
        groupStateObjects: R2D.SceneHistory.makeGroupsStates(scene),
        skybox: {id: scene.skyboxId, r: scene.skyboxRotation}
    };
};

//core

R2D.Scene = function (api) {
    EventDispatcher.call(this);

    var scope = this;
    var history = new R2D.SceneHistory(scope);
    var radiusDropElement = 10;
    var sceneObjects = [];
    var constructor = new WC.WallsData();
    var projectId = 0;
    var projectHash = 0;
    var projectName = "New project"; // R2D.TRANSLATION.DEFAULT_SCENE_NAME;
    var projectDimension = 0;
    var projectUserKey = null;
    var extraData = null;

    scope.currentView3DObject = null;
    scope.currentView3DObjectData = null;
    scope.currentSceneObject = null;
    scope.currentPartNum = -1;
    scope.currentConstructorElementData = null;
    scope.prevSelectedView3DObject = null;
    scope.prevView3DObjectData = null;
    scope.groups = [];
    scope.currentGroup = null;

    scope.isRotation3dActive = false;

    scope.skyboxId = "";
    scope.skyboxRotation = 0;

    scope.needClearPool = true;

    scope.api = api;

    function getSceneObjectsForWall() {
        var objects = [];

        for (var i = 0, l = sceneObjects.length; i < l; i++) {
            var sceneObject = sceneObjects[i];

            if (
                sceneObject.getType() == R2D.ProductType.MODEL &&
                sceneObject.getForWall()
            ) {
                objects.push(sceneObject);
            }
        }

        return objects;
    }
    scope.getSceneObjectsForWall = getSceneObjectsForWall;

    function removeIfExist(sceneObject) {
        if (sceneObjects.length != 0) {
            var index = sceneObjects.indexOf(sceneObject);

            if (index >= 0) sceneObjects.splice(index, 1);
        }

        return sceneObject;
    }
    function updatePositionObjectsForWall(data) {
        var inputData = data.slice();
        var sceneObjectsForWall = getSceneObjectsForWall().slice();
        var sceneObject = null;
        var dataForWall = null;
        var dropResult = null;
        var dataElement = null;
        var processed = false;

        if (inputData.length != 0 && sceneObjectsForWall.length == 0) {
            console.error("Received data has objects walls but scene has no one!");
            return;
        }

        while (inputData.length > 0) {
            dataElement = inputData.pop();
            sceneObject = null;
            processed = false;

            for (var i = 0, il = sceneObjectsForWall.length; i < il; i++) {
                sceneObject = sceneObjectsForWall[i];

                if (sceneObject.getObjectId() == dataElement["id"]) {
                    dataForWall = R2D.Scene.getObjectDataForWallElement(sceneObject);
                    dropResult = null;

                    dataForWall.x = dataElement.x;
                    dataForWall.y = dataElement.y;

                    dropResult = constructor.dropElement(dataForWall, radiusDropElement);

                    if (dropResult) {
                        R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
                    } else {
                        console.error(
                            "Received data has object which has not been dropped!"
                        );
                        scope.remove(sceneObject);
                    }

                    sceneObjectsForWall.splice(i, 1);
                    processed = true;
                    break;
                }
            }

            if (!processed) {
                console.error(
                    "Received data has object which doesn't exist in the scene!"
                );
            }
        }

        while (sceneObjectsForWall.length > 0) {
            sceneObject = sceneObjectsForWall.pop();
            dataForWall = R2D.Scene.getObjectDataForWallElement(sceneObject);
            dropResult = constructor.dropElement(dataForWall, radiusDropElement);

            if (dropResult) {
                R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
            } else {
                scope.remove(sceneObject);
            }
        }
    }
    function constructorEventHandler(event) {
        if (event.type == WC.RESET_MODELS) {
            updatePositionObjectsForWall(event.data);
        }
    }
    function sceneObjectHistoryUpdate(event) {
        var sceneObject = event.currentTarget;

        if (sceneObject.getType() == R2D.ProductType.MODEL && sceneObject.getForWall()) {
            constructor.pickElement(sceneObject.getObjectId());

            var dataForWall = R2D.Scene.getObjectDataForWallElement(sceneObject);
            var dropResult = constructor.dropElement(dataForWall, radiusDropElement);

            R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
        }
    }

    Object.defineProperties(scope, {
        constructor: {
            get() {
                return constructor;
            },
        },
        history: {
            get() {
                return history;
            },
        },
    });

    scope.setMinElevation = function (value) {
        R2D.SceneObject.OBJECT_Y_MIN = value;
    };

    scope.getProjectId = function () {
        return projectId;
    };
    scope.updateProjectId = function (id) {
        projectId = id;
    };
    scope.updateExtraData = function (data) {
        extraData = data || null;
    };
    scope.getProjectHash = function () {
        return projectHash;
    };
    scope.updateProjectHash = function (hash) {
        projectHash = hash;
    };
    scope.getProjectName = function () {
        return projectName;
    };
    scope.updateProjectName = function (name) {
        projectName = name;
    };
    scope.getProjectDimension = function () {
        return projectDimension;
    };
    scope.updateProjectDimension = function (dimension) {
        projectDimension = dimension;
    };
    scope.getProjectUserKey = function () {
        return projectUserKey;
    };
    scope.updateProjectUserKey = function (userKey) {
        projectUserKey = userKey;
    };
    scope.getSceneState = function (forRender = false) {
        var sceneObjectsData = R2D.Scene.makeSceneObjectsData(sceneObjects, scope.groups, forRender);
        var constructionData = R2D.Scene.makeConstructionData(constructor, forRender);

        //var list_materials_old = [...new Set(sceneObjectsData.list_materials.concat(constructionData.list_materials))];
        var list_materials_old = sceneObjectsData.list_materials.concat(
            constructionData.list_materials
        );
        var list_materials = [];
        for (var i = 0; i < list_materials_old.length; i++) {
            var m = list_materials_old[i];
            if (
                m == 0 ||
                m == "0" ||
                m == "" ||
                m == null ||
                (typeof m == "string" && m[0] == "#")
            )
                continue;
            list_materials.push(m);
        }

        var res = {
            id: projectId,
            name: projectName,
            extraData: extraData,
            //        version:R2D.Scene._PROJECT_VERSION_001,
            dimension: projectDimension,
            construction: constructionData.construction,
            scene: {
                //            version:R2D.Scene._SCENE_VERSION_001,
                products: sceneObjectsData.products,
                groups: sceneObjectsData.groups,
                viewState: R2D.Viewers.getViewState(),
                skybox: {
                    id: scope.skyboxId,
                    r: scope.skyboxRotation,
                },
            },
            floorplan: constructor.getDrawingData(),
            preview: null,
        };

        res.construction.list = [
            ...new Set(sceneObjectsData.list_products.concat(list_materials)),
        ];

        if (scope.skyboxId) res.construction.list.push(scope.skyboxId);

        R2D.SceneParser.projectMissingDataCorrector.checkSceneDataBeforeSend(res);

        return res;
    };
    scope.getSceneDataForApp = function () {
        return {
            construction: constructor.getDataForApp(),
            //    scene:{
            //        viewState:R2D.Viewers.getViewState()
            //    }
        };
    };
    scope.getSceneBounds = function () {
        var sceneObject = null;
        var objectsBounds = null;

        if (sceneObjects.length == 0) {
            return new GEOM.Bounds(0, 0, 0, 0);
        }
        if (sceneObjects.length == 1) {
            return R2D.SceneObject.get2DBounds(sceneObjects[0]);
        }

        objectsBounds = new Array(sceneObjects.length);

        for (var i = 0, l = sceneObjects.length; i < l; i++) {
            objectsBounds[i] = R2D.SceneObject.get2DBounds(sceneObjects[i]);
        }

        return GEOM.Bounds.getMaxBounds(objectsBounds);
    };
    scope.getConstructorBounds = function () {
        return constructor.getRect();
    };
    scope.getBounds = function () {
        var constructorBounds = scope.getConstructorBounds();
        var sceneBounds = scope.getSceneBounds();
        var boundsArr = [];

        if (
            constructorBounds &&
            constructorBounds.width != 0 &&
            constructorBounds.height != 0
        ) {
            boundsArr.push(constructorBounds);
        }
        if (sceneBounds && sceneBounds.width != 0 && sceneBounds.height != 0) {
            boundsArr.push(sceneBounds);
        }

        return (
            GEOM.Bounds.getMaxBounds(boundsArr) || new GEOM.Bounds(-100, -100, 100, 100)
        );
    };
    scope.getSceneObjectById = function (objectId) {
        for (var i = 0, l = sceneObjects.length; i < l; i++) {
            if (sceneObjects[i].getObjectId() == objectId) {
                return sceneObjects[i];
            }
        }

        return null;
    };
    scope.getSceneObjectsByIds = function (objectsIds) {
        var objects = [];

        for (var i = 0, l = objectsIds.length; i < l; i++) {
            var obj = scope.getSceneObjectById(objectsIds[i]);

            if (obj) objects.push(obj);
            else console.error("Scene object by id: " + objectsIds[i] + " isn't exist!");
        }

        return objects;
    };
    scope.getSceneObjects = function () {
        return sceneObjects;
    };
    scope.getConstructor = function () {
        return constructor;
    };
    scope.getSceneObjectById = function (objectId) {
        for (var i = 0, l = sceneObjects.length; i < l; i++) {
            if (sceneObjects[i].getObjectId() == objectId) {
                return sceneObjects[i];
            }
        }

        return null;
    };
    scope.add = function (sceneObject) {
        var add = false;

        removeIfExist(sceneObject);

        if (sceneObject.type == R2D.ProductType.MODEL && sceneObject.forWall) {
            var dataForWall = R2D.Scene.getObjectDataForWallElement(sceneObject);
            var dropResult = constructor.dropElement(dataForWall, radiusDropElement);

            if (dropResult) {
                R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
                //add = true;
            }
            //} else {
            //    add = true;
        }

        //if ( add ) {
        sceneObject.addEventListener(
            R2D.SceneObject.HISTORY_UPDATE,
            sceneObjectHistoryUpdate
        );
        sceneObjects.push(sceneObject);
        scope.dispatchEvent(new Event(R2D.Scene.OBJECT_ADDED, sceneObject));
        return true;
        //}

        return false;
    };
    scope.drag = function (sceneObject) {
        scope.dispatchEvent(new Event(R2D.Scene.DRAG_OBJECT, sceneObject));
    };
    scope.remove = function (sceneObject) {
        var index = sceneObjects.indexOf(sceneObject);

        if (index < 0) throw "Error removing object from scene!";

        if (sceneObject.type == R2D.ProductType.MODEL && sceneObject.getForWall()) {
            constructor.pickElement(sceneObject.getObjectId());
        }

        sceneObject.removeEventListener(
            R2D.SceneObject.HISTORY_UPDATE,
            sceneObjectHistoryUpdate
        );
        sceneObjects.splice(index, 1);
        scope.dispatchEvent(new Event(R2D.Scene.OBJECT_REMOVED, sceneObject));
    };
    scope.removeFarSceneObjects = function () {
        var farSceneObjects = R2D.Scene.findFarObject(sceneObjects);

        for (var i = 0, l = farSceneObjects.length; i < l; i++) {
            scope.remove(farSceneObjects[i]);
        }
    };
    scope.removeCurrentObject = function () {
        if (
            (scope.currentView3DObject &&
                scope.currentView3DObject.objectType == "product") ||
            scope.currentGroup
        )
            scope.dispatchEvent(new Event(R2D.Scene.CURRENT_OBJECT_REMOVED));
    };
    scope.replaceCurrentObject = function (id, settings = {}, changeStateNeed = true, needToChangeScale = true) {
        if(!scope.currentView3DObject) return;
        return new Promise(resolve => {
            R2D.Pool3D.clearData(id);

            var dataLoader = R2D.Pool.isLoaderProductData(id);
            if (!dataLoader) dataLoader = R2D.Pool.loadProductData(id);
            dataLoader.addEventListener(Event.COMPLETE, loaderCompleteListener);
            dataLoader.addEventListener(Event.ERROR, loaderErrorListener);

            function loaderCompleteListener(e) {
                var oldSceneObj = scope.currentView3DObject?.sceneObject;
                var x = oldSceneObj?.x;
                var y = oldSceneObj?.y;
                var z = oldSceneObj?.z;
                var flipX = oldSceneObj?.flipX;
                var flipY = oldSceneObj?.flipY;
                var flipZ = oldSceneObj?.flipZ;
                var rotationX = oldSceneObj?.rotationX;
                var rotationY = oldSceneObj?.rotationY;
                var rotationZ = oldSceneObj?.rotationZ;
                var scaleX = oldSceneObj?.scaleX;
                var scaleY = oldSceneObj?.scaleY;
                var scaleZ = oldSceneObj?.scaleZ;

                scope.currentView3DObject && scope.remove(scope.currentView3DObject.sceneObject);

                var productData = R2D.Pool.getProductData(id);
                var sceneObject = R2D.Creator.makeSceneObject(productData);
                scope.add(sceneObject);

                if ("x" in settings) {
                    sceneObject.x = settings.x;
                } else {
                    sceneObject.x = x;
                }
                if ("y" in settings) {
                    sceneObject.y = settings.y;
                } else {
                    sceneObject.y = y;
                }
                if ("z" in settings) {
                    sceneObject.z = settings.z;
                } else {
                    sceneObject.z = z;
                }
                if ("flipX" in settings) {
                    sceneObject.flipX = settings.flipX;
                } else {
                    sceneObject.flipX = flipX;
                }
                if ("flipY" in settings) {
                    sceneObject.flipY = settings.flipY;
                } else {
                    sceneObject.flipY = flipY;
                }
                if ("flipZ" in settings) {
                    sceneObject.flipZ = settings.flipZ;
                } else {
                    sceneObject.flipZ = flipZ;
                }
                if ("rotationX" in settings) {
                    sceneObject.rotationX = settings.rotationX;
                } else {
                    sceneObject.rotationX = rotationX;
                }
                if ("rotationY" in settings) {
                    sceneObject.rotationY = settings.rotationY;
                } else {
                    sceneObject.rotationY = rotationY;
                }
                if ("rotationZ" in settings) {
                    sceneObject.rotationZ = settings.rotationZ;
                } else {
                    sceneObject.rotationZ = rotationZ;
                }
                if(needToChangeScale) {
                    if ("scaleX" in settings) {
                    sceneObject.scaleX = settings.scaleX;
                    } else {
                        sceneObject.scaleX = scaleX;
                    }
                    if ("scaleY" in settings) {
                        sceneObject.scaleY = settings.scaleY;
                    } else {
                        sceneObject.scaleY = scaleY;
                    }
                    if ("scaleZ" in settings) {
                        sceneObject.scaleZ = settings.scaleZ;
                    } else {
                        sceneObject.scaleZ = scaleZ;
                    };
                }

                sceneObject.update();

                if(sceneObject.forWall) {
                    let dropData = R2D.Scene.getObjectDataForWallElement(sceneObject);
                    let dropResult = constructor.dropElement(dropData, 10);
                    dropResult && R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
                }

                scope.history.saveState();

                changeStateNeed && scope.dispatchEvent(new Event(R2D.Scene.CURRENT_OBJECT_REPLACED));

                resolve(sceneObject);
            }

            function loaderErrorListener(e) {
                console.log("Error loading product ", id);
                console.log(e);
                resolve({type: "error"});
            }
        })
    };

    scope.placeObject = async function (id, settings) {
        return new Promise((resolve) => {
            let dataLoader = R2D.Pool.isLoaderProductData(id);
            if (!dataLoader) dataLoader = R2D.Pool.loadProductData(id);
            dataLoader.addEventListener(Event.COMPLETE, loaderCompleteListener);
            dataLoader.addEventListener(Event.ERROR, loaderErrorListener);

            function loaderCompleteListener(e) {
                const productData = R2D.Pool.getProductData(id);
                const sceneObject = R2D.Creator.makeSceneObject(productData);

                R2D.scene.add(sceneObject);

                if ("x" in settings) sceneObject.x = settings.x;
                if ("y" in settings) sceneObject.y = settings.y;
                if ("z" in settings) sceneObject.z = settings.z;
                if ("flipX" in settings) sceneObject.flipX = settings.flipX;
                if ("flipY" in settings) sceneObject.flipY = settings.flipY;
                if ("flipZ" in settings) sceneObject.flipZ = settings.flipZ;
                if ("rotationX" in settings) sceneObject.rotationX = settings.rotationX;
                if ("rotationY" in settings) sceneObject.rotationY = settings.rotationY;
                if ("rotationZ" in settings) sceneObject.rotationZ = settings.rotationZ;
                if ("scaleX" in settings) sceneObject.scaleX = settings.scaleX;
                if ("scaleY" in settings) sceneObject.scaleY = settings.scaleY;
                if ("scaleZ" in settings) sceneObject.scaleZ = settings.scaleZ;
                if ("isStartCoordInModelCenter" in settings)
                    sceneObject.y = -sceneObject.defaultHeight / 2;
                sceneObject.update();

                if (sceneObject.forWall) {
                    let dropData = R2D.Scene.getObjectDataForWallElement(sceneObject);
                    let dropResult = constructor.dropElement(dropData, 10);
                    dropResult && R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
                }

                R2D.scene.history.saveState();

                resolve(sceneObject);
            }

            function loaderErrorListener(e) {
                console.log("Error loading product ", id);
                console.log(e);
                resolve({type: "error"});
            }
        });
    }

    scope.getHistory = function () {
        return history;
    };
    scope.clear = function () {
        R2D.mouseInteractionHelper.unsetActiveGroup();
        R2D.mouseInteractionHelper.unsetActiveObject();

        scope.currentView3DObject = null; // moved from mouse helper
        scope.currentView3DObjectData = null;
        scope.currentSceneObject = null;
        scope.currentPartNum = -1;
        scope.currentConstructorElementData = null;
        scope.currentGroup = null;

        scope.setSkyboxMat("");
        scope.setSkyboxRotation(0);

        R2D.commonSceneObject.hideContour();

        while (scope.groups.length > 0) {
            R2D.commonSceneHelper.productHelper.removeGroup(scope.groups[0]);
        }

        while (sceneObjects.length > 0) {
            scope.remove(sceneObjects[0]);
        }

        constructor.removeAll();
        constructor.delImageDrawing();
        if(R2D.Viewers.getCurrentViewerType() === "3d") R2D.mouseInteractionHelper._currentViewer.coversTitleViewer3D.disable();
        else if(R2D.Viewers.getCurrentViewerType() === "2d") R2D.mouseInteractionHelper._titlesTool.hide();
        else if(R2D.Viewers.getCurrentViewerType() === "constructor") WC.wallsEditor.titlesTool.hide();
        history.clear();
        history.saveState();

        scope.dispatchEvent(new Event(R2D.Scene.SCENE_CLEARED));
    };
    scope.isEmpty = function () {
        return sceneObjects.length == 0 && constructor.isEmpty();
    };

    constructor.addEventListener(WC.RESET_MODELS, constructorEventHandler);
    history.saveState();

    scope.copy = function () {
        if (scope.currentConstructorElementData) {
            R2D.CopyPaste.copyConstruction(
                scope.currentConstructorElementData,
                scope.currentPartNum
            );
        }
        else if (scope.currentSceneObject) R2D.CopyPaste.copyModel(scope.currentSceneObject);
        else if (scope.currentGroup) R2D.CopyPaste.copyGroup(scope.currentGroup);
    };

    scope.paste = async function () {
        const isClipboardData = await R2D.CopyPaste.checkGlobalClipboard();

        if (isClipboardData) {
            R2D.mouseInteractionHelper.unsetActiveObject();
            R2D.mouseInteractionHelper.api.dispatchEvent(
                new Event(R2D.mouseInteractionHelper.api.QUICK_PANELS_HIDE, {})
            );
            R2D.mouseInteractionHelper.api.dispatchEvent(
                new Event(R2D.mouseInteractionHelper.api.OBJECT_DRAG_OUT_OF_WALL, {})
            );
        }

        if (scope.currentConstructorElementData) {
            R2D.CopyPaste.pasteConstructionTo(
                scope.currentConstructorElementData,
                scope.currentPartNum
            );
        }
           else
           {
                if(R2D.Viewers._instance.getCurrentViewerType() == "constructor") return;
                var pasteObj = R2D.CopyPaste.objFromClipboard();
                var model = await R2D.CopyPaste.pasteModel();
                if (model) {
                    let raycaster = new THREE.Raycaster();
                    let point = R2D.Renderer3D.getMousePointForPicker(R2D.mouseInteractionHelper._currentCanvas, R2D.mouseInteractionHelper.mouseX, R2D.mouseInteractionHelper.mouseY);
                    raycaster.setFromCamera(new THREE.Vector2(point.x, point.y), R2D.mouseInteractionHelper._currentCamera);
                    let data = model.type == R2D.ProductType.POSTER ? raycaster.intersectObjects(R2D.mouseInteractionHelper._commonSceneObject.interactiveObjects.children, true) : raycaster.intersectObject(R2D.mouseInteractionHelper._commonSceneObject.getTerrain(), true);
                    var camData = R2D.Viewers.getCameraData();

                    if(pasteObj.type == "group") {
                        let alreadyExist = false;
                        let grData = pasteObj.value;
                        let prodHelper = R2D.commonSceneHelper.productHelper;
                        let group = prodHelper.addGroup();
                        
                        let viewObjs = prodHelper.view3DObjects;
                        
                        for (let i = 0; i < R2D.scene.groups.length; i++) {
                            
                           if(R2D.scene.groups[i].getObjViews().length == model.length) {
                                if(R2D.scene.groups[i].getObjViews().map(j => j.sceneObject.productId).sort().toString() == model.map(y => y.productId).sort().toString()) {
                                    alreadyExist = true;
                                    
                                    group.copyFrom(R2D.scene.groups[i]);
                                    break;
                                }
                           }
                        }

                        if(!alreadyExist) {
                            for(let i = 0; i < model.length; i++) {
                                scope.add(model[i]);
                            }
                    
                            for (let j = 0; j < grData.objects.length; j++)
                            {
                                for (let k = 0; k < viewObjs.length; k++)
                                {
                                    if (grData.objects[j] == viewObjs[k].sceneObject.objid)
                                    {
                                        group.addUnchanged(viewObjs[k]);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        group.x = data[0]?.point.x;
                        group.y = pasteObj.value.y;
                        group.z = data[0]?.point.z;
                
                        group.rotation = GEOM.toRad(grData.r);
                        group.fx = grData.fx;
                        group.fz = grData.fz;
                
                        group.sx = grData.sx ? grData.sx : 1;
                        group.sy = grData.sy ? grData.sy : 1;
                        group.sz = grData.sz ? grData.sz : 1;
                
                        group.isLockedOnScene = grData.isLockedOnScene ? grData.isLockedOnScene : false;

                        api.dispatchEvent(new Event(api.SET_ACTIVE_GROUP, {group}));

                    } else {
                        let dataObject = data[0];
                        if(model.type == R2D.ProductType.POSTER && R2D.MouseInteractionHelper._instance._constructorHelper.findObjectView3DByObject3D(data[0].object)?.type == "ceiling") dataObject = data[1];
                        if(dataObject) {
                            model.z = dataObject?.point.z;
                            model.y = model.type == R2D.ProductType.POSTER ? dataObject?.point.y < 0 ? 0 : dataObject?.point.y : pasteObj.value.y;
                            model.x = dataObject?.point.x;
                        } else {
                            if(pasteObj?.value) {
                                model.z = pasteObj.value.z;
                                model.y = pasteObj.value.y;
                                model.x = pasteObj.value.x;
                            } else {
                                model.z = 0;
                                model.y = 0;
                                model.x = 0;
                            }
                        }
                        if (camData.type == 'perspective') {
                            var p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
                            var pi4 = Math.PI / 4;
                            if (p > pi4 && p < 3 * pi4)
                            {
                                model.rotationY = -270;
                            }
                            else if (p > 3 * pi4 && p < 5 * pi4)
                            {
                                model.rotationY = -180;
                            }
                            else if (p > 5 * pi4 && p < 7 * pi4)
                            {
                                model.rotationY = -90;
                            }
                            else
                            {
                                model.rotationY = 0;
                            }
                        }
                        
                        scope.add(model);
                        if (!isClipboardData) {
                            api.dispatchEvent(new Event(api.SET_ACTIVE_PRODUCT, { model }));
                        }
                    }
                }
           }

        scope.history.saveState();
    };

    var skyboxGeom = new THREE.SphereGeometry(3000, 60, 40);
    skyboxGeom.scale(-1, -1, 1);
    var skyboxMat = new THREE.MeshBasicMaterial({ color: "#ffffff" });
    var skyboxMesh = new THREE.Mesh(skyboxGeom, skyboxMat);

    var cursorGeom = new THREE.RingGeometry(10, 15, 64);
    var cursorMat = new THREE.MeshBasicMaterial({
        color: 0x9dd900,
        opacity: 0.8,
        transparent: true,
        side: THREE.DoubleSide,
        depthTest: false,
    });
    var cursorMesh = new THREE.Mesh(cursorGeom, cursorMat);
    //cursor3d.rotateX(Math.PI/2);
    cursorMesh.renderOrder = 0;

    scope.repositionSkybox = function () {
        var pos = R2D.Viewers.getCameraData().position;
        skyboxMesh.position.set(pos.x, pos.y, pos.z);
    };

    scope.repositionCursor3D = function (pos, normal) {
        if (!pos) {
            cursorMesh.position.set(0, 1000, 0);
        } else {
            cursorMesh.position.set(pos.x, pos.y, pos.z);
            cursorMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
            cursorMesh.rotateX(Math.PI / 2);
        }
    };

    scope.setSkyboxMat = function (matId) {
        if(!R2D.Viewers.getCameraData()) return;
        return new Promise((resolve, reject) => {
            var matViewer;
            if (matId == R2D.Default.SKYBOX_ID || matId == 0) {
                scope.skyboxId = "";
            } else {
                scope.skyboxId = matId;
            }

            let wasCreated = false;
            if (scope.skyboxId) {
                if (R2D.PoolMaterials.isMaterial(scope.skyboxId)) {
                    matViewer = R2D.PoolMaterials.getMaterial(scope.skyboxId);
                    wasCreated = true;
                } else {
                    matViewer = R2D.PoolMaterials.create(scope.skyboxId);
                    wasCreated = false;
                }

                var pos = R2D.Viewers.getCameraData().position;
                skyboxMesh.position.set(pos.x, pos.y, pos.z);

                matViewer.type = "skybox";

                skyboxMesh.material = matViewer.getMaterial();

                matViewer.addEventListener(Event.UPDATE, matUpdateListener);
                R2D.commonSceneHelper.dispatchUpdate();

                if (wasCreated) resolve(scope.checkSkybox());

                function matUpdateListener(e) {
                    e.currentTarget.removeEventListener(Event.UPDATE, matUpdateListener);
                    R2D.commonSceneHelper.dispatchUpdate();
                    resolve(scope.checkSkybox());
                }
            } else resolve(scope.checkSkybox());
        });
    };

    scope.setSkyboxRotation = function (r) {
        scope.skyboxRotation = r;
        skyboxMesh.rotation.set(0, GEOM.___ratioPI180 * r, 0);
        R2D.commonSceneHelper.dispatchUpdate();
    };

    scope.checkSkybox = function (defId) {
        //if (! cursorMesh.parent) R2D.scene3d.add(cursorMesh, 'top');

        if (
            R2D.Viewers.getCurrentViewerType() == "walk" &&
            scope.skyboxId &&
            scope.skyboxId != R2D.Scene.getDefaultPanoId()
        ) {
            R2D.commonSceneObject.hideTerrain();
            if (!skyboxMesh.parent) R2D.scene3d.add(skyboxMesh, "bottom");
            var pos = R2D.Viewers.getCameraData().position;
            skyboxMesh.position.set(pos.x, pos.y, pos.z);
        } else {
            R2D.commonSceneObject.showTerrain();
            if (skyboxMesh.parent) R2D.scene3d.remove(skyboxMesh, "bottom");
            R2D.commonSceneHelper.dispatchUpdate();
        }
    };

    scope.showCursor = function () {
        if (!R2D.config.isDesktop) return;

        R2D.scene3d.add(cursorMesh, "top");
    };

    scope.hideCursor = function () {
        if (cursorMesh.parent) R2D.scene3d.remove(cursorMesh, "top");
    };

    scope.hideSkybox = function () {
        R2D.commonSceneObject.showTerrain();
        R2D.scene3d.remove(skyboxMesh, "bottom");
        R2D.scene3d.remove(cursorMesh, "top");
    };

    scope.setDefaultPanoId = (id) => (scope.defaultPanoId = id);

    scope.getDefaultPanoId = () => scope.defaultPanoId;

    scope.configurateCurrentObject = function () {
        if (
            !scope.currentView3DObject ||
            scope.currentView3DObject.objectType != "product"
        )
            return;
        R2D.createAppIFrame(
            scope.currentView3DObject.getProductId(),
            null,
        );
    };

    scope.startClearingPool = function () {
        scope.needClearPool = true;
    };

    scope.stopClearingPool = function () {
        scope.needClearPool = false;
    }

    setInterval(() => {
        if (!scope.needClearPool) {
            return;
        }

        const matIdsSceneObj = [
            ...new Set(
                scope.getSceneObjects()?.flatMap && 
                scope
                    .getSceneObjects()
                    .flatMap((el) => (el.getMaterials ? el.getMaterials() : []))
                    .flatMap((el) => [el.addMaterial, el.current])
                    .filter((el) => !!el)
                    .filter(Number)
            ),
        ];

        const matIdsConstr = scope
            .getConstructor()
            .getData()
            .list_materials.filter(Number);

        const matIds = [...matIdsSceneObj, ...matIdsConstr];

        const matIdsPool = Object.keys(R2D.PoolMaterials.__materials);

        matIdsPool.forEach((idPool) => {
            if (!matIds.find((idScene) => idScene === idPool)) {
                R2D.PoolMaterials.remove(idPool);                
            }
        });
    }, 60000);
};

R2D.extend(R2D.Scene, EventDispatcher);

R2D.Scene.OBJECT_ADDED = "objectAdded";
R2D.Scene.OBJECT_REMOVED = "objectRemoved";
R2D.Scene.DRAG_OBJECT = "dragObject";
R2D.Scene.SCENE_CLEARED = "sceneCleared";
R2D.Scene.CURRENT_OBJECT_REMOVED = "currentObjectRemoved";
R2D.Scene.CURRENT_OBJECT_REPLACED = "currentObjectReplaced";

R2D.Scene._PROJECT_VERSION_001 = "version_001";
R2D.Scene._SCENE_VERSION_001 = "version_001";
R2D.Scene._CONSTRUCTOR_VERSION_001 = "version_001";

R2D.Scene._instance = null;

R2D.Scene.init = (api) => {
    R2D.Scene._instance = new R2D.Scene(api);
    return R2D.Scene._instance;
};

R2D.Scene.getDefaultPanoId = () => R2D.Scene._instance.defaultPanoId;

R2D.Scene.getObjectDataForWallElement = function (sceneObject) {
    return {
        id: sceneObject.getObjectId(),
        x: sceneObject.x,
        y: sceneObject.z,
        elevation: sceneObject.y,
        scaleX: sceneObject.scaleX,
        scaleY: sceneObject.scaleY,
        flipX: sceneObject.flipX,
        flipY: sceneObject.flipZ,
        contour: sceneObject.getObjectData()["source"]["body"]["contourCut"],
        addMaterialFrame: sceneObject.getAddMaterialFrame(),
        materialFrame: sceneObject.getMaterialFrame(),
        materialFrameRotation: sceneObject.getMaterialFrameRotation(),
        materialFrameX: sceneObject.getMaterialFrameX(),
        materialFrameY: sceneObject.getMaterialFrameY(),
        addMaterialBottom: sceneObject.getAddMaterialBottom(),
        materialBottom: sceneObject.getMaterialBottom(),
        materialBottomRotation: sceneObject.getMaterialBottomRotation(),
        materialBottomX: sceneObject.getMaterialBottomX(),
        materialBottomY: sceneObject.getMaterialBottomY(),
    };
};
R2D.Scene.setDropDataToWallElement = function (sceneObject, dropData) {
    if(!dropData) return;
    sceneObject.x = dropData.x;
    sceneObject.z = dropData.y;
    sceneObject.rotationY = G.toDeg(dropData.rotation);
    sceneObject.setDepth(dropData.depth + 1);
    sceneObject.update();
};

R2D.Scene.makeConstructionData = function (construction, forRender = false) {
    const data = construction.getData();

    if (forRender) {
        data.construction.walls.forEach((wall) => {
            wall.pltdist = WC.plinthCreator.getDistToCeiling(wall.pltsh);
            wall.plbsh = WC.plinthCreator.getShapePath(wall.plbsh);
            wall.pltsh = WC.plinthCreator.getShapePath(wall.pltsh);
        });
        data.construction.walls.forEach((w) => {
            const wall = R2D.scene.getConstructor().walls.find((el) => el.id === w.id);

            if (w.conf) {
                const meshesOnWall = R2D.commonSceneHelper.constructorHelper
                    .findObjectView3DByConstructionData(wall)
                    .getMeshes();
                const parts = wall.parts;
                w.conf.areas.forEach((area) => {
                    area.trs = {};
                    const part = parts.find((el) => el.id === area.id);
                    area.trs.verts = part.vertices;
                    area.trs.uvs = part.uvs;
                    const mesh = meshesOnWall.find((el) => el.num === area.id);
                    area.trs.norms = [...mesh.geometry.attributes.normal.array];
                });
            } else {
                w.trs = {};
                w.trs.verts = wall.vertices;
                w.trs.uvs = wall.uvs;
                const wall3d = R2D.commonSceneHelper.constructorHelper
                    .findObjectView3DByConstructionData(wall)
                    .getObject3d();
                w.trs.norms = [...wall3d.geometry.attributes.normal.array];
            }
        });

        data.construction.frames = [];
        const axes = R2D.scene.getConstructor().axes;

        axes.forEach((axis) => {
            const frames = axis.frames;
            frames.forEach((frame) => {
                fr = {};
                fr.type = frame.type;
                fr.verts = frame.vertices;
                fr.uvs = frame.uvs;
                const frame3d = R2D.commonSceneHelper.constructorHelper
                    .findObjectView3DByConstructionData(frame)
                    .getObject3d();
                fr.norms = [...frame3d.geometry.attributes.normal.array];
                fr.m = frame.materialID;
                fr.addM = frame.addMaterialID;

                data.construction.frames.push(fr);
            });
        });
    }

    return data;
};

//scene
R2D.Scene.makeSceneObjectData = function (sceneObject, forRender = false) {
    var data = {
        id: sceneObject.getProductId(),
        objid: String(sceneObject.getObjectId()),
        type: sceneObject.getType(),
        x: sceneObject.x,
        y: sceneObject.y,
        z: -sceneObject.z,
        sx: sceneObject.scaleX,
        sy: sceneObject.scaleY,
        sz: sceneObject.scaleZ,
        rx: sceneObject.rotationX,
        ry: -sceneObject.rotationY,
        rz: sceneObject.rotationZ,
        width: sceneObject.width,
        height: sceneObject.height,
        isLockedOnScene: sceneObject.isLockedOnScene || false
    };

    if (sceneObject.configInfo) data.configInfo = sceneObject.configInfo;

    if (data.type == R2D.ProductType.MODEL) {
        data["fx"] = sceneObject.flipX ? 1 : 0;
        data["fy"] = sceneObject.flipY ? 1 : 0;
        data["fz"] = sceneObject.flipZ ? 1 : 0;
        data["materials"] = sceneObject.getMaterials();
        //data['materials'].push(sceneObject.getMaterialFrame());
        //data['materials'].push(sceneObject.getMaterialBottom());

        // ------------get new UV----------------
        if (forRender) {
            if (sceneObject.rotationX !== 0 || sceneObject.rotationZ !== 0) {
                const worldQuaternion = new THREE.Quaternion();
                const viewer3d =
                    R2D.commonSceneHelper.productHelper.findObjectView3dBySceneObject(
                        sceneObject
                    );
                viewer3d.object3d.getWorldQuaternion(worldQuaternion);
                data["q"] = worldQuaternion
                    .toArray()
                    .map((el) => Math.round(el * 10000) / 10000);
            }
            if (
                sceneObject.scaleX === 1 &&
                sceneObject.scaleY === 1 &&
                sceneObject.scaleZ === 1
            ) {
                data["materials"].forEach((material) => {
                    material.newUV = "";
                });
            } else {
                const viewer3d =
                    R2D.commonSceneHelper.productHelper.findObjectView3dBySceneObject(
                        sceneObject
                    );

                data["materials"].forEach((material) => {
                    const hash = material.hash;
                    if (!hash) {
                        material.newUV = "";
                    } else {
                        const mesh = viewer3d.getMeshByHash(hash);
                        const uvArr = mesh.geometry.attributes.uv.array;
                        const uvStrTransformed = transformUVForRender(uvArr);
                        material.newUV = uvStrTransformed;
                    }
                });
            }
        }

        function transformUVForRender(uvArr) {
            return [...uvArr]
                .map((coord, index) => (index % 2 === 0 ? coord : 1 - coord))
                .map((el) => el.toFixed(4))
                .join(" ");
        }
        // ------------------------------

        if ( sceneObject.forWall ) {
            data['mf'] = sceneObject.getMaterialFrame();
            data['addMf'] = sceneObject.getAddMaterialFrame();
            data['mfr'] = sceneObject.getMaterialFrameRotation();
            data['mfx'] = sceneObject.getMaterialFrameX();
            data['mfy'] = sceneObject.getMaterialFrameY();
            data['mb'] = sceneObject.getMaterialBottom();
            data['addMb'] = sceneObject.getAddMaterialBottom();
            data['mbr'] = sceneObject.getMaterialBottomRotation();
            data['mbx'] = sceneObject.getMaterialBottomX();
            data['mby'] = sceneObject.getMaterialBottomY();
        }
    } else if (data.type == R2D.ProductType.POSTER || data.type == R2D.ProductType.CARPET) {
        if (forRender) {
            if (sceneObject.rotationX !== 0 || sceneObject.rotationZ !== 0) {
                const worldQuaternion = new THREE.Quaternion();
                const viewer3d =
                    R2D.commonSceneHelper.productHelper.findObjectView3dBySceneObject(
                        sceneObject
                    );
                viewer3d.object3d.getWorldQuaternion(worldQuaternion);
                data["q"] = worldQuaternion
                    .toArray()
                    .map((el) => Math.round(el * 10000) / 10000);
            }
        }
    }

    return data;
};
R2D.Scene.makeSceneGroupData = function (group, forRender = false) {
    var data = {
        objects: [],
        objectsData: [],

        x: group.x,
        y: group.y,
        z: group.z,

        r: GEOM.toDeg(group.rotation),
        fx: group.fx ? 1 : 0,
        fz: group.fz ? 1 : 0,

        sx: group.sx,
        sy: group.sy,
        sz: group.sz,
        isLockedOnScene: group.isLockedOnScene || false
    };

    var objs = group.getObjViews();

    for (var i = 0; i < objs.length; i++)
        data.objects.push(String(objs[i].sceneObject.getObjectId()));

    for (var i = 0; i < objs.length; i++) {
        let sceneObject = objs[i].sceneObject;
        data.objectsData.push({
            id: sceneObject.getProductId(),
            objid: String(sceneObject.getObjectId()),
            type: sceneObject.getType(),
            x: sceneObject.x,
            y: sceneObject.y,
            z: sceneObject.z,
            sx: sceneObject.scaleX,
            sy: sceneObject.scaleY,
            sz: sceneObject.scaleZ,
            rx: sceneObject.rotationX,
            ry: -sceneObject.rotationY,
            rz: sceneObject.rotationZ,
            width: sceneObject.width,
            height: sceneObject.height,
            isLockedOnScene: sceneObject.isLockedOnScene || false
        });
        data.objectsData[i]["fx"] = sceneObject.flipX ? 1 : 0;
        data.objectsData[i]["fy"] = sceneObject.flipY ? 1 : 0;
        data.objectsData[i]["fz"] = sceneObject.flipZ ? 1 : 0;
        data.objectsData[i]["materials"] = sceneObject.getMaterials && sceneObject.getMaterials();

        // ------------get new UV----------------
        if (forRender) {
            if (sceneObject.rotationX !== 0 || sceneObject.rotationZ !== 0) {
                const worldQuaternion = new THREE.Quaternion();
                const viewer3d =
                    R2D.commonSceneHelper.productHelper.findObjectView3dBySceneObject(
                        sceneObject
                    );
                viewer3d.object3d.getWorldQuaternion(worldQuaternion);
                data.objectsData[i]["q"] = worldQuaternion
                    .toArray()
                    .map((el) => Math.round(el * 10000) / 10000);
            }
            if (
                sceneObject.scaleX === 1 &&
                sceneObject.scaleY === 1 &&
                sceneObject.scaleZ === 1
            ) {
                data.objectsData[i]["materials"].forEach((material) => {
                    material.newUV = "";
                });
            } else {
                const viewer3d =
                    R2D.commonSceneHelper.productHelper.findObjectView3dBySceneObject(
                        sceneObject
                    );

                data.objectsData[i]["materials"].forEach((material) => {
                    const hash = material.hash;
                    if (!hash) {
                        material.newUV = "";
                    } else {
                        const mesh = viewer3d.getMeshByHash(hash);
                        const uvArr = mesh.geometry.attributes.uv.array;
                        const uvStrTransformed = transformUVForRender(uvArr);
                        material.newUV = uvStrTransformed;
                    }
                });
            }
        }

        function transformUVForRender(uvArr) {
            return [...uvArr]
                .map((coord, index) => (index % 2 === 0 ? coord : 1 - coord))
                .map((el) => el.toFixed(4))
                .join(" ");
        }
        // ------------------------------

        if ( sceneObject.forWall ) {
            data.objects[i]['mf'] = sceneObject.getMaterialFrame();
            data.objects[i]['addMf'] = sceneObject.getAddMaterialFrame();
            data.objects[i]['mfr'] = sceneObject.getMaterialFrameRotation();
            data.objects[i]['mfx'] = sceneObject.getMaterialFrameX();
            data.objects[i]['mfy'] = sceneObject.getMaterialFrameY();
            data.objects[i]['mb'] = sceneObject.getMaterialBottom();
            data.objects[i]['addMb'] = sceneObject.getAddMaterialBottom();
            data.objects[i]['mbr'] = sceneObject.getMaterialBottomRotation();
            data.objects[i]['mbx'] = sceneObject.getMaterialBottomX();
            data.objects[i]['mby'] = sceneObject.getMaterialBottomY();
        }
    }

    return data;
};
R2D.Scene.makeSceneObjectsData = function (sceneObjects, groups, forRender = false) {
    var products = new Array(sceneObjects.length);
    var list_products = [];
    var list_materials = [];

    for (var i = 0, l = sceneObjects.length; i < l; i++) {
        products[i] = R2D.Scene.makeSceneObjectData(sceneObjects[i], forRender);

        list_products.push(products[i].id);
        if (products[i].materials) {
            for (var j = 0; j < products[i].materials.length; j++) {
                list_materials.push(products[i].materials[j].current);
            }
        }
        if (sceneObjects[i].getMaterialFrame && sceneObjects[i].getMaterialFrame())
            list_materials.push(sceneObjects[i].getMaterialFrame());
        if (sceneObjects[i].getMaterialBottom && sceneObjects[i].getMaterialBottom())
            list_materials.push(sceneObjects[i].getMaterialBottom());
    }

    var groupsData = [];
    for (i = 0; i < groups.length; i++) {
        groupsData.push(R2D.Scene.makeSceneGroupData(groups[i]));
    }

    return {
        products: products,
        list_products: list_products,
        list_materials: list_materials,
        groups: groupsData,
    };
};

//
R2D.Scene.findFarObject = function (sceneObjects) {
    if (sceneObjects.length < 1) return [];

    var minFarObjects = 10;
    var maxDistanceDelta = 2000;
    var center = new GEOM.Point(0, 0);
    var summ = new GEOM.Point(0, 0);
    var distances = [];
    var farObjects = [];
    var farSceneObjects = [];
    var len = sceneObjects.length;
    var sceneObject = null;
    var i, l;
    var countMax = 100000;
    var count = 0;

    for (count = 0, i = 0, l = len; i < l && count < countMax; i++, count++) {
        sceneObject = sceneObjects[i];
        summ.x += sceneObject.x;
        summ.y += sceneObject.z;
    }
    if (count == countMax) {
        console.error("Find far objects error!");
        return [];
    }

    center.x = summ.x / len;
    center.y = summ.y / len;

    for (count = 0, i = 0, l = len; i < l && count < countMax; i++, count++) {
        sceneObject = sceneObjects[i];
        distances.push({
            distance: GEOM.Point.distance(
                new GEOM.Point(sceneObject.x, sceneObject.z),
                center
            ),
            sceneObject: sceneObject,
        });
    }
    if (count == countMax) {
        console.error("Find far objects error!");
        return [];
    }

    distances.sort(function (a, b) {
        if (a.distance < b.distance) return 1;
        if (a.distance > b.distance) return -1;

        return 0;
    });

    for (
        count = 0, i = 0, l = distances.length - 1;
        i < l && count < countMax;
        i++, count++
    ) {
        if (
            Math.abs(distances[i].distance - distances[i + 1].distance) > maxDistanceDelta
        ) {
            farObjects = farObjects.concat(distances.splice(0, i + 1));
            i = 0;
            l = distances.length - 1;

            if (farObjects.length >= minFarObjects) return [];
        }
    }
    if (count == countMax) {
        console.error("Find far objects error!");
        return [];
    }

    for (i = 0, l = farObjects.length; i < l; i++) {
        farSceneObjects.push(farObjects[i].sceneObject);
    }

    return farSceneObjects;
};

// core

R2D.SceneRename = function(planId, oldName, newName) {
    EventDispatcher.call(this);

    var scope = this;
    var loader = null;

    function checkResultData(data) {
        var object = null;

        try {
            object = JSON.parse(data);
        } catch ( error ) {
            console.error("Error parse JSON string!");
            console.log(data);
            return false;
        }
        if ( !object.hasOwnProperty('status') ) {
            console.error('Object has no property "status"!');
            console.log(object);
            return false;
        }
        if ( object['status'] != 'success' ) {
            console.error('Rename plan ' + planId + ' error!');
            console.log(object);
            return false;
        }

        return true;
    }
    function removeLoader() {
        if ( loader == null ) return;

        loader.removeEventListener(Event.COMPLETE, loaderEventHandler);
        loader.removeEventListener(Event.ERROR, loaderEventHandler);
        loader.close();
        loader = null;
    }
    function loaderEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            if ( checkResultData(event.data.data) ) {
                scope.dispatchEvent(new Event(Event.COMPLETE, scope));
            } else {
                scope.dispatchEvent(new Event(Event.ERROR, scope));
            }
        } else {
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        removeLoader();
    }

    scope.getSceneId = function() { return planId };
    scope.getSceneName = function() { return newName };
    scope.getSceneNameOld = function() { return oldName };
    scope.execute = function() {
        var params = 'json=' + JSON.stringify({
                plan_id:planId,
                plan_name:newName,
                plan_old_name:oldName
            });
        var url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_RENAME_PLAN);

        loader = R2D.XHRLoader.getPostLoader(url, params, null, null, true);

        loader.addEventListener(Event.COMPLETE, loaderEventHandler);
        loader.addEventListener(Event.ERROR, loaderEventHandler);
    };
    scope.dispose = function() {
        removeLoader();
    };
};

R2D.extend(R2D.SceneRename, EventDispatcher);
// core

R2D.SceneCopy = function(planId, oldName, newName) {
    EventDispatcher.call(this);

    let scope = this;
    let loader = null;
    let newId = null;
    let newHash = null;

    function checkResultData(data) {
        let object = null;

        try {
            object = JSON.parse(data);
        } catch ( error ) {
            console.error("Error parse JSON string!");
            console.log(data);
            return false;
        }
        if ( !object.hasOwnProperty('status') ) {
            console.error('Object has no property "status"!');
            console.log(object);
            return false;
        }
        if ( !object.hasOwnProperty('plan') ) {
            console.error('Object has no property "plan"!');
            console.log(object);
            return false;
        }
        if ( object['status'] != 'success' ) {
            console.error('Copy plan ' + planId + ' error!');
            console.log(object);
            return false;
        }

        newId = object['plan'];

        newHash = object['hash'];

        return true;
    }
    function removeLoader() {
        if ( loader == null ) return;

        loader.removeEventListener(Event.COMPLETE, loaderEventHandler);
        loader.removeEventListener(Event.ERROR, loaderEventHandler);
        loader.close();
        loader = null;
    }
    function loaderEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            if ( checkResultData(event.data.data) ) {
                console.log('Copied id: ', newId);
                scope.dispatchEvent(new Event(Event.COMPLETE, scope));
            } else {
                scope.dispatchEvent(new Event(Event.ERROR, scope));
            }
        } else {
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        removeLoader();
    }

    scope.getNewId = function() { return newId };
    scope.getNewHash = function() { return newHash };
    scope.getSceneId = function() { return planId };
    scope.getSceneName = function() { return newName };
    scope.getSceneNameOld = function() { return oldName };
    scope.execute = function() {
        let params = 'json=' + JSON.stringify({
                plan_id:planId,
                plan_new_name:newName,
                plan_old_name:oldName
            });
        let url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_COPY_PLAN);

        loader = R2D.XHRLoader.getPostLoader(url, params, null, null, true);

        loader.addEventListener(Event.COMPLETE, loaderEventHandler);
        loader.addEventListener(Event.ERROR, loaderEventHandler);
    };
    scope.dispose = function() {
        removeLoader();
    };
};

R2D.extend(R2D.SceneRename, EventDispatcher);
// core

R2D.SceneDelete = function(planId) {
    EventDispatcher.call(this);

    var scope = this;
    var loader = null;

    function checkResultData(data) {
        var object = null;

        try {
            object = JSON.parse(data);
        } catch ( error ) {
            console.error("Error parse JSON string!");
            console.log(data);
            return false;
        }
        if ( !object.hasOwnProperty('status') ) {
            console.error('Object has no property "status"!');
            console.log(object);
            return false;
        }
        if ( object['status'] != 'success' ) {
            console.error('Delete plan ' + planId + ' error!');
            console.log(object);
            return false;
        }

        return true;
    }
    function removeLoader() {
        if ( loader == null ) return;

        loader.removeEventListener(Event.COMPLETE, loaderEventHandler);
        loader.removeEventListener(Event.ERROR, loaderEventHandler);
        loader.close();
        loader = null;
    }
    function loaderEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            if ( checkResultData(event.data.data) ) {
                scope.dispatchEvent(new Event(Event.COMPLETE, scope));
            } else {
                scope.dispatchEvent(new Event(Event.ERROR, scope));
            }
        } else {
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        removeLoader();
    }

    scope.getSceneId = function() { return planId };
    scope.execute = function() {
        var params = 'json=' + JSON.stringify({
                plan_id:planId
            });
        var url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_DELETE_PLAN);

        loader = R2D.XHRLoader.getPostLoader(url, params, null, null, true);

        loader.addEventListener(Event.COMPLETE, loaderEventHandler);
        loader.addEventListener(Event.ERROR, loaderEventHandler);
    };
    scope.dispose = function() {
        removeLoader();
    };
};

R2D.extend(R2D.SceneDelete, EventDispatcher);
// core

R2D.Controller = function(scene, apiDispatcher) {
    EventDispatcher.call(this);

    let scope = this;
    let sceneLoader = null;
    let isSaving = false;
    let notificationSaving = null;

    let country = null;

    scope.savedLastChanges = false;

    async function setSceneData(data)
    {
        if(!data) return;
        let constructionData = data['construction'];
        let floorplanData = data['floorplan'];
        
        let sceneObjects = await R2D.Creator.makeFromLoadedData(data['scene']['products']);

        scene.updateProjectId(data['id']);
        scene.updateExtraData(data['extraData']);
        scene.updateProjectHash(data['hash']);
        scene.updateProjectName(data['name']);
        scene.updateProjectDimension(data['dimension']);
        scene.updateProjectUserKey(data['user_key']);

        const plinthsIdsUnique = [
            ...new Set(
                constructionData.walls.flatMap((wall) => [
                    `${wall.plbsh}`,
                    `${wall.pltsh}`,
                ])
            ),
        ];

        const arrOfPromises = plinthsIdsUnique.map(
            async (id) => await WC.plinthCreator?.loadSVG(id)
        );

        await Promise.all(arrOfPromises);

        scene.constructor.setData(constructionData);

        let loadedProjectData = {
            id: 0,
            rotation: 0,
            viewState: "",
            hash: data.hash,
            name: data['name']
        };

        if (data['scene']['skybox'])
        {
            if (data['scene']['skybox']['id']) scene.setSkyboxMat(data['scene']['skybox']['id']);
            if (data['scene']['skybox']['r']) scene.setSkyboxRotation(data['scene']['skybox']['r']);
            loadedProjectData.id = data['scene']['skybox']['id'];
            loadedProjectData.rotation = data['scene']['skybox']['r'];
        }

        if ( floorplanData ) {
            floorplanData['drawing']['source'] = ~floorplanData['drawing']['source'].indexOf("base64") ? floorplanData['drawing']['source'] : R2D.makeURL(R2D.URL.DOMAIN, floorplanData['drawing']['source']);
            scene.constructor.setDrawingData(floorplanData);
            R2D.commonSceneHelper.drawingHelper.state = parseInt(floorplanData['drawing']['display']);
        }
        else R2D.commonSceneHelper.drawingHelper.state = null;

        for ( let i = 0, l = sceneObjects.length; i < l; i++ ) {
            scene.add(sceneObjects[i]);
        }

        if (data['scene']['groups']) loadGroups(data['scene']['groups']);

        scene.removeFarSceneObjects();
        scene.history.clear();
        scene.history.saveState();

        R2D.Viewers.setViewState(data['scene']['viewState']);

        if(data['scene']['viewState']) loadedProjectData.viewState = data['scene']['viewState'];

        return loadedProjectData;
    }

    function loadGroups(groupsData)
    {
        let prodHelper = R2D.commonSceneHelper.productHelper;
        let viewObjs = prodHelper.view3DObjects;

        for (let i = 0; i < groupsData.length; i++)
        {
            let grData = groupsData[i];

            let group = prodHelper.addGroup();

            for (let j = 0; j < grData.objects.length; j++)
            {
                for (let k = 0; k < viewObjs.length; k++)
                {
                    if (grData.objects[j] == viewObjs[k].sceneObject.objid)
                    {
                        group.addUnchanged(viewObjs[k]);
                        break;
                    }
                }
            }

            group.x = grData.x;
            group.y = grData.y;
            group.z = grData.z;

            group.rotation = GEOM.toRad(grData.r);
            group.fx = grData.fx;
            group.fz = grData.fz;

            group.sx = grData.sx ? grData.sx : 1;
            group.sy = grData.sy ? grData.sy : 1;
            group.sz = grData.sz ? grData.sz : 1;

            group.isLockedOnScene = grData.isLockedOnScene ? grData.isLockedOnScene : false;
        }
    }
    function sendSceneDataOnServer(project)
    {
        return new Promise((resolve, reject) => {
            if (R2D.Viewers.getCurrentViewerType() == 'constructor')
            {
                R2D.viewConstructor.setStructureToWallsData();
            }

            let sceneData = scene.getSceneState();

            let floorplanData = sceneData['floorplan'];
            let preview = R2D.Viewers.makePreviewScreenShot();
            let topview = R2D.Viewers.makePreviewScreenShot();
            let sceneSaver = new R2D.SceneSaver();
            let planData = null;

            sceneData.preview = preview.split(',')[1];//preview.replace(regexp, '');

            if ( floorplanData != null ) {
                floorplanData['drawing']['source'] = floorplanData['drawing']['source'].split(',')[1];//floorplanData['drawing']['source'].replace(regexp, '');
                floorplanData['drawing']['display'] = R2D.commonSceneHelper.drawingHelper.state;
            }

            planData = {
                plan:sceneData
            };

            sceneSaver.addEventListener(Event.COMPLETE, sceneSaverEventHandler);
            sceneSaver.addEventListener(Event.ERROR, sceneSaverEventHandler);
            sceneSaver.save(planData);


            function sceneSaverEventHandler(event) {
                let sceneSaver = event.currentTarget;
                let data = event.data;
        
                sceneSaver.removeEventListener(Event.COMPLETE, sceneSaverEventHandler);
                sceneSaver.removeEventListener(Event.ERROR, sceneSaverEventHandler);
                sceneSaver.close();
                sceneSaver = null;
        
                isSaving = false;
        
                if ( notificationSaving ) {
                //    R2D.Notification.hide(notificationSaving);
        
                    notificationSaving = null;
                }
        
                if ( event.type == Event.COMPLETE )
                {
                    R2D.scene.updateProjectId(data['plan_id']);
                    R2D.scene.updateProjectHash(data['hash']);
                    scope.dispatchEvent(new Event(R2D.Controller.SAVE_CURRENT_SCENE_COMPLETE, scope));
                    scope.savedLastChanges = true;
        
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.PROJECT_SAVE_COMPLETE, {}));

                    R2D.config.data.enable_set_project && R2D.postMessageToParent(JSON.stringify({
                        action: "set_project",
                        projectId: data['plan_id']
                    }));

                    resolve();
                } else {
                    console.error('Scene save error!');
                    scope.dispatchEvent(new Event(R2D.Controller.SAVE_CURRENT_SCENE_ERROR, scope));
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.PROJECT_SAVE_ERROR, event));
                }
            }

            isSaving = true;
        })
        
    }

    scope.setCountry = function (value) {
        country = value;
    }

    scope.getCountry = function () {
        return country;
    }

    scope.getTextData = function()
    {
        return JSON.stringify(scope.getObjData());
    };

    scope.getObjData = function()
    {
        if (R2D.Viewers.getCurrentViewerType() == 'constructor')
        {
            R2D.viewConstructor.setStructureToWallsData();
        }

        let sceneData = scene.getSceneState();

        let floorplanData = sceneData['floorplan'];
        let preview = R2D.Viewers.makePreviewScreenShot();

        sceneData.preview = preview.split(',')[1];
        sceneData.user_key = null;

        if ( floorplanData != null ) {
            //floorplanData['drawing']['source'] = floorplanData['drawing']['source'].split(',')[1];//floorplanData['drawing']['source'].replace(regexp, '');
            floorplanData['drawing']['display'] = R2D.commonSceneHelper.drawingHelper.state;
        }

        return sceneData;
    };

    scope.setTextData = function(json)
    {
        return new Promise((resolve, reject) => {
            scope.clearCurrentScene(true);

            sceneLoader = new R2D.SceneLoader();

            sceneLoader.addEventListener(Event.COMPLETE, loadListener);
            sceneLoader.addEventListener(Event.ERROR, loadListener);
            sceneLoader.loadFromString(json);

            async function loadListener(event)
            {
                if (event.type == Event.COMPLETE )
                {
                    let result = await setSceneData(sceneLoader['sceneData']);
                    scope.savedLastChanges = true;
                    resolve(result);
                } else {
                    resolve(null);
                    //scope.dispatchEvent(new Event(Event.ERROR, scope));
                }
            }
        })
    };

    scope.trySaveProjectToStorage = function()
    {
        let str = scope.getTextData();
        R2D.Storage.save('r2d_project', str);
    };

    scope.tryLoadProjectFromStorage = function()
    {
        return new Promise(async (resolve, reject) => {
            let str = R2D.Storage.load('r2d_project');
            if (! str) resolve(null);
            else {
                let result = await scope.setTextData(str);
                if(result) {
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.PROJECT_LOADED, result));
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.ESTIMATION_SEND, {}));
                    resolve(result);
                }
                
                else {
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.PROJECT_LOADED, {status: "error", data: {status: "error"}}));
                    resolve(null);
                }
            }
        })
        
    };

    scope.clearStorage = function()
    {
        R2D.Storage.clear('r2d_project');
    };

    scope.estimationToFile = function()
    {
        let constrObj = scene.constructor.getEstimate();
        let prodDict = {};

        let sceneObjects = scene.getSceneObjects();
        for (let obj of sceneObjects)
        {
            let id = obj.getProductId();
            if (id in prodDict)
            {
                prodDict[id] += 1;
            }
            else
            {
                prodDict[id] = 1;
            }
        }

        const file = new Blob([JSON.stringify(Object.assign(constrObj, {products: prodDict}))], {type: 'text'});

        const a = document.createElement('a');
        a.href = URL.createObjectURL(file);
        a.download = 'plan.json';
        a.click();

        URL.revokeObjectURL(a.href);
    };
    scope.getEstimation = function()
    {
        var constrObj = scene.constructor.getEstimate();
        var products = [];

        var sceneObjects = scene.getSceneObjects();

        var walls = {};

        function fillWallsMaterials(data) {
            var t = [];
            for (var material_id in data) {
                t.push(
                    {
                        material_id,
                        addMaterial_id: data[material_id].addMaterialID ? data[material_id].addMaterialID : "",
                        value: data[material_id].addMaterialID ? data[material_id].area : data[material_id],
                    }
                );
            }
            return t;
        }

        walls.materialsCeiling = fillWallsMaterials(constrObj.materialsCeiling);
        walls.materialsFloor = fillWallsMaterials(constrObj.materialsFloor);
        walls.materialsWall = fillWallsMaterials(constrObj.materialsWall);
        walls.plinths = constrObj.plinths;

        for (var obj of sceneObjects)
        {
            var product = {};
            var id = obj.getProductId();
            product.model_id = id;
            product.name = obj.getName();
            product.width = obj.width;
            product.height = obj.height;
            product.depth = obj.depth;
            product.geometries = [];

            var materials = obj.getMaterials();
            for (var i = 0; i < materials.length; i++) {
                const material = materials[i];
                product.geometries.push(
                    {
                        'name': material.name,
                        'material_id': material.current,
                        'addMaterial': material.addMaterial
                    },
                );
            }
            products.push(product);
        }

        return {
            rooms: constrObj.rooms,
            wallsHeight: constrObj.wallsHeight,
            walls,
            products,
        };
    };

    scope.planToFile = function()
    {
        const file = new Blob([scope.getTextData()], {type: 'text'});

        const a = document.createElement('a');
        a.href = URL.createObjectURL(file);
        a.download = 'plan.json';
        a.click();

        URL.revokeObjectURL(a.href);
    };
    document.addEventListener('keydown', keyDownListener);
    function keyDownListener(e)
    {
        if (e.ctrlKey && e.altKey && e.code == 'KeyS')
        {
            //scope.trySaveProjectToStorage();
            //return;
            scope.planToFile();
        }
        else if (e.ctrlKey && e.altKey && e.code == 'KeyO')
        {
            //scope.tryLoadProjectFromStorage();
            //return;

            let inputFile = document.createElement('input');
            inputFile.accept='.json';

            function inputFileChangeEventHandler(event) {
                let jsonFile = event.currentTarget.files[0];

                inputFile.removeEventListener('change', inputFileChangeEventHandler);
                inputFile = null;

                let fr = new FileReader();
                fr.onload = function()
                {
                    scope.setTextData(fr.result);
                };

                fr.readAsText(jsonFile);
            }

            inputFile.setAttribute('type', 'file');
            inputFile.addEventListener('change', inputFileChangeEventHandler);
            inputFile.click();
        }
        else if (e.ctrlKey && e.altKey && e.code == 'KeyE')
        {
            //scope.trySaveProjectToStorage();
            //return;
            scope.estimationToFile();
        }
    }

    Object.defineProperties(scope, {
        "scene":{
            get() { return scene; }
        }
    });

    scope.getScene = function() { return scene };
    scope.addSceneObject = function(sceneObject) {
        scene.add(sceneObject);
    };
    scope.dragSceneObject = function(sceneObject) {
        scene.drag(sceneObject);
    };
    scope.createNewScene = function(ignoreConfirm) {
        let confirm = null;

        function newScene() {
            
            scene.clear();
            scene.updateProjectId(0);
            scene.updateProjectUserKey('');
        }
        newScene();
    };
    scope.getProjectId = function() {
        return scene.getProjectId();
    };
    scope.getProjectUserKey = function() {
        return scene.getProjectUserKey();
    };
    scope.loadScene = function(projectId, asHash) {

        return new Promise((resolve, reject) => {
            scope.clearCurrentScene(true);

            sceneLoader = new R2D.SceneLoader(apiDispatcher);

            sceneLoader.addEventListener(Event.COMPLETE, eventLoadSceneHandler);
            sceneLoader.addEventListener(Event.ERROR, eventLoadSceneHandler);
            sceneLoader.load(projectId, asHash);

            async function eventLoadSceneHandler(event) {
                if ( event.type == Event.COMPLETE ) {
                    if(!sceneLoader) return;
                    if (R2D.Viewers.getCurrentViewerType() == 'constructor') R2D.Viewers.enableViewer(1);
                    let result = await setSceneData(sceneLoader['sceneData']);
                    
                    scope.dispatchEvent(new Event(Event.COMPLETE, scope));
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.PROJECT_LOADED, result));
                    scope.savedLastChanges = true;
                } else {
                    scope.dispatchEvent(new Event(Event.ERROR, scope));
                    apiDispatcher.dispatchEvent(new Event(apiDispatcher.PROJECT_LOADED, {status: "error", data: event}));
                }
                if(!sceneLoader) return;
                sceneLoader.removeEventListener(Event.COMPLETE, eventLoadSceneHandler);
                sceneLoader.removeEventListener(Event.ERROR, eventLoadSceneHandler);
                sceneLoader.dispose();
                sceneLoader = null;

                R2D.config.data.enable_set_project && R2D.postMessageToParent(JSON.stringify({
                    action: "set_project",
                    projectId
                }));

                apiDispatcher.dispatchEvent(new Event(apiDispatcher.ESTIMATION_SEND, {}));

                resolve(R2D.Viewers.getCurrentViewerType());
            }
        })
    };

    scope.saveCurrentScene = async function(project)
    {
        if(project) {
            if(project.name) R2D.scene.updateProjectName(project.name);
            if(project.createNew) R2D.scene.updateProjectId(0);
        }
        
        await sendSceneDataOnServer();
    };

    scope.clearCurrentScene = function(ignoreConfirm) {
        let windowConfirm = null;

        function actionEventHandler(event) {
            windowConfirm.removeEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, actionEventHandler);
            windowConfirm.removeEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, actionEventHandler);

            R2D.DialogStage.hide(windowConfirm);

            if ( event.type == R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE ) {
                scene.clear();
            }
        }

        if ( ignoreConfirm ) {
            scene.clear();
        } else {
            windowConfirm = R2D.DialogStage.getWindowConfirm(R2D.TRANSLATION.TEXT_CLEAR_SCENE, R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);

            windowConfirm.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, actionEventHandler);
            windowConfirm.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, actionEventHandler);

            R2D.DialogStage.show(windowConfirm);
        }
    };
    scope.renameCurrentScene = newName => {
        return new Promise((resolve, reject) => {
            let projectId = scene.getProjectId();
            let projectName = scene.getProjectName();
            let sceneRenamer = null;

            sceneRenamer = new R2D.SceneRename(projectId, projectName, newName);

            sceneRenamer.addEventListener(Event.COMPLETE, sceneRenamerEventHandler);
            sceneRenamer.addEventListener(Event.ERROR, sceneRenamerEventHandler);
            sceneRenamer.execute();

            function sceneRenamerEventHandler(event) {
                if ( event.type == Event.COMPLETE ) {
                    scene.updateProjectName(sceneRenamer.getSceneName());
                    resolve({status: "success"});
                } else {
                    resolve({status: "error", data: "NOTIFY_RENAME_PLAN_ERROR"});
                }

                sceneRenamer.removeEventListener(Event.COMPLETE, sceneRenamerEventHandler);
                sceneRenamer.removeEventListener(Event.ERROR, sceneRenamerEventHandler);
                sceneRenamer.dispose();
                sceneRenamer = null;
            }
        })
    };
    scope.checkProjectForLoad = function() {
        return new Promise(async (resolve, reject) => {
            if(window.location.pathname.match("/project/")) {
                let projectHash = window.location.pathname.split("/project/")[1];
                let result = await scope.loadScene(projectHash, true);
                resolve(result);
            }
            else if ( R2D.OPTIONS.PLAN_ID && R2D.OPTIONS.PLAN_ID != '' ) {
                let result = await scope.loadScene(R2D.OPTIONS.PLAN_ID, false);
                resolve(result);
            } else if ( R2D.OPTIONS.PLAN_HASH && R2D.OPTIONS.PLAN_HASH != '' ) {
                let result = await scope.loadScene(R2D.OPTIONS.PLAN_HASH, true);
                resolve(result);
            } else {
                resolve(null);
            }
        })
        
    };
    scope.sceneIsEmpty = function() {
        return scene.isEmpty();
    };
    scope.renderProject = function(projectId) {
        let wait = R2D.DialogStage.getWindowInfo("Sending...");
        let url = `${R2D.URL.DOMAIN}${R2D.URL.URL_RENDER_NEW}?project_id=${projectId}`;
        let loader = new R2D.XHRLoader();

        function eventHandler(event) {
            R2D.DialogStage.hide(wait);

            if ( event.type == Event.ERROR ) {
                R2D.DialogStage.show(R2D.DialogStage.getWindowAlert("Sending error!", "OK"));
                return;
            }

            let json = event.data.data;
            let data = null;

            try { data = JSON.parse(json) }
            catch ( error ) {
                R2D.DialogStage.show(R2D.DialogStage.getWindowAlert("Sending error!", "OK"));
                return;
            }

            if ( !data.status ) {
                R2D.DialogStage.show(R2D.DialogStage.getWindowAlert("Sending error!\nReceived bad data.", "OK"));
                return;
            }
            if ( data.status == 'error' ) {
                R2D.DialogStage.show(R2D.DialogStage.getWindowAlert(data.error, "OK"));
                return;
            }
            if ( data.status == 'success' ) {
                R2D.DialogStage.show(R2D.DialogStage.getWindowAlert("Sending complete!", "OK"));
                return;
            }

            R2D.DialogStage.show(R2D.DialogStage.getWindowAlert("Something wrong!", "OK"));
        }

        loader.addEventListener(Event.COMPLETE, eventHandler);
        loader.addEventListener(Event.ERROR, eventHandler);
        loader.load(url, null, 'GET', null, null, true);
    };

    scope.wasChanged = function()
    {
        return ! (scope.sceneIsEmpty() || scope.savedLastChanges);
    };

    scope.wasSaved = function()
    {
        return ! (scene.getProjectId() == 0);
        /*|| projectUserKey != R2D.User.getKey()*/
    };

    // Saving scene:
    // R2D.controller.saveCurrentScene();
    //
    // R2D.Controller.SAVE_CURRENT_SCENE_COMPLETE
    // R2D.Controller.SAVE_CURRENT_SCENE_CANCELED
    // R2D.Controller.SAVE_CURRENT_SCENE_ERROR
};

R2D.extend(R2D.Controller, EventDispatcher);

R2D.Controller.SAVE_CURRENT_SCENE_COMPLETE = 'saveCurrentSceneComplete';
R2D.Controller.SAVE_CURRENT_SCENE_ERROR = 'saveCurrentSceneError';
R2D.Controller.SAVE_CURRENT_SCENE_CANCELED = 'saveCurrentSceneCanceled';

R2D.Controller.RENAME_CURRENT_SCENE_COMPLETE = 'renameCurrentSceneComplete';
R2D.Controller.RENAME_CURRENT_SCENE_ERROR = 'renameCurrentSceneError';
R2D.Controller.RENAME_CURRENT_SCENE_CANCELED = 'renameCurrentSceneCanceled';
//core

/**
 *
 * @param icon {String} url
 * @param domElement {HTMLElement} html element
 * @param hintKey {String} hint key
 * @constructor
 */
R2D.ViewerData = function(icon, domElement, hintKey) {
    this.icon = icon;
    this.domElement = domElement;
    this.hintKey = hintKey;
};

//-
R2D.Viewer = function(type, data, scene, useZoom, useToCenter) {
    EventDispatcher.call(this);

    this.isEnabled = function() {
        throw "Error! The isEnabled method must be overridden!";
    };
    this.getType = function() {
        return type;
    };
    this.getIcon = function() {
        return data.icon;
    };
    this.getDomElement = function() {
        return data.domElement;
    };
    this.getHintKey = function() {
        return data.hintKey;
    };
    this.getData = function() {
        return data;
    };
    this.getScene = function() {
        return scene;
    };
    this.getUseZoom = function() {
        return useZoom;
    };
    this.getUseToCenter = function() {
        return useToCenter;
    };
    this.getUseRulers = function()
    {
        return false;
    };
    this.setViewStateData = function(data) {
        console.error("Error! The setViewStateData method must be overridden!");
    };
    this.getWidth = function() {
        console.error("Error! The getWidth method must be overridden!");
    };
    this.getHeight = function() {
        console.error("Error! The getHeight method must be overridden!");
    };
    this.setSize = function(width, height) {
        console.error("Error! The setSize method must be overridden!");
    };
    this.enable = function(previousViewer) {
        console.error("Error! The enable method must be overridden!");
    };
    this.disable = function() {
        console.error("Error! The disable method must be overridden!");
    };
    this.reset = function() {

    };
    this.rendererUpdate = function() {
        console.error("Error! The rendererUpdate method must be overridden!");
    };
    this.stateUserUnknown = function() {
        console.error("Error! The stateUserUnknown method must be overridden!");
    };
    this.stateUserLogged = function() {
        console.error("Error! The stateUserLogged method must be overridden!");
    };
    this.toCenter = function() {
        console.error("Error! The toCenter method must be overridden!");
    };
    this.makePreviewScreenShot = function() {
        console.error("Error! The makePreviewScreenShot method must be overridden!");
    };
    this.makeScreenShot = function() {
        console.error("Error! The makeScreenShot method must be overridden!");
    };
    this.getViewStateData = function() {
        console.error("Error! The getViewStateData method must be overridden!");
    };
    this.selectedObject = function(object) {
        console.error("Error! The selectedObject method must be overridden!");
    };
    this.unselectedObject = function(object) {
        console.error("Error! The unselectedObject method must be overridden!");
    };
    this.canRender = function() {
        console.error("Error! The canRebder method must be overridden!");
    };
    this.objectSelection = function (value) {
        console.error("Error! The objectSelection method must be overridden!");
    };
    this.getCameraData = function () {
        console.error("Error! The getCameraData method must be overridden!");
    };
    this.moveSelectedObject = function(dx, dy)
    {
        console.error("Error! The moveSelectedObject method must be overridden!");
    };
    this.moveSelectedMaterial = function(dx, dy)
    {
        console.error("Error! The moveSelectedMaterial method must be overridden!");
    };
    this.finishMoveSelectedObject = function()
    {
        console.error("Error! The finishMoveSelectedObject method must be overridden!");
    };
    this.showCursor = function() {

    };
    this.hideCursor = function() {

    };
    this.updateCursor = function() {

    };

    // var viewerStyles = `
    //     .viewer-body
    //     {
    //       position: absolute;
    //       padding: 0;
    //       margin: 0;
    //       left: 0;
    //       top: 0;
    //       width: 0;
    //       height: 0;
    //     }
    //     .viewer-canvas
    //     {
    //       position: absolute;
    //       padding: 0;
    //       margin: 0;
    //       left: 0;
    //       top: 0;
    //       width: 800px;
    //       height: 600px;
    //     }
    //     .viewer-tools
    //     {
    //       position: absolute;
    //       padding: 0;
    //       margin: 0;
    //       left: 0;
    //       top: 0;
    //       width: 0;
    //       height: 0;
    //     }
    //     .viewer-ruler-value
    //     {
    //       position: absolute;
    //       margin: 0;
    //       left: 0;
    //       top: 0;
    //       padding: 2px 4px;
    //       outline: 1px solid #dd0066;
    //       background-color: #ffffff;
    //       font-family: "Roboto", sans-serif;
    //       font-size: 13px;
    //       color: #2f2f2f;
    //       text-align: center;
    //       pointer-events: none;
    //       user-select: none;
    //       white-space: nowrap;
    //     }
    //     .viewer-custom-ruler-flag
    //     {
    //       position: absolute;
    //       pointer-events: none;
    //       margin: 0;
    //       padding: 0;
    //       display: inline-block;
    //       -webkit-touch-callout: none;
    //       -webkit-user-select: none;
    //       -moz-user-select: none;
    //       -ms-user-select: none;
    //       user-select: none;
    //       outline: 0;
    //     }
    // `;

    // var styleSheet = document.createElement("style");
    // styleSheet.type = "text/css";
    // styleSheet.innerText = viewerStyles;
    // document.head.appendChild(styleSheet)
};

R2D.extend(R2D.Viewer, EventDispatcher);

R2D.Viewer.VIEWER_ENABLED = "viewerEnabled";
R2D.Viewer.VIEWER_DISABLED = "viewerDisabled";

R2D.Viewer.CAMERA_POSITION_UPDATE = "cameraPositionUpdate";

R2D.Viewer.CAMERA_HEIGHT_RATIO = 3;
R2D.Viewer.SCREENSHOT_W = 1280;
R2D.Viewer.SCREENSHOT_H = 720;

R2D.Viewer.ADD_RULER = 'addRuler';
// core

//site parameters
R2D.SP = {};

R2D.SP.buttonProductAddToCart = false;
R2D.SP.buttonProductDescription = true;
R2D.SP.wallsConfigurator = false;

R2D.SP.setParameters = function(params) {
    console.log(params);

    R2D.SP.buttonProductAddToCart = params.buttonProductAddToCart;
    R2D.SP.buttonProductDescription = params.buttonProductDescription;
    R2D.SP.wallsConfigurator = params.wallsConfigurator;

    //R2D.Viewers.hidePanels();

    if (typeof(params.buttonConstructor) != 'undefined' &&
        ! params.buttonConstructor && R2D.viewConstructor)
    {
        R2D.Viewers.remove(R2D.viewConstructor);
    }

    if (typeof(params.topLeftPanelVisible) != 'undefined' &&
        ! params.topLeftPanelVisible)
    {
        R2D.TopLeftPanel.hide();
    }
};

// core

R2D.Viewers = function (viewersContainer, enableRuler) {
    R2D.DomElement.call(this);

    var scope = this;
    var body = scope.getDomElement();
    var width = 800;
    var height = 600;
    var viewers = [];
    var buttons = [];
    var currentViewer = null;
    var renderFrame = new R2D.RenderFrame();
    scope.isRightPanelOpen = true;
    scope.rightPanelStatusBefore = scope.isRightPanelOpen;
    let isRenderMakeActive = false;
    // function selectedViewer(event) { // todo: public functions
    //     var index = buttons.indexOf(event.currentTarget);

    //     if ( index < 0 ) {
    //         console.error('Unknown button!');
    //         return;
    //     }

    //     scope.enableViewer(index);
    // }

    scope.changeIsRenderActive = status => {
        isRenderMakeActive = status;
        scope.setSize(width, height, { status: status });
    }

    scope.getIsRenderMakeActive = () => isRenderMakeActive;

    scope.toggleRightPanelStatus = (status) => {
        scope.isRightPanelOpen = status;
        scope.rightPanelStatusBefore = status;
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;

        width = status == true ? width - 270 : width + 270;
        scope.setSize(width, height);
    };

    scope.getSize = () => {return { width, height }};

    scope.showRightPanelStatus = () => {
        scope.isRightPanelOpen = true;
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;
        width = scope.rightPanelStatusBefore ? width : width - rightPanelWidth;
        scope.setSize(width, height);
    };

    scope.setRightPanelStatusBefore = () => {
        scope.isRightPanelOpen = scope.rightPanelStatusBefore;
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;
        width = scope.isRightPanelOpen ? width : width + rightPanelWidth;
        scope.setSize(width, height);
    };

    scope.getCurrentViewerName = () => scope.getCurrentViewer() == R2D.view3d ? 'view3d' : R2D.Viewers.getCurrentViewer() == R2D.view2d ? 'view2d' : 'viewConstructor'

    scope.fullscreenState = false;
    scope.currentPanelState = true;

    function onFullscreenClick() {
        scope.fullscreenState = true;

        let a = document.querySelector(".viewer-body").parentNode;

        a.addEventListener("fullscreenchange", onFullscreenchange);

        if (a.requestFullscreen) a = a.requestFullscreen(void 0);
        else if (a.webkitRequestFullscreen) a = a.webkitRequestFullscreen();
        else if (a.mozRequestFullScreen) a = a.mozRequestFullScreen();
        else if (a.msRequestFullscreen) a = a.msRequestFullscreen();
        else if (a.webkitEnterFullscreen) a = a.webkitEnterFullscreen();
        else return Promise.reject(Error("Fullscreen API unavailable"));
        return a instanceof Promise ? a : Promise.resolve();
    }

    function onFullscreenchange() {
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;

        if (scope.fullscreenState) {
            scope.currentPanelState = scope.isRightPanelOpen;
            if (scope.isRightPanelOpen) {
                scope.toggleRightPanelStatus(false);
                document.querySelector(
                    ".viewer-body"
                ).parentNode.style.width = `${window.innerWidth}px`;
                R2D.mouseInteractionHelper.setSize(window.innerWidth, window.innerHeight);
            }
            scope.fullscreenState = false;

            return;
        }
        // fullscreenState --> false
        if (scope.currentPanelState) {
            scope.toggleRightPanelStatus(true);
            document.querySelector(".viewer-body").parentNode.style.width = `${
                window.innerWidth - rightPanelWidth
            }px`;
            R2D.mouseInteractionHelper.setSize(
                window.innerWidth - rightPanelWidth,
                window.innerHeight
            );
        }
        scope.fullscreenState = true;
    }

    scope.clickOnButton = (eventName) => {
        // todo: public functions

        if (!currentViewer) return;

        switch (eventName) {
            case "zoomIn":
                currentViewer.cameraZoom(-1);
                break;

            case "zoomOut":
                currentViewer.cameraZoom(1);
                break;

            case "toCenter":
                currentViewer.toCenter();
                break;

            case "addRuler":
                currentViewer.addRuler();
                break;

            case "fullscreen":
                onFullscreenClick();
                break;
        }
    };

    scope.getDrawingDisplayState = function () {
        if (currentViewer == null) return null;

        return currentViewer.getDrawingDisplayState();
    };
    scope.setDrawingDisplayState = function (value) {
        if (currentViewer == null) return;

        currentViewer.setDrawingDisplayState(value);
    };
    scope.makePreviewScreenShot = function () {
        if (currentViewer == null) return null;

        return currentViewer.makePreviewScreenShot();
    };    
    scope.makeRenderScreenShot = function () {
        if (currentViewer == null) return null;

        return currentViewer.makeRenderScreenShot();
    };
    scope.makeScreenShot = function () {
        if (currentViewer == null) return null;

        return currentViewer.makeScreenShot();
    };
    scope.enableViewer = function (i) {
        var prevViewerType = null;
        var viewer = viewers[i];

        Array.from(document.querySelectorAll(".left_bar_btn")).forEach((i) =>
            i.removeAttribute("style")
        );

        if (viewer == currentViewer) {
            viewer.reset(currentViewer.getType());
            return;
        }

        if (currentViewer) {
            prevViewerType = currentViewer.getType();

            currentViewer.disable();

            if(viewersContainer.contains(currentViewer.getDomElement())) viewersContainer.removeChild(currentViewer.getDomElement());
        }

        currentViewer = R2D.Viewers.currentViewer = viewer;

        /*
        if ( R2D.User.isStateLogged() ) {
            currentViewer.stateUserLogged();
        } else {
            currentViewer.stateUserUnknown();
        }
        */

        currentViewer.enable(prevViewerType);
        currentViewer.setSize(width, height);

        viewersContainer.appendChild(currentViewer.getDomElement());

        scope.dispatchEvent(new Event(Event.CHANGE, scope));
    };

    scope.setViewState = function (data) {
        for (var i = 0, l = viewers.length; i < l; i++) {
            if (viewers[i].setViewStateData(data)) {
                scope.enableViewer(i);
                return true;
            }
        }

        return false;
    };

    scope.add = function (viewer) {
        viewers.push(viewer);
        scope.dispatchEvent(new Event(R2D.Viewers.VIEWER_ADDED, viewer));
    };
    scope.remove = function (viewer) {
        var index = viewers.indexOf(viewer);

        if (index < 0) {
            throw "Error removing viewer!";
        }
        viewers.splice(index, 1);
        scope.dispatchEvent(new Event(R2D.Viewers.VIEWER_REMOVED, viewer));
    };
    scope.setSize = function (w, h, isRenderMake) {
        if(isRenderMake) {
            if(isRenderMake.status) {
                let currWidth = w - 100;
                let ratioHeight = currWidth / ( 16 / 9 );
                
                if(ratioHeight > window.innerHeight - 100) {
                    width = (window.innerHeight - 100) * ( 16 / 9 );
                    height = window.innerHeight - 100;
                }
                else {
                    width = currWidth;
                    height = ratioHeight;
                }
            }
            else {
                let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;
                width = scope.isRightPanelOpen ? window.innerWidth - rightPanelWidth : window.innerWidth;
                height = window.innerHeight;
            }
        }
        else {
            if(isRenderMakeActive) {
                let currWidth = w - 100;
                let ratioHeight = currWidth / ( 16 / 9 );
                if(ratioHeight > window.innerHeight - 100) {
                    width = (window.innerHeight - 100) * ( 16 / 9 );
                    height = window.innerHeight - 100;
                }
                else {
                    width = currWidth;
                    height = ratioHeight;
                }
            }
            else {
                width = w;
                height = h;
            }
        }

        currentViewer.setSize(width, height, isRenderMakeActive);
        //for (var viewer of viewers) viewer.setSize(width, height);
        //renderFrame.setSize(width, height);
    };
    scope.getDomElement = function () {
        return body;
    };
    scope.stateUserUnknown = function () {
        currentViewer.stateUserUnknown();
    };
    scope.stateUserLogged = function () {
        currentViewer.stateUserLogged();
    };
    scope.cameraZoom = function (delta) {
        currentViewer.cameraZoom(delta);
    };
    scope.cameraMove = function (dx, dy) {
        currentViewer?.cameraMove && currentViewer.cameraMove(dx, dy);
    };
    scope.getCurrentViewerType = function () {
        return currentViewer.getType();
    };
    scope.getCurrentViewer = function () {
        return currentViewer;
    };
    scope.getCurrentViewState = function () {
        return currentViewer.getViewStateData();
    };
    scope.showRenderFrame = function () {
        currentViewer.objectSelection(false);
        //viewersContainer.appendChild(renderFrame.getDomElement());
        document.querySelector("#planner").appendChild(renderFrame.getDomElement());
    };
    scope.hideRenderFrame = function () {
        currentViewer.objectSelection(true);
        viewersContainer.removeChild(renderFrame.getDomElement());
    };
    scope.getRenderFrameData = function () {
        return renderFrame.getData();
    };
    scope.getCameraData = function () {
        return currentViewer.getCameraData();
    };
    scope.showPanels = function () {
        console.log("do nothing");
    };
    scope.hidePanels = function () {
        console.log("do nothing");
    };
};

R2D.extend(R2D.Viewers, EventDispatcher);

R2D.Viewers.VIEWER_ADDED = "viewerAdded";
R2D.Viewers.VIEWER_REMOVED = "viewerRemoved";

R2D.Viewers._instance = null;

R2D.Viewers.init = function (viewersContainer, enableRuler) {
    R2D.Viewers._instance = new R2D.Viewers(viewersContainer, enableRuler);
};

R2D.Viewers.clickOnButton = (eventName) => R2D.Viewers._instance.clickOnButton(eventName);

R2D.Viewers.getCurrentViewerType = function () {
    return R2D.Viewers._instance.getCurrentViewerType();
};
R2D.Viewers.getViewState = function () {
    return R2D.Viewers._instance.getCurrentViewState();
};
R2D.Viewers.setViewState = function (data) {
    R2D.Viewers._instance.setViewState(data);
};
R2D.Viewers.enableViewer = function (index) {
    R2D.Viewers._instance.enableViewer(index);
};
R2D.Viewers.cameraZoom = function (delta) {
    R2D.Viewers._instance.cameraZoom(delta);
};
R2D.Viewers.add = function (viewer) {
    R2D.Viewers._instance.add(viewer);
};
R2D.Viewers.remove = function (viewer) {
    R2D.Viewers._instance.remove(viewer);
};
R2D.Viewers.setSize = function (width, height) {
    R2D.Viewers._instance.setSize(width, height);
};
R2D.Viewers.getSize = function () {
    return R2D.Viewers._instance.getSize();
};
R2D.Viewers.getDomElement = function () {
    return R2D.Viewers._instance.getDomElement();
};
R2D.Viewers.makePreviewScreenShot = function () {
    return R2D.Viewers._instance.makePreviewScreenShot();
};
R2D.Viewers.getCurrentViewerName = function () {
    return R2D.Viewers._instance.getCurrentViewerName();
};
R2D.Viewers.makeScreenShot = function () {
    return R2D.Viewers._instance.makeScreenShot();
};
R2D.Viewers.makeRenderScreenShot = function() {   
    return R2D.Viewers._instance.makeRenderScreenShot();
};
R2D.Viewers.stateUserUnknown = function () {
    R2D.Viewers._instance.stateUserUnknown();
};
R2D.Viewers.stateUserLogged = function () {
    R2D.Viewers._instance.stateUserLogged();
};
R2D.Viewers.addEventListener = function (type, listener) {
    R2D.Viewers._instance.addEventListener(type, listener);
};
R2D.Viewers.removeEventListener = function (type, listener) {
    R2D.Viewers._instance.removeEventListener(type, listener);
};
R2D.Viewers.showRenderFrame = function () {
    R2D.Viewers._instance.showRenderFrame();
};
R2D.Viewers.hideRenderFrame = function () {
    R2D.Viewers._instance.hideRenderFrame();
};
R2D.Viewers.getRenderFrameData = function () {
    return R2D.Viewers._instance.getRenderFrameData();
};
R2D.Viewers.getCameraData = function () {
    return R2D.Viewers._instance.getCameraData();
};
R2D.Viewers.showPanels = function () {
    R2D.Viewers._instance.showPanels();
};
R2D.Viewers.hidePanels = function () {
    R2D.Viewers._instance.hidePanels();
};
R2D.Viewers.toggleRightPanelStatus = function (status) {
    R2D.Viewers._instance.toggleRightPanelStatus(status);
};
R2D.Viewers.showRightPanelStatus = function () {
    R2D.Viewers._instance.showRightPanelStatus();
};
R2D.Viewers.getIsRenderMakeActive = function () {
    return R2D.Viewers._instance.getIsRenderMakeActive();
};
R2D.Viewers.setRightPanelStatusBefore = function () {
    R2D.Viewers._instance.setRightPanelStatusBefore();
};
R2D.Viewers.cameraMove = (dx, dy) => {
    R2D.Viewers._instance.cameraMove(dx, dy);
};
R2D.Viewers.changeIsRenderActive = (status) => {
    R2D.Viewers._instance.changeIsRenderActive(status);
};
R2D.Viewers.getCurrentViewer = function () {
    return R2D.Viewers._instance.getCurrentViewer();
};
// core

R2D.API = {};

R2D.API.getProductInfo = function(sceneObject) {
      let result = {
          productId:sceneObject.productId,
          type:sceneObject.type,
          x:sceneObject.x,
          y:sceneObject.y,
          z:sceneObject.z,
          width:sceneObject.width,
          height:sceneObject.height,
          depth:sceneObject.depth,
          rotationX:sceneObject.rotationX,
          rotationY:sceneObject.rotationY,
          rotationZ:sceneObject.rotationZ,
          flipX:sceneObject.flipX,
          flipY:sceneObject.flipY,
          flipZ:sceneObject.flipZ
      };

      if ( sceneObject.type == R2D.ProductType.MODEL ) {
          let productMaterials = sceneObject.getMaterials();
          let resultMaterials = new Array(productMaterials.length);

          productMaterials.forEach((material, index) => {
              resultMaterials[index] = {
                  default:material["default"],
                  current:material["current"],
                  name:material["name"]
              };
          });

          result["materials"] = resultMaterials;
      }

      return result;
};

R2D.API.getConstructorInfoInCurrentProject = function () {
    if ( !R2D.scene ) {
        console.error("Scene is not created!");
        return {};
    }
    if ( !R2D.SP.userKey ) {
        console.error("Site user key is null!");
        return {};
    }

    let userKey = R2D.SP.userKey;
    let tempData = {};
    let constructorObjects = R2D.scene.constructor.getObjects();
    let productData = [];

    function isOwner(id) {
        if ( tempData.hasOwnProperty(id) ) return tempData[id];

        let data = R2D.Pool.getProductData(id);

        if ( !data ) return false;

        let res = data["user_key"] == userKey;

        tempData[id] = res;

        return res;
    }
    function appendObject(object, where) {
        if ( !isOwner(object.materialID) ) return;

        productData.push({
            productId:object.materialID,
            area:object.area,
            where:where
        });
    }
    function appendObjects(array, where) {
        array.forEach(object => appendObject(object, where));
    }

    appendObject(constructorObjects["cap"], "cap");
    appendObjects(constructorObjects["walls"], "wall");
    appendObjects(constructorObjects["covers"], "cover");
    appendObjects(constructorObjects["ceilings"], "ceiling");
    appendObjects(constructorObjects["areas"], "area");
    appendObjects(constructorObjects["cuts"], "cut");
    appendObjects(constructorObjects["frames"], "frame");

    return productData;

};

R2D.API.getProductsInfoInCurrentProject = function() {
    if ( !R2D.scene ) {
        console.error("Scene is not created!");
        return {};
    }
    if ( !R2D.SP.userKey ) {
        console.error("Site user key is null!");
        return {};
    }

    let userKey = R2D.SP.userKey;
    let sceneObjects = R2D.scene.getSceneObjects().filter(product => product.userKey == userKey);
    let productsData = [];
    let constructorData = R2D.API.getConstructorInfoInCurrentProject(userKey);

    sceneObjects.forEach(sceneObject => {
        productsData.push(R2D.API.getProductInfo(sceneObject));
    });

    return {
        types:R2D.ProductType.getTypes(),
        products:productsData,
        constructor:constructorData
    };
};

R2D.API.setConstructionStyle = function(styleString)
{
    if ( !R2D.scene ) {
        console.error("Scene is not created!");
        return {};
    }

    R2D.scene.constructor.setStyleFromJSON(styleString);
};

R2D.API.getConstructorEstimate = function()
{
    if ( !R2D.scene ) {
        console.error("Scene is not created!");
        return {};
    }

    return R2D.scene.constructor.getEstimate();
};

R2D.API.selectRoomByName = function(name)
{
    if ( !R2D.scene ) {
        console.error("Scene is not created!");
        return {};
    }

    R2D.scene.constructor.selectRoomByName(name);
};

R2D.API.unselectRoom = function()
{
    if ( !R2D.scene ) {
        console.error("Scene is not created!");
        return {};
    }

    R2D.scene.constructor.unselectRoom(name);
};

R2D.API.getProjectData = function()
{
    return R2D.controller.getTextData();
};

R2D.API.getProductList = function()
{
    var sceneData = R2D.scene.getSceneState();

    var res = [];
    for (var i = 0; i < sceneData.scene.products.length; i++)
    {
        var prod = sceneData.scene.products[i];
        var prodData = {id: prod.id, materials: []};
        for (var j = 0; j < prod.materials.length; j++)
        {
            var mat = prod.materials[j];
            prodData.materials.push({id: mat.current, name: mat.name});
        }
        res.push(prodData);
    }

    return JSON.stringify(res);
};
R2D.Config = function()
{
    var me = this;
    EventDispatcher.call(this);

    var configLoader;

    me.isDesktop = false;
    me.isMobile = false;
    me.isTablet = false;
 
    me.data = {
        enable_pro: true,
        enable_estimation: false,
        enable_set_project: false,
        enable_merchant_login: false,
        logo: {
            type: "image",
            show: true,
            src: '',
            href: '',
            target: "_blank"
        },
        ui:{
            custom_registration: false,
            fb_login: true,

            top_login: true,
            top_user: true,
            profile_news: true,
            sharing: true,

            top_project: true,
            top_language: true,
            top_screenshot: true,
            top_save: true,
            top_help: true,
            top_units: true,
            top_render: true,

            show_logo: true,
            send_a_request: false,

            mode_constructor: true,
        },
        additional: {
            terms: {
                type: "text",
                show: true,
                text: '',
                href: 'https://roomtodo.com/en/terms_of_service/',
                target: "_blank"
            },
            copyright: {
                type: "text",
                show: true,
                text: '2023  Roomtodo',
                href: 'https://roomtodo.com/',
                target: "_blank"
            },
            feedback: {
                type: "text",
                show: true,
                text: "Feedback",
                href: "http://roomtodo.idea.informer.com/",
                target: "_blank"
            },
            orderFloorPlanUrl: ""
        }
    };

    if (R2D.Config.mobileAndTabletCheck())
    {
        if ((window.innerWidth <= 600) || (window.innerHeight <= 600) )
        {
            me.isMobile = true;
        }
        else
        {
            me.isTablet = true;
        }
    }
    else
    {
        me.isDesktop = true;
    }

    me.update = function(callback)
    {
        if ( configLoader ) {
            configLoader.close();
        }

        configLoader = new R2D.JSONLoader(R2D.URL.DOMAIN + R2D.URL.URL_CONFIG);

        function errorLoadConfig() {
            console.error('Config not loaded');

            configLoader.close();
            configLoader = null;

            if (callback) callback();
        }

        configLoader.addEventListener(Event.COMPLETE, function(event) {
            var data = configLoader.getData();
            var location = null;
            var object = null;

            if ( !data.hasOwnProperty('status') ) {
                console.error('!status');
                errorLoadConfig();
                return;
            }
            if ( data['status'] != 'success' ) {
                console.error('!success');
                errorLoadConfig();
                return;
            }

            if ( !data.hasOwnProperty('result') ) {
                console.error('!result');
                errorLoadConfig();
                return;
            }
            if ( !data.hasOwnProperty('location') ) {
                console.error('!location');
                errorLoadConfig();
                return;
            }

            try {
                object = JSON.parse(data['result']);
            } catch ( error ) {
                console.error('!result JSON');
                errorLoadConfig();
                return;
            }
            try {
                location = JSON.parse(data['location']);
            } catch ( error ) {
                console.error('!location JSON');
                errorLoadConfig();
                return;
            }

            copyProperties(object, me.data);

            //if (R2D.copyrightPanel)
            //{
            //    if (object.ui.logo)
            //    R2D.copyrightPanel.updateLogo(object.hasOwnProperty('logo') ? object['logo'] : {});
            //    R2D.copyrightPanel.updateAdditional(object.hasOwnProperty('additional') ? object['additional'] : {});
            //}

            //R2D.User.setLocationData(location);

            configLoader.close();
            configLoader = null;

            me.dispatchEvent(new Event(Event.UPDATE));
            if (callback) callback();
        });
        configLoader.addEventListener(Event.ERROR, function(event) {
            errorLoadConfig();
        });
        configLoader.load();
    };

    function copyProperties(source, target)
    {
        for (var k in source)
        {
            if (! source.hasOwnProperty(k)) continue;

            if (! target.hasOwnProperty(k))
            {
                if(source[k] === "true") source[k] = true;
                else if(source[k] === "false") source[k] = false;
                
                target[k] = source[k];
            }
            else if (typeof source[k] === 'object' && source[k] !== null)
            {
                copyProperties(source[k], target[k]);
            }
            else
            {
                if(source[k] === "true") source[k] = true;
                else if(source[k] === "false") source[k] = false;

                target[k] = source[k];
            }
        }
    }
};

R2D.Config.mobileAndTabletCheck = function() {
    let check = false;
    (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
    return check;
};

R2D.extend(R2D.Config, EventDispatcher);

R2D.GA = {};

R2D.GA.getOrigin = function()
{
    var origin = 'empty';

    var urlParams = new URLSearchParams(window.location.search);

    if (urlParams.has('user_plan'))
    {
        origin = 'landing';
    }
    else if (urlParams.has('key') || urlParams.has('site_key'))
    {
        var key = urlParams.get('site_key');
        if (! key) key = urlParams.get('key');

        if (key != '4500282e6846fe6650de81bd35d27540') origin = 'iframe';
    }
    else if (window.location.href.includes('ckhUA37eeeb33'))
    {
        origin = 'demo';
    }
    else if (window.location.href.includes('project'))
    {
        origin = 'shared';
    }

    return origin;
};

R2D.GA.isDev = function()
{
    return (window.location.hostname == 'dev.roomtodo.com' || window.location.hostname == 'react.roomtodo.com');
};

R2D.GA.sendFromPlanList = function()
{
    if (R2D.GA.isDev()) return;

    var label = R2D.GA.getOrigin();

    console.log('Sending ', 'planList', label);

    try {
        ga('send', 'event', 'planList', 'open', label);
        console.log('ok');
    }
    catch (e)
    {
        console.log(e);
    }
};

R2D.GA.sendFromPayForm = function()
{
    if (R2D.GA.isDev()) return;

    var label = R2D.GA.getOrigin();

    console.log('Sending ', 'payForm', label);

    try {
        ga('send', 'event', 'payForm', 'open', label);
        console.log('ok');
    }
    catch (e)
    {
        console.log(e);
    }
};

R2D.GA.sendFromPayFinish = function()
{
    if (R2D.GA.isDev()) return;

    var label = R2D.GA.getOrigin();

    console.log('Sending ', 'payFinish', label);

    try {
        ga('send', 'event', 'payFinish', 'open', label);
        console.log('ok');
    }
    catch (e)
    {
        console.log(e);
    }
};

R2D.GA.sendFromPayOk = function()
{
    if (R2D.GA.isDev()) return;

    var label = R2D.GA.getOrigin();

    console.log('Sending ', 'payOK', label);

    try {
        ga('send', 'event', 'payOK', 'open', label);
        console.log('ok');
    }
    catch (e)
    {
        console.log(e);
    }
};

R2D.Storage = {};

R2D.Storage.getKey = function()
{
    var urlParts = R2D.URL.URL_SIGN_IN.split('?');
    try
    {
        var urlParams = new URLSearchParams(urlParts[1]);
        if (urlParams.has('key')) return urlParams.get('key');
        return '';
    }
    catch (e)
    {
        return ''
    }
};

R2D.Storage.save = function(key, value)
{
    var k = key + '_' + R2D.Storage.getKey();

    try {
        localStorage.setItem(k, value);
    } catch (e) {}

};

R2D.Storage.load = function(key)
{
    var k = key + '_' + R2D.Storage.getKey();

    try {
        return localStorage.getItem(k);
    } catch (e) {
        return null;
    }
};

R2D.Storage.clear = function(key)
{
    var k = key + '_' + R2D.Storage.getKey();

    try{
        localStorage.removeItem(k);
    }
    catch (e) {}
};

R2D.Cookies = {};

R2D.Cookies.get = function(cname)
{
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(';');
    for(let i = 0; i <ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) == ' ') {
        c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
        }
    }
    return "";
};

R2D.Cookies.set = function(cname, cvalue, exdays)
{
    const d = new Date();
    d.setTime(d.getTime() + (exdays*24*60*60*1000));
    let expires = "expires="+ d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
};

//core

R2D.ProductType = function() {
    //-
};

R2D.ProductType.MATERIAL = 1;
R2D.ProductType.MODEL = 2;
R2D.ProductType.POSTER = 3;
R2D.ProductType.CARPET = 4;
R2D.ProductType.PLINTH = 5;

R2D.ProductType.getTypes = function () {
    return [
        {
            type:1,
            name:"material"
        },
        {
            type:2,
            name:"model"

        },
        {
            type:3,
            name:"poster"
        },
        {
            type:4,
            name:"carpet"
        },
        {
            type:5,
            name:"plinth"
        },
    ]
};
//core

R2D.Pool = function() {
    throw "Error! You cannot create instance of R2D.Pool!";
};

R2D.Pool._products_data = {}; //[R2D.ProductData]
R2D.Pool._loaders_products_data = {};

R2D.Pool.isProductData = function(id) {
    //var array = R2D.Pool._products_data;

    //for ( var i = 0, l = array.length; i < l; i++ ) {
    //    if ( array[i].productId == id ) return array[i];
    //}
    if (id in R2D.Pool._products_data) return R2D.Pool._products_data[id];

    return null;
};
R2D.Pool.getProductData = function(id) {
    return R2D.Pool.isProductData(id);
};
R2D.Pool.addProductData = function(productData) {
    if ( !productData.hasOwnProperty("productId") || !productData.productId ) return;
    
    //R2D.Pool._products_data.push(productData);
    R2D.Pool._products_data[productData.productId] = productData;
    
};
R2D.Pool.isLoaderProductData = function(id) {
    //var array = R2D.Pool._loaders_products_data;

    //for ( var i = 0, l = array.length; i < l; i++ ) {
    //    if ( array[i].productId == id ) return array[i];
    //}

    if (id in R2D.Pool._loaders_products_data) return R2D.Pool._loaders_products_data[id];

    return null;
};

R2D.Pool.addRawProductsData = function(productsData) {
    if ( !R2D.ProductDataParser.parseJSON(productsData) ) {
        console.warn("Some products data have errors!");
    }

    for ( var i = 0, l = productsData.length; i < l; i++ ) {
        R2D.Pool.addProductData(productsData[i]);
    }
};

R2D.Pool._loaderProductDataEventHandler = function(event) {
    var loader = event.currentTarget;
    //loader.productId
    //var index = R2D.Pool._loaders_products_data.indexOf(loader);

    loader.removeEventListener(Event.COMPLETE, R2D.Pool._loaderProductDataEventHandler);
    loader.removeEventListener(Event.ERROR, R2D.Pool._loaderProductDataEventHandler);

    if (loader.productId in R2D.Pool._loaders_products_data) delete R2D.Pool._loaders_products_data[loader.productId];

    //if ( index >= 0 ) R2D.Pool._loaders_products_data.splice(index, 1);

    if ( event.type == Event.COMPLETE ) {
        var jsonString = loader.data;
        var jsonObject = null;
        var parserResult = null;

        try {
            jsonObject = JSON.parse(jsonString);
        } catch(error) {
            console.error("Error parse JSON string!");
            console.log(jsonString);
            return;
        }

        if ( !jsonObject.hasOwnProperty('status') ) {
            console.error('Received object has no property "status"!');
            console.log(jsonObject);
            return;
        }
        if ( jsonObject['status'] != 'success' ) {
            console.error('Received status is not "success"!');
            console.log(jsonObject);
            return;
        }
        if ( !jsonObject.hasOwnProperty('products') ) {
            console.error('Received object has no property "products"!');
            console.log(jsonObject);
            return;
        }

        parserResult = R2D.ProductDataParser.parseJSON(jsonObject.products);
        for ( let i = 0, l = parserResult.length; i < l; i++ ) {
            R2D.Pool.addProductData(parserResult[i]);
        }
    } else {
        console.warn("R2D.Pool._loaderProductDataEventHandler: Error load data of product!");
        console.warn(loader);
    }
};
R2D.Pool.loadProductData = function(productId) {
    
    var loader = R2D.Pool.isLoaderProductData(productId);

    if ( loader ) return loader;

    loader = new R2D.ProductDataLoader();

    loader.addEventListener(Event.COMPLETE, R2D.Pool._loaderProductDataEventHandler);
    loader.addEventListener(Event.ERROR, R2D.Pool._loaderProductDataEventHandler);
    loader.load(productId);

    //R2D.Pool._loaders_products_data.push(loader);
    R2D.Pool._loaders_products_data[productId] = loader;

    return loader;
};

//core

R2D.Creator = function () {
    //-
};

R2D.Creator.makeSceneObject = function (productData, color) {
    if(!productData) return;
    switch (parseInt(productData.type)) {
        case R2D.ProductType.MATERIAL:
            return new R2D.SceneObjectMaterial(productData, color);
            break;

        case R2D.ProductType.MODEL:
            return new R2D.SceneObjectModel(productData);
            break;

        case R2D.ProductType.POSTER:
            if (productData.source.body.package.endsWith(".glb")) {
                return new R2D.SceneObjectModel(productData);
            } else {
                return new R2D.SceneObjectPoster(productData);
            }
            break;

        case R2D.ProductType.CARPET:
            return new R2D.SceneObjectCarpet(productData);
            break;

        default:
            console.warn("Unknown type of data!");
            console.log(productData);
    }

    return null;
};

let dataLoader;

function loaderDataEventHandler(e, dataProductObject, defaultProductData) {
    let sceneObject;
    switch (parseInt(dataProductObject.type)) {
        case R2D.ProductType.MODEL:
            sceneObject = new R2D.SceneObjectModel(defaultProductData);

            sceneObject.objid = dataProductObject.objid;
            sceneObject.x = dataProductObject.x;
            sceneObject.y = dataProductObject.y;
            sceneObject.z = dataProductObject.z;
            sceneObject.scaleX = dataProductObject.sx;
            sceneObject.scaleY = dataProductObject.sy;
            sceneObject.scaleZ = dataProductObject.sz;
            sceneObject.rotationX = dataProductObject.rx;
            sceneObject.rotationY = dataProductObject.ry;
            sceneObject.rotationZ = dataProductObject.rz;
            sceneObject.flipX = dataProductObject.fx;
            sceneObject.flipY = dataProductObject.fy;
            sceneObject.flipZ = dataProductObject.fz;

            sceneObject.isLockedOnScene = dataProductObject.isLockedOnScene || false;

            if (dataProductObject.configInfo) sceneObject.configInfo = dataProductObject.configInfo;

            sceneObject.setMaterials(dataProductObject.materials);
            sceneObject.setMaterialFrameData(
                dataProductObject.mf,
                dataProductObject.addMf,
                parseFloat(dataProductObject.mfr),
                parseFloat(dataProductObject.mfx),
                parseFloat(dataProductObject.mfy)
            );
            sceneObject.setMaterialBottomData(
                dataProductObject.mb,
                dataProductObject.addMb,
                parseFloat(dataProductObject.mbr),
                parseFloat(dataProductObject.mbx),
                parseFloat(dataProductObject.mby)
            );
            
            sceneObject.update();
            break;

        case R2D.ProductType.POSTER:
            sceneObject = new R2D.SceneObjectPoster(defaultProductData);
            sceneObject.objid = dataProductObject.objid;
            sceneObject.x = dataProductObject.x;
            sceneObject.y = dataProductObject.y;
            sceneObject.z = dataProductObject.z;
            sceneObject.scaleX = dataProductObject.sx;
            sceneObject.scaleY = dataProductObject.sy;
            sceneObject.scaleZ = dataProductObject.sz;
            sceneObject.rotationX = dataProductObject.rx;
            sceneObject.rotationY = dataProductObject.ry;
            sceneObject.rotationZ = dataProductObject.rz;
            sceneObject.isLockedOnScene = dataProductObject.isLockedOnScene || false;
            break;

        case R2D.ProductType.CARPET:
            sceneObject = new R2D.SceneObjectCarpet(defaultProductData);
            sceneObject.objid = dataProductObject.objid;
            sceneObject.x = dataProductObject.x;
            sceneObject.y = dataProductObject.y;
            sceneObject.z = dataProductObject.z;
            sceneObject.scaleX = dataProductObject.sx;
            sceneObject.scaleY = dataProductObject.sy;
            sceneObject.scaleZ = dataProductObject.sz;
            sceneObject.rotationX = dataProductObject.rx;
            sceneObject.rotationY = dataProductObject.ry;
            sceneObject.rotationZ = dataProductObject.rz;
            sceneObject.isLockedOnScene = dataProductObject.isLockedOnScene || false;
            break;

        default:
            console.warn("Unknown type of data!");
            console.log(defaultProductData);
    }

    return sceneObject;
}

R2D.Creator.makeFromLoadedData = function (dataProductsObjects) {
    return new Promise(res => {
        var sceneObjects = [];

        if(!dataProductsObjects || dataProductsObjects.length < 1) res([]);
        for (var i = 0, l = dataProductsObjects.length; i < l; i++) {
            var dataProductObject = dataProductsObjects[i];
            var defaultProductData = R2D.Pool.isProductData(dataProductObject.id);
            //console.log('Making object from data ', dataProductObject.id, Boolean(defaultProductData));
            var sceneObject = null;

            if(!defaultProductData) {
        
                dataLoader = R2D.Pool.isLoaderProductData(dataProductObject.id);

                let currentI = i;
        
                if (!dataLoader) dataLoader = R2D.Pool.loadProductData(dataProductObject.id);
        
                dataLoader.addEventListener(Event.COMPLETE, e => {
                    sceneObject = loaderDataEventHandler(e, dataProductObject, R2D.Pool.isProductData(dataProductObject.id));
                    if (sceneObject) sceneObjects.push(sceneObject);
                    if(currentI + 1 == dataProductsObjects.length) res(sceneObjects);
                });
            } 
            else {
                switch (parseInt(dataProductObject.type)) {
                    case R2D.ProductType.MODEL:
                        sceneObject = new R2D.SceneObjectModel(defaultProductData);

                        sceneObject.objid = dataProductObject.objid;
                        sceneObject.x = dataProductObject.x;
                        sceneObject.y = dataProductObject.y;
                        sceneObject.z = dataProductObject.z;
                        sceneObject.scaleX = dataProductObject.sx;
                        sceneObject.scaleY = dataProductObject.sy;
                        sceneObject.scaleZ = dataProductObject.sz;
                        sceneObject.rotationX = dataProductObject.rx;
                        sceneObject.rotationY = dataProductObject.ry;
                        sceneObject.rotationZ = dataProductObject.rz;
                        sceneObject.flipX = dataProductObject.fx;
                        sceneObject.flipY = dataProductObject.fy;
                        sceneObject.flipZ = dataProductObject.fz;

                        sceneObject.isLockedOnScene = dataProductObject.isLockedOnScene || false;

                        if (dataProductObject.configInfo)
                            sceneObject.configInfo = dataProductObject.configInfo;

                        sceneObject.setMaterials(dataProductObject.materials);
                        sceneObject.setMaterialFrameData(
                            dataProductObject.mf,
                            dataProductObject.addMf,
                            parseFloat(dataProductObject.mfr),
                            parseFloat(dataProductObject.mfx),
                            parseFloat(dataProductObject.mfy)
                        );
                        sceneObject.setMaterialBottomData(
                            dataProductObject.mb,
                            dataProductObject.addMb,
                            parseFloat(dataProductObject.mbr),
                            parseFloat(dataProductObject.mbx),
                            parseFloat(dataProductObject.mby)
                        );
                        
                        sceneObject.update();
                        break;

                    case R2D.ProductType.POSTER:
                        sceneObject = new R2D.SceneObjectPoster(defaultProductData);
                        sceneObject.objid = dataProductObject.objid;
                        sceneObject.x = dataProductObject.x;
                        sceneObject.y = dataProductObject.y;
                        sceneObject.z = dataProductObject.z;
                        sceneObject.scaleX = dataProductObject.sx;
                        sceneObject.scaleY = dataProductObject.sy;
                        sceneObject.scaleZ = dataProductObject.sz;
                        sceneObject.rotationX = dataProductObject.rx;
                        sceneObject.rotationY = dataProductObject.ry;
                        sceneObject.rotationZ = dataProductObject.rz;
                        sceneObject.isLockedOnScene = dataProductObject.isLockedOnScene || false;

                        sceneObject.update();
                        break;

                    case R2D.ProductType.CARPET:
                        sceneObject = new R2D.SceneObjectCarpet(defaultProductData);
                        sceneObject.objid = dataProductObject.objid;
                        sceneObject.x = dataProductObject.x;
                        sceneObject.y = dataProductObject.y;
                        sceneObject.z = dataProductObject.z;
                        sceneObject.scaleX = dataProductObject.sx;
                        sceneObject.scaleY = dataProductObject.sy;
                        sceneObject.scaleZ = dataProductObject.sz;
                        sceneObject.rotationX = dataProductObject.rx;
                        sceneObject.rotationY = dataProductObject.ry;
                        sceneObject.rotationZ = dataProductObject.rz;
                        sceneObject.isLockedOnScene = dataProductObject.isLockedOnScene || false;

                        sceneObject.update();
                        break;

                    default:
                        console.warn("Unknown type of data!");
                        console.log(defaultProductData);
                }
            
                if (sceneObject) sceneObjects.push(sceneObject);

                if(i + 1 == dataProductsObjects.length) res(sceneObjects);
            }
        }
    });
    
};

//core

R2D.Default = function () {
    let scope = this;

    let wallDefaultMatId = "2013"; 
    let ceilingDefaultMatId = "2013";
    let coverDefaultMatId = "2525";
    let capDefaultMatId = "#606b67";
    let plinthDefaultMatId = "#ffffff";
    let moldingDefaultMatId = "#ffffff";

    let wallDefaultAddMatId = "";
    let coverDefaultAddMatId = "";
    let ceilingDefaultAddMatId = "";
    let capDefaultAddMatId = "32771";
    let plinthDefaultAddMatId = "32770";
    let moldingDefaultAddMatId = "32770";

    scope.materials = {
        "wall": {
            "matId": wallDefaultMatId,
            "addMatId": wallDefaultAddMatId
        },
        "cover": {
            "matId": coverDefaultMatId,
            "addMatId": coverDefaultAddMatId
        },
        "ceiling": {
            "matId": ceilingDefaultMatId,
            "addMatId": ceilingDefaultAddMatId
        },
        "cap": {
            "matId": capDefaultMatId,
            "addMatId": capDefaultAddMatId
        },
        "plinth": {
            "matId": plinthDefaultMatId,
            "addMatId": plinthDefaultAddMatId
        },
        "molding": {
            "matId": moldingDefaultMatId,
            "addMatId": moldingDefaultAddMatId
        },
    }

    scope.setDefaultMaterials = newDefaultMaterials => {
        for(let i in newDefaultMaterials) {
            if(scope.materials[i]) {
                if(newDefaultMaterials[i].matId) {
                    scope.setDefaultMaterialByKey(i, newDefaultMaterials[i].matId);
                    scope.setDefaultAddMaterialByKey(i, "");
                }
                if(newDefaultMaterials[i].addMatId) scope.setDefaultAddMaterialByKey(i, newDefaultMaterials[i].addMatId);
            }
        }
    }
    
    scope.setDefaultMaterialByKey = (key, value) => scope.materials[key].matId = value;
    scope.setDefaultAddMaterialByKey = (key, value) => scope.materials[key].addMatId = value;

    scope.getDefaultMaterialByKey = key => scope.materials[key].matId;
    scope.getDefaultAddMaterialByKey = key => scope.materials[key].addMatId;

};

//R2D.Default.PATH_SKYBOX = '/api/category/products?category_tag=skybox';
//R2D.Default.PATH_SKYBOX_DEFAULT = '/api/category/products?category_tag=skybox_default';
R2D.Default.SKYBOX_DEFAULT_TAG = 'skybox_default';
R2D.Default.FREE_TAG = 'free';

R2D.Default.WHITE_MATERIAL_ID = "#ffffff";


// core

R2D.Ruler = function() {
    var scope = this;
    var lines = [];
    var boxes = [];
    var target = null;

    Object.defineProperties(scope, {
        "lines":{
            get() { return lines.slice(); }
        }
    });

    scope.clear = function() {
        lines = [];
        boxes = [];
    };
    scope.appendLine = function(line) {
        lines.push(line);
    };
    scope.appendLines = function (array) {
        lines = lines.concat(array);
    };
    scope.appendBox = function(box) {
        boxes.push(box);
        scope.appendLines(box?.realLines());
    };
    scope.appendBoxes = function (array) {
        boxes = boxes.concat(array);

        array.forEach(box => scope.appendLines(box.realLines()));
    };
    scope.findRulersToPerpendicular = function(targetLine) {
        var distanceFront = Infinity;
        var distanceBack = Infinity;
        var pointFront = null;
        var pointBack = null;
        var lineFront = null;
        var lineBack = null;
        var precisionDistance = 5;

        lines.forEach(line => {
            if ( GEOM.Line.parallels(line, targetLine) ) return;

            let intersection = GEOM.Line.intersection(line, targetLine);

            if ( !intersection ) return;

            let lineLength = line.length();

            if ( (intersection.va - 1) * lineLength > precisionDistance || -intersection.va * lineLength > precisionDistance || (intersection.vb > 0 && intersection.vb < 1) ) return;

            if ( intersection.vb >= 1 ) {
                let dist = GEOM.Point.distance(targetLine.b, intersection.point);

                if ( dist < distanceFront ) {
                    distanceFront = dist;
                    pointFront = intersection.point;
                    lineFront = line;
                }
            } else if ( intersection.vb <= 0 ) {
                let dist = GEOM.Point.distance(targetLine.a, intersection.point);

                if ( dist < distanceBack ) {
                    distanceBack = dist;
                    pointBack = intersection.point;
                    lineBack = line;
                }
            }
        });

        return {
            distanceFront:distanceFront,
            pointFront:pointFront,
            lineFront:lineFront,
            distanceBack:distanceBack,
            pointBack:pointBack,
            lineBack:lineBack
        }
    };
    scope.findRulersFromBox = function(box) {
        var resultLines = [];
        var testLines = [];
        var resultLengths = [];

        box.realLines().forEach(line => {
            var pa = line.center();
            var pb = line.normal().invert().normalize().add(pa);
            var normalLine = new GEOM.Line(pa, pb);
            var nearLine = null;
            var testLine = null;
            var nearDistance = Infinity;

            var veryClose = false;

            for ( let i = 0, l = lines.length; i < l; i++ )
            {
                let tLine = lines[i];
                let intersect = null;

            //    if ( tLine.onLine(pa) ) {
            //        nearLine = new GEOM.Line(pa, pa);
            //        testLine = tLine;
            //        break;
            //    }

                intersect = GEOM.Line.intersection(normalLine, tLine);

                if (intersect && intersect.onB)
                {
                    if (intersect.va < 0 && intersect.va >= -1.5)
                    {
                        veryClose = true;
                        break;
                    }
                }

                if ( intersect && intersect.onB && intersect.va >= 0 )
                {
                    let projectLine = new GEOM.Line(pa, intersect.point);
                    let distanceLine = projectLine.length();

                    if ( distanceLine < nearDistance ) {
                        nearDistance = distanceLine;
                        nearLine = projectLine;
                        testLine = tLine;
                    }
                }
            }

            if (veryClose)
            {
                resultLines.push(null);
                testLines.push(null);
                resultLengths.push(0);
            }
            else if ( nearLine )
            {
                resultLines.push(nearLine);
                testLines.push(testLine);
                resultLengths.push(nearLine.length());
            }
            else
            {
                resultLines.push(null);
                testLines.push(null);
                resultLengths.push(NaN);
            }
        });

        return {
            rulers:resultLines,
            nears:testLines,
            distances: resultLengths
        };
    };
};


//loaders

R2D.XHRLoader = function() {
    EventDispatcher.call(this);

    var scope = this;

    scope.url = null;
    scope.params = null;
    scope.method = null;
    scope.headers = null;
    scope.xhr = null;
    scope.data = null;

    function xhrEventHandler(event) {
        scope.xhr.removeEventListener("load", scope.xhrEventHandler);
        scope.xhr.removeEventListener("error", scope.xhrEventHandler);

        if ( event.type == "load" && scope.xhr.status == "200" ) {
            scope.data = scope.xhr.response;
            scope.dispatchEvent(new Event(Event.COMPLETE, scope));
        } else {
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }
    }

    scope.load = function(url, params, method, headers, responseType, withCredentials)
    {
        if ( !url ) throw "Error XHRLoader's url!";
        if ( !params ) params = "";
        if ( !method ) method = "GET";
        if ( !headers ) headers = [];

        var needTokens = false;
        try {
            var urlParts = url.split('?');
            var urlParams = new URLSearchParams(urlParts[1]);
            if (urlParams.has('key') || urlParams.has('site_key') || url.match("promo")) needTokens = true;
        }
        catch(e){}

        if (needTokens && R2D.token)
        {
            headers.push({header: "x-token", value: R2D.token});
        }

        if (needTokens && R2D.language)
        {
            headers.push({header: "x-lang", value: R2D.language});
        }

        scope.url = url;
        scope.params = params;
        scope.method = method;
        scope.headers = headers;
        scope.responseType = responseType || "";
        scope.xhr = new XMLHttpRequest();

        scope.xhr.open(method, url, true);
        scope.xhr.responseType = scope.responseType;
        scope.xhr.withCredentials = withCredentials;

        for ( var i = 0, l = headers.length; i < l; i++ ) {
            scope.xhr.setRequestHeader(headers[i].header, headers[i].value);
        }

        scope.xhr.addEventListener("load", xhrEventHandler);
        scope.xhr.addEventListener("error", xhrEventHandler);
        scope.xhr.send(params);

        //console.log('----------');
        //console.log(R2D.User.getToken());
        //if (R2D.Language._instance) console.log(R2D.Language.getCurrentLanguageCode());
    };
    scope.close = function() {
        scope.url = null;
        scope.params = null;
        scope.method = null;
        scope.headers = null;

        if ( scope.xhr ) {
            scope.xhr.abort();
            scope.xhr.removeEventListener("load", xhrEventHandler);
            scope.xhr.removeEventListener("error", xhrEventHandler);
            scope.xhr = null;
        }
    };
};

R2D.extend(R2D.XHRLoader, EventDispatcher);

/**
 *
 * @param {Object} object 
 * @returns {string}
 */
R2D.XHRLoader.makeParamsString = function(object) {
    var string = '';
    var amp = '';

    for ( var key in object ) {
        string += amp + key + '=' + object[key];
        amp = '&';
    }

    return string;
};
/**
 *
 * @param {String} url
 * @param {String} params
 * @param {String} headers
 * @param {String} responseType
 * @param {Boolean} withCredentials
 * @returns {R2D.XHRLoader}
 */
R2D.XHRLoader.getPostLoader = function(url, params, headers, responseType, withCredentials) {
    var loader = new R2D.XHRLoader();
    var postHeader = {
        header:"Content-type",
        value:"application/x-www-form-urlencoded"
    };

    if ( headers ) headers.push(postHeader);
    else headers = [postHeader];
    
    loader.load(url, params, 'POST', headers, responseType, withCredentials);

    return loader;
};
//loaders

R2D.ProductDataLoader = function() {
    R2D.XHRLoader.call(this);

    var scope = this;
    var superLoad = scope.load;

    scope.load = function(productId) {
        var url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_GET_PRODUCT);
        var json = {
            ids:productId
        };
        var param = 'json=' + JSON.stringify(json);

        scope.productId = productId;

        superLoad(url, param, "POST", [{
            header:"Content-type",
            value:"application/x-www-form-urlencoded"
        }], null, true);
    };
};

R2D.extend(R2D.ProductDataLoader, R2D.XHRLoader);
//loaders

R2D.ProductsDataLoader = function () {
    EventDispatcher.call(this);

    var scope = this;
    var productsIds;
    var dataLoader;
    var currentIndex = 0;
    var total = 0;

    scope.callback = null;

    function completeLoad() {
        if (scope.callback) {
            scope.callback();
        }

        scope.dispatchEvent(new Event(Event.COMPLETE, scope));
    }
    function loadNext() {
        if (R2D.Pool.isProductData(productsIds[currentIndex])) {
            productDataLoaded();
            return;
        }

        dataLoader = R2D.Pool.isLoaderProductData(productsIds[currentIndex]);

        if (!dataLoader) dataLoader = R2D.Pool.loadProductData(productsIds[currentIndex]);

        dataLoader.addEventListener(Event.COMPLETE, loaderDataEventHandler);
        dataLoader.addEventListener(Event.ERROR, loaderDataEventHandler);
    }
    function loaderDataEventHandler(event) {
        if (!JSON.parse(event.data.data) || JSON.parse(event.data.data).status === "error") {
            scope.callback = null;
        }

        removeDataLoader();
        productDataLoaded();
    }
    function productDataLoaded() {
        currentIndex += 1;

        scope.dispatchEvent(
            new Event(Event.PROGRESS, { loaded: currentIndex, total: total })
        );
        checkLoad();
    }
    function checkLoad() {
        if (currentIndex == total) completeLoad();
        else loadNext();
    }

    function removeDataLoader() {
        if (dataLoader) {
            dataLoader.removeEventListener(Event.COMPLETE, loaderDataEventHandler);
            dataLoader.removeEventListener(Event.ERROR, loaderDataEventHandler);
            dataLoader = null;
        }
    }

    scope.loadOne = function (id, callback) {
        scope.callback = callback;

        scope.load([id]);
    };

    scope.load = function (ids) {
        productsIds = ids;
        currentIndex = 0;
        total = productsIds.length;

        checkLoad();
    };

    scope.dispose = function () {
        removeDataLoader();
    };
};

R2D.extend(R2D.ProductsDataLoader, EventDispatcher);

R2D.SceneLoader = function (apiDispatcher) {
    EventDispatcher.call(this);

    var scope = this;
    var sceneLoader;
    var productsDataLoader;
    var infoWindow = null;

    function completeLoadScene() {
        apiDispatcher &&
            apiDispatcher.dispatchEvent(new Event(apiDispatcher.SCENE_LOAD_COMPLETE, {}));
        scope.dispatchEvent(new Event(Event.COMPLETE, scope));
        R2D.scene.startClearingPool();
    }
    function productsDataLoaderEventHandler(event) {
        if (event.type == Event.PROGRESS) {
            apiDispatcher && apiDispatcher.dispatchEvent(
                new Event(apiDispatcher.SCENE_LOAD_PROGRESS, event.data)
            );
            //if (infoWindow) infoWindow.updateMessage(R2D.TRANSLATION.NOTIFY_LOADING_PRODUCTS + '<br>' + event.data.loaded + '/' + event.data.total);
        } else {
            removeProductsDataLoader();
            completeLoadScene();
        }
    }
    function loadProductsData() {
        if (infoWindow) infoWindow.updateMessage(R2D.TRANSLATION.NOTIFY_LOADING_PRODUCTS);

        productsDataLoader = new R2D.ProductsDataLoader();

        productsDataLoader.addEventListener(
            Event.PROGRESS,
            productsDataLoaderEventHandler
        );
        productsDataLoader.addEventListener(
            Event.COMPLETE,
            productsDataLoaderEventHandler
        );
        productsDataLoader.load(scope.sceneData.uniqueProductsIds);
    }
    function errorSceneData() {
        if (infoWindow) R2D.DialogStage.hide(infoWindow);
        infoWindow = null;

        scope.sceneData = null;
        scope.dispatchEvent(new Event(Event.ERROR, scope));
    }
    function makeUniqueProductsIds() {
        var products = scope.sceneData.scene.products;
        var idsObject = {};
        var idsArray = [];

        for (var i = 0, l = products.length; i < l; i++) {
            var product = products[i];
            var id = product["id"];

            if (idsObject.hasOwnProperty(id)) continue;

            idsArray.push(id);
        }

        scope.sceneData.uniqueProductsIds = idsArray;
    }
    function sceneLoaderEventHandler(event) {
        if (event.type == Event.COMPLETE) {
            var jsonString = sceneLoader.data;
            var jsonObject = null;

            try {
                jsonObject = JSON.parse(jsonString);
            } catch (error) {
                errorSceneData();
                return;
            }

            if (!jsonObject.hasOwnProperty("status")) {
                console.error("Error data of plan!");
                console.log(jsonObject);
                errorSceneData();
                return;
            }
            if (jsonObject["status"] != "success") {
                console.error("Error status of plan!");

                //R2D.User.doIfLogged(errorSceneData, function()
                //{
                //    if (infoWindow) R2D.DialogStage.hide(infoWindow);
                //}, true);
                scope.dispatchEvent(new Event(Event.ERROR, scope));
                return;
            }
            if (!jsonObject.hasOwnProperty("plan")) {
                console.error('Data has no propert "plan"!');
                console.log(jsonObject);
                errorSceneData();
                return;
            }

            scope.sceneData = R2D.SceneParser.parse(jsonObject["plan"]);

            if (scope.sceneData) {
                makeUniqueProductsIds();
                loadProductsData();
            } else {
                errorSceneData();
            }
        } else {
            errorSceneData();
        }

        removeSceneLoader();
    }

    function removeProductsDataLoader() {
        if (productsDataLoader) {
            productsDataLoader.removeEventListener(
                Event.COMPLETE,
                productsDataLoaderEventHandler
            );
            productsDataLoader.dispose();
            productsDataLoader = null;
        }
    }
    function removeSceneLoader() {
        if (sceneLoader) {
            sceneLoader.removeEventListener(Event.COMPLETE, sceneLoaderEventHandler);
            sceneLoader.removeEventListener(Event.ERROR, sceneLoaderEventHandler);
            sceneLoader.close();
            sceneLoader = null;
        }
    }

    scope.loadFromString = function (strData) {
        try {
            var jsonObj = JSON.parse(strData);
        } catch (error) {
            errorSceneData();
            return;
        }

        // infoWindow = R2D.DialogStage.getWindowInfo(R2D.TRANSLATION.TEXT_WAIT);
        // R2D.DialogStage.show(infoWindow);

        scope.sceneData = R2D.SceneParser.parse(jsonObj);

        if (scope.sceneData) {
            makeUniqueProductsIds();
            loadProductsData();
        } else {
            errorSceneData();
        }
    };

    scope.load = function (planId, asHash) {
        var params = "";
        var url = "";

        if (asHash) {
            params =
                "json=" +
                JSON.stringify({
                    plan_hash: planId,
                });
            //-----

            url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_LOAD_SHARED_PLAN);
            var urlParts = url.split("?");
            try {
                var urlParams = new URLSearchParams(urlParts[1]);
                if (!urlParams.has("plan_hash")) {
                    urlParams.set("plan_hash", planId);
                } else if (urlParams.get("plan_hash") == "") {
                    urlParams.set("plan_hash", planId);
                }
                url = urlParts[0] + "?" + urlParams.toString();
            } catch (e) {
                console.log(e);
            }
        } else {
            params =
                "json=" +
                JSON.stringify({
                    plan_id: planId,
                });
            url = R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_LOAD_PLAN);
        }

        //infoWindow = R2D.DialogStage.getWindowInfo(R2D.TRANSLATION.TEXT_WAIT);
        R2D.scene.stopClearingPool();

        sceneLoader = R2D.XHRLoader.getPostLoader(url, params, null, null, true);

        sceneLoader.addEventListener(Event.COMPLETE, sceneLoaderEventHandler);
        sceneLoader.addEventListener(Event.ERROR, sceneLoaderEventHandler);

        //R2D.DialogStage.show(infoWindow);
    };
    scope.dispose = function () {
        scope.sceneData = null;

        removeSceneLoader();
        removeProductsDataLoader();
    };
    scope.sceneData = null;
};

R2D.extend(R2D.SceneLoader, EventDispatcher);

// loader

R2D.SceneSaver = function() {
    EventDispatcher.call(this);

    var scope = this;
    var loader = null;

    function loaderEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            var json = event.data.data;
            var object = null;

            try {
                object = JSON.parse(json);
            } catch ( error ) {
                console.error('Received data is not JSON data!');
                console.log(json);
                scope.close();
                scope.dispatchEvent(new Event(Event.ERROR, {message:'An error occurred!'}));
                return;
            }

            if ( !object.hasOwnProperty('status') ) {
                console.error('Received data has no property "status"!');
                console.log(json);
                scope.close();
                scope.dispatchEvent(new Event(Event.ERROR, {message:'An error occurred!'}));
                return;
            }
            if ( object['status'] == 'error' ) {
                var message = '';

                if ( !object.hasOwnProperty('error') ) {
                    message = 'An error occurred!';
                } else {
                    message = object['error'];
                }

                console.warn('Save plan error! ' + message);
                scope.close();
                scope.dispatchEvent(new Event(Event.ERROR, {message:message}));
                return;
            }
            if ( object['status'] != 'success' ) {
                console.error('Status of saving plan is not success!');
                console.log(object);
                scope.close();
                scope.dispatchEvent(new Event(Event.ERROR, {message:'An error occurred!'}));
                return;
            }
            if ( !object.hasOwnProperty('plan_id') ) {
                console.error('Received data has no property "plan_id"!');
                console.log(object);
                scope.dispatchEvent(new Event(Event.ERROR, {message:'An error occurred!'}));
                return;
            }

            scope.dispatchEvent(new Event(Event.COMPLETE, object));
        } else {
            scope.close();
            scope.dispatchEvent(new Event(Event.ERROR, null));
        }
    }

    scope.close = function() {
        if ( loader == null ) return;

        loader.removeEventListener(Event.COMPLETE, loaderEventHandler);
        loader.removeEventListener(Event.ERROR, loaderEventHandler);
        loader.close();
        loader = null;
    };
    scope.save = function(data) {
        if ( loader != null ) return;
        
        var params = R2D.XHRLoader.makeParamsString({
            json:encodeURIComponent(JSON.stringify(data))
        });

        // console.log(params);

        loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_SAVE_PLAN), params, null, null, true);

        loader.addEventListener(Event.COMPLETE, loaderEventHandler);
        loader.addEventListener(Event.ERROR, loaderEventHandler);
    };
};

R2D.extend(R2D.SceneSaver, EventDispatcher);
//loaders

R2D.CatalogLoader = function(CatalogClass, rightPanel) {
    EventDispatcher.call(this);

    var scope = this;
    var loader = null;
    var catalog = null;

    function removeLoader() {
        if ( loader == null ) return;

        loader.removeEventListener(Event.COMPLETE, loaderEventHandler);
        loader.removeEventListener(Event.ERROR, loaderEventHandler);
        loader.close();
        loader = null;
    }
    function loaderEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            var string = loader.data;
            var json = null;
            var homePage = null;

            try {
                json = JSON.parse(string);
            } catch ( error ) {
                console.error('Error parse JSON string!');
                console.log(string);
                return;
            }

            if ( json.hasOwnProperty('status') && json.status == 'success' ) {
                catalog = new CatalogClass(json, rightPanel);
                scope.dispatchEvent(new Event(Event.COMPLETE, scope));
            } else {
                console.error('Error received data catalog!');
                console.log(json);
                scope.dispatchEvent(new Event(Event.ERROR, scope));
            }
        } else {
            console.error('Error load catalog tree!');
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        removeLoader();
    }

    scope.getCatalog = function() { return catalog; };
    scope.close = function() {
        removeLoader();

        catalog = null;
    };
    scope.load = function(url) {
        if ( loader ) return;

        loader = R2D.XHRLoader.getPostLoader(url);

        loader.addEventListener(Event.COMPLETE, loaderEventHandler);
        loader.addEventListener(Event.ERROR, loaderEventHandler);
    };
};

R2D.extend(R2D.CatalogLoader, EventDispatcher);
//loaders

R2D.DataLoader = function(url, responseType) {
    EventDispatcher.call(this);

    var scope = this;
    var loader = null;
    var data = null;

    function close() {
        if ( !loader ) return;

        loader.removeEventListener('load', loadEventHandler);
        loader.removeEventListener('progress', progressEventHandler);
        loader.removeEventListener('error', errorEventHandler);
        loader.abort();

        loader = null;
    }

    function complete() {
        close();
        scope.dispatchComplete();
    }
    function error() {
        close();
        scope.dispatchError();
    }

    function loadEventHandler(event) {
        if ( event.currentTarget.status == 200 ) {
            data = event.currentTarget.response;

            complete();
        } else {
            error();
        }
    }
    function progressEventHandler(event) {
        scope.dispatchProgress(event.loaded / event.total);
    }
    function errorEventHandler(event) {
        error();
    }

    scope.getData = function() {
        return data;
    };
    scope.load = function() {
        if ( loader ) throw "Error!";

        loader = new XMLHttpRequest();

        loader.withCredentials = true;

        if ( responseType != undefined ) {
            loader.responseType = responseType;
        }

        loader.addEventListener('load', loadEventHandler);
        loader.addEventListener('progress', progressEventHandler);
        loader.addEventListener('error', errorEventHandler);
        loader.open('GET', url, true);

        // -----

        var headers = [];

        var needTokens = false;
        try {
            var urlParts = url.split('?');
            var urlParams = new URLSearchParams(urlParts[1]);
            if (urlParams.has('key') || urlParams.has('site_key')) needTokens = true;
        }
        catch(e){}
        
        
        if (needTokens && R2D.token)
        {
            loader.setRequestHeader("x-token", R2D.token);
        }

        if (needTokens && R2D.language)
        {
            loader.setRequestHeader("x-lang", R2D.language);
        }

        // -----

        loader.send();
    };
    scope.close = function() {
        close();
    };
};

R2D.extend(R2D.DataLoader, EventDispatcher);

R2D.DataLoader.EMPTY = '';
R2D.DataLoader.TEXT = 'text';
R2D.DataLoader.JSON = 'json';
R2D.DataLoader.ARRAY_BUFFER = 'arraybuffer';
R2D.DataLoader.BLOB = 'blob';

R2D.DataLoader.loadArrayBuffer = function(url, onComplete, onError, onProgress) {
    var loader = new R2D.DataLoader(url, R2D.DataLoader.ARRAY_BUFFER);

    if ( onComplete ) {
        console.log(onComplete);
        loader.addEventListener(Event.COMPLETE, onComplete);
    }
    if ( onError ) {
        console.log(onError);
        loader.addEventListener(Event.ERROR, onError);
    }
    if ( onProgress ) {
        console.log(onProgress);
        loader.addEventListener(Event.PROGRESS, onProgress);
    }

    loader.load();

    return loader;
};
R2D.JSONLoader = function(url) {
    EventDispatcher.call(this);

    var scope = this;
    var loader = null;
    var json = null;
    var data = null;

    function close() {
        if ( !loader ) return;

        loader.removeEventListener(Event.COMPLETE, completeEventHandler);
        loader.removeEventListener(Event.ERROR, errorEventHandler);
        loader.close();

        loader = null;
    }

    function completeEventHandler() {
        var isError = false;

        json = loader.getData();

        try {
            data = JSON.parse(json);
        } catch ( error ) {
            isError = true;
        }

        close();

        if ( isError ) {
            console.error('Parse JSON string error!');
            scope.dispatchError();
        } else {
            scope.dispatchComplete();
        }
    }
    function errorEventHandler() {
        close();
        scope.dispatchError();
    }

    scope.getJSON = function() {
        return json;
    };
    scope.getData = function() {
        return data;
    };
    scope.load = function () {
        if ( loader ) throw "Error!";

        loader = new R2D.DataLoader(url, 'text');

        loader.addEventListener(Event.COMPLETE, completeEventHandler);
        loader.addEventListener(Event.ERROR, errorEventHandler);
        loader.load();
    };
    scope.close = function() {
        json = null;
        data = null;

        close();
    }
};

R2D.extend(R2D.JSONLoader, EventDispatcher);
//loaders

R2D.SourceLibrary = function() {
    var scope = this;
    var isLoading = false;
    var isReady = false;
    var library = new Map();
    var loaders = new Map();
    var callbackOnReady = null;
    var callbackOnProgress = null;
    var callbackOnError = null;

    function loadComplete() {
        isLoading = false;
        isReady = true;

        callbackOnReady();
    }

    function removeLoader(loader) {
        loader.close();
        loaders.delete(loader);
    }
    function removeAllLoaders() {
        loaders.forEach(function(object, loader) {
            loader.close();
        });
        loaders.clear();
    }

    function loaderOnReady(loader) {
        var object = loaders.get(loader);

        object['ready'] = true;
        object['data'] = loader.data;

        switch ( object['type'] ) {
            case R2D.SourceLibrary.TYPE_IMAGE:
                object['image'] = loader.image;
                object['element'] = loader.image;
                break;

            case R2D.SourceLibrary.TYPE_VIDEO:
                object['video'] = loader.video;
                object['element'] = loader.video;
                break;

            case R2D.SourceLibrary.TYPE_JSON:
                object['json'] = loader.json;
                object['object'] = loader.object;
                object['element'] = loader.json;
                break;

            case R2D.SourceLibrary.TYPE_HTML:
                object['html'] = loader.html;
                object['object'] = loader.object;
                object['element'] = loader.html;
                break;
        }

        removeLoader(loader);

        if ( loaders.size == 0 ) {
            loadComplete();
        }
    }
    function loaderOnProgress(loader, loaded, total) {
        if ( !callbackOnProgress ) return;

        var step = 1 / library.size;
        var progress = (library.size - loaders.size) / library.size;
        var currentProgress = loaded / total;

        if ( currentProgress == Infinity || currentProgress == -Infinity ) currentProgress = 0;

        loaders.get(loader)['progress'] = currentProgress;
        loaders.forEach(function(object, loader) {
            progress += object['progress'] * step;
        });

        callbackOnProgress(progress);
    }
    function loaderOnError(loader) {
        if ( callbackOnError ) {
            var object = loaders.get(loader);

            callbackOnError(object['id'], object['type'], object['url']);
        }
        else console.warn('Some item wasn\'t loaded!');

        removeLoader(loader);

        if ( loaders.size == 0 ) {
            loadComplete();
        }
    }

    function load() {
        library.forEach(function(object, id) {
            var loader = null;

            switch ( object['type'] ) {
                case R2D.SourceLibrary.TYPE_IMAGE:
                    loader = new R2D.SourceLibrary.LoaderImage();
                    break;

                case R2D.SourceLibrary.TYPE_VIDEO:
                    loader = new R2D.SourceLibrary.LoaderVideo();
                    break;

                case R2D.SourceLibrary.TYPE_JSON:
                    loader = new R2D.SourceLibrary.LoaderJSON();
                    break;

                case R2D.SourceLibrary.TYPE_HTML:
                    loader = new R2D.SourceLibrary.LoaderHTML();
                    break;

                default:
                    loader = new R2D.SourceLibrary.Loader(object['type']);
            }

            loader.onAction(loaderOnReady, loaderOnProgress, loaderOnError);
            loader.load(object['url']);

            loaders.set(loader, object);
        });
    }

    Object.defineProperties(scope, {
        isLoading:{
            get() { return isLoading; }
        },
        isReady:{
            get() { return isReady; }
        },
        _library:{
            get() {
                return library;
            }
        }
    });

    scope.onActionReady = function(callback) {
        callbackOnReady = callback;
    };
    scope.onActionProgress = function(callback) {
        callbackOnProgress = callback;
    };
    scope.onActionError = function(callback) {
        callbackOnError = callback;
    };
    scope.add = function(id, type, url) {
        if ( isReady ) throw 'Library is ready! Use a new instance!';
        if ( isLoading ) throw 'Library is loading! Use a new instance!';
        if ( library.has(id) ) throw 'Current id is already exist!';

        library.set(id, {
            id:id,
            url:url,
            type:type,
            progress:0,
            ready:false,
            data:null,
            element:null
        });
    };
    scope.getData = function (id) {
        if ( !library.has(id) ) return null;

        return library.get(id);
    };
    scope.fromObject = function(object) {
        for ( var id in object ) {
            var d = object[id];

            scope.add(id, d['type'], d['url']);
        }
    };
    scope.load = function() {
        if ( !callbackOnReady ) throw 'Needs set a callback for ready action! Use "onActionReady" method!';
        if ( isLoading ) throw 'Library is loading!';
        if ( isReady ) throw 'Library is ready!';

        isLoading = true;

        load();
    };
    scope.close = function() {
        if ( isReady ) throw 'Library have loaded!';
        if ( !isLoading ) return;

        removeAllLoaders();

        isLoading = false;
        isReady = true;
    };
};

R2D.SourceLibrary.TYPE_IMAGE = 'image';
R2D.SourceLibrary.TYPE_VIDEO = 'video';
R2D.SourceLibrary.TYPE_JSON = 'json';
R2D.SourceLibrary.TYPE_HTML = 'html';

//Loader
R2D.SourceLibrary.Loader = function(type, responseType) {
    var scope = this;
    var loader = null;
    var data = null;
    var onLoad = null;
    var onProgress = null;
    var onError = null;

    Object.defineProperties(scope, {
        type:{
            get() {
                return type;
            }
        },
        data:{
            get() {
                return data;
            }
        }
    });

    function removeLoader() {
        if ( !loader ) return;

        loader.removeEventListener('load', loadEventHandler);
        loader.removeEventListener('progress', progressEventHandler);
        loader.removeEventListener('error', errorEventHandler);
        loader.abort();

        loader = null;
    }

    function loadEventHandler(event) {
        if ( loader.status == 200 ) {
            data = loader.response;

            removeLoader();
            onLoad(scope);
        } else {
            removeLoader();
            onError(scope);
        }
    }
    function progressEventHandler(event) {
        onProgress(scope, event.loaded, event.total);
    }
    function errorEventHandler(event) {
        removeLoader();
        onError(scope);
    }

    scope.onAction = function(load, progress, error) {
        onLoad = load;
        onProgress = progress;
        onError = error;
    };
    scope.load = function(url) {
        loader = new XMLHttpRequest();

        loader.responseType = responseType;

        loader.withCredentials = true;

        loader.addEventListener('load', loadEventHandler);
        loader.addEventListener('progress', progressEventHandler);
        loader.addEventListener('error', errorEventHandler);
        loader.open('GET', url, true);
        loader.send();
    };
    scope.close = function() {
        onLoad = null;
        onProgress = null;
        onError = null;

        removeLoader();
    };
};

R2D.SourceLibrary.LoaderFileReader = function(type) {
    R2D.SourceLibrary.Loader.call(this, type, 'blob');

    var scope = this;
    var superClose = scope.close;
    var superOnAction = scope.onAction;
    var fileReader = null;
    var fileReaderResult = null;
    var callbackOnLoad = null;
    var callbackOnError = null;

    Object.defineProperties(scope, {
        result:{
            get() {
                return fileReaderResult;
            }
        }
    });

    function fileReaderEventHandler(event) {
        fileReader.removeEventListener('load', fileReaderEventHandler);
        fileReader.removeEventListener('error', fileReaderEventHandler);

        if ( event.type == 'load' ) {
            fileReaderResult = fileReader.result;

            callbackOnLoad(scope);
        } else {
            callbackOnError(scope);
        }

        fileReader = null;
    }
    function onLoad() {
        fileReader = new FileReader();

        fileReader.addEventListener('load', fileReaderEventHandler);
        fileReader.addEventListener('error', fileReaderEventHandler);
        fileReader.readAsDataURL(scope.data);
    }
    function onError() {
        callbackOnError(scope);
    }

    scope.onAction = function (load, progress, error) {
        callbackOnLoad = load;
        callbackOnError = error;

        superOnAction(onLoad, progress, onError);
    };
    scope.close = function() {
        if ( fileReader ) {
            fileReader.removeEventListener('load', fileReaderEventHandler);
            fileReader.removeEventListener('error', fileReaderEventHandler);
            fileReader = null;
        }

        callbackOnLoad = null;
        callbackOnError = null;

        superClose();
    };
};

R2D.extend(R2D.SourceLibrary.LoaderFileReader, R2D.SourceLibrary.Loader);

//Loader image
R2D.SourceLibrary.LoaderImage = function() {
    R2D.SourceLibrary.LoaderFileReader.call(this, R2D.SourceLibrary.Loader.TYPE_IMAGE);

    var scope = this;
    var superClose = scope.close;
    var superOnAction = scope.onAction;
    var callbackOnLoad = null;
    var callbackOnError = null;
    var image = null;

    Object.defineProperties(scope, {
        image:{
            get() {
                return image;
            }
        }
    });

    function imageEventHandler(event) {
        image.removeEventListener('load', imageEventHandler);
        image.removeEventListener('error', imageEventHandler);

        callbackOnLoad(scope);
    }
    function onLoad() {
        image = document.createElement('img');

        image.addEventListener('load', imageEventHandler);
        image.addEventListener('error', imageEventHandler);
        image.setAttribute('src', scope.result);
    }
    function onError() {
        callbackOnError(scope);
    }

    scope.onAction = function (load, progress, error) {
        callbackOnLoad = load;
        callbackOnError = error;

        superOnAction(onLoad, progress, onError);
    };
    scope.close = function() {
        if ( image ) {
            image.removeEventListener('load', imageEventHandler);
            image.removeEventListener('error', imageEventHandler);
        }

        callbackOnLoad = null;
        callbackOnError = null;

        superClose();
    };
};

R2D.extend(R2D.SourceLibrary.LoaderImage, R2D.SourceLibrary.Loader);

//Loader video
R2D.SourceLibrary.LoaderVideo = function() {
    R2D.SourceLibrary.LoaderFileReader.call(this, R2D.SourceLibrary.Loader.TYPE_IMAGE);

    var scope = this;
    var superClose = scope.close;
    var superOnAction = scope.onAction;
    var callbackOnLoad = null;
    var callbackOnError = null;
    var video = null;

    Object.defineProperties(scope, {
        video:{
            get() {
                return video;
            }
        }
    });

    function loadedDataEventHandler(event) {
        if ( video.readyState >= 2 ) {
            video.removeEventListener('loadeddata', loadedDataEventHandler);

            callbackOnLoad(scope);
        }
    }
    function onLoad() {
        video = document.createElement('video');

        video.addEventListener('loadeddata', loadedDataEventHandler);
        video.setAttribute('src', scope.result);
    }
    function onError() {
        callbackOnError(scope);
    }

    scope.onAction = function (load, progress, error) {
        callbackOnLoad = load;
        callbackOnError = error;

        superOnAction(onLoad, progress, onError);
    };
    scope.close = function() {
        if ( video ) {
            video.removeEventListener('loadeddata', loadedDataEventHandler);
        }

        callbackOnLoad = null;
        callbackOnError = null;

        superClose();
    };
};

R2D.extend(R2D.SourceLibrary.LoaderVideo, R2D.SourceLibrary.Loader);

//loader JSON
R2D.SourceLibrary.LoaderJSON = function() {
    R2D.SourceLibrary.Loader.call(this, R2D.SourceLibrary.Loader.TYPE_JSON, 'text');

    var scope = this;
    var superClose = scope.close;
    var superOnAction = scope.onAction;
    var callbackOnLoad = null;
    var callbackOnError = null;
    var json = null;
    var object = null;

    Object.defineProperties(scope, {
        json:{
            get() {
                return json;
            }
        },
        object:{
            get() {
                return object;
            }
        }
    });

    function onLoad() {
        try {
            object = JSON.parse(scope.data);
        } catch ( error ) {
            callbackOnError(scope);
            return;
        }

        json = scope.data;

        callbackOnLoad(scope);
    }
    function onError() {
        callbackOnError(scope);
    }

    scope.onAction = function (load, progress, error) {
        callbackOnLoad = load;
        callbackOnError = error;

        superOnAction(onLoad, progress, onError);
    };
    scope.close = function() {
        callbackOnLoad = null;
        callbackOnError = null;

        superClose();
    };
};

R2D.extend(R2D.SourceLibrary.LoaderJSON, R2D.SourceLibrary.Loader);

//loader HTML
R2D.SourceLibrary.LoaderHTML = function() {
    R2D.SourceLibrary.Loader.call(this, R2D.SourceLibrary.Loader.TYPE_JSON, 'text');

    var scope = this;
    var superClose = scope.close;
    var superOnAction = scope.onAction;
    var callbackOnLoad = null;
    var callbackOnError = null;
    var html = null;
    var object = null;

    Object.defineProperties(scope, {
        html:{
            get() {
                return html;
            }
        },
        object:{
            get() {
                return object;
            }
        }
    });

    function onLoad() {
        html = scope.data;
        object = scope.data;

        callbackOnLoad(scope);
    }
    function onError() {
        callbackOnError(scope);
    }

    scope.onAction = function (load, progress, error) {
        callbackOnLoad = load;
        callbackOnError = error;

        superOnAction(onLoad, progress, onError);
    };
    scope.close = function() {
        callbackOnLoad = null;
        callbackOnError = null;

        superClose();
    };
};

R2D.extend(R2D.SourceLibrary.LoaderJSON, R2D.SourceLibrary.Loader);
R2D.pageFromZipUrl = function (url) {
    return openZip(url).then(R2D.pageFromZip);

    function openZip(filename) {
        return new Promise(function (resolve, reject) {
            JSZipUtils.getBinaryContent(filename, function (err, data) {
                if (err) {
                    reject(err);
                } else {
                    resolve(data);
                }
            });
        });
    }
};

R2D.pageFromZip = function (file) {
    return JSZip.loadAsync(file).then(processFiles).then(pageFromSources);

    function processFiles(zip) {
        let reText = /(.html|.htm|.js|.css)$/;
        //let reImage = /(.jpg|.png|.gif|.ps|.jpeg)$/;

        let promises = Object.keys(zip.files)
            .filter(function (fileName) {
                return !fileName.toLowerCase().endsWith("/");
            })
            .map(function (fileName) {
                let file = zip.files[fileName];
                if (reText.test(fileName.toLowerCase())) {
                    return file.async("string").then(function (data) {
                        return [fileName, data, false];
                    });
                } else {
                    return file.async("blob").then(function (data) {
                        return [fileName, data, true];
                    });
                }
            });

        return Promise.all(promises);
    }

    function pageFromSources(sources) {
        return new Promise(function (resolve, reject) {
            let pageContent = null;
            let rootLen = 0;

            for (let [fn, fdata, asBlob] of sources) {
                if (fn.endsWith("index.html")) {
                    pageContent = fdata;
                    rootLen = fn.length - 10;
                }
            }

            if (!pageContent) reject(new Error("No index.html"));

            for (let [fn, fdata, asBlob] of sources) {
                if (fn.endsWith("index.html")) continue;
                let srcName = fn.slice(rootLen);
                if (asBlob) {
                    let blobURL = URL.createObjectURL(fdata);
                    pageContent = pageContent.replace(srcName, blobURL);
                } else {
                    let blobURL = URL.createObjectURL(new Blob([fdata]));
                    pageContent = pageContent.replace(`./${srcName}`, blobURL);
                }
            }

            resolve(pageContent);
        });
    }
};

R2D.createAppIFrameOld = function (url, zip, id = "") {
    var pr;
    if (url) {
        pr = R2D.pageFromZipUrl(url);
    } else {
        pr = R2D.pageFromZip(zip);
    }

    pr.then(function (data) {
        var iframe = document.createElement("iframe");
        document.body.appendChild(iframe);

        iframe.style.position = "absolute";
        iframe.style.backgroundColor = "#ffffff";
        iframe.style.border = "1px solid #cccccc";
        iframe.style.width = document.body.clientWidth - 200 + "px";
        iframe.style.height = document.body.clientHeight - 100 + "px";
        iframe.style.left = "100px";
        iframe.style.top = "50px";

        window.addEventListener("message", messageListener, false);

        var iframedoc = iframe.contentWindow.document;
        iframedoc.open();
        iframedoc.write(data);
        iframedoc.close();

        function messageListener(e) {
            try {
                var messageObj = JSON.parse(e.data);
            } catch (error) {
                console.error("Error parse JSON string!");
                return;
            }

            if (messageObj.action == "app_ready") {
                //var token = R2D.User.loadToken();
                //var lang = R2D.Language.getCurrentLanguageCode();
                var token = R2D.token;
                var lang = R2D.language;

                iframe.contentWindow.postMessage(
                    JSON.stringify({
                        action: "set_data",
                        url_files: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_FILE),
                        url_entities: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_ENTITY),
                        url_products: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.CATALOG_TREE),
                        url_materials: R2D.makeURL(
                            R2D.URL.DOMAIN,
                            R2D.URL.CATALOG_MATERIALS_TREE_FOR_MODELS
                        ),
                        url_apps: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_CONFIG_APPS),
                        token: token,
                        lang: lang,
                        product_id: id,
                        scene_data: R2D.scene.getSceneDataForApp(),
                    }),
                    "*"
                );
            } else if (messageObj.action == "app_save") {
                if (R2D.scene.currentView3DObject) {
                    R2D.scene.replaceCurrentObject(
                        messageObj.product_id,
                        messageObj.settings ? messageObj.settings : {}
                    );
                } else {
                    R2D.scene.placeObject(
                        messageObj.product_id,
                        messageObj.settings ? messageObj.settings : {}
                    );
                }
            } else if (messageObj.action == "app_close") {
                window.removeEventListener("message", messageListener);
                document.body.removeChild(iframe);
            }
        }
    });
};

document.addEventListener("keydown", function (e) {
    if (e.ctrlKey && e.altKey && e.code == "KeyC") {
        var input = document.createElement("input");
        input.type = "file";
        input.accept = ".zip";

        input.onchange = function (e) {
            var id = "";
            if (R2D.scene.currentSceneObject) {
                if (R2D.scene.currentSceneObject.configInfo) {
                    id = R2D.scene.currentSceneObject.configInfo.modelData.startModelId;
                } else {
                    id = R2D.scene.currentSceneObject.getProductId();
                }
            }
            if (e.target.files[0]) R2D.createAppIFrame(id, e.target.files[0]);
        };

        input.click();
    }
});

R2D.createAppIFrame = function (modelId = "", file) {
    const appStyle = {
        position: "absolute",
        backgroundColor: "#ffffff",
        border: "1px solid #cccccc",
        width: document.body.clientWidth - 200 + "px",
        height: document.body.clientHeight - 100 + "px",
        left: "100px",
        top: "50px",
        zIndex: "1",
    };

    let iframe = null;

    const startModelId = R2D.scene.currentSceneObject.configInfo
        ? R2D.scene.currentSceneObject.configInfo.startModelId
        : modelId;

    if (file) {
        //  
        R2D.pageFromZip(file).then(function (data) {
            iframe = document.createElement("iframe");
            document.body.appendChild(iframe);

            Object.assign(iframe.style, appStyle);

            window.addEventListener("message", messageListener);

            var iframedoc = iframe.contentWindow.document;
            iframedoc.open();
            iframedoc.write(data);
            iframedoc.close();

            const script = document.createElement("script");
            script.innerHTML = `let modelId = "${startModelId}";`;
            iframedoc.body.appendChild(script);

            setTimeout(() => {
                iframedoc.querySelector("body").style.opacity = "1";
            }, 50);
        });
    } else {
        //   
        iframe = document.createElement("iframe");
        document.body.appendChild(iframe);

        Object.assign(iframe.style, appStyle);

        window.addEventListener("message", messageListener);

        iframe.src = "https://dev.roomtodo.com/planner/configurator_launcher";
        // iframe.src = "https://roomtodo/planner/configurator_launcher"; //  
    }

    function messageListener(e) {
        checkMessage(e, iframe);
    }

    function checkMessage(e, curIframe) {
        if (!e.data || typeof e.data !== "string" || e.data.startsWith("/*framebus*/")) return;

        try {
            var messageObj = JSON.parse(e.data);
        } catch (error) {
            console.error("Error parse JSON string!");
            return;
        }

        switch (messageObj.action) {
            case "conf_ready":
                curIframe.contentWindow.postMessage(
                    JSON.stringify({
                        action: "start_configurate",
                        modelId: startModelId,
                        isPlanner: true,
                    }),
                    "*"
                );
                break;

            case "insert_to_planner":
                console.log("planer recieved insert_to_planner");
                console.log(messageObj.dataModel);
                if (R2D.scene.currentView3DObject) {
                    R2D.replaceCurrentObjectWithConfigModel(messageObj.configInfo);
                    window.removeEventListener("message", messageListener);
                    document.body.removeChild(iframe);
                } else {
                    // R2D.scene.placeObject(
                    //     messageObj.product_id,
                    //     messageObj.settings ? messageObj.settings : {}
                    // );
                }
                break;

            case "close":
                window.removeEventListener("message", messageListener);
                document.body.removeChild(iframe);
                break;

            case "check_parent":
                curIframe.contentWindow.postMessage(JSON.stringify({ action: "parent" }), "*");
                break;

            default:
                break;
        }

        // if (messageObj.action == 'app_ready')
        // {
        //     //var token = R2D.User.loadToken();
        //     //var lang = R2D.Language.getCurrentLanguageCode();
        //     var token = R2D.token;
        //     var lang = R2D.language;

        //     iframe.contentWindow.postMessage(JSON.stringify({
        //         action: 'set_data',
        //         url_files: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_FILE),
        //         url_entities: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_UPLOAD_ENTITY),
        //         url_products: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.CATALOG_TREE),
        //         url_materials: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.CATALOG_MATERIALS_TREE_FOR_MODELS),
        //         url_apps: R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_CONFIG_APPS),
        //         token: token,
        //         lang: lang,
        //         product_id: id,
        //         scene_data: R2D.scene.getSceneDataForApp()
        //     }), '*');
        // }
        // else if (messageObj.action == 'app_save')
        // {
        //     if (R2D.scene.currentView3DObject)
        //     {
        //         R2D.scene.replaceCurrentObject(messageObj.product_id, messageObj.settings ? messageObj.settings : {});
        //     }
        //     else
        //     {
        //         R2D.scene.placeObject(messageObj.product_id, messageObj.settings ? messageObj.settings : {});
        //     }
        // }
        // else if (messageObj.action == 'app_close')
        // {
        //     window.removeEventListener('message', messageListener);
        //     document.body.removeChild(iframe);
        // }
    }
};

R2D.replaceCurrentObjectWithConfigModel = function (configInfo) {
    if (configInfo.modelData) {
        let dataLoader = R2D.Pool.isLoaderProductData(configInfo.modelData.curId);
        if (!dataLoader) dataLoader = R2D.Pool.loadProductData(configInfo.modelData.curId);
        dataLoader.addEventListener(Event.COMPLETE, loaderCompleteListener);
        dataLoader.addEventListener(Event.ERROR, loaderErrorListener);

        function loaderCompleteListener(e) {
            const oldSceneObj = R2D.scene.currentView3DObject?.sceneObject;

            R2D.scene.currentView3DObject && R2D.scene.remove(oldSceneObj);

            const productData = R2D.Pool.getProductData(configInfo.modelData.curId);
            const sceneObject = R2D.Creator.makeSceneObject(productData);
            R2D.scene.add(sceneObject);

            sceneObject.x = oldSceneObj.x;
            sceneObject.y = oldSceneObj.y;
            sceneObject.z = oldSceneObj.z;
            sceneObject.flipX = oldSceneObj.flipX;
            sceneObject.flipY = oldSceneObj.flipY;
            sceneObject.flipZ = oldSceneObj.flipZ;
            sceneObject.rotationX = oldSceneObj.rotationX;
            sceneObject.rotationY = oldSceneObj.rotationY;
            sceneObject.rotationZ = oldSceneObj.rotationZ;

            sceneObject.configInfo = { ...configInfo };
            delete sceneObject.configInfo.materials;
            sceneObject.setMaterials(configInfo.materials);

            sceneObject.update();

            if (sceneObject.forWall) {
                let dropData = R2D.Scene.getObjectDataForWallElement(sceneObject);
                let dropResult = constructor.dropElement(dropData, 10);
                dropResult && R2D.Scene.setDropDataToWallElement(sceneObject, dropResult);
            }

            R2D.scene.history.saveState();

            R2D.mouseInteractionHelper.unsetActiveObject();
            R2D.mouseInteractionHelper.api.dispatchEvent(
                new Event(R2D.mouseInteractionHelper.api.QUICK_PANELS_HIDE, {})
            );
            R2D.mouseInteractionHelper.api.dispatchEvent(
                new Event(R2D.mouseInteractionHelper.api.OBJECT_DRAG_OUT_OF_WALL, {})
            );
        }

        function loaderErrorListener(e) {
            console.log("Error loading product ", id);
            console.log(e);
        }
    }

    if (configInfo.meshesData) {
    }

    // R2D.scene.currentView3DObject.object3d.clear();

    // const geometries = configInfo.model3d.geometries;
    // geometries.forEach((geo) => {
    //     const geometry = new THREE.BufferGeometry();
    //     geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(geo.data.attributes.position.array), 3));
    //     geometry.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(geo.data.attributes.normal.array), 3));
    //     geometry.setAttribute("uv", new THREE.BufferAttribute(new Float32Array(geo.data.attributes.uv.array), 2));

    //     const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
    //     R2D.scene.currentView3DObject.object3d.add(mesh);
    // });
    // R2D.scene.currentSceneObject.setMaterials(configInfo.materials);
    // R2D.scene.currentSceneObject.configInfo = configInfo;
    // R2D.scene.currentSceneObject.update();
};

// parsers

R2D.OBJParser = function() {
    EventDispatcher.call(this);

    var scope = this;
    var lines = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var faces = [];
    var geometry = {
        indices:[],
        vertices:[],
        uvs:[],
        normals:[],
        totalTriangles:0,
        bounds:null
    };

    function simplifyGeometry() {
        var index = 0;
        var pool = {};
        var indices = [];
        var vertices = [];
        var uvs = [];
        var normals = [];
        var minX = Infinity, maxX = -Infinity;
        var minY = Infinity, maxY = -Infinity;
        var minZ = Infinity, maxZ = -Infinity;
        var width, height, depth;
        var centerX, centerY, centerZ;
        var radius;

        function getIndex(vx, vy, vz, u, v, nx, ny, nz) {
            if ( !pool.hasOwnProperty(vx) ) return -1;
            if ( !pool[vx].hasOwnProperty(vy) ) return -1;
            if ( !pool[vx][vy].hasOwnProperty(vz) ) return -1;
            if ( !pool[vx][vy][vz].hasOwnProperty(u) ) return -1;
            if ( !pool[vx][vy][vz][u].hasOwnProperty(v) ) return -1;
            if ( !pool[vx][vy][vz][u][v].hasOwnProperty(nx) ) return -1;
            if ( !pool[vx][vy][vz][u][v][nx].hasOwnProperty(ny) ) return -1;
            if ( !pool[vx][vy][vz][u][v][nx][ny].hasOwnProperty(nz) ) return -1;

            return pool[vx][vy][vz][u][v][nx][ny][nz];
        }
        function add(vx, vy, vz, u, v, nx, ny, nz) {
            indices.push(index);
            vertices.push(vx, vy, vz);
            uvs.push(u, v);
            normals.push(nx, ny, nz);

            if ( !pool.hasOwnProperty(vx) ) pool[vx] = {};
            if ( !pool[vx].hasOwnProperty(vy) ) pool[vx][vy] = {};
            if ( !pool[vx][vy].hasOwnProperty(vz) ) pool[vx][vy][vz] = {};
            if ( !pool[vx][vy][vz].hasOwnProperty(u) ) pool[vx][vy][vz][u] = {};
            if ( !pool[vx][vy][vz][u].hasOwnProperty(v) ) pool[vx][vy][vz][u][v] = {};
            if ( !pool[vx][vy][vz][u][v].hasOwnProperty(nx) ) pool[vx][vy][vz][u][v][nx] = {};
            if ( !pool[vx][vy][vz][u][v][nx].hasOwnProperty(ny) ) pool[vx][vy][vz][u][v][nx][ny] = {};
            if ( !pool[vx][vy][vz][u][v][nx][ny].hasOwnProperty(nz) ) pool[vx][vy][vz][u][v][nx][ny][nz] = index;

            if ( vx < minX ) minX = vx;
            if ( vx > maxX ) maxX = vx;
            if ( vy < minY ) minY = vy;
            if ( vy > maxY ) maxY = vy;
            if ( vz < minZ ) minZ = vz;
            if ( vz > maxZ ) maxZ = vz;

            index += 1;
        }

        for ( var i = 0, l = geometry.vertices.length / 3; i < l; i++ ) {
            var vx = geometry.vertices[i * 3];
            var vy = geometry.vertices[i * 3 + 1];
            var vz = geometry.vertices[i * 3 + 2];
            var u = geometry.uvs[i * 2];
            var v = geometry.uvs[i * 2 + 1];
            var nx = geometry.normals[i * 3];
            var ny = geometry.normals[i * 3 + 1];
            var nz = geometry.normals[i * 3 + 2];
            var vi = getIndex(vx, vy, vz, u, v, nx, ny, nz);

            vi < 0 ? add(vx, vy, vz, u, v, nx, ny, nz) : indices.push(vi);
        }

        width = maxX - minX;
        height = maxY - minY;
        depth = maxZ - minZ;
        centerX = width / 2 + minX;
        centerY = height / 2 + minY;
        centerZ = depth / 2 + minZ;
        radius = Math.sqrt((width / 2) * (width / 2) + (height / 2) * (height / 2) + (depth / 2) * (depth / 2));

        geometry.indices = indices;
        geometry.vertices = vertices;
        geometry.uvs = uvs;
        geometry.normals = normals;
        geometry.md5 = R2D.OBJParser.getGeometryMD5(indices, vertices, normals, uvs);
        geometry.totalTriangles = indices.length / 3;
        geometry.bounds = {
            minX:minX, maxX:maxX,
            minY:minY, maxY:maxY,
            minZ:minZ, maxZ:maxZ,
            width:width,
            height:height,
            depth:depth,
            centerX:centerX,
            centerY:centerY,
            centerZ:centerZ,
            radius:radius
        };
    }

    function appendNormal(index) {
        var p = index > 0 ? (index - 1) * 3 : normals.length + (index * 3);

        geometry.normals.push(normals[p], normals[p + 1], normals[p + 2]);
    }
    function appendUV(index) {
        var p = index > 0 ? (index - 1) * 2 : uvs.length + (index * 2);

        geometry.uvs.push(uvs[p], uvs[p + 1]);
    }
    function appendVertex(index) {
        var p = index > 0 ? (index - 1) * 3 : vertices.length + (index * 3);

        geometry.vertices.push(vertices[p], vertices[p + 1], vertices[p + 2]);
    }

    function makeGeometry() {
        for ( var i = 0, l = faces.length; i < l; i++ ) {
            var face = faces[i];

            appendVertex(face[0]);
            appendVertex(face[3]);
            appendVertex(face[6]);

            appendUV(face[1]);
            appendUV(face[4]);
            appendUV(face[7]);

            appendNormal(face[2]);
            appendNormal(face[5]);
            appendNormal(face[8]);
        }
    }
    function parseLineFace(line) {
        var a = line.split(' ');
        var f = [];

        for ( var i = 1, l = a.length; i < l; i++ ) {
            var v = a[i].split('/');

            //TODO add check

            //v, vt/uv, vn/normal
            f.push(parseInt(v[0]), parseInt(v[1]), parseInt(v[2]));
        }

        faces.push(f);

        return true;
    }
    function parseLineNormal(line) {
        var a = line.split(' ');

        //TODO add check

        normals.push(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]));

        return true;
    }
    function parseLineTexture(line) {
        var a = line.split(' ');

        //TODO add check

        uvs.push(parseFloat(a[1]), parseFloat(a[2]));

        return true;
    }
    function parseLineVertex(line) {
        var a = line.split(' ');

        //TODO add check

        vertices.push(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]));

        return true;
    }
    function parseLine(line) {
        var clearLine = R2D.OBJParser.clearString(line);
        var firstChar, secondChar;

        if ( clearLine == '' ) return true;

        firstChar = clearLine.charAt(0);

        if ( firstChar == 'v' ) {
            secondChar = clearLine.charAt(1);

            if ( secondChar == ' ' ) {
                return parseLineVertex(line);
            } else if ( secondChar == 't' ) {
                return parseLineTexture(line);
            } else if ( secondChar == 'n' ) {
                return parseLineNormal(line);
            }
        } else if ( firstChar == 'f' ) {
            return parseLineFace(line);
        } else {
            console.warn('ignored: ' + line);
        }

        return true;
    }
    function clearLine(line) {
        line = line.replace(/^ +/, "");
        line = line.replace(/ +$/, "");
        line = line.replace(/ +/g, " ");

        return line;
    }

    Object.defineProperties(scope, {
        'geometry':{
            get() {
                return geometry;
            }
        }
    });

    scope.parse = function(string) {
        var isError = false;

        lines = string.split('\n');

        for ( var i = 0, l = lines.length; i < l; i++ ) {
            if ( !parseLine(clearLine(lines[i])) ) {
                isError = true;
                break;
            }
        }

        if ( isError ) {
            console.error('Error');
            console.log(lines[i]);
            console.log(vertices);
            console.log(uvs);
            console.log(normals);
            console.log(faces);
            console.log(geometry);
            scope.dispatchError(scope);
        } else {
            makeGeometry();
            simplifyGeometry();
            scope.dispatchComplete(scope);
        }
    };
};

R2D.extend(R2D.OBJParser, EventDispatcher);

R2D.OBJParser.trim = function(string) {
    return string.replace(/^ +/, '').replace(/ +$/, '');
};
R2D.OBJParser.removeDoubleSpace = function(string) {
    return string.replace(/ +/g, ' ');
};
R2D.OBJParser.clearString = function (string) {
    return R2D.OBJParser.removeDoubleSpace(R2D.OBJParser.trim(string));
};
R2D.OBJParser.getGeometryMD5 = function (indices, vertices, normals, uvs) {
    var string = "";

    string += indices.join(",");
    string += vertices.join(",");
    string += normals.join(",");
    string += uvs.join(",");

    return md5(string);
}
//parsers

R2D.SceneParser = function() {
    throw "Error!";
};

R2D.SceneParser.parseConstructionVersion001 = function(data)
{
    if ( !data.hasOwnProperty('points') ) {
        console.error('Construction data has no property "points"!');
        return null;
    }
    if ( !data.hasOwnProperty('walls') ) {
        console.error('Construction data has no property "walls"!');
        return null;
    }
    if ( !data.hasOwnProperty('covers') ) {
        console.error('Construction data has no property "covers"!');
        return null;
    }
    if ( !data.hasOwnProperty('cuts') ) {
        console.error('Construction data has no property "cuts"!');
        return null;
    }
    if ( !data.hasOwnProperty('rooms') ) {
        console.error('Construction data has no property "rooms"!');
        return null;
    }
    if ( !data.hasOwnProperty('areas') ) {
        console.error('Construction data has no property "areas"!');
        return null;
    }
    if ( !data.hasOwnProperty('cap') ) {
        console.error('Construction data has no property "cap"!');
        return null;
    }

    if ( R2D.SceneParser.parseConstructionVersion001.parsePoints(data['points']) == null ) {
        console.error('Error parse points!');
        console.log(data['points']);
        return null;
    }
    if ( R2D.SceneParser.parseConstructionVersion001.parseWalls(data['walls']) == null ) {
        console.error('Error parse walls!');
        console.log(data['walls']);
        return null;
    }
    if ( R2D.SceneParser.parseConstructionVersion001.parseCovers(data['covers']) == null ) {
        console.error('Error parse covers!');
        console.log(data['covers']);
        return null;
    }
    if ( R2D.SceneParser.parseConstructionVersion001.parseCuts(data['cuts']) == null ) {
        console.error('Error parse cuts!');
        console.log(data['cuts']);
        return null;
    }
    if ( R2D.SceneParser.parseConstructionVersion001.parseRooms(data['rooms']) == null ) {
        console.error('Error parse rooms!');
        console.log(data['rooms']);
        return null;
    }
    if ( R2D.SceneParser.parseConstructionVersion001.parseAreas(data['areas']) == null ) {
        console.error('Error parse areas!');
        console.log(data['areas']);
        return null;
    }
    if ( R2D.SceneParser.parseConstructionVersion001.parseCup(data['cap']) == null ) {
        console.error('Error parse cap!');
        console.log(data['cap']);
        return null;
    }

    return data;
};
R2D.SceneParser.parseConstructionVersion001.parsePoints = function(points) {
    for ( var index = 0, length = points.length; index < length; index++ ) {
        var point = points[index];

        if ( !point.hasOwnProperty('id') ) {
            console.error('A point of construction has no property "id"!');
            console.log(point);
            return null;
        }
        if ( !point.hasOwnProperty('type') ) {
            console.error('A point of construction has no property "type"!');
            console.log(point);
            return null;
        }
        if ( !point.hasOwnProperty('control') ) {
            console.error('A point of construction has no property "control"!');
            console.log(point);
            return null;
        }
        if ( !point.hasOwnProperty('x') ) {
            console.error('A point of construction has no property "x"!');
            console.log(point);
            return null;
        }
        if ( !point.hasOwnProperty('y') ) {
            console.error('A point of construction has no property "y"!');
            console.log(point);
            return null;
        }
    }

    return points;
};
R2D.SceneParser.parseConstructionVersion001.parseWalls = function(walls) {
    for ( var index = 0, length = walls.length; index < length; index++ ) {
        var wall = walls[index];

        if ( !wall.hasOwnProperty('id') ) {
            console.error('A wall of construction has no property "id"!');
            console.log(wall);
            return [];
        }
        if ( !wall.hasOwnProperty('m') ) {
            console.error('A wall of construction has no property "m"!');
            console.log(wall);
            return [];
        }
        if ( !wall.hasOwnProperty('mr') || wall['mr'] == null || wall['mr'] == undefined) {
            console.error('A wall of construction has no property "mr"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(wall, 'mr');
        }
        if ( !wall.hasOwnProperty('mx') || wall['mx'] == null || wall['mx'] == undefined) {
            console.error('A wall of construction has no property "mx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(wall, 'mx');
        }
        if ( !wall.hasOwnProperty('my') || wall['my'] == null || wall['my'] == undefined) {
            console.error('A wall of construction has no property "my"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(wall, 'my');
        }
        if ( !wall.hasOwnProperty('pa') ) {
            console.error('A wall of construction has no property "pa"!');
            console.log(wall);
            return [];
        }
        if ( !wall.hasOwnProperty('pb') ) {
            console.error('A wall of construction has no property "pb"!');
            console.log(wall);
            return [];
        }
        if ( !wall.hasOwnProperty('pm') ) {
            console.error('A wall of construction has no property "pm"!');
            console.log(wall);
            return [];
        }
    }

    return walls;
};
R2D.SceneParser.parseConstructionVersion001.parseCovers = function(covers) {
    for ( var index = 0, length = covers.length; index < length; index++ ) {
        var cover = covers[index];

        if ( !cover.hasOwnProperty('id') ) {
            console.error('A cover of construction has no property "id"!');
            console.log(cover);
            return null;
        }
        if ( !cover.hasOwnProperty('m') ) {
            console.error('A cover of construction has no property "m"!');
            console.log(cover);
            return null;
        }
        if ( !cover.hasOwnProperty('mr') || cover['mr'] == null || cover['mr'] == undefined) {
            console.error('A cover of construction has no property "mr"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'mr');
        }
        if ( !cover.hasOwnProperty('mx') || cover['mx'] == null || cover['mx'] == undefined) {
            console.error('A cover of construction has no property "mx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'mx');
        }
        if ( !cover.hasOwnProperty('my') || cover['my'] == null || cover['my'] == undefined) {
            console.error('A cover of construction has no property "my"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'my');
        }
        if ( !cover.hasOwnProperty('mc') ) {
            console.error('A cover of construction has no property "mc"!');
            console.log(cover);
            return null;
        }
        if ( !cover.hasOwnProperty('mcr') || cover['mcr'] == null || cover['mcr'] == undefined) {
            console.error('A cover of construction has no property "mcr"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'mcr');
        }
        if ( !cover.hasOwnProperty('mcx') || cover['mcx'] == null || cover['mcx'] == undefined) {
            console.error('A cover of construction has no property "mcx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'mcx');
        }
        if ( !cover.hasOwnProperty('mcy') || cover['mcy'] == null || cover['mcy'] == undefined) {
            console.error('A cover of construction has no property "mcy"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'mcy');
        }
        if ( !cover.hasOwnProperty('o') ) {
            console.error('A cover of construction has no property "o"!');
            console.log(cover);
            return null;
        }
        if ( !cover.hasOwnProperty('ch') || cover['ch'] == null || cover['ch'] == undefined) {
            console.error('A cover of construction has no property "ch"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'ch');
        }
        if ( !cover.hasOwnProperty('cv') || cover['cv'] == null || cover['cv'] == undefined) {
            console.error('A cover of construction has no property "cv"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cover, 'cv');
        }
        if ( !cover.hasOwnProperty('points') ) {
            console.error('A cover of construction has no property "points"!');
            console.log(cover);
            return null;
        }
    }

    return covers;
};
R2D.SceneParser.parseConstructionVersion001.parseCuts = function(cuts) {
    for ( var index = 0, length = cuts.length; index < length; index++ ) {
        var cut = cuts[index];

        if ( !cut.hasOwnProperty('id') ) {
            console.error('A cut of construction has no property "id"!');
            console.log(cut);
            return null;
        }
        if ( !cut.hasOwnProperty('pa') ) {
            console.error('A cut of construction has no property "pa"!');
            console.log(cut);
            return null;
        }
        if ( !cut.hasOwnProperty('pb') ) {
            console.error('A cut of construction has no property "pb"!');
            console.log(cut);
            return null;
        }
        if ( !cut.hasOwnProperty('m') ) {
            console.error('A cut of construction has no property "m"!');
            console.log(cut);
            return null;
        }
        if ( !cut.hasOwnProperty('mr') || cut['mr'] == null || cut['mr'] == undefined) {
            console.error('A cut of construction has no property "mr"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cut, 'mr');
        }
        if ( !cut.hasOwnProperty('mx') || cut['mx'] == null || cut['mx'] == undefined) {
            console.error('A cut of construction has no property "mx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cut, 'mx');
        }
        if ( !cut.hasOwnProperty('my') || cut['my'] == null || cut['my'] == undefined) {
            console.error('A cut of construction has no property "my"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cut, 'my');
        }
    }

    return cuts;
};
R2D.SceneParser.parseConstructionVersion001.parseRooms = function(rooms) {
    for ( var index = 0, length = rooms.length; index < length; index++ ) {
        var room = rooms[index];

        if ( !room.hasOwnProperty('id') ) {
            console.error('A room of construction has no property "id"!');
            console.log(room);
            return null;
        }
        if ( !room.hasOwnProperty('outer') ) {
            console.error('A room of construction has no property "outer"!');
            console.log(room);
            return null;
        }
        if ( !room.hasOwnProperty('points') ) {
            console.error('A room of construction has no property "points"!');
            console.log(room);
            return null;
        }
        if ( !room.hasOwnProperty('walls') ) {
            console.error('A room of construction has no property "walls"!');
            console.log(room);
            return null;
        }
    }

    return rooms;
};
R2D.SceneParser.parseConstructionVersion001.parseAreas = function(areas) {
    for ( var index = 0, length = areas.length; index < length; index++ ) {
        var area = areas[index];

        if ( !area.hasOwnProperty('id') ) {
            console.error('An area of construction has no property "id"!');
            console.log(area);
            return null;
        }
        if ( !area.hasOwnProperty('h') || area['h'] == null || area['h'] == undefined) {
            console.error('An area of construction has no property "h"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'h');
        }
        if ( !area.hasOwnProperty('m') ) {
            console.error('An area of construction has no property "m"!');
            console.log(area);
            return null;
        }
        if ( !area.hasOwnProperty('mr') || area['mr'] == null || area['mr'] == undefined) {
            console.error('An area of construction has no property "mr"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'mr');
        }
        if ( !area.hasOwnProperty('mx') || area['mx'] == null || area['mx'] == undefined) {
            console.error('An area of construction has no property "mx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'mx');
        }
        if ( !area.hasOwnProperty('my') || area['my'] == null || area['my'] == undefined) {
            console.error('An area of construction has no property "my"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'my');
        }
        if ( !area.hasOwnProperty('mc') ) {
            console.error('An area of construction has no property "mc"!');
            console.log(area);
            return null;
        }
        if ( !area.hasOwnProperty('mcr') || area['mcr'] == null || area['mcr'] == undefined) {
            console.error('An area of construction has no property "mcr"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'mcr');
        }
        if ( !area.hasOwnProperty('mcx') || area['mcx'] == null || area['mcx'] == undefined) {
            console.error('An area of construction has no property "mcx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'mcx');
        }
        if ( !area.hasOwnProperty('mcy') || area['mcy'] == null || area['mcy'] == undefined) {
            console.error('An area of construction has no property "mcy"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'mcy');
        }
        if ( !area.hasOwnProperty('ch') || area['ch'] == null || area['ch'] == undefined) {
            console.error('An area of construction has no property "ch"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'ch');
        }
        if ( !area.hasOwnProperty('cv') || area['cv'] == null || area['cv'] == undefined) {
            console.error('An area of construction has no property "cv"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(area, 'cv');
        }
        if ( !area.hasOwnProperty('walls') ) {
            console.error('An area of construction has no property "walls"!');
            console.log(area);
            return null;
        }
        if ( !area.hasOwnProperty('cuts') ) {
            console.error('An area of construction has no property "cuts"!');
            console.log(area);
            return null;
        }
    }

    return areas;
};
R2D.SceneParser.parseConstructionVersion001.parseCup = function(cup) {
    if ( !cup.hasOwnProperty('m') ) {
        console.error('A cup of construction has no property "m"!');
        console.log(cup);
        return null;
    }
    if ( !cup.hasOwnProperty('mr') || cup['mr'] == null || cup['mr'] == undefined) {
        console.error('A cup of construction has no property "mr"!');
        R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cup, 'mr');
    }
    if ( !cup.hasOwnProperty('mx') || cup['mx'] == null || cup['mx'] == undefined) {
        console.error('A cup of construction has no property "mx"!');
        R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cup, 'mx');
    }
    if ( !cup.hasOwnProperty('my') || cup['my'] == null || cup['my'] == undefined) {
        console.error('A cup of construction has no property "my"!');
        R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cup, 'my');
    }
    if ( !cup.hasOwnProperty('wh') || cup['wh'] == null || cup['wh'] == undefined) {
        console.error('A cup of construction has no property "wh"!');
        R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(cup, 'wh');
    }

    return cup;
};

R2D.SceneParser.parseSceneVersion001 = function(data)
{
    /*
    if ( !data.hasOwnProperty('version') ) {
        console.error('Scene data has no property "version"!');
        console.log(data);
        return null;
    }
    */
    if ( !data.hasOwnProperty('products') ) {
        console.error('Scene data has no property "products"!');
        console.log(data);
        return null;
    }
    if ( !data.hasOwnProperty('viewState') ) {
        console.error('Scene data has no property "viewState"!');
        console.log(data);
        return null;
    }
    if ( R2D.SceneParser.parseSceneVersion001.parseProducts(data['products']) == null ) {
        console.error('Error parse products!');
        console.log(data['products']);
        return null;
    }

    return data;
};

R2D.SceneParser.parseSceneVersion001.parseProducts = function(products) {
    for ( var i = 0, l = products.length; i < l; i++ ) {
        var product = products[i];

        if ( !product.hasOwnProperty('id') ) {
            console.error('Product has no property "id"!');
            console.log(product);
            return null;
        }
        if ( !product.hasOwnProperty('type') ) {
            console.error('Product has no property "type"!');
            console.log(product);
            return null;
        }
        if ( !product.hasOwnProperty('x') || product['x'] == null || product['x'] == undefined) {
            console.error('Product has no property "x"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'x');
        }
        if ( !product.hasOwnProperty('y') || product['y'] == null || product['y'] == undefined) {
            console.error('Product has no property "y"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'y');
        }
        if ( !product.hasOwnProperty('z') || product['z'] == null || product['z'] == undefined) {
            console.error('Product has no property "z"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'z');
        }
        if ( !product.hasOwnProperty('sx') || product['sx'] == null || product['sx'] == undefined) {
            console.error('Product has no property "sx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'sx');
        }
        if ( !product.hasOwnProperty('sy') || product['sy'] == null || product['sy'] == undefined) {
            console.error('Product has no property "sy"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'sy');
        }
        if ( !product.hasOwnProperty('sz') || product['sz'] == null || product['sz'] == undefined) {
            console.error('Product has no property "sz"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'sz');
        }
        if ( !product.hasOwnProperty('rx') || product['rx'] == null || product['rx'] == undefined) {
            console.error('Product has no property "rx"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'rx');
        }
        if ( !product.hasOwnProperty('ry') || product['ry'] == null || product['ry'] == undefined) {
            console.error('Product has no property "ry"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'ry');
        }
        if ( !product.hasOwnProperty('rz') || product['rz'] == null || product['rz'] == undefined) {
            console.error('Product has no property "rz"!');
            R2D.SceneParser.projectMissingDataCorrector.setDefaultValue(product, 'rz');
        }

        product['x'] =  Number(product['x']);
        product['y'] =  Number(product['y']);
        product['z'] = -Number(product['z']);

        product['sx'] = Number(product['sx']);
        product['sy'] = Number(product['sy']);
        product['sz'] = Number(product['sz']);

        product['rx'] =  Number(product['rx']);
        product['ry'] = -Number(product['ry']);
        product['rz'] =  Number(product['rz']);

        if ( parseInt(product['type']) == R2D.ProductType.MODEL ) {
            if ( !product.hasOwnProperty('materials') ) {
                console.error('Product has no property "materials"!');
                console.log(product);
                return null;
            }

            if ( R2D.SceneParser.parseSceneVersion001.parseProductModelMaterials(product['materials']) == null ) {
                console.error('Error parse product materials!');
                console.log(product);
                return null;
            }

            //flip
            product["fx"] = Number(product["fx"]) == 1;
            product["fy"] = Number(product["fy"]) == 1;
            product["fz"] = Number(product["fz"]) == 1;

            if ( product["sx"] < 0 ) {
                // product["fx"] = !product["fx"];
                product["sx"] = -product["sx"];
            }
            if ( product["sy"] < 0 ) {
                // product["fy"] = !product["fy"];
                product["sy"] = -product["sy"];
            }
            if ( product["sz"] < 0 ) {
                // product["fz"] = !product["fz"];
                product["sz"] = -product["sz"];
            }
        }
    }

    return products;
};
R2D.SceneParser.parseSceneVersion001.parseProductModelMaterials = function(materials) {
    for ( var i = 0, l = materials.length; i < l; i++ ) {
        var material = materials[i];

        if ( !material.hasOwnProperty('current') ) {
            if( !material.hasOwnProperty('default') ) {
                console.error('Material has no property "current" and "default"!');
                console.log(material);
                return null;
            }
            material.current = material.default;
        }
    }

    return materials;
};


R2D.SceneParser.parseVersion001 = function(data) {
    if ( R2D.SceneParser.parseConstructionVersion001(data['construction']) == null ) {
        console.error('Error parse a construction data!');
        console.log(data['construction']);
        return null;
    }
    if ( R2D.SceneParser.parseSceneVersion001(data['scene']) == null ) {
        console.error('Error parse a scene data!');
        console.log(data['scene']);
        return null;
    }

    return data;
};

R2D.SceneParser.parse = function(data) {
    if ( !data.hasOwnProperty('id') ) {
        console.error('Plan has no property "id"!');
        return null;
    }
    if ( !data.hasOwnProperty('user_key') ) {
        console.error('Plan has no property "user_key"!');
        return null;
    }
    if ( !data.hasOwnProperty('name') ) {
        console.error('Plan has no property "name"!');
        return null;
    }
    if ( !data.hasOwnProperty('dimension') ) {
        console.error('Plan has no property "dimension"!');
        return null;
    }
    if ( !data.hasOwnProperty('scene') ) {
        console.error('Plan has no property "scene"!');
        return null;
    }
    if ( !data.hasOwnProperty('construction') ) {
        console.error('Plan has no property "construction"!');
        return null;
    }
    /*if ( !data.hasOwnProperty('floorplan') ) {
        console.error('Plan has no property "floorplan"!');
        return null;
    }*/
    /*if ( !data.hasOwnProperty('preview') ) {
        console.error('Plan has no property "preview"!');
        return null;
    }*/

    switch ( data['version'] ) {
        case 'version_001':
            return R2D.SceneParser.parseVersion001(data);

        default:
            return R2D.SceneParser.parseVersion001(data);
    }

    return null;
};

class ProjectMissingDataCorrector extends EventDispatcher {
    constructor() {
        super();

        this.default = {
            mr: 0,
            mx: 0,
            my: 0,
            mcr: 0,
            mcx: 0,
            mcy: 0,
            ch: 280,
            wh: 280,
            h: 100,
            cv: 1,
            x: 0,
            y: 0,
            z: 0,
            sx: 1,
            sy: 1,
            sz: 1,
            rx: 0,
            ry: 0,
            rz: 0,
        };
    }

    setDefaultValue(object, name) {
        console.log(object);
        console.warn("Added default value");
        object[name] = this.default[name];
        this.dispatchEvent(new Event("sendToSentry", { message: "Something went wrong" }));
    }

    checkProperty(object, name) {
        if (
            !object.hasOwnProperty(name) ||
            object[name] == null ||
            object[name] == undefined ||
            object[name].toString() == "NaN"
        ) {
            console.error(`Problem with property "${name}"!`);
            this.setDefaultValue(object, name);
        }
    }

    checkSceneDataBeforeSend = function (data) {
        for (let i = 0; i < data.construction.walls.length; i += 1) {
            const wall = data.construction.walls[i];
            this.checkProperty(wall, "mr");
            this.checkProperty(wall, "mx");
            this.checkProperty(wall, "my");
        }

        for (let i = 0; i < data.construction.covers.length; i += 1) {
            const cover = data.construction.covers[i];
            this.checkProperty(cover, "mr");
            this.checkProperty(cover, "mx");
            this.checkProperty(cover, "my");
            this.checkProperty(cover, "mcr");
            this.checkProperty(cover, "mcx");
            this.checkProperty(cover, "mcy");
            this.checkProperty(cover, "ch");
            this.checkProperty(cover, "cv");
        }

        for (let i = 0; i < data.construction.cuts.length; i += 1) {
            const cut = data.construction.cuts[i];
            this.checkProperty(cut, "mr");
            this.checkProperty(cut, "mx");
            this.checkProperty(cut, "my");
        }

        for (let i = 0; i < data.construction.areas.length; i += 1) {
            const area = data.construction.areas[i];
            this.checkProperty(area, "h");
            this.checkProperty(area, "mr");
            this.checkProperty(area, "mx");
            this.checkProperty(area, "my");
            this.checkProperty(area, "mcr");
            this.checkProperty(area, "mcx");
            this.checkProperty(area, "mcy");
            this.checkProperty(area, "ch");
            this.checkProperty(area, "cv");
        }

        const cup = data.construction.cap;
        this.checkProperty(cup, "mr");
        this.checkProperty(cup, "mx");
        this.checkProperty(cup, "my");
        this.checkProperty(cup, "wh");

        for (let i = 0; i < data.scene.products.length; i += 1) {
            const product = data.scene.products[i];
            this.checkProperty(product, "x");
            this.checkProperty(product, "y");
            this.checkProperty(product, "z");
            this.checkProperty(product, "sx");
            this.checkProperty(product, "sy");
            this.checkProperty(product, "sz");
            this.checkProperty(product, "rx");
            this.checkProperty(product, "ry");
            this.checkProperty(product, "rz");
        }
    };
}

R2D.SceneParser.projectMissingDataCorrector = new ProjectMissingDataCorrector();

//parsers

R2D.ProductDataParser = function() {
    throw "Error! Use static methods!";
};

R2D.ProductDataParser.parseJSONMaterial = function(data) {
    var base = R2D.ProductDataParser.parseJSONBase(data);

    if ( base == null ) {
        console.error("Error parse material data!");
        return null;
    }

    return data;
};
R2D.ProductDataParser.parseJSONPoster = function(data) {
    var base = R2D.ProductDataParser.parseJSONBase(data);

    if ( base == null ) {
        console.error("Error parse poster data!");
        return null;
    }
    if ( !data['property'].hasOwnProperty('position') ) {
        console.error("Data of poster has no property \"position\"!");
        console.log(data);
        return null;
    }
    if ( R2D.ProductDataParser.parseJSONBasePosition(data['property']['position']) == null ) {
        console.error("Error parse poster data!");
        return null;
    }
    if ( R2D.ProductDataParser.parseJSONBaseSizes(data['property']['sizes']) == null ) {
        console.error("Error parse poster data!");
        return null;
    }

    //----
    var w = data['property']['sizes']['width'].toString();
    var h = data['property']['sizes']['height'].toString();

    data['source']['body']['contourCut'] = '0,0,' + w + ',0,' + w + ',' + h + ',0,' + h;

    return data;
};
R2D.ProductDataParser.parseJSONCarpet = function(data) {
    var base = R2D.ProductDataParser.parseJSONBase(data);

    if ( base == null ) {
        console.error("Error parse carpet data!");
        return null;
    }
    if ( !data['property'].hasOwnProperty('position') ) {
        console.error("Data of carpet has no property \"position\"!");
        console.log(data);
        return null;
    }
    if ( R2D.ProductDataParser.parseJSONBasePosition(data['property']['position']) == null ) {
        console.error("Error parse carpet data!");
        return null;
    }
    if ( R2D.ProductDataParser.parseJSONBaseSizes(data['property']['sizes']) == null ) {
        console.error("Error parse carpet data!");
        return null;
    }

    //----
    var w = data['property']['sizes']['width'].toString();
    var h = data['property']['sizes']['height'].toString();

    data['source']['body']['contourCut'] = '0,0,' + w + ',0,' + w + ',' + h + ',0,' + h;

    return data;
};

R2D.ProductDataParser.parseJSONModelMaterials = function(data) {
    for ( var i = 0, l = data.length; i < l; i++ ) {
        var element = data[i];

        if ( !element.hasOwnProperty('id') ) {
            console.error('Material item geometry\'s data has no property "id"!');
            console.log(element);
            return null;
        }
        if ( !element.hasOwnProperty('name') ) {
            console.error('Material item geometry\'s data has no property "name"!');
            console.log(element);
            return null;
        }
        if ( !element.hasOwnProperty('source') ) {
            console.error('Material item geometry\'s data has no property "source"!');
            console.log(element);
            return null;
        }
        if ( !element.hasOwnProperty('default') ) {
            console.error('Material item geometry\'s data has no property "default"!');
            console.log(element);
            return null;
        }
    }

    return data;
};
R2D.ProductDataParser.parseJSONModel = function(data) {
    var base = R2D.ProductDataParser.parseJSONBase(data);

    if ( base == null ) {
        console.error("Error parse model data!");
        return null;
    }
    if ( !data['property'].hasOwnProperty('position') ) {
        console.error("Data of model has no property \"position\"!");
        console.log(data);
        return null;
    }
    if ( R2D.ProductDataParser.parseJSONBasePosition(data['property']['position']) == null ) {
        console.error("Error parse model data!");
        return null;
    }
    if ( R2D.ProductDataParser.parseJSONBaseSizes(data['property']['sizes']) == null ) {
        console.error("Error parse model data!");
        return null;
    }

    if ( !data['property'].hasOwnProperty('appointment') ) {
        console.error('Model data has no property "property.appointment"');
        console.log(data);
        return null;
    }
    if ( !data['source']['body'].hasOwnProperty('contourCut') ) {
        console.error('Model data has no property "source.body.contourCut"');
        console.log(data);
        return null;
    }
    if ( !data['source']['body'].hasOwnProperty('contourTop') ) {
        console.error('Model data has no property "source.body.contourTop"');
        console.log(data);
        return null;
    }
    if ( !data['source']['body'].hasOwnProperty('materials') ) {
        console.error('Model data has no property "source.body.materials"');
        console.log(data);
        return null;
    }

    if ( R2D.ProductDataParser.parseJSONModelMaterials(data['source']['body']['materials']) == null ) {
        console.error("Model data materials is null!");
        console.log(data);
        return null;
    }

    if ( !data['source']['body'].hasOwnProperty("contourCut") || data['source']['body']['contourCut'] == '' ) {
        //console.warn("Model data contour cut is null or empty. Set contour cut by model size.");
        //console.log(data);

        var w = data['property']['sizes']['width'].toString();
        var h = data['property']['sizes']['height'].toString();

        data['source']['body']['contourCut'] = '0,0,' + w + ',0,' + w + ',' + h + ',0,' + h;
    }

    return data;
};
R2D.ProductDataParser.parseJSONBasePosition = function(data) {
    if ( !data.hasOwnProperty('x') ) {
        console.error('Position has no property "x"');
        return null;
    }
    if ( !data.hasOwnProperty('y') ) {
        console.error('Position has no property "y"');
        return null;
    }
    if ( !data.hasOwnProperty('z') ) {
        console.error('Position has no property "z"');
        return null;
    }

    data['x'] = Number(data['x']);
    data['y'] = Number(data['y']);
    data['z'] = Number(data['z']);

    return data;
};
R2D.ProductDataParser.parseJSONBaseSizes = function(data) {
    if ( !data.hasOwnProperty('width') ) {
        console.error('Sizes has no property "width"');
        return null;
    }
    if ( !data.hasOwnProperty('height') ) {
        console.error('Sizes has no property "height"');
        return null;
    }
    if ( !data.hasOwnProperty('depth') ) {
        console.error('Sizes has no property "depth"');
        return null;
    }

    data['width'] = Number(data['width']);
    data['height'] = Number(data['height']);
    data['depth'] = Number(data['depth']);

    return data;
};
R2D.ProductDataParser.parseJSONBaseDetails = function(data) {
    if ( !data.hasOwnProperty('description') ) {
        return null;
    }
    if ( !data.hasOwnProperty('productPage') ) {
        return null;
    }
    if ( !data['productPage'].hasOwnProperty('available') ) {
        return null;
    }
    if ( !data['productPage'].hasOwnProperty('url') ) {
        return null;
    }

    return data;
};

R2D.ProductDataParser.parseJSONBase = function(data) {
    if ( !data.hasOwnProperty('id') ) {
        console.error('Product data has no property "id"');
        console.log(data);
        return null;
    }
    if ( !data.hasOwnProperty('type') ) {
        console.error('Product data has no property "type"');
        console.log(data);
        return null;
    }
    if ( !data.hasOwnProperty("user_key") ) {
        console.warn('Product data has no property "user_key"');
        console.log(data);
        // return null;
    }
    if ( !data.hasOwnProperty('name') ) {
        console.error('Product data has no property "name"');
        console.log(data);
        return null;
    }
    if ( !data.hasOwnProperty('description') ) {
        console.error('Product data has no property "description"');
        console.log(data);
        return null;
    }
    if ( !data.hasOwnProperty('source') ) {
        console.error('Product data has no property "source"');
        console.log(data);
        return null;
    }
    if ( !data['source'].hasOwnProperty('images') ) {
        console.error('Product data has no property "source.images"');
        console.log(data);
        return null;
    }
    if ( !data['source']['images'].hasOwnProperty('preview') ) {
        console.error('Product data has no property "source.images.preview"');
        console.log(data);
        return null;
    }
    if ( !data['source'].hasOwnProperty('body') ) {
        console.error('Product data has no property "source.body"');
        console.log(data);
        return null;
    }
    if ( !data['source']['body'].hasOwnProperty('package') ) {
        console.error('Product data has no property "source.body.package"');
        console.log(data);
        return null;
    }
    if ( !data.hasOwnProperty('property') ) {
        console.error('Product data has no property "property"');
        console.log(data);
        return null;
    }
    if ( !data['property'].hasOwnProperty('sizes') ) {
        console.error('Product data has no property "property.sizes"');
        console.log(data);
        return null;
    }

    //optional
    if ( data.hasOwnProperty('details') && R2D.ProductDataParser.parseJSONBaseDetails(data['details']) == null ) {
        console.warn('Product data has property "details" but the data incorrect!');
    }

    data['productId'] = data['id'];

    return data;
};

R2D.ProductDataParser.parseJSON = function(products) {
    var productsData = [];

    for ( var i = 0, l = products.length; i < l; i++ ) {
        var product = products[i];
        var productType = 0;
        var productData = null;

        if ( !product.hasOwnProperty('type') ) {
            console.error('Product data has no property "type". Data was ignored!');
            continue;
        }

        productType = parseInt(product.type);

        switch ( productType ) {
            case R2D.ProductType.MATERIAL:
                productData = R2D.ProductDataParser.parseJSONMaterial(product);
                break;

            case R2D.ProductType.MODEL:
                productData = R2D.ProductDataParser.parseJSONModel(product);
                break;

            case R2D.ProductType.POSTER:
                productData = R2D.ProductDataParser.parseJSONPoster(product);
                break;

            case R2D.ProductType.CARPET:
                productData = R2D.ProductDataParser.parseJSONCarpet(product);
                break;

            default:
                console.error("Error type of data");
                console.log(product);
                continue;
        }

        if ( productData ) productsData.push(productData);
    }

    return productsData;
};
R2D.ProductPackageParser = function() {
    //-
};

R2D.ProductPackageParser.MARKER_ROOMTODO = "ROOMTODO";

R2D.ProductPackageParser.readString = function(dataView, offset, length) {
    var string = "";

    for ( var i = offset; i < offset + length; i += 1 ) {
        string += String.fromCharCode(dataView.getInt8(i));
    }

    return string;
};

R2D.ProductPackageParser.readData = function(dataView, offset, length) {
    var ab = new ArrayBuffer(length);
    var dw = new DataView(ab);

    for ( var pc = 0, ps = offset, l = length; pc < l; pc += 1, ps += 1 ) {
        dw.setInt8(pc, dataView.getInt8(ps));
    }

    return ab;
};

R2D.ProductPackageParser.parse = function(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var marker = R2D.ProductPackageParser.readString(dataView, 0, R2D.ProductPackageParser.MARKER_ROOMTODO.length);
    var type = 0;

    if ( marker != R2D.ProductPackageParser.MARKER_ROOMTODO ) return null;

    type = dataView.getInt32(8);

    switch ( type ) {
        case 1: return R2D.ProductPackageParser.parseMaterial(arrayBuffer);
        case 2: return R2D.ProductPackageParser.parseModel(arrayBuffer);
        case 3: return null; //R2D.ProductPackageParser.parsePoster(arrayBuffer);
        case 4: return null; //R2D.ProductPackageParser.parseCarpet(arrayBuffer);
    }

    return null;
};
//parsers

R2D.ProductPackageParser.parseMaterial = function(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var materialData = {
        type:0,
        version:0,
        defaultWidth:1,
        defaultHeight:1,
        currentWidth:1,
        currentHeight:1,
        scaleX:1,
        scaleY:1,
        scalability:true,
        transparent:true,
        gloss:false,
        metal:false,
        intensityGloss:0,
        intensityMetal:0,
        materialType:0,
        materialReflectivity:0,
        diffuseData:null,
        specularData:null,
        normalData:null,
        diffuseImage:null,
        specularImage:null,
        normalImage:null
    };
    var size = dataView.byteLength;
    var marker = R2D.ProductPackageParser.readString(dataView, 0, R2D.ProductPackageParser.MARKER_ROOMTODO.length);
    var type = 0;
    var version = 0;
    var offset = R2D.ProductPackageParser.MARKER_ROOMTODO.length;
    var dataLen = 0;

    if ( marker != R2D.ProductPackageParser.MARKER_ROOMTODO ) throw "Error parsing a material data! Marker error!";

    type = dataView.getInt32(offset);
    offset += 4;

    if ( type != 1 && type != 2 ) throw "Error parsing a material data! Type error!";

    version = dataView.getInt32(offset);
    offset += 4;

    materialData.type = type;
    materialData.version = version;

    for ( ; offset < size; ) {
        type = dataView.getInt32(offset);
        offset += 4;

        switch ( type ) {
            case 10:
                materialData.defaultWidth = dataView.getInt32(offset);
                offset += 4;
                break;

            case 11:
                materialData.defaultHeight = dataView.getInt32(offset);
                offset += 4;
                break;

            case 12:
                materialData.currentWidth = dataView.getInt32(offset);
                offset += 4;
                break;

            case 13:
                materialData.currentHeight = dataView.getInt32(offset);
                offset += 4;
                break;

            case 14:
                materialData.scaleX = dataView.getFloat32(offset);
                offset += 4;
                break;

            case 15:
                materialData.scaleY = dataView.getFloat32(offset);
                offset += 4;
                break;

            case 20:
                materialData.scalability = dataView.getInt8(offset) == 1;
                offset += 1;
                break;

            case 21:
                materialData.transparent = dataView.getInt8(offset) == 1;
                offset += 1;
                break;

            case 22:
                materialData.gloss = dataView.getInt8(offset) == 1;
                offset += 1;
                break;

            case 23:
                materialData.metal = dataView.getInt8(offset) == 1;
                offset += 1;
                break;

            case 30:
                materialData.intensityGloss = dataView.getFloat32(offset);
                offset += 4;

                if ( isNaN(materialData.intensityGloss) ) {
                    materialData.intensityGloss = 0;
                }
                break;

            case 31:
                materialData.intensityMetal = dataView.getFloat32(offset);
                offset += 4;

                if ( isNaN(materialData.intensityMetal) ) {
                    materialData.intensityMetal = 0;
                }
                break;

            case 60:
                materialData.materialType = dataView.getInt32(offset);
                offset += 4;
                break;

            case 61:
                materialData.materialReflectivity = dataView.getFloat32(offset);
                offset += 4;

                if ( isNaN(materialData.materialReflectivity) ) {
                    materialData.materialReflectivity = 0;
                }
                break;

            case 50:
                dataLen = dataView.getInt32(offset);
                offset += 4;
                materialData.diffuseData = R2D.ProductPackageParser.readData(dataView, offset, dataLen);
                offset += dataLen;
                break;

            case 51:
                dataLen = dataView.getInt32(offset);
                offset += 4;
                materialData.specularData = R2D.ProductPackageParser.readData(dataView, offset, dataLen);
                offset += dataLen;
                break;

            case 52:
                dataLen = dataView.getInt32(offset);
                offset += 4;
                materialData.normalData = R2D.ProductPackageParser.readData(dataView, offset, dataLen);
                offset += dataLen;
                break;

            default:
                console.warn('ProductPackageParserMaterial: Unknown type ' + type);
        }
    }

    return materialData;
};
//parsers

R2D.ProductPackageParser.parseModel = function(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var modelData = {
        type:0,
        version:0,
        geometries:[],
        contourCut:null
    };
    var size = dataView.byteLength;
    var marker = R2D.ProductPackageParser.readString(dataView, 0, R2D.ProductPackageParser.MARKER_ROOMTODO.length);
    var type = 0;
    var version = 0;
    var offset = R2D.ProductPackageParser.MARKER_ROOMTODO.length;
    var geometriesAmount = 0;
    var index = 0;
    var i = 0;
    var length = 0;

    if ( marker != R2D.ProductPackageParser.MARKER_ROOMTODO ) throw "Error parsing a model data! Marker error!";

    type = dataView.getInt32(offset);
    offset += 4;

    if ( type != 2 ) {
        throw "Error parsing a model data! Type error! Received " + type + ". Needs 2.";
    }

    version = dataView.getInt32(offset);
    offset += 4;

    modelData.type = type;
    modelData.version = version;

    for ( ; offset < size; ) {
        type = dataView.getInt32(offset);
        offset += 4;

        switch ( type ) {
            case 10:
                geometriesAmount = dataView.getInt32(offset);
                offset += 4;

                for ( index = 0; index < geometriesAmount; index += 1 ) {
                    var vertices = null;
                    var uvs = null;
                    var normals = null;
                    var indices = null;
                    var md5 = null;

                    if ( R2D.ProductPackageParser.readString(dataView, offset, 5) != "BEGIN" ) {
                        throw "Error parsing a model data! Geometry marker error!";
                    }

                    offset += 5;

                    for ( ; ; ) {
                        if ( R2D.ProductPackageParser.readString(dataView, offset, 3) == "END" ) {
                            offset += 3;
                            break;
                        }

                        type = dataView.getInt32(offset);
                        offset += 4;

                        switch ( type ) {
                            case 20:
                                vertices = [];

                                length = dataView.getInt32(offset);
                                offset += 4;

                                for ( i = 0; i < length; i++ ) {
                                    vertices.push(dataView.getFloat32(offset));
                                    offset += 4;
                                    vertices.push(dataView.getFloat32(offset));
                                    offset += 4;
                                    vertices.push(dataView.getFloat32(offset));
                                    offset += 4;
                                }

                                break;

                            case 21:
                                uvs = [];

                                length = dataView.getInt32(offset);
                                offset += 4;

                                for ( i = 0; i < length; i++ ) {
                                    uvs.push(dataView.getFloat32(offset));
                                    offset += 4;
                                    uvs.push(dataView.getFloat32(offset));
                                    offset += 4;
                                }

                                break;

                            case 22:
                                normals = [];

                                length = dataView.getInt32(offset);
                                offset += 4;

                                for ( i = 0; i < length; i++ ) {
                                    normals.push(dataView.getFloat32(offset));
                                    offset += 4;
                                    normals.push(dataView.getFloat32(offset));
                                    offset += 4;
                                    normals.push(dataView.getFloat32(offset));
                                    offset += 4;
                                }

                                break;

                            case 23:
                                indices = [];

                                length = dataView.getInt32(offset);
                                offset += 4;

                                for ( i = 0; i < length; i++ ) {
                                    indices.push(dataView.getUint32(offset));
                                    offset += 4;
                                }

                                break;

                            case 30:
                                md5 = "";

                                for ( i = 0; i < 32; i++ ) {
                                    md5 += String.fromCharCode(dataView.getUint8(offset));
                                    offset += 1;
                                }

                                break;
                        }
                    }

                    modelData.geometries.push({
                        vertices:vertices,
                        uvs:uvs,
                        normals:normals,
                        indices:indices,
                        md5:md5
                    });
                }

                break; //end case 10

            case 50:
                var contourCut = [];

                length = dataView.getInt32(offset);
                offset += 4;

                for ( i = 0; i < length; i++ ) {
                    contourCut.push(dataView.getFloat32(offset));
                    offset += 4;
                    contourCut.push(dataView.getFloat32(offset));
                    offset += 4;
                }

                modelData.contourCut = contourCut;

                break; //end case 50
        }
    }

    if ( version == 1 ) {
        //console.warn("Received old model data! Version " + version);

        modelData.geometries = R2D.Tool.flipGeometriesByZ(modelData.geometries);
    }
    if ( version < 3 ) {
        //console.warn("Received old model data! Version " + version);
        //console.warn("Creating md5 ...");

        modelData.geometries.forEach(function(geometry) {
            let indices = geometry.indices || [];
            let vertices = geometry.vertices || [];
            let normals = geometry.normals || [];
            let uvs = geometry.uvs || [];

            geometry.md5 = R2D.OBJParser.getGeometryMD5(indices, vertices, normals, uvs);
        });
    }

    return modelData;
};


R2D.ProductPackageParser.parsePoster = function(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var posterData = {
        type:0,
        version:0,
        materialData:null
    };
    var size = dataView.byteLength;
    var marker = R2D.ProductPackageParser.readString(dataView, 0, R2D.ProductPackageParser.MARKER_ROOMTODO.length);
    var type = 0;
    var version = 0;
    var offset = R2D.ProductPackageParser.MARKER_ROOMTODO.length;
    var dataLen = 0;

    if ( marker != R2D.ProductPackageParser.MARKER_ROOMTODO ) throw "Error parsing a poster data! Marker error!";

    type = dataView.getInt32(offset);
    offset += 4;

    if ( type != 3 ) throw "Error parsing a poster data! Type error!";

    version = dataView.getInt32(offset);
    offset += 4;

    posterData.type = type;
    posterData.version = version;

    for ( ; offset < size; ) {
        type = dataView.getInt32(offset);
        offset += 4;

        switch ( type ) {
            case 10:
                var arrayBinary;
                var materialRaw;

                dataLen = dataView.getInt32(offset);
                offset += 4;

                arrayBinary = new Int8Array(dataLen);

                for ( var b = 0; b < dataLen; b += 1 ) {
                    arrayBinary[b] = dataView.getInt8(offset);
                    offset += 1;
                }

                posterData.materialData = R2D.ProductPackageParser.parseMaterial(arrayBinary.buffer);
                break;
        }
    }

    return posterData;
};
R2D.ProductPackageParser.parseCarpet = function(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var carpetData = {
        type:0,
        version:0,
        carpetType:0,
        materialData:null
    };
    var size = dataView.byteLength;
    var marker = R2D.ProductPackageParser.readString(dataView, 0, R2D.ProductPackageParser.MARKER_ROOMTODO.length);
    var type = 0;
    var version = 0;
    var offset = R2D.ProductPackageParser.MARKER_ROOMTODO.length;
    var dataLen = 0;

    if ( marker != R2D.ProductPackageParser.MARKER_ROOMTODO ) throw "Error parsing a carpet data! Marker error!";

    type = dataView.getInt32(offset);
    offset += 4;

    if ( type != 4 ) throw "Error parsing a carpet data! Type error!";

    version = dataView.getInt32(offset);
    offset += 4;

    carpetData.type = type;
    carpetData.version = version;

    for ( ; offset < size; ) {
        type = dataView.getInt32(offset);
        offset += 4;

        switch ( type ) {
            case 10:
                var arrayBinary;
                var materialRaw;

                dataLen = dataView.getInt32(offset);
                offset += 4;

                arrayBinary = new Int8Array(dataLen);

                for ( var b = 0; b < dataLen; b += 1 ) {
                    arrayBinary[b] = dataView.getInt8(offset);
                    offset += 1;
                }

                carpetData.materialData = R2D.ProductPackageParser.parseMaterial(arrayBinary.buffer);
                break;

            case 20:
                carpetData.carpetType = dataView.getInt32(offset);
                offset += 4;
                break;
        }
    }

    return carpetData;
};
// controllers

R2D.MouseEventController = function() {
    throw "You can't create instance of R2D.MouseEventController! Use the static methods!"
};

R2D.MouseEventController.LEFT_MOUSE_DOWN = "leftMouseDown";
R2D.MouseEventController.LEFT_MOUSE_UP = "leftMouseUp";
R2D.MouseEventController.LEFT_MOUSE_CLICK = "leftMouseClick";
R2D.MouseEventController.RIGHT_MOUSE_DOWN = "rightMouseDown";
R2D.MouseEventController.RIGHT_MOUSE_UP = "rightMouseUp";
R2D.MouseEventController.RIGHT_MOUSE_CLICK = "rightMouseClick";
R2D.MouseEventController.MOUSE_OVER = "mouseOver";
R2D.MouseEventController.MOUSE_OUT = "mouseOut";
R2D.MouseEventController.MOUSE_ENTER = "mouseEnter";
R2D.MouseEventController.MOUSE_LEAVE = "mouseLeave";
R2D.MouseEventController.MOUSE_WHEEL = "mouseWheel";
R2D.MouseEventController.MOUSE_MOVE = "mouseMove";

R2D.MouseEventController.TOUCH_DOWN = "touchDown";
R2D.MouseEventController.TOUCH_UP = "touchUp";
R2D.MouseEventController.TOUCH_MOVE = "touchMove";

R2D.MouseEventController.__link = new Map();

R2D.MouseEventController.__supportedEvents = [
    R2D.MouseEventController.LEFT_MOUSE_DOWN,
    R2D.MouseEventController.LEFT_MOUSE_UP,
    R2D.MouseEventController.LEFT_MOUSE_CLICK,
    R2D.MouseEventController.RIGHT_MOUSE_DOWN,
    R2D.MouseEventController.RIGHT_MOUSE_UP,
    R2D.MouseEventController.RIGHT_MOUSE_CLICK,
    R2D.MouseEventController.MOUSE_OVER,
    R2D.MouseEventController.MOUSE_OUT,
    R2D.MouseEventController.MOUSE_ENTER,
    R2D.MouseEventController.MOUSE_LEAVE,
    R2D.MouseEventController.MOUSE_WHEEL,
    R2D.MouseEventController.MOUSE_MOVE,

    R2D.MouseEventController.TOUCH_DOWN,
    R2D.MouseEventController.TOUCH_UP,
    R2D.MouseEventController.TOUCH_MOVE
];

R2D.MouseEventController.__isSupported = function(type) {
    for ( var i = R2D.MouseEventController.__supportedEvents.length - 1; i >= 0; i-- ) {
        if ( R2D.MouseEventController.__supportedEvents[i] == type ) {
            return;
        }
    }

    throw type + " of event doesn't supported!";
};

R2D.MouseEventController.__nativeListener = function(method, target, type, callback) {
    switch ( type ) {
        case R2D.MouseEventController.LEFT_MOUSE_DOWN:
            target[method]("mousedown", callback);
            break;

        case R2D.MouseEventController.LEFT_MOUSE_UP:
            target[method]("mouseup", callback);
            break;

        case R2D.MouseEventController.LEFT_MOUSE_CLICK:
            target[method]("click", callback);
            break;

        case R2D.MouseEventController.RIGHT_MOUSE_DOWN:
            target[method]("mousedown", callback);
            break;

        case R2D.MouseEventController.RIGHT_MOUSE_UP:
            target[method]("mouseup", callback);
            break;

        case R2D.MouseEventController.RIGHT_MOUSE_CLICK:
            target[method]("click", callback);
            break;

        case R2D.MouseEventController.MOUSE_OVER:
            target[method]("mouseover", callback);
            break;

        case R2D.MouseEventController.MOUSE_OUT:
            target[method]("mouseout", callback);
            break;

        case R2D.MouseEventController.MOUSE_ENTER:
            target[method]("mouseenter", callback);
            break;

        case R2D.MouseEventController.MOUSE_LEAVE:
            target[method]("mouseleave", callback);
            break;

        case R2D.MouseEventController.MOUSE_WHEEL:
            target[method]("wheel", callback);
        //    target[method]("mousewheel", callback);
        //    target[method]("DOMMouseScroll", callback); // firefox
            break;

        case R2D.MouseEventController.MOUSE_MOVE:
            target[method]("mousemove", callback);
            break;


        case R2D.MouseEventController.TOUCH_DOWN:
            target[method]("touchstart", callback);
            break;

        case R2D.MouseEventController.TOUCH_MOVE:
            target[method]("touchmove", callback);
            break;

        case R2D.MouseEventController.TOUCH_UP:
            target[method]("touchend", callback);
            break;

        default:
            throw "Unknown type of event!";
    }
};

R2D.MouseEventController.__getChecker = function(type) {
    switch ( type ) {
        case R2D.MouseEventController.LEFT_MOUSE_DOWN:
        case R2D.MouseEventController.LEFT_MOUSE_UP:
        case R2D.MouseEventController.LEFT_MOUSE_CLICK:
            return function(event) {
                return event.button == 0;
            };

        case R2D.MouseEventController.RIGHT_MOUSE_DOWN:
        case R2D.MouseEventController.RIGHT_MOUSE_UP:
        case R2D.MouseEventController.RIGHT_MOUSE_CLICK:
            return function(event) {
                return event.button == 2;
            };

        case R2D.MouseEventController.MOUSE_OVER:
        case R2D.MouseEventController.MOUSE_OUT:
        case R2D.MouseEventController.MOUSE_ENTER:
        case R2D.MouseEventController.MOUSE_LEAVE:
        case R2D.MouseEventController.MOUSE_WHEEL:
        case R2D.MouseEventController.MOUSE_MOVE:

        case R2D.MouseEventController.TOUCH_DOWN:
        case R2D.MouseEventController.TOUCH_MOVE:
        case R2D.MouseEventController.TOUCH_UP:

            return function(event) {
                return true;
            };

        default:
            throw "Unknown type of event!";
    }
};
R2D.MouseEventController.__getListener = function(type, currentTarget, listener) {
    var checker = R2D.MouseEventController.__getChecker(type);
    

    return function (event) {
        if( checker(event) ) {
            var newEvent = {
                type:type,
                currentTarget:currentTarget,
                target:event.target,
                clientX:event.clientX,
                clientY:event.clientY,
                pageX:event.pageX,
                pageY:event.pageY,
                movementX:event.movementX,
                movementY:event.movementY,
                offsetX:event.offsetX,
                offsetY:event.offsetY,
                screenX:event.screenX,
                screenY:event.screenY,
                button:event.button,
                buttons:event.buttons,
                metaKey:event.metaKey,
                shiftKey:event.shiftKey,
                ctrlKey:event.ctrlKey,
                altKey:event.altKey,
                region:event.region,
                deltaWheel:(event.deltaY || event.detail || event.wheelDelta),
                nativeEvent:event
            };

            if (event.touches && event.touches.length > 0)
            {
                newEvent.clientX = event.touches[0].clientX;
                newEvent.clientY = event.touches[0].clientY;

                newEvent.pageX = event.touches[0].pageX;
                newEvent.pageY = event.touches[0].pageY;

                newEvent.screenX = event.touches[0].screenX;
                newEvent.screenY = event.touches[0].screenY;
            }
            else if (event.changedTouches && event.changedTouches.length > 0)
            {
                newEvent.clientX = event.changedTouches[0].clientX;
                newEvent.clientY = event.changedTouches[0].clientY;

                newEvent.pageX = event.changedTouches[0].pageX;
                newEvent.pageY = event.changedTouches[0].pageY;

                newEvent.screenX = event.changedTouches[0].screenX;
                newEvent.screenY = event.changedTouches[0].screenY;
            }

            listener(newEvent);
        }
    };
};
R2D.MouseEventController.__addListener = function(currentTarget, target, type, listener) {
    var link = R2D.MouseEventController.__link;
    var targets = link.get(type);
    var listeners = null;
    var callback = null;

    if ( targets == null ) {
        targets = new Map();
        link.set(type, targets);
    }

    listeners = targets.get(currentTarget);

    if ( listeners == null ) {
        listeners = new Map();
        targets.set(currentTarget, listeners);
    }

    if ( listeners.get(listener) ) {
        return;
    }
    callback = R2D.MouseEventController.__getListener(type, currentTarget, listener);

    listeners.set(listener, callback);

    R2D.MouseEventController.__nativeListener("addEventListener", target, type, callback);
};
R2D.MouseEventController.__removeListener = function(currentTarget, target, type, listener) {
    var link = R2D.MouseEventController.__link;
    var targets = link.get(type);
    var listeners = null;
    var callback = null;

    if ( targets == null ) {
        return;
    }

    listeners = targets.get(currentTarget);

    if ( listeners == null ) {
        return;
    }

    callback = listeners.get(listener);

    if ( callback == null ) {
        return;
    }

    listeners.delete(listener);

    R2D.MouseEventController.__nativeListener("removeEventListener", target, type, callback);
};
R2D.MouseEventController.__checkInputData = function(currentTargetObject, targetObject, eventType, listener) {
    if ( !currentTargetObject ) throw "MouseEventController: current target is " + currentTargetObject;
    if ( !targetObject ) throw "MouseEventController: target is " + targetObject;
    if ( !eventType ) throw "MouseEventController: type is " + eventType;
    if ( !listener ) throw "MouseEventController: listener is " + listener;
};

R2D.MouseEventController.addListener = function(currentTargetObject, targetObject, eventType, listener) {
    R2D.MouseEventController.__checkInputData(currentTargetObject, targetObject, eventType, listener);
    R2D.MouseEventController.__isSupported(eventType);

    R2D.MouseEventController.__addListener(currentTargetObject, targetObject, eventType, listener);
};
R2D.MouseEventController.removeListener = function(currentTargetObject, targetObject, eventType, listener) {
    R2D.MouseEventController.__checkInputData(currentTargetObject, targetObject, eventType, listener);
    R2D.MouseEventController.__isSupported(eventType);

    R2D.MouseEventController.__removeListener(currentTargetObject, targetObject, eventType, listener);
};

//alias
R2D.MEC = R2D.MouseEventController;
R2D.MEC.add = R2D.MouseEventController.addListener;
R2D.MEC.remove = R2D.MouseEventController.removeListener;
// controllers

R2D.EntityController = function() {
    EventDispatcher.call(this);

    var scope = this;

    scope.enable = function() {
        throw "Method \"enable\" in R2D.EntityController class needs to implement!"
    };
    scope.disable = function() {
        throw "Method \"disable\" in R2D.EntityController class needs to implement!"
    };
};

R2D.extend(R2D.EntityController, EventDispatcher);
// controllers

R2D.OrbitController = function() {
    R2D.EntityController.call(this);

    var scope = this;
    var pan = 0;
    var tilt = 0;
    var distance = 500;
    var anchor = { x:0, y:0, z:0 };
    var position = { x:0, y:0, z:0 };
    var rotation = { x:0, y:0, z:0 };

    scope.minDistance = 100;
    scope.maxDistance = 1000;
    scope.minTilt = -Math.PI / 2;
    scope.maxTilt = Math.PI / 2;

    scope.getAnchor = function() { return anchor; };
    scope.getPan = function() { return pan; };
    scope.getTilt = function() { return tilt; };
    scope.getDistance = function() { return distance; };
    scope.getPosition = function() { return position; };
    scope.getRotation = function() { return rotation; };

    scope.setAnchor = function(x, y, z)
    {
        anchor.x = x;
        anchor.y = y;
        anchor.z = z;
    };
    scope.setPan = function (angle) {
        pan = angle;
    };
    scope.setTilt = function(angle) {
        if ( angle > scope.maxTilt ) tilt = scope.maxTilt;
        else if ( angle < scope.minTilt ) tilt = scope.minTilt;
        else tilt = angle;
    };
    scope.setDistance = function (dist) {
        distance = Math.min(Math.max(dist, scope.minDistance), scope.maxDistance);
    };
    scope.update = function() {
        scope.setDistance(distance); //for check

        position.y = anchor.y + distance * Math.sin(tilt);
        position.x = anchor.x + distance * Math.cos(tilt) * Math.sin(pan);
        position.z = anchor.z + distance * Math.cos(tilt) * Math.cos(pan);

        rotation.y = pan;
        rotation.x = -tilt;

        scope.dispatchEvent(new Event(Event.UPDATE, scope));
    };
};

R2D.extend(R2D.OrbitController, R2D.EntityController);
// controllers

R2D.CameraOrbitController = function(camera, canvas) {
    R2D.EntityController.call(this);

    var scope = this;
    var panSensitive = 0.01;
    var tiltSensitive = 0.01;
    var orbitController = new R2D.OrbitController();
    var mousePoint = {x:0, y:0};
    var zoom = 1;
    var zoomSteps = 20;
    var zoomStep = 1 / zoomSteps;
    var distanceMin = 500;
    var distanceMax = 2000;
    var distance = getDistance(distanceMin, distanceMax, zoom);

    function orbitControllerUpdate(event) {
        camera.position.set(orbitController.getPosition().x, orbitController.getPosition().y, orbitController.getPosition().z);
        camera.rotation.set(orbitController.getRotation().x, orbitController.getRotation().y, 0, 'YXZ');

        scope.dispatchUpdate(scope);
    }

    function getDistance(min, max, zoom) {
        return (max - min) * zoom + min;
    }

    function canvasMouseWheelZoom(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();

        zoom = event.deltaWheel > 0 ? Math.min(zoom + zoomStep, 1) : Math.max(zoom - zoomStep, 0);
        distance = getDistance(distanceMin, distanceMax, zoom);

        orbitController.setDistance(distance);
        orbitController.update();
    }

    //object moving
    function canvasMouseMoveMoving(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();

        var dx = event.clientX - mousePoint.x;
        var dy = event.clientY - mousePoint.y;

        //TODO
        console.warn('TODO: moving');

        mousePoint.x = event.clientX;
        mousePoint.y = event.clientY;
    }
    function canvasMouseUpMoving(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.MOUSE_MOVE, canvasMouseMoveMoving);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_UP, canvasMouseUpMoving);

        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_DOWN, canvasMouseDownRotate);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_DOWN, canvasMouseDownMoving);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.MOUSE_WHEEL, canvasMouseWheelZoom);
    }
    function canvasMouseDownMoving(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();

        mousePoint.x = event.clientX;
        mousePoint.y = event.clientY;

        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_DOWN, canvasMouseDownRotate);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_DOWN, canvasMouseDownMoving);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.MOUSE_WHEEL, canvasMouseWheelZoom);

        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.MOUSE_MOVE, canvasMouseMoveMoving);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_UP, canvasMouseUpMoving);
    }

    //object rotate
    function canvasMouseMoveRotate(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();

        var dx = event.clientX - mousePoint.x;
        var dy = event.clientY - mousePoint.y;

        orbitController.setPan(orbitController.getPan() - dx * panSensitive);
        orbitController.setTilt(orbitController.getTilt() + dy * tiltSensitive);
        orbitController.update();

        mousePoint.x = event.clientX;
        mousePoint.y = event.clientY;
    }
    function canvasMouseUpRotate(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();

        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.MOUSE_MOVE, canvasMouseMoveRotate);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_UP, canvasMouseUpRotate);

        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_DOWN, canvasMouseDownRotate);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_DOWN, canvasMouseDownMoving);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.MOUSE_WHEEL, canvasMouseWheelZoom);
    }
    function canvasMouseDownRotate(event) {
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();

        mousePoint.x = event.clientX;
        mousePoint.y = event.clientY;

        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_DOWN, canvasMouseDownRotate);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_DOWN, canvasMouseDownMoving);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.MOUSE_WHEEL, canvasMouseWheelZoom);

        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.MOUSE_MOVE, canvasMouseMoveRotate);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_UP, canvasMouseUpRotate);
    }
    function canvasContextMenuEventHandler(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    function releaseCanvas() {
        if ( !canvas ) return;

        canvas.removeEventListener('contextmenu', canvasContextMenuEventHandler);

        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_DOWN, canvasMouseDownRotate);
        R2D.MouseEventController.removeListener(canvas, canvas, R2D.MouseEventController.MOUSE_WHEEL, canvasMouseWheelZoom);
    }
    function keepCanvas() {
        if ( !canvas ) return;

        canvas.addEventListener('contextmenu', canvasContextMenuEventHandler);

        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.LEFT_MOUSE_DOWN, canvasMouseDownRotate);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.RIGHT_MOUSE_DOWN, canvasMouseDownMoving);
        R2D.MouseEventController.addListener(canvas, canvas, R2D.MouseEventController.MOUSE_WHEEL, canvasMouseWheelZoom);
    }

    Object.defineProperties(scope, {
        'minDistance':{
            get() {
                return distanceMin;
            },
            set(v) {
                distanceMin = v;
                orbitController.minDistance = distanceMin;
            }
        },
        'maxDistance':{
            get() {
                return distanceMax;
            },
            set(v) {
                distanceMax = v;
                orbitController.maxDistance = distanceMax;
            }
        }
    });

    scope.getAnchor = function() { return orbitController.anchor; };
    scope.getPan = function() { return orbitController.pan; };
    scope.getTilt = function() { return orbitController.tilt; };
    scope.getPosition = function() { return orbitController.position; };
    scope.getRotation = function() { return orbitController.rotation; };

    scope.getDistance = orbitController.getDistance;

    scope.setAnchor = orbitController.setAnchor;
    scope.setPan = orbitController.setPan;
    scope.setTilt = orbitController.setTilt;
    scope.setDistance = orbitController.setDistance;

    scope.getCamera = function () { return camera; };
    scope.getCanvas = function () { return canvas; };
    scope.setCamera = function(cam) {
        camera = cam;
    };
    scope.setCanvas = function (can) {
        releaseCanvas();

        canvas = can;

        keepCanvas();
    };

    scope.update = function() {
        orbitController.update();
    };

    scope.enable = function() {
        //-
    };
    scope.disable = function() {
        //-
    };

    orbitController.minDistance = distanceMin;
    orbitController.maxDistance = distanceMax;

    orbitController.setDistance(distance);
    orbitController.addEventListener(Event.UPDATE, orbitControllerUpdate);
    orbitController.update();

    keepCanvas();
};

R2D.extend(R2D.CameraOrbitController, R2D.EntityController);
// controllers

R2D.MouseController = function() {
    R2D.EntityController.call(this);

    let scope = this;
    let currentCanvas = null;
    let windowMouseDownPoint = {x:0, y:0};
    let enabled = true;

    function mouseWheelEventHandler(event) {
        if ( event.deltaWheel == 0 ) return;

        let x = event.offsetX == undefined ? event.layerX : event.offsetX;
        let y = event.offsetY == undefined ? event.layerY : event.offsetY;

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.ZOOM,
            delta:event.deltaWheel,
            x,
            y
        }));
    }
    function leftMouseMoveEventHandler(event) {
        let dx = event.screenX - windowMouseDownPoint.x;
        let dy = event.screenY - windowMouseDownPoint.y;

        windowMouseDownPoint.x = event.screenX;
        windowMouseDownPoint.y = event.screenY;

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.ROTATE,
            dx:dx,
            dy:dy
        }));
    }
    function leftMouseUpEventHandler(event) {
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, leftMouseMoveEventHandler);
        R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUpEventHandler);

        R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.LEFT_MOUSE_DOWN, leftMouseDownEventHandler);

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.END_ROTATE
        }));
    }
    function leftMouseDownEventHandler(event) {
        R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.LEFT_MOUSE_DOWN, leftMouseDownEventHandler);
        
        windowMouseDownPoint.x = event.screenX;
        windowMouseDownPoint.y = event.screenY;

        R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, leftMouseMoveEventHandler);
        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUpEventHandler);

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.START_ROTATE
        }));
    }
    function rightMouseMoveEventHandler(event) {
        let dx = event.screenX - windowMouseDownPoint.x;
        let dy = event.screenY - windowMouseDownPoint.y;

        windowMouseDownPoint.x = event.screenX;
        windowMouseDownPoint.y = event.screenY;

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.MOVE,
            dx:dx,
            dy:dy
        }));
    }
    function rightMouseUpEventHandler(event) {
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, rightMouseMoveEventHandler);
        R2D.MEC.remove(window, window, R2D.MEC.RIGHT_MOUSE_UP, rightMouseUpEventHandler);

        //R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.END_MOVE
        }));
    }
    function rightMouseDownEventHandler(event) {
        //R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);

        windowMouseDownPoint.x = event.screenX;
        windowMouseDownPoint.y = event.screenY;

        R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, rightMouseMoveEventHandler);
        R2D.MEC.add(window, window, R2D.MEC.RIGHT_MOUSE_UP, rightMouseUpEventHandler);

        scope.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.START_MOVE
        }));
    }

    function preventContextMenu(event) {
        event.preventDefault();
    }

    function addListeners() {
        currentCanvas.addEventListener("contextmenu", preventContextMenu);

        R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.LEFT_MOUSE_DOWN, leftMouseDownEventHandler);
        //R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);
        R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.MOUSE_WHEEL, mouseWheelEventHandler);

        enabled = true;
    }
    function removeListeners() {
        currentCanvas.removeEventListener("contextmenu", preventContextMenu);

        R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.LEFT_MOUSE_DOWN, leftMouseDownEventHandler);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, leftMouseMoveEventHandler);
        R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUpEventHandler);

        //R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, rightMouseMoveEventHandler);
        R2D.MEC.remove(window, window, R2D.MEC.RIGHT_MOUSE_UP, rightMouseUpEventHandler);

        R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.MOUSE_WHEEL, mouseWheelEventHandler);
    }

    scope.enable = function() {
        if ( enabled ) return;
        if ( currentCanvas ) {
            addListeners();
        }

        enabled = true;
    };
    scope.disable = function() {
        if ( !enabled ) return;
        if ( currentCanvas ) {
            removeListeners();
        }

        enabled = false;
    };
    scope.updateComponents = function(canvas) {
        if ( currentCanvas && enabled ) removeListeners();

        currentCanvas = canvas;

        if ( currentCanvas && enabled ) addListeners();
    };
};

R2D.extend(R2D.MouseController, R2D.EntityController);

R2D.MouseController.MOVE = 'mouseControllerMove';
R2D.MouseController.START_MOVE = 'mouseControllerStartMove';
R2D.MouseController.END_MOVE = 'mouseControllerEndMove';
R2D.MouseController.ZOOM = 'mouseControllerZoom';
R2D.MouseController.ROTATE = 'mouseControllerRotate';
R2D.MouseController.START_ROTATE = 'mouseControllerStartRotate';
R2D.MouseController.END_ROTATE = 'mouseControllerEndRotate';
// controllers

R2D.TouchController = function() {
    R2D.EntityController.call(this);

    var scope = this;
    var currentCanvas = null;
    var touchPoint = {x:0, y:0, radius:0};
    var startPoint = {x:0, y:0, radius:0};
    var enabled = true;
    var timePrev = null;
    var timeCurrent = null;
    var timeDelta = 0;
    var isRotate = false;
    var isZoom = false;
    var isMove = false;
/*
    var debugDiv = document.createElement('div');
    debugDiv.style.position = 'absolute';
    debugDiv.style.bottom = '0';
    debugDiv.style.color = 'red';
    debugDiv.style['pointer-events'] = 'none';
    debugDiv.style['z-index'] = 100;
    document.body.appendChild(debugDiv);
*/
    function touchHandler(event) {
        if ( !enabled ) return;

        var x = 0;
        var y = 0;
        var dx = 0;
        var dy = 0;
        var r = 0;

        event.preventDefault();
        //event.stopPropagation();

        switch ( event.touches.length ) {
            case 0:
                if ( event.type == 'touchend' ) {

                    isRotate = false;
                    isMove = false;
                    isZoom = false;
                }
                break;

            case 1:
                if ( isZoom || isMove ) return;

                if ( event.type == 'touchstart' ) {
                    timePrev = Date.now();
                    touchPoint.x = event.touches[0].clientX;
                    touchPoint.y = event.touches[0].clientY;
                } else if ( event.type == 'touchmove' ) {
                    timeCurrent = Date.now();
                    timeDelta = timeCurrent - timePrev;
                    timePrev = timeCurrent;
                    x = event.touches[0].clientX;
                    y = event.touches[0].clientY;

                    if ( timeDelta < 100 ) {
                        isRotate = true;

                        scope.dispatchEvent(new Event(Event.UPDATE, {
                            type: R2D.MouseController.ROTATE,
                            dx:x - touchPoint.x,
                            dy:y - touchPoint.y
                        }));
                    }

                    touchPoint.x = x;
                    touchPoint.y = y;
                }
                break;

            case 2:
                isRotate = false;

                if ( event.type == 'touchstart' ) {
                    //timePrev = Date.now();
                    dx = event.touches[1].clientX - event.touches[0].clientX;
                    dy = event.touches[1].clientY - event.touches[0].clientY;
                    x = event.touches[0].clientX + dx / 2;
                    y = event.touches[0].clientY + dy / 2;
                    r = Math.sqrt(dx * dx + dy * dy);

                    touchPoint.x = x;
                    touchPoint.y = y;
                    touchPoint.radius = r;

                    startPoint.x = x;
                    startPoint.y = y;
                    startPoint.radius = r;

                } else if ( event.type == 'touchmove' ) {
                    dx = event.touches[1].clientX - event.touches[0].clientX;
                    dy = event.touches[1].clientY - event.touches[0].clientY;
                    x = event.touches[0].clientX + dx / 2;
                    y = event.touches[0].clientY + dy / 2;
                    r = Math.sqrt(dx * dx + dy * dy);

                    if (Math.abs(r - startPoint.radius) > 20) {
                        isZoom = true;
                        isMove = false;

                    //    debugDiv.innerText += '\n' + 'zoom ' + String(touchPoint.radius - r);

                        scope.dispatchEvent(new Event(Event.UPDATE, {
                            type: R2D.MouseController.ZOOM,
                            delta: (touchPoint.radius - r) * 0.3
                        }));
                    } else {
                        isMove = true;
                        isZoom = false;

                    //    debugDiv.innerText += '\n' + 'move ' + String(x - touchPoint.x) + ', ' + String(y - touchPoint.y);

                        scope.dispatchEvent(new Event(Event.UPDATE, {
                            type: R2D.MouseController.MOVE,
                            dx:x - touchPoint.x,
                            dy:y - touchPoint.y
                        }));
                    }

                    touchPoint.x = x;
                    touchPoint.y = y;
                    touchPoint.radius = r;
                }

        }
    }
    function addListeners() {
        currentCanvas.addEventListener("touchstart", touchHandler);
        currentCanvas.addEventListener("touchend", touchHandler);
        currentCanvas.addEventListener("touchmove", touchHandler);
    }
    function  removeListeners() {
        currentCanvas.removeEventListener("touchstart", touchHandler);
        currentCanvas.removeEventListener("touchend", touchHandler);
        currentCanvas.removeEventListener("touchmove", touchHandler);
    }

    scope.enable = function() {
        if ( enabled ) return;

        addListeners();

        enabled = true;
    };
    scope.disable = function() {
        if ( !enabled ) return;

        removeListeners();

        enabled = false;
    };
    scope.updateComponents = function(canvas) {
        if ( currentCanvas && enabled ) removeListeners();

        currentCanvas = canvas;

        if ( currentCanvas && enabled ) addListeners();
    };
};

R2D.extend(R2D.TouchController, R2D.EntityController);
// controllers

R2D.KeyboardController = function(api) {
    R2D.EntityController.call(this);

    var scope = this;
    var enabled = true;

    var domElement = null;
    var sendingAction = false;

    var downA = false;
    var downD = false;
    var downW = false;
    var downS = false;

    var downLeft = false;
    var downRight = false;
    var downForward = false;
    var downBackward = false;

    var upLeft = false;
    var upRight = false;
    var upForward = false;
    var upBackward = false;

    var downShift = false;
    var downCtrl = false;

    function sendFirstAction()
    {
        if ( downA || downLeft )
        {
            var evt = new Event(R2D.KeyboardController.LEFT_DOWN, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
        if ( downD || downRight )
        {
            evt = new Event(R2D.KeyboardController.RIGHT_DOWN, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
        if ( downW || downForward )
        {
            evt = new Event(R2D.KeyboardController.FORWARD_DOWN, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
        if ( downS || downBackward )
        {
            evt = new Event(R2D.KeyboardController.BACKWARD_DOWN, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
    }

    function sendUpAction()
    {
        if (upLeft)
        {
            var evt = new Event(R2D.KeyboardController.LEFT_UP, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
        if (upRight)
        {
            evt = new Event(R2D.KeyboardController.RIGHT_UP, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
        if (upForward)
        {
            evt = new Event(R2D.KeyboardController.FORWARD_UP, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
        if (upBackward)
        {
            evt = new Event(R2D.KeyboardController.BACKWARD_UP, scope);
            evt.shiftKey = downShift;
            evt.ctrlKey = downCtrl;
            scope.dispatchEvent(evt);
        }
    }

    function sendAction() {
        var needsRepeat = false;

        if ( downA || downLeft ) {
            needsRepeat = true;

            scope.dispatchEvent(new Event(R2D.KeyboardController.LEFT, scope));
        }
        if ( downD || downRight ) {
            needsRepeat = true;

            scope.dispatchEvent(new Event(R2D.KeyboardController.RIGHT, scope));
        }
        if ( downW || downForward ) {
            needsRepeat = true;

            scope.dispatchEvent(new Event(R2D.KeyboardController.FORWARD, scope));
        }
        if ( downS || downBackward ) {
            needsRepeat = true;

            scope.dispatchEvent(new Event(R2D.KeyboardController.BACKWARD, scope));
        }

        if ( needsRepeat ) {
            sendingAction = true;

            window.requestAnimationFrame(sendAction);
        } else {
            sendingAction = false;
        }
    }

    function keyDownEventHandler(event)
    {
        if(event.target.matches("input")) return;

        downShift = event.shiftKey;
        downCtrl = event.ctrlKey;

        switch (event.keyCode) {
            case 65:
                downA = true;
                upLeft = false;
                break;

            case 68:
                downD = true;
                upRight = false;
                break;

            case 87:
                downW = true;
                upForward = false;
                break;

            case 83:
                downS = true;
                upBackward = true;
                break;

            case 37:
                downLeft = true;
                upLeft = false;
                break;

            case 39:
                downRight = true;
                upRight = false;
                break;

            case 38:
                downForward = true;
                upForward = false;
                break;

            case 40:
                downBackward = true;
                upBackward = true;
                break;
        }

        sendFirstAction();
        if ( !sendingAction ) sendAction();
    }
    function keyUpEventHandler(event) {
        switch ( event.keyCode ) {
            case 65:
                downA = false;
                upLeft = true;
                break;

            case 68:
                downD = false;
                upRight = true;
                break;

            case 87:
                downW = false;
                upForward = true;
                break;

            case 83:
                downS = false;
                upBackward = true;
                break;

            case 37:
                downLeft = false;
                upLeft = true;
                break;

            case 39:
                downRight = false;
                upRight = true;
                break;

            case 38:
                downForward = false;
                upForward = true;
                break;

            case 40:
                downBackward = false;
                upBackward = true;
                break;
        }

        if (event.keyCode == 87 || event.keyCode == 83 || event.keyCode == 65 || event.keyCode == 68) {
            R2D.scene.history.saveState();
            api.dispatchEvent(new Event(api.HISTORY_UNDO_REDO, {removeQuickPanel: false, clearRightPanel: false}));
        }

        if ( !sendingAction ) sendAction();
        sendUpAction();
    }

    function removeListeners() {
        downA = false;
        downD = false;
        downW = false;
        downS = false;
        downLeft = false;
        downRight = false;
        downForward = false;
        downBackward = false;

        window.removeEventListener('keydown', keyDownEventHandler);
        window.removeEventListener('keyup', keyUpEventHandler);
    }
    function addListeners() {
        document.addEventListener('keydown', keyDownEventHandler);
        document.addEventListener('keyup', keyUpEventHandler);
    }

    function mouseOutEventHandler(event) {
        removeListeners();
    }
    function mouseOverEventHandler(event) {
        addListeners();
    }

    scope.enable = function() {
        if ( enabled ) return;
    };
    scope.disable = function() {
        if ( !enabled ) return;
    };
    scope.updateComponents = function(element) {
        if ( domElement ) {
            removeListeners();
            domElement.removeEventListener('mouseover', mouseOverEventHandler);
            domElement.removeEventListener('mouseout', mouseOutEventHandler);
        }

        domElement = element;

        if ( domElement ) {
            domElement.addEventListener('mouseover', mouseOverEventHandler);
            domElement.addEventListener('mouseout', mouseOutEventHandler);
        }
    };
};

R2D.extend(R2D.KeyboardController, R2D.EntityController);

R2D.KeyboardController.LEFT = 'left';
R2D.KeyboardController.RIGHT = 'right';
R2D.KeyboardController.FORWARD = 'forward';
R2D.KeyboardController.BACKWARD = 'backward';

R2D.KeyboardController.LEFT_DOWN = 'leftDown';
R2D.KeyboardController.RIGHT_DOWN = 'rightDown';
R2D.KeyboardController.FORWARD_DOWN = 'forwardDown';
R2D.KeyboardController.BACKWARD_DOWN = 'backwardDown';

R2D.KeyboardController.LEFT_UP = 'leftUp';
R2D.KeyboardController.RIGHT_UP = 'rightUp';
R2D.KeyboardController.FORWARD_UP = 'forwardUp';
R2D.KeyboardController.BACKWARD_UP = 'backwardUp';
// controllers

R2D.ButtonsController = function() {
    var scope = this;
    var topLeftPanelButtons = [];

    function clearTopLeftPanelButtons()
    {
        topLeftPanelButtons.forEach(function (element) {
            if ( element.isAdded() ) {
                R2D.TopLeftPanel.remove(element, 3);
            }
        });

        topLeftPanelButtons = [];
    }

    function displayTopLeftPanelButtons()
    {
        topLeftPanelButtons.forEach(function (element) {
            if ( !element.isAdded() ) {
                R2D.TopLeftPanel.add(element, 3);
            }
        });
    }
    function createTopLeftPanelButtons(data) {
        data.forEach(function(item) {
            var face, button, element;

            switch ( item['type'] ) {
                case 'icon':
                    face = new R2D.TopLeftPanel.FaceIcon(
                        item['style']['icon']['url'],
                        R2D.TopLeftPanel.Face.ALIGN_CENTER,
                        false,
                        item['style']['icon']
                    );
                    button = new R2D.TopLeftPanel.Button(
                        face,
                        null,
                        true,
                        item['style']['background']
                    );
                    element = new R2D.TopLeftPanel.Element(1, true, [button]);

                    break;

                case 'text':

                    var customColors = Boolean(item['style']['background']);

                    face = new R2D.TopLeftPanel.FaceText(
                        item['style']['text'],
                        null//,
                        //! customColors
                    );
                    button = new R2D.TopLeftPanel.Button(
                        face,
                        null,
                        customColors,
                        item['style']['background']
                    );

                    //button = R2D.TopLeftPanel.Button.makeButtonText(item['style']['text']);
                    element = new R2D.TopLeftPanel.Element(1, true, [button]);

                    break;

                default:
                    console.error('Unknown type of object! Current ' + item['type']);
                    console.log(item);
                    return;
            }

            topLeftPanelButtons.push(element);
            addEventsToButton(button, item);
        });

        displayTopLeftPanelButtons();
    }

    var projToCalcMessage = '';
    function addEventsToButton(button, item)
    {
        projToCalcMessage = item['message_complete'];

        if (item['action'] && item['action'] == 'sendProjectCalc')
        {
            button.addLeftMouseClickListener(sendProjectCalc);
        }
    }

    scope.update = function(data) {

        if (! data) return;

        clearTopLeftPanelButtons();

        createTopLeftPanelButtons(data);

    };

    var windowWait = R2D.DialogStage.getWindowInfo(R2D.TRANSLATION.TEXT_WAIT);
    var windowReg;

    function sendProjectCalc()
    {
        R2D.User.doIfLogged(
            function(){
                var planData = R2D.controller.getObjData();
                var sendObj = {json: JSON.stringify({plan: planData})};

                var params = R2D.XHRLoader.makeParamsString(sendObj);
                var loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_SEND_PROJECT_CALC), params, null, null, true);

                loader.addEventListener(Event.COMPLETE, sendCompleteListener);
                loader.addEventListener(Event.ERROR, sendErrorListener);

                R2D.DialogStage.show(windowWait);
            },
            function(){
                if (R2D.config.data.ui.custom_registration)
                {
                    windowReg = new R2D.DialogStage.CustomRegistration(regDataEntered);
                    R2D.DialogStage.show(windowReg);
                    windowReg.run();
                }
                else
                {
                    windowReg = new R2D.DialogStage.WindowRegistration(regDataEntered);
                    R2D.DialogStage.show(windowReg);
                }
            });

        function regDataEntered(regData)
        {
            var planData = R2D.controller.getObjData();
            var sendObj = {json: JSON.stringify({register: regData, plan: planData})};

            var params = R2D.XHRLoader.makeParamsString(sendObj);
            var loader = R2D.XHRLoader.getPostLoader(R2D.makeURL(R2D.URL.DOMAIN, R2D.URL.URL_SEND_PROJECT_CALC), params, null, null, true);

            loader.addEventListener(Event.COMPLETE, sendCompleteListener);
            loader.addEventListener(Event.ERROR, sendErrorListener);

            R2D.DialogStage.show(windowWait);
        }
    }

    function sendCompleteListener(e)
    {
        R2D.DialogStage.hide(windowWait);
        var dataObj;
        try {
            dataObj = JSON.parse(e.data.data);
        } catch ( error ) {
            console.error('Error parse JSON string!');
            console.log(e.data.data);
            return;
        }
        if ( !dataObj.hasOwnProperty('status') ) {
            console.error('Error! Received data has no property "status"!');
            console.log(dataObj);
            return;
        }
        if ( dataObj['status'] != 'success' ) {
            console.error('Error! Received data status is not "success"!');
            console.log(dataObj);
            if (dataObj['error'] == 'email is bound to another user')
            {
                //R2D.DialogStage.show(R2D.DialogStage.getWindowAlert(R2D.TRANSLATION.TEXT_REG_ERROR_EMAIL_USED, R2D.TRANSLATION.BUTTON_OK));
                onLoginUsed();
            }
            else
            {
                R2D.DialogStage.show(R2D.DialogStage.getWindowAlert(R2D.TRANSLATION.TEXT_ACTION_ERROR, R2D.TRANSLATION.BUTTON_OK));
                console.log(dataObj);
            }
            return;
        }

        R2D.DialogStage.show(R2D.DialogStage.getWindowAlert(projToCalcMessage , R2D.TRANSLATION.BUTTON_OK));
    }

    function onLoginUsed()
    {
        var alertWindow = R2D.DialogStage.getWindowAlert(R2D.TRANSLATION.TEXT_REG_ERROR_EMAIL_USED, R2D.TRANSLATION.BUTTON_OK);
        alertWindow.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, alertListener);
        R2D.DialogStage.show(alertWindow);

        function alertListener()
        {
            R2D.DialogStage.hide(alertWindow);
            alertWindow.removeEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, alertListener);
            alertWindow = null;

            R2D.DialogStage.show(windowReg);
            //R2D.User._windowSignIn.clearUserData();
            //R2D.DialogStage.show(R2D.User._windowSignIn);
        }
    }

    function sendErrorListener(e)
    {
        R2D.DialogStage.hide(windowWait);
        R2D.DialogStage.show(R2D.DialogStage.getWindowAlert(R2D.TRANSLATION.TEXT_ACTION_ERROR, R2D.TRANSLATION.BUTTON_OK));
        console.log(e);
    }

    R2D.config.addEventListener(Event.UPDATE, configUpdateListener);

    function configUpdateListener(e)
    {
        R2D.ButtonsController._instance.update(R2D.config.data.buttons);
    }
};

R2D.ButtonsController._instance = null;

R2D.ButtonsController.init = function() {
    R2D.ButtonsController._instance = new R2D.ButtonsController();

    R2D.ButtonsController._instance.update(R2D.config.data.buttons);
};
R2D.ButtonsController.update = function(data) {
    R2D.ButtonsController._instance.update(data);
};
//viewers

R2D.Tool = function() {

};

R2D.Tool.getGeometryBounds = function(vertices) {
    var minX = vertices[0];
    var maxX = minX;
    var minY = vertices[1];
    var maxY = minY;
    var minZ = vertices[2];
    var maxZ = minZ;

    for ( var x = 3, y = 4, z = 5, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        if ( vertices[x] < minX ) minX = vertices[x];
        if ( vertices[x] > maxX ) maxX = vertices[x];
        if ( vertices[y] < minY ) minY = vertices[y];
        if ( vertices[y] > maxY ) maxY = vertices[y];
        if ( vertices[z] < minZ ) minZ = vertices[z];
        if ( vertices[z] > maxZ ) maxZ = vertices[z];
    }

    return {
        minX:minX, maxX:maxX,
        minY:minY, maxY:maxY,
        minZ:minZ, maxZ:maxZ
    }
};
R2D.Tool.makeGeometryLinesBox = function(cx, cy, cz, width, height, depth) {
    var w2 = width / 2;
    var h2 = height / 2;
    var d2 = depth / 2;
    var vertices = [
        cx + w2, cy + h2, cz + d2,
        cx + w2, cy + h2, cz - d2,
        cx - w2, cy + h2, cz - d2,
        cx - w2, cy + h2, cz + d2,
        cx + w2, cy + h2, cz + d2,
        cx + w2, cy - h2, cz + d2,
        cx + w2, cy - h2, cz - d2,
        cx + w2, cy + h2, cz - d2,
        cx + w2, cy - h2, cz - d2,
        cx - w2, cy - h2, cz - d2,
        cx - w2, cy + h2, cz - d2,
        cx - w2, cy - h2, cz - d2,
        cx - w2, cy - h2, cz + d2,
        cx - w2, cy + h2, cz + d2,
        cx - w2, cy - h2, cz + d2,
        cx + w2, cy - h2, cz + d2
    ];
    var geometry = new THREE.BufferGeometry();

    geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));

    return geometry;
};
R2D.Tool.makeGeometryBox = function(cx, cy, cz, width, height, depth) {
    var w2 = width / 2;
    var h2 = height / 2;
    var d2 = depth / 2;
    var vertices = [
         w2,  h2,  d2,    -w2,  h2,  d2,    w2, -h2,  d2,
         w2, -h2,  d2,    -w2,  h2,  d2,   -w2, -h2,  d2,
        -w2,  h2,  d2,    -w2,  h2, -d2,   -w2, -h2, -d2,
        -w2,  h2,  d2,    -w2,  h2, -d2,   -w2, -h2,  d2,
        -w2,  h2, -d2,     w2,  h2, -d2,   -w2, -h2, -d2,
        -w2, -h2, -d2,     w2,  h2, -d2,    w2, -h2, -d2,
         w2,  h2, -d2,     w2,  h2,  d2,    w2, -h2, -d2,
         w2, -h2, -d2,     w2,  h2,  d2,    w2, -h2,  d2,
         w2,  h2,  d2,     w2,  h2, -d2,   -w2,  h2, -d2,
         w2,  h2,  d2,    -w2,  h2, -d2,   -w2,  h2,  d2,
         w2, -h2,  d2,    -w2, -h2, -d2,    w2, -h2, -d2,
         w2, -h2,  d2,    -w2, -h2,  d2,   -w2, -h2, -d2
    ];
    var uvs = [
        1, 0,   0, 0,   1, 1,
        1, 1,   0, 0,   0, 1,
        1, 0,   0, 0,   1, 1,
        1, 1,   0, 0,   0, 1,
        1, 0,   0, 0,   1, 1,
        1, 1,   0, 0,   0, 1,
        1, 0,   0, 0,   1, 1,
        1, 1,   0, 0,   0, 1,
        1, 1,   0, 0,   1, 0,
        1, 1,   1, 0,   0, 0,
        0, 0,   1, 1,   0, 1,
        0, 0,   1, 0,   1, 1
    ];
    var indices = [
         0,  1,  2,
         3,  4,  5,
         5,  7,  8,
         9, 10, 11,
        12, 13, 14,
        15, 16, 17,
        18, 19, 20,
        21, 22, 23,
        24, 25, 26,
        27, 28, 29,
        30, 31, 32,
        33, 34, 35
    ];
    var geometry = new THREE.BufferGeometry();

    for ( var x = 0, y = 1, z = 2, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        vertices[x] += cx;
        vertices[y] += cy;
        vertices[z] += cz;
    }

    geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
    geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
    geometry.setAttribute("uv", new THREE.BufferAttribute(new Float32Array(uvs), 2));

    geometry.computeFaceNormals();

    return geometry;
};

R2D.Tool.makeBufferGeometry = function(index, vertex, uv, normal) {
    var geometry = new THREE.BufferGeometry();

    if ( index && Array.isArray(index) && index.length > 0 ) {
        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(index), 1))
    }
    if ( vertex && Array.isArray(vertex) && vertex.length > 0 ) {
        geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertex), 3));
    }
    if ( uv && Array.isArray(uv) && uv.length > 0 ) {
        geometry.setAttribute("uv", new THREE.BufferAttribute(new Float32Array(uv), 2));
    }
    if ( normal && Array.isArray(normal) && normal.length > 0 ) {
        geometry.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(normal), 3));
    } else {
        geometry.computeVertexNormals();
    }

    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();

    return geometry;
};

R2D.Tool.translateVertices = function(vertices, tx, ty, tz) {
    var result = new Array(vertices.length);

    for ( var x = 0, y = 1, z = 2, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        result[x] = vertices[x] + tx;
        result[y] = vertices[y] + ty;
        result[z] = vertices[z] + tz;
    }

    return result;
};
R2D.Tool.scaleVertices = function(vertices, sx, sy, sz) {
    var result = new Array(vertices.length);

    for ( var x = 0, y = 1, z = 2, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        result[x] = vertices[x] * sx;
        result[y] = vertices[y] * sy;
        result[z] = vertices[z] * sz;
    }

    return result;
};

R2D.Tool.flipGeometryByX = function(geometry) {
    var newGeometry = {};
    var i, l;
    var oldData, newData;

    if ( geometry.hasOwnProperty("vertices") && geometry.vertices != null && geometry.vertices.length > 0 ) {
        oldData = geometry.vertices;
        newData = new Array(oldData.length);

        for ( i = 0, l = oldData.length; i < l; i += 3 ) {
            newData[i    ] = -oldData[i    ];
            newData[i + 1] =  oldData[i + 1];
            newData[i + 2] =  oldData[i + 2];
        }

        newGeometry.vertices = newData;
    }
    if ( geometry.hasOwnProperty("normals") && geometry.normals != null && geometry.normals.length > 0 ) {
        oldData = geometry.normals;
        newData = new Array(oldData.length);

        for ( i = 0, l = oldData.length; i < l; i += 3 ) {
            newData[i    ] = -oldData[i    ];
            newData[i + 1] =  oldData[i + 1];
            newData[i + 2] =  oldData[i + 2];
        }

        newGeometry.normals = newData;
    }
    if ( geometry.hasOwnProperty("indices") && geometry.indices != null && geometry.indices.length > 0 ) {
        oldData = geometry.indices;
        newData = new Array(oldData.length);

        for ( i = 0, l = oldData.length; i < l; i += 3 ) {
            newData[i    ] = oldData[i    ];
            newData[i + 1] = oldData[i + 2];
            newData[i + 2] = oldData[i + 1];
        }

        newGeometry.indices = newData;
    }
    if ( geometry.hasOwnProperty("uvs") && geometry.uvs != null && geometry.uvs.length > 0 ) {
        newGeometry.uvs = geometry.uvs.slice();
    }

    return newGeometry;
};

R2D.Tool.flipGeometryByZ = function(geometry) {
    var newGeometry = {};
    var i, l;
    var oldData, newData;

    if ( geometry.hasOwnProperty("vertices") && geometry.vertices && geometry.vertices.length > 0 ) {
        oldData = geometry.vertices;
        newData = new Array(oldData.length);

        for ( i = 0, l = oldData.length; i < l; i += 3 ) {
            newData[i    ] =  oldData[i    ];
            newData[i + 1] =  oldData[i + 1];
            newData[i + 2] = -oldData[i + 2];
        }

        newGeometry.vertices = newData;
    }
    if ( geometry.hasOwnProperty("normals") && geometry.normals && geometry.normals.length > 0 ) {
        oldData = geometry.normals;
        newData = new Array(oldData.length);

        for ( i = 0, l = oldData.length; i < l; i += 3 ) {
            newData[i    ] =  oldData[i    ];
            newData[i + 1] =  oldData[i + 1];
            newData[i + 2] = -oldData[i + 2];
        }

        newGeometry.normals = newData;
    }
    if ( geometry.hasOwnProperty("indices") && geometry.indices && geometry.indices.length > 0 ) {
        oldData = geometry.indices;
        newData = new Array(oldData.length);

        for ( i = 0, l = oldData.length; i < l; i += 3 ) {
            newData[i    ] = oldData[i    ];
            newData[i + 1] = oldData[i + 2];
            newData[i + 2] = oldData[i + 1];
        }

        newGeometry.indices = newData;
    }
    if ( geometry.hasOwnProperty("uvs") && geometry.uvs && geometry.uvs.length > 0 ) {
        newGeometry.uvs = geometry.uvs.slice();
    }

    return newGeometry;
};

R2D.Tool.flipGeometriesByX = function(geometries) {
    var newGeometries = [];

    geometries.forEach(function(geometry) {
        newGeometries.push(R2D.Tool.flipGeometryByX(geometry));
    });

    return newGeometries;
};
R2D.Tool.flipGeometriesByZ = function(geometries) {
    var newGeometries = [];

    geometries.forEach(function(geometry) {
        newGeometries.push(R2D.Tool.flipGeometryByZ(geometry));
    });

    return newGeometries;
};

/**
 * Rotate vertices by X axis on angle in radians
 * @param vertices {Array}[x, y, z, ...]
 * @param angle {Number}radians
 * @returns {Array}
 */
R2D.Tool.rotateVerticesByX = function(vertices, angle) {
    var result = new Array(vertices.length);

    /*
     1    0     0 | x
     0 cosA -sinA | y
     0 sinA  cosA | z
     */

    for ( var x = 0, y = 1, z = 2, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        result[x] = vertices[x];
        result[y] = Math.cos(angle) * vertices[y] - Math.sin(angle) * vertices[z]
        result[z] = Math.sin(angle) * vertices[y] + Math.cos(angle) * vertices[z];
    }

    return result;
};
/**
 * Rotate vertices by Y axis on angle in radians
 * @param vertices {Array}[x, y, z, ...]
 * @param angle {Number}radians
 * @returns {Array}
 */
R2D.Tool.rotateVerticesByY = function(vertices, angle) {
    var result = new Array(vertices.length);

    /*
     cosA 0 sinA | x
        0 1    0 | y
    -sinA 0 cosA | z
     */

    for ( var x = 0, y = 1, z = 2, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        result[x] = Math.cos(angle) * vertices[x] + Math.sin(angle) * vertices[z];
        result[y] = vertices[y];
        result[z] = -Math.sin(angle) * vertices[x] + Math.cos(angle) * vertices[z];
    }

    return result;
};
/**
 * Rotate vertices by Z axis on angle in radians
 * @param vertices {Array}[x, y, z, ...]
 * @param angle {Number}radians
 * @returns {Array}
 */
R2D.Tool.rotateVerticesByZ = function(vertices, angle) {
    var result = new Array(vertices.length);

    /*
     cosA -sinA 0 | x
     sinA  cosA 0 | y
        0     0 1 | z
     */

    for ( var x = 0, y = 1, z = 2, l = vertices.length; z < l; x += 3, y += 3, z += 3 ) {
        result[x] = Math.cos(angle) * vertices[x] - Math.sin(angle) * vertices[y];
        result[y] = Math.sin(angle) * vertices[x] + Math.cos(angle) * vertices[y];
        result[z] = vertices[z];
    }

    return result;
};

R2D.Tool.makeModelGeometries = function(raw) {
    var geometries = [];

    raw.forEach(function(data) {
        geometries.push(R2D.Tool.makeBufferGeometry(data.indices, data.vertices, data.uvs, data.normals));
    });

    return geometries;
};

R2D.Tool.makeModelMeshes = function(raw) {
    var geometries = R2D.Tool.makeModelGeometries(raw);
    var meshes = [];

    for ( var i = 0, l = geometries.length; i < l; i++ ) {
        var mesh = new THREE.Mesh(geometries[i], new THREE.MeshBasicMaterial({color:Math.random() * 0xffffff}));

        meshes.push(mesh);
    }

    return meshes;
};

R2D.Tool.arrayBufferToImage = function(arrayBuffer) {
    var img = document.createElement("img");

    img.src = R2D.Tool.arrayBufferToImageUrl(arrayBuffer);

    return img;
};
R2D.Tool.arrayBufferToImageUrl = function(arrayBuffer) {
    var arrayBufferView = new Uint8Array(arrayBuffer);
    var blob = new Blob([arrayBufferView]);
    var urlCreator = window.URL || window.webkitURL;
    var imageUrl = urlCreator.createObjectURL(blob);

    return imageUrl;
};
R2D.Tool.stringDataToArrayBuffer = function(data) {
    var stringNumbers = data.split(",");
    var lengthNumbers = stringNumbers.length;
    var uint8Array = new Uint8Array(lengthNumbers);
    var arrayBuffer;

    for ( var i = 0; i < lengthNumbers; i++ ) uint8Array[i] = parseInt(stringNumbers[i]);

    arrayBuffer = uint8Array.buffer;

    return arrayBuffer;
};

R2D.Tool.resizeImage = function(image, scaleX, scaleY, callback) {
    var imageSource = image.src;

    function resize() {
        var width = image.width;
        var height = image.height;
        var newWidth = Math.round(width * scaleX);
        var newHeight = Math.round(height * scaleY);
        var canvas;
        var context;
        var newImage;

        if ( newWidth < 1 || newHeight < 1 ) {
            callback(image);
        } else {
            canvas = document.createElement("canvas");
            context = canvas.getContext("2d");
            newImage = document.createElement("img");

            canvas.width = newWidth;
            canvas.height = newHeight;

            context.scale(scaleX, scaleY);
            context.drawImage(image, 0, 0);

            newImage.src = canvas.toDataURL();

            canvas = null;
            context = null;

            callback(newImage)
        }
    }
    function imageLoadHandler(event) {
        image.removeEventListener("load", imageLoadHandler);

        resize();
    }

    image.src = null;
    image.src = imageSource;
    image.addEventListener("load", imageLoadHandler);
};

R2D.Tool.makeTextureMap = function(material, targetMap, image, repeatX, repeatY, callback) {
    var texture = new THREE.Texture();

    texture.anisotropy = R2D.Renderer3D.maxAnisotropy;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.flipY = false;

    function imageLoaded(event) {
        image.removeEventListener("load", imageLoaded);

        material[targetMap] = texture;

        texture.repeat.set(repeatX, repeatY);

        texture.image = image;
        texture.needsUpdate = true;

        material.needsUpdate = true;

        if ( callback ) callback();
    }
    function imageRescaled(rescaledImage) {
        var sourceImage = rescaledImage.src;

        image = rescaledImage;
        image.src = null;
        image.src = sourceImage;
        image.addEventListener("load", imageLoaded);
    }

    if ( R2D.ObjectViewer3D.TEXTURE_SCALE == 1 ) {
        image.addEventListener("load", imageLoaded);
    } else {
        R2D.Tool.resizeImage(image, R2D.ObjectViewer3D.TEXTURE_SCALE, R2D.ObjectViewer3D.TEXTURE_SCALE, imageRescaled);
    }
};

R2D.Tool.getMatPrevFromCubeMesh = function (cubeMesh) {
    // -----------------creating scene------------------
    const halfCubeSize = R2D.Tool.CUBE_MESH_SIZE / 2;
    const canvasSize = 250;

    const canvas = document.createElement("canvas");
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const ctx = canvas.getContext("2d");

    if (!cubeMesh) return canvas;

    const cube = cubeMesh.clone();
    if (cube.material.roughness < 0.5 || cube.material.metalness > 0.1) {
        cube.material.envMapIntensity = 1;
        cube.material.envMap = R2D.EnvironmentMetal.getTexture();
    }

    // init lights
    const light = new THREE.Object3D();

    const ambientLight = new THREE.AmbientLight(0x555555);

    const rightLight = new THREE.DirectionalLight(0xffffff, 0.5);
    rightLight.position.set(1, 0, -1);
    rightLight.target.position.set(0, 0, 0);

    const leftLight = new THREE.DirectionalLight(0xffffff, 0.5);
    leftLight.position.set(1, 0, 1);
    leftLight.target.position.set(0, 0, 0);

    light.add(ambientLight);
    light.add(rightLight);
    light.add(rightLight.target);
    light.add(leftLight);
    light.add(leftLight.target);

    // init camera
    const previewFOV = 45;
    const angle = ((previewFOV / 2) * Math.PI) / 180;
    const distance = (halfCubeSize / Math.sin(angle)) * Math.cos(angle) + halfCubeSize;
    const camera = new THREE.PerspectiveCamera(previewFOV, 1, 10, distance + 1000);
    camera.position.set(distance, 0, 0);
    camera.lookAt(0, 0, 0);

    // init scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    scene.add(light);
    scene.add(cube);

    // init renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(canvasSize, canvasSize);
    renderer.render(scene, camera);
    renderer.render(scene, camera);

    ctx.drawImage(renderer.domElement, 0, 0, canvasSize, canvasSize);

    renderer.dispose();
    renderer.forceContextLoss();

    return canvas;
};

R2D.Tool.getModelPrev = function (model3D, canvasSize = 250) {
    const removeBlanks = function (canvas) {
        var context = canvas.getContext("2d");
        var imgWidth = canvas.width;
        var imgHeight = canvas.height;

        var imageData = context.getImageData(0, 0, canvas.width, canvas.height),
            data = imageData.data,
            getRBG = function (x, y) {
                return {
                    red: data[(imgWidth * y + x) * 4],
                    green: data[(imgWidth * y + x) * 4 + 1],
                    blue: data[(imgWidth * y + x) * 4 + 2],
                };
            },
            isWhite = function (rgb) {
                return rgb.red == 255 && rgb.green == 255 && rgb.blue == 255;
            },
            scanY = function (fromTop) {
                var offset = fromTop ? 1 : -1;

                // loop through each row
                for (
                    var y = fromTop ? 0 : imgHeight - 1;
                    fromTop ? y < imgHeight : y > -1;
                    y += offset
                ) {
                    // loop through each column
                    for (var x = 0; x < imgWidth; x++) {
                        if (!isWhite(getRBG(x, y))) {
                            return y;
                        }
                    }
                }
                return null; // all image is white
            },
            scanX = function (fromLeft) {
                var offset = fromLeft ? 1 : -1;

                // loop through each column
                for (
                    var x = fromLeft ? 0 : imgWidth - 1;
                    fromLeft ? x < imgWidth : x > -1;
                    x += offset
                ) {
                    // loop through each row
                    for (var y = 0; y < imgHeight; y++) {
                        if (!isWhite(getRBG(x, y))) {
                            return x;
                        }
                    }
                }
                return null; // all image is white
            };

        var cropTop = scanY(true),
            cropBottom = scanY(false),
            cropLeft = scanX(true),
            cropRight = scanX(false);

        if (cropTop !== null) {
            var _canvas = document.createElement("canvas");
            var _context = canvas.getContext("2d");

            _context.drawImage(
                _canvas,
                cropLeft,
                cropTop,
                imgWidth,
                imgHeight,
                0,
                0,
                imgWidth,
                imgHeight
            );
            imageData = context.getImageData(
                cropLeft,
                cropTop,
                cropRight - cropLeft,
                cropBottom - cropTop
            );

            context.clearRect(0, 0, imgWidth, imgHeight);

            canvas.width = imageData.width;
            canvas.height = imageData.height;

            context.putImageData(imageData, 0, 0);
        }
    };

    const canvas = document.createElement("canvas");
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const ctx = canvas.getContext("2d");

    if (!model3D) return canvas;

    const bbox = new THREE.Box3().setFromObject(model3D);
    const modelWidth = bbox.max.x - bbox.min.x;
    const modelHeight = bbox.max.y - bbox.min.y;
    const modelDepth = bbox.max.z - bbox.min.z;

    const model = model3D.clone();

    // init lights
    const light = new R2D.Light3D(true);

    // init camera
    const previewFOV = 12;
    const angle = ((previewFOV / 2) * Math.PI) / 180;
    const radius = Math.sqrt(
        (modelWidth * modelWidth) / 4 +
            (modelHeight * modelHeight) / 4 +
            (modelDepth * modelDepth) / 4
    );
    const distance = (radius / Math.sin(angle)) * Math.cos(angle) + radius;
    const camera = new THREE.PerspectiveCamera(previewFOV, 1, 10, distance + 1000);
    const pan = (30 * Math.PI) / 180;
    const tilt = (15 * Math.PI) / 180;
    const y = distance * Math.sin(tilt) + modelHeight / 2;
    const x = distance * Math.cos(tilt) * Math.sin(pan);
    const z = distance * Math.cos(tilt) * Math.cos(pan);
    camera.position.set(x, y, z);
    camera.lookAt(0, modelHeight / 2, 0);

    // init scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    scene.add(light.getMiddle());
    scene.add(model);

    // init renderer
    console.log("creating renderer");
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(canvasSize, canvasSize);
    renderer.render(scene, camera);
    renderer.render(scene, camera);

    ctx.drawImage(renderer.domElement, 0, 0, canvasSize, canvasSize);

    removeBlanks(canvas);

    return canvas;
};

R2D.Tool.getMatPrevFromAnyMesh = function (mesh) {
    const material = mesh.material;
    const geometry = new THREE.BoxGeometry(
        R2D.Tool.CUBE_MESH_SIZE,
        R2D.Tool.CUBE_MESH_SIZE,
        R2D.Tool.CUBE_MESH_SIZE
    );
    const cubeMesh = new THREE.Mesh(geometry, material);

    const materPrev = R2D.Tool.getMatPrevFromCubeMesh(cubeMesh);

    return materPrev;
};

R2D.Tool.loadMeshFromMatIdAndColor = async function (matId) {
    const material3d = R2D.PoolMaterials.getMaterial(matId).getMaterial();

    const geometry = new THREE.BoxGeometry(
        R2D.Tool.CUBE_MESH_SIZE,
        R2D.Tool.CUBE_MESH_SIZE,
        R2D.Tool.CUBE_MESH_SIZE
    );
    
    const cubeMesh = new THREE.Mesh(geometry, material3d);

    return cubeMesh;
};

R2D.Tool.getMatPrevFromMatIdAndColor = async function (matId, color) {
    // color -  ' .    -  -     .
    const material3d = R2D.PoolMaterials.getMaterial(color, matId)?.getMaterial();

    const geometry = new THREE.BoxGeometry(
        R2D.Tool.CUBE_MESH_SIZE,
        R2D.Tool.CUBE_MESH_SIZE,
        R2D.Tool.CUBE_MESH_SIZE
    );

    const cubeMesh = new THREE.Mesh(geometry, material3d);

    const preview = R2D.Tool.getMatPrevFromCubeMesh(cubeMesh);

    return preview;
};

R2D.Tool.CUBE_MESH_SIZE = 100;

R2D.Tool.getDownscaledImageFromMap = function (map, newSize) {
    //    ,  
    const scale =
        map.image.width > map.image.height
            ? newSize / map.image.width
            : newSize / map.image.height;

    const canvasOriginal = document.createElement("canvas");
    const ctxO = canvasOriginal.getContext("2d");

    canvasOriginal.width = map.image.width;
    canvasOriginal.height = map.image.height;
    ctxO?.drawImage(map?.image, 0, 0);

    const downscaledCanvas = R2D.Tool.getDownscaledCanvas(canvasOriginal, scale);

    return downscaledCanvas;
};

R2D.Tool.getDownscaledCanvas = function (canvas, scale) {
    // scale must be < 1
    if (!(scale < 1) || !(scale > 0)) return canvas;
    let sqScale = scale * scale;
    let sw = canvas.width;
    let sh = canvas.height;
    let tw = Math.floor(sw * scale);
    let th = Math.floor(sh * scale);
    let sx = 0,
        sy = 0,
        sIndex = 0;
    let tx = 0,
        ty = 0,
        yIndex = 0,
        tIndex = 0;
    let tX = 0,
        tY = 0;
    let w = 0,
        nw = 0,
        wx = 0,
        nwx = 0,
        wy = 0,
        nwy = 0;

    let crossX = false;
    let crossY = false;
    let sBuffer = canvas.getContext("2d")?.getImageData(0, 0, sw, sh)?.data;
    let tBuffer = new Float32Array(3 * tw * th);
    let sR = 0,
        sG = 0,
        sB = 0;

    for (sy = 0; sy < sh; sy++) {
        ty = sy * scale;
        tY = 0 | ty;
        yIndex = 3 * tY * tw;
        crossY = tY !== (0 | (ty + scale));
        if (crossY) {
            wy = tY + 1 - ty;
            nwy = ty + scale - tY - 1;
        }
        for (sx = 0; sx < sw; sx++, sIndex += 4) {
            tx = sx * scale;
            tX = 0 | tx;
            tIndex = yIndex + tX * 3;
            crossX = tX !== (0 | (tx + scale));
            if (crossX) {
                wx = tX + 1 - tx;
                nwx = tx + scale - tX - 1;
            }
            sR = sBuffer[sIndex];
            sG = sBuffer[sIndex + 1];
            sB = sBuffer[sIndex + 2];
            if (!crossX && !crossY) {
                tBuffer[tIndex] += sR * sqScale;
                tBuffer[tIndex + 1] += sG * sqScale;
                tBuffer[tIndex + 2] += sB * sqScale;
            } else if (crossX && !crossY) {
                w = wx * scale;

                tBuffer[tIndex] += sR * w;
                tBuffer[tIndex + 1] += sG * w;
                tBuffer[tIndex + 2] += sB * w;

                nw = nwx * scale;
                tBuffer[tIndex + 3] += sR * nw;
                tBuffer[tIndex + 4] += sG * nw;
                tBuffer[tIndex + 5] += sB * nw;
            } else if (!crossX && crossY) {
                w = wy * scale;

                tBuffer[tIndex] += sR * w;
                tBuffer[tIndex + 1] += sG * w;
                tBuffer[tIndex + 2] += sB * w;

                nw = nwy * scale;
                tBuffer[tIndex + 3 * tw] += sR * nw;
                tBuffer[tIndex + 3 * tw + 1] += sG * nw;
                tBuffer[tIndex + 3 * tw + 2] += sB * nw;
            } else {
                w = wx * wy;
                tBuffer[tIndex] += sR * w;
                tBuffer[tIndex + 1] += sG * w;
                tBuffer[tIndex + 2] += sB * w;

                nw = nwx * wy;
                tBuffer[tIndex + 3] += sR * nw;
                tBuffer[tIndex + 4] += sG * nw;
                tBuffer[tIndex + 5] += sB * nw;

                nw = wx * nwy;
                tBuffer[tIndex + 3 * tw] += sR * nw;
                tBuffer[tIndex + 3 * tw + 1] += sG * nw;
                tBuffer[tIndex + 3 * tw + 2] += sB * nw;

                nw = nwx * nwy;
                tBuffer[tIndex + 3 * tw + 3] += sR * nw;
                tBuffer[tIndex + 3 * tw + 4] += sG * nw;
                tBuffer[tIndex + 3 * tw + 5] += sB * nw;
            }
        }
    }

    let resCanvas = document.createElement("canvas");
    resCanvas.width = tw;
    resCanvas.height = th;
    let resCtx = resCanvas.getContext("2d");
    let imgRes = resCtx.getImageData(0, 0, tw, th);
    let tByteBuffer = imgRes.data;

    let pxIndex = 0;
    for (sIndex = 0, tIndex = 0; pxIndex < tw * th; sIndex += 3, tIndex += 4, pxIndex++) {
        tByteBuffer[tIndex] = 0 | tBuffer[sIndex];
        tByteBuffer[tIndex + 1] = 0 | tBuffer[sIndex + 1];
        tByteBuffer[tIndex + 2] = 0 | tBuffer[sIndex + 2];
        tByteBuffer[tIndex + 3] = 255;
    }

    resCtx.putImageData(imgRes, 0, 0);
    return resCanvas;
};

R2D.Tool.updateModelUV = function (model3D, param = "All") {
    model3D.children.forEach((mesh) => {
        let totalScale = {
            x: model3D.scale.x * mesh.scale.x,
            y: model3D.scale.y * mesh.scale.y,
            z: model3D.scale.z * mesh.scale.z,
        };
        if (
            Math.round(totalScale.x * 10) === Math.round(totalScale.y * 10) &&
            Math.round(totalScale.y * 10) === Math.round(totalScale.z * 10)
        ) {
            updateMeshUV(mesh, "Fixed", totalScale);
        } else {
            if (param === "All") {
                updateMeshUV(mesh, "X", totalScale);
                updateMeshUV(mesh, "Y", totalScale);
                updateMeshUV(mesh, "Z", totalScale);
            } else {
                updateMeshUV(mesh, param, totalScale);
            }
        }
    });

    function updateMeshUV(mesh, scaleDir, scale) {
        class Point {
            constructor(index, pos, uv) {
                this.x = pos[index * 3];
                this.y = pos[index * 3 + 1];
                this.z = pos[index * 3 + 2];
                this.u = uv[index * 2];
                this.v = uv[index * 2 + 1];
            }
        }

        function checkAngles(XYZ, UV) {
            return (
                Math.abs(XYZ.AB - UV.AB) < limRad &&
                Math.abs(XYZ.BC - UV.BC) < limRad &&
                Math.abs(XYZ.CA - UV.CA) < limRad
            );
        }

        // --------------------

        if (mesh.material.userData.blockScalingUV) {
            return;
        }

        if (mesh.geometry.index) {
            mesh.geometry = mesh.geometry.toNonIndexed();
        }

        if (!mesh.userData.initUV) {
            mesh.userData.initUV = {...mesh.geometry.attributes.uv.array};
        }

        const pos = mesh.geometry.attributes.position.array;
        const uv = mesh.geometry.attributes.uv.array;
        const uvInit = mesh.userData.initUV;

        const initScale = scale.x > 10 ? 100 : 1;

        // -----------------------

        if (scaleDir === "Fixed") {
            const k = (scale.x + scale.y + scale.z) / 3;
            for (let i = 0; i < pos.length; i += 3) {
                const iUV = (i / 3) * 2;
                uv.set(
                    [(uvInit[iUV] * k) / initScale, (uvInit[iUV + 1] * k) / initScale],
                    iUV
                );
            }
            mesh.geometry.attributes.uv.needsUpdate = true;
            return;
        }

        // -----------------------

        const index = [];
        for (let i = 0; i < mesh.geometry.attributes.position.count; i++) {
            index[i] = i;
        }

        const limGrad = 10;
        const limRad = (limGrad * Math.PI) / 180;
        const limN = 0.7;

        const UPos = new THREE.Vector3(10, 0, 0);
        const UNeg = new THREE.Vector3(-10, 0, 0);
        const VPos = new THREE.Vector3(0, 0, 10);
        const VNeg = new THREE.Vector3(0, 0, -10);

        const axisX = new THREE.Vector3(10, 0, 0);
        const axisY = new THREE.Vector3(0, 10, 0);
        const axisZ = new THREE.Vector3(0, 0, 10);

        for (let i = 0; i < index.length; i += 3) {
            let dir = "check dir";
            let axis = null;
            let sc = null;

            const indA = index[i];
            const indB = index[i + 1];
            const indC = index[i + 2];

            const p = {
                A: new Point(indA, pos, uvInit),
                B: new Point(indB, pos, uvInit),
                C: new Point(indC, pos, uvInit),
            };

            const A = new THREE.Vector3(p.A.x, p.A.y, p.A.z);
            const B = new THREE.Vector3(p.B.x, p.B.y, p.B.z);
            const C = new THREE.Vector3(p.C.x, p.C.y, p.C.z);

            const AB = new THREE.Vector3().subVectors(B, A);
            const BC = new THREE.Vector3().subVectors(C, B);
            const CA = new THREE.Vector3().subVectors(A, C);

            const Auv = new THREE.Vector3(p.A.u, 0, p.A.v);
            const Buv = new THREE.Vector3(p.B.u, 0, p.B.v);
            const Cuv = new THREE.Vector3(p.C.u, 0, p.C.v);

            const ABuv = new THREE.Vector3().subVectors(Buv, Auv);
            const BCuv = new THREE.Vector3().subVectors(Cuv, Buv);
            const CAuv = new THREE.Vector3().subVectors(Auv, Cuv);

            const angUPosToABC = {
                AB: UPos.angleTo(ABuv),
                BC: UPos.angleTo(BCuv),
                CA: UPos.angleTo(CAuv),
            };

            const angUNegToABC = {
                AB: UNeg.angleTo(ABuv),
                BC: UNeg.angleTo(BCuv),
                CA: UNeg.angleTo(CAuv),
            };

            const angVPosToABC = {
                AB: VPos.angleTo(ABuv),
                BC: VPos.angleTo(BCuv),
                CA: VPos.angleTo(CAuv),
            };

            const angVNegToABC = {
                AB: VNeg.angleTo(ABuv),
                BC: VNeg.angleTo(BCuv),
                CA: VNeg.angleTo(CAuv),
            };

            const plane = new THREE.Plane();
            plane.setFromCoplanarPoints(A, B, C);

            if (scaleDir === "X") {
                if (Math.abs(plane.normal.x) > limN) {
                    continue;
                }

                axis = axisX;
                sc = scale.x;
            } else if (scaleDir === "Y") {
                if (Math.abs(plane.normal.y) > limN) {
                    continue;
                }

                axis = axisY;
                sc = scale.y;
            } else if (scaleDir === "Z") {
                if (Math.abs(plane.normal.z) > limN) {
                    continue;
                }

                axis = axisZ;
                sc = scale.z;
            }

            const OProj = new THREE.Vector3();
            const AxisProj = new THREE.Vector3();

            plane.projectPoint(new THREE.Vector3(0, 0, 0), OProj);
            plane.projectPoint(axis, AxisProj);

            const axisVector = new THREE.Vector3().subVectors(AxisProj, OProj);

            const angAxisToABC = {
                AB: axisVector.angleTo(AB),
                BC: axisVector.angleTo(BC),
                CA: axisVector.angleTo(CA),
            };

            if (checkAngles(angAxisToABC, angUPosToABC)) {
                dir = "UP";
            } else if (checkAngles(angAxisToABC, angUNegToABC)) {
                dir = "UN";
            } else if (checkAngles(angAxisToABC, angVPosToABC)) {
                dir = "VP";
            } else if (checkAngles(angAxisToABC, angVNegToABC)) {
                dir = "VN";
            } 

            if (dir === "UP" || dir === "UN") {
                uv.set([(p.A.u * sc) / initScale], indA * 2);
                uv.set([(p.B.u * sc) / initScale], indB * 2);
                uv.set([(p.C.u * sc) / initScale], indC * 2);
            } else if (dir === "VP" || dir === "VN") {
                uv.set([(p.A.v * sc) / initScale], indA * 2 + 1);
                uv.set([(p.B.v * sc) / initScale], indB * 2 + 1);
                uv.set([(p.C.v * sc) / initScale], indC * 2 + 1);
            }
        }

        mesh.geometry.attributes.uv.needsUpdate = true;
    }
};

R2D.Tool.resetUV = function (mesh, index, productId) {
    if (mesh.userData.isUVReseted) {
        return;
    }

    mesh.userData.isUVReseted = true;

    const data = R2D.Pool3D.getData(productId);
    if (!data) {
        return
    }

    let initMesh = null;
    if (data.scene?.children[0].type === "Mesh") {
        initMesh = data.scene.children[index];
    } else {
        initMesh = data.scene?.children[0].children[index];
    }
    mesh.geometry = initMesh?.geometry.toNonIndexed();
};



//viewers

R2D.ObjectConstructor3D = function(type, constructorElementData) {
    EventDispatcher.call(this);

    let scope = this;
    let meshes = []; // new THREE.Mesh(new THREE.Geometry(), R2D.ObjectConstructor3D.__defaultMaterial);
    let tempData = {};
    let materialViewers = []; //null;
    //let obj3d = null;

    init();

    function init()
    {
        for (let i = 0; i < constructorElementData.parts.length; i++)
        {
            meshes.push(new THREE.Mesh(new THREE.BufferGeometry(), R2D.ObjectConstructor3D.__defaultMaterial));
            meshes[i].num = constructorElementData.parts[i].id;

            meshes[i].castShadow = false;
        }
    }

    function needsUpdateHandler(e) {
        
        if (e.currentTarget.error)
        {
            e.currentTarget.relatedPart.materialID = '2013';
            e.currentTarget.relatedPart.addMaterialID = '';
            updateMaterial();
            return;
        }

        let matViewer = e.currentTarget;
        if (matViewer.relatedMesh.material != matViewer.getMaterial())
        {
            matViewer.relatedMesh.material = matViewer.getMaterial();
        }

        scope.needsUpdate();

        updateMaterial();
    }
    function updateMaterial()
    {
        for (let i = 0; i < materialViewers.length; i++)
        {
            materialViewers[i].removeEventListener(Event.UPDATE, needsUpdateHandler);
        }
        materialViewers = [];
        for (let i = 0; i < constructorElementData.parts.length; i++)
        {
            let matId = constructorElementData.parts[i].materialID;
            let addMatId = constructorElementData.parts[i].addMaterialID;
            matId = R2D.ObjectConstructor3D.__checkMaterialId(type, matId);
            let matViewer = addMatId ? R2D.PoolMaterials.getMaterial(matId, addMatId) : R2D.PoolMaterials.getMaterial(matId);
            meshes[i].material = matViewer.getMaterial();
            matViewer.relatedPart = constructorElementData.parts[i];
            matViewer.relatedMesh = meshes[i];
            matViewer.addEventListener(Event.UPDATE, needsUpdateHandler);
            materialViewers.push(matViewer);
        }
    }
    function updateGeometry(event) {
        for (let i = 0; i < meshes.length; i++)
        {
            meshes[i].geometry.dispose();
            if (meshes[i].parent) meshes[i].parent.remove(meshes[i]);
        }
        while (meshes.length > 0) meshes.pop();

        for (i = 0; i < constructorElementData.parts.length; i++)
        {
            let flipped = R2D.Tool.flipGeometryByZ(constructorElementData.parts[i]);
            let geometry = R2D.Tool.makeBufferGeometry(flipped.indices, flipped.vertices, flipped.uvs);
            let mesh = new THREE.Mesh(new THREE.BufferGeometry(), R2D.ObjectConstructor3D.__defaultMaterial);
            mesh.castShadow = false;
            meshes.push(mesh);
            mesh.num = constructorElementData.parts[i].id;
            mesh.geometry = geometry;
            mesh.needsUpdate = true;

            mesh.receiveShadow = true;
        }
    }
    function elementUpdateEventHandler(event) {
        updateGeometry();
        updateMaterial();

        for (let i = 0; i < meshes.length; i++)
        {
            meshes[i].visible = constructorElementData.exists && constructorElementData.visible;
        }

        scope.needsUpdate();
    }

    Object.defineProperties(scope, {
        "objectType":{
            get() { return "constructor" }
        },
        "type":{
            get() { return type; }
        },
        "object3d":{
            get() { return meshes[0]; }
        },
        "constructorElementData":{
            get() { return constructorElementData; }
        },
        "tempData":{
            get() { return tempData; }
        }
    });

    scope.getObject3d = function(num)
    {
        if (typeof num == 'undefined' || num == -1) return meshes[0];

        for (let i = 0; i < meshes.length; i++)
        {
            if (meshes[i].num == num) return meshes[i];
        }
    };

    scope.needsUpdate = function() {
        scope.dispatchEvent(new Event(Event.UPDATE, scope));
    };
    scope.getType = function() {
        return type;
    };
    scope.getConstructorElementData = function() {
        return constructorElementData;
    };
    scope.getMeshes = function() {
        return meshes;
    };
    scope.startRotateMaterial = function(point) {
        constructorElementData.startRotateMaterial(point);
    };
    scope.stopRotateMaterial = function() {
        constructorElementData.stopRotateMaterial();
    };
    scope.getMaterialRotation = function(partNum) {
        return constructorElementData.getMaterialRotation(partNum);
    };
    scope.setMaterialRotation = function(angle, partNum) {
        constructorElementData.setMaterialRotation(angle, partNum);
    };
    scope.rotateMaterial = function(angle, partNum) {
        constructorElementData.rotateMaterial(angle, partNum);
    };
    scope.startMoveMaterial = function(point) {
        constructorElementData.startMoveMaterial(point);
    };
    scope.stopMoveMaterial = function() {
        constructorElementData.stopMoveMaterial();
    };
    scope.getMaterialShift = function(partNum) {
        return constructorElementData.getMaterialShift(partNum);
    };
    scope.setMaterialShift = function(shift, partNum) {
        constructorElementData.setMaterialShift(shift, partNum);
    };
    scope.moveMaterial = function(shift, partNum) {
        constructorElementData.moveMaterial(shift, partNum);
    };
    scope.setMaterial = function(materialId, partNum) {
        constructorElementData.setMaterial(materialId, partNum);
    };
    scope.setAddMaterial = function(addMaterialId, partNum) {
        constructorElementData.setAddMaterial(addMaterialId, partNum);
    };
    scope.clearMaterial = function(){
        constructorElementData.clearMaterial();
        constructorElementData.build3D();
    };
    scope.update = function() {
        constructorElementData.dispatchUpdate();
    };

    scope.destroy = function() {
        //TODO
        console.warn("TODO");
    };

    updateGeometry();
    updateMaterial();

    constructorElementData.addEventListener(WC.ELEMENT_UPDATE, elementUpdateEventHandler);
};

R2D.extend(R2D.ObjectConstructor3D, EventDispatcher);

R2D.ObjectConstructor3D.__lineDashedMaterial = (() => {
    return new THREE.LineDashedMaterial({
        color:0xffaa00,
        dashSize:3,
        gapSize:1,
        linewidth:2
    });
})();
R2D.ObjectConstructor3D.__defaultMaterial = (() => {
    let material = new THREE.MeshPhongMaterial({color:0xffe400});

    material.transparent = true;
    material.opacity = 0.5;
    material.side = THREE.DoubleSide;

    return material;
})();

/*
R2D.ObjectConstructor3D.__getGeometries = function(data) {
    let geoms = [];
    for (let i = 0; i < data.parts.length; i++)
    {
        let flipped = R2D.Tool.flipGeometryByZ(data.parts[i]);
        let geometry = R2D.Tool.makeBufferGeometry(flipped.indices, flipped.vertices, flipped.uvs);
        geoms.push(geometry);
    }

    return geoms;
};
*/
R2D.ObjectConstructor3D.__checkMaterialId = function(type, materialId) {
    if ( materialId == 0 || materialId == "0" || materialId == null || materialId == undefined || materialId == "undefined" ) {
        switch ( type ) {
            case R2D.ObjectConstructor3DType.COVER:
                return R2D.default.getDefaultMaterialByKey("cover");
            case R2D.ObjectConstructor3DType.CAP:
                return R2D.default.getDefaultMaterialByKey("cap");
            case R2D.ObjectConstructor3DType.PLINTH_TOP:
                return R2D.default.getDefaultMaterialByKey("molding");
            case R2D.ObjectConstructor3DType.PLINTH_BOTTOM:
                return R2D.default.getDefaultMaterialByKey("plinth");
            case R2D.ObjectConstructor3DType.WALL:
            case R2D.ObjectConstructor3DType.CUT:
            case R2D.ObjectConstructor3DType.AREA:
            default:
                return R2D.default.getDefaultMaterialByKey("wall");
        }
    }

    return materialId;
};

R2D.ObjectConstructor3D.make = function(constructorObject) {
    let ObjectType = null;

    switch ( constructorObject.type ) {
        case R2D.ObjectConstructor3DType.WALL:
            ObjectType = R2D.ObjectConstructor3DWall;
            break;

        case R2D.ObjectConstructor3DType.COVER:
            ObjectType = R2D.ObjectConstructor3DCover;
            break;

        case R2D.ObjectConstructor3DType.CEILING:
            ObjectType = R2D.ObjectConstructor3DCeiling;
            break;

        case R2D.ObjectConstructor3DType.FRAME_TOP:
            ObjectType = R2D.ObjectConstructor3DFrameTop;
            break;

        case R2D.ObjectConstructor3DType.FRAME_BOTTOM:
            ObjectType = R2D.ObjectConstructor3DFrameBottom;
            break;

        case R2D.ObjectConstructor3DType.CUT:
            ObjectType = R2D.ObjectConstructor3DCut;
            break;

        case R2D.ObjectConstructor3DType.AREA:
            ObjectType = R2D.ObjectConstructor3DArea;
            break;

        case R2D.ObjectConstructor3DType.CAP:
            ObjectType = R2D.ObjectConstructor3DCap;
            break;

        case R2D.ObjectConstructor3DType.PLUG:
            ObjectType = R2D.ObjectConstructor3DPlug;
            break;

        case R2D.ObjectConstructor3DType.PLINTH_BOTTOM:
            ObjectType = R2D.ObjectConstructor3DPlinthBottom;
            break;

        case R2D.ObjectConstructor3DType.PLINTH_TOP:
            ObjectType = R2D.ObjectConstructor3DPlinthTop;
            break;

        default:
            throw "Unknown type of the constructor data. Received " + constructorObject.type;
    }

    if ( ObjectType == null ) throw "ObjectType is null.";

    return new ObjectType(constructorObject);
};

R2D.ObjectConstructor3D.makeContour = function(contours) {
    let object3d = new THREE.Object3D();

    contours = contours || [];

    contours.forEach(contour => {
        let geometry = new THREE.BufferGeometry();
        let lineSegment = new THREE.LineSegments(geometry, R2D.ObjectConstructor3D.__lineDashedMaterial);
        let previous = contour[0];
        let current = null;

        for ( let i = 1, l = contour.length; i < l; i++ ) {
            current = contour[i];

            geometry.vertices.push(new THREE.Vector3(previous.x, previous.y, -previous.z));
            geometry.vertices.push(new THREE.Vector3(current.x, current.y, -current.z));

            previous = current;
        }

        current = contour[0];

        geometry.vertices.push(new THREE.Vector3(previous.x, previous.y, -previous.z));
        geometry.vertices.push(new THREE.Vector3(current.x, current.y, -current.z));
        geometry.computeLineDistances();

        object3d.add(lineSegment);
    });

    return object3d;
};
//viewers

R2D.ObjectConstructor3DType = function() {
    //-
};

R2D.ObjectConstructor3DType.WALL = "wall";
R2D.ObjectConstructor3DType.COVER = "cover";
R2D.ObjectConstructor3DType.CEILING = "ceiling";
R2D.ObjectConstructor3DType.FRAME_TOP = "topFrame";
R2D.ObjectConstructor3DType.FRAME_BOTTOM = "bottomFrame";
R2D.ObjectConstructor3DType.CAP = "cap";
R2D.ObjectConstructor3DType.CUT = "cut";
R2D.ObjectConstructor3DType.AREA = "area";
R2D.ObjectConstructor3DType.PLUG = "plug";
R2D.ObjectConstructor3DType.PLINTH_TOP = "topPlinth";
R2D.ObjectConstructor3DType.PLINTH_BOTTOM = "bottomPlinth";
//viewers

R2D.ObjectConstructor3DWall = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.WALL, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DWall, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DCover = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.COVER, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DCover, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DCeiling = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.CEILING, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DCeiling, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DFrameTop = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.FRAME_TOP, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DFrameTop, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DFrameBottom = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.FRAME_BOTTOM, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DFrameBottom, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DCut = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.CUT, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DCut, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DArea = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.AREA, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DArea, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DCap = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.CAP, constructorElementData);

    var scope = this;
    var meshes = scope.getMeshes();
};

R2D.extend(R2D.ObjectConstructor3DCap, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DPlug = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.PLUG, constructorElementData);

    var scope = this;
    var meshes = scope.getMeshes();
};

R2D.extend(R2D.ObjectConstructor3DPlug, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectConstructor3DPlinthTop = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.PLINTH_TOP, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DPlinthTop, R2D.ObjectConstructor3D);

//viewers

R2D.ObjectConstructor3DPlinthBottom = function(constructorElementData) {
    R2D.ObjectConstructor3D.call(this, R2D.ObjectConstructor3DType.PLINTH_BOTTOM, constructorElementData);

    var scope = this;
};

R2D.extend(R2D.ObjectConstructor3DPlinthBottom, R2D.ObjectConstructor3D);
//viewers

R2D.ObjectViewer3D = function (type, sceneObject) {
    EventDispatcher.call(this);

    var scope = this;
    var object3d = new THREE.Object3D();
    var geometryBox = R2D.ObjectViewer3D.getBoxGeometry(
        sceneObject.getDefaultWidth(),
        sceneObject.getDefaultHeight(),
        sceneObject.getDefaultDepth()
    );
    var material = R2D.ObjectViewer3D.__defaultMaterial;
    var mesh = new THREE.Mesh(geometryBox, material);

    function updatePosition() {
        var x = sceneObject.x;
        var y = sceneObject.y;
        var z = sceneObject.z;

        object3d.position.set(x, y, z);
    }
    function updateScales() {
        var sx = sceneObject.scaleX;
        var sy = sceneObject.scaleY;
        var sz = sceneObject.scaleZ;

        object3d.scale.set(sx, sy, sz);
    }
    function updateRotations() {
        var rx = (sceneObject.rotationX * Math.PI) / 180;
        var ry = (sceneObject.rotationY * Math.PI) / 180;
        var rz = (sceneObject.rotationZ * Math.PI) / 180;

        object3d.rotation.set(rx, ry, rz);
    }

    scope.updateUV = function () {
        if (!sceneObject.isLoaded) {
            return;
        }

        if (Number(sceneObject.type) !== 2) {
            return;
        }

        if (!sceneObject.isAddScaleChanged && !sceneObject.isFirstLoading) {
            return;
        }

        if (
            sceneObject.scaleX === 1 &&
            sceneObject.scaleY === 1 &&
            sceneObject.scaleZ === 1
        ) {
            return;
        }

        if (sceneObject.isFirstLoading) {
            R2D.Tool.updateModelUV(object3d, "All");
        } else {
            R2D.Tool.updateModelUV(object3d, sceneObject.scaleDir);
        }

        sceneObject.isFirstLoading = false;
        sceneObject.isAddScaleChanged = false;
    };
    function setupObject3d() {
        updatePosition();
        updateScales();
        updateRotations();
        scope.updateUV();
    }
    function sceneObjectUpdateEventHandler(event) {
        setupObject3d();
        scope._needsUpdate();
    }

    Object.defineProperties(scope, {
        objectType: {
            get() {
                return "product";
            },
        },
        type: {
            get() {
                return type;
            },
        },
        sceneObject: {
            get() {
                return sceneObject;
            },
        },
        object3d: {
            get() {
                return object3d;
            },
        },
        y: {
            get() {
                return sceneObject.y;
            },
            set(val) {
                sceneObject.y = val;
            },
        },
    });

    scope.getType = function () {
        return type;
    };
    scope.getProductId = function () {
        return sceneObject.getProductId();
    };
    scope.getSceneObject = function () {
        return sceneObject;
    };
    scope.getObject3d = function () {
        return object3d;
    };
    scope._needsUpdate = function () {
        scope.dispatchEvent(new Event(Event.UPDATE, scope));
    };
    scope.update = function () {
        sceneObject.update();
    };

    material.side = THREE.DoubleSide;

    object3d.castShadow = false;
    object3d.receiveShadow = true;

    object3d.add(mesh);
    sceneObject.addEventListener(Event.UPDATE, sceneObjectUpdateEventHandler);

    setupObject3d();
};

R2D.extend(R2D.ObjectViewer3D, EventDispatcher);

R2D.ObjectViewer3D.prototype.getGeomBox = function () {
    return new GEOM.Box(
        new GEOM.Point(this.sceneObject.x, this.sceneObject.z),
        this.sceneObject.width,
        this.sceneObject.depth,
        -GEOM.toRad(this.sceneObject.rotationY)
    );
};
R2D.ObjectViewer3D.prototype.getVectorsSides = function () {
    var sceneObject = this.getSceneObject();
    var w = sceneObject.getWidth();
    var h = sceneObject.getHeight();
    var d = sceneObject.getDepth();
    var w2 = w / 2;
    var d2 = d / 2;
    var positions = [
        new G.V(-w2, 0, -d2),
        new G.V(w2, 0, -d2),
        new G.V(w2, 0, d2),
        new G.V(-w2, 0, d2),
        new G.V(-w2, h, -d2),
        new G.V(w2, h, -d2),
        new G.V(w2, h, d2),
        new G.V(-w2, h, d2),
    ];
    var ry = G.toRad(sceneObject.rotationY);

    for (var i = 0, l = positions.length; i < l; i++) {
        var p = positions[i];

        p.rotateByY(ry);
    }

    return positions;
};

R2D.ObjectViewer3D.prototype.getVectorsBoundsPositions = function () {
    var sceneObject = this.getSceneObject();
    var x = sceneObject.x;
    var y = sceneObject.y;
    var z = sceneObject.z;
    var w = sceneObject.getWidth();
    var h = sceneObject.getHeight();
    var d = sceneObject.getDepth();
    var w2 = w / 2;
    var d2 = d / 2;

    return [
        new G.V(-w2 + x, 0 + y, -d2 + z),
        new G.V(w2 + x, 0 + y, -d2 + z),
        new G.V(w2 + x, 0 + y, d2 + z),
        new G.V(-w2 + x, 0 + y, d2 + z),
        new G.V(-w2 + x, h + y, -d2 + z),
        new G.V(w2 + x, h + y, -d2 + z),
        new G.V(w2 + x, h + y, d2 + z),
        new G.V(-w2 + x, h + y, d2 + z),
    ];
};

R2D.ObjectViewer3D.TEXTURE_SCALE = 1;

R2D.ObjectViewer3D.__defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xffe400 });
R2D.ObjectViewer3D.__defaultMaterial.transparent = true;
R2D.ObjectViewer3D.__defaultMaterial.opacity = 0.5;
R2D.ObjectViewer3D.__defaultMaterial.side = THREE.DoubleSide;

R2D.ObjectViewer3D.__lineDashedMaterial = new THREE.LineDashedMaterial({
    color: 0xffaa00,
    dashSize: 3,
    gapSize: 1,
    linewidth: 2,
});
R2D.ObjectViewer3D.__lineDashedMaterialRuler = new THREE.LineDashedMaterial({
    color: 0x00fff6,
    dashSize: 3,
    gapSize: 1,
    linewidth: 2,
});
R2D.ObjectViewer3D.__lineDashedMaterialRed = new THREE.LineDashedMaterial({
    color: 0xfa39e4,
    dashSize: 3,
    gapSize: 1,
    linewidth: 5,
});
R2D.ObjectViewer3D.__lineDashedMaterialWhite = new THREE.LineDashedMaterial({
    color: 0xffffff,
    dashSize: 3,
    gapSize: 1,
    linewidth: 5,
    transparent: true,
    opacity: 0.5,
});
R2D.ObjectViewer3D.__lineDashedMaterialWrong = new THREE.LineDashedMaterial({
    color: 0xff0000,
    dashSize: 3,
    gapSize: 1,
    linewidth: 2,
});
R2D.ObjectViewer3D.__lineDashedMaterialGood = new THREE.LineDashedMaterial({
    color: 0x00ff00,
    dashSize: 3,
    gapSize: 1,
    linewidth: 2,
});
/*R2D.ObjectViewer3D.__defaultMaterialRing.transparent = true;
R2D.ObjectViewer3D.__defaultMaterialRing.opacity = 0.9;
R2D.ObjectViewer3D.__defaultMaterialRing.side = THREE.DoubleSide;*/

R2D.ObjectViewer3D.getBoxGeometry = function (width, height, depth) {
    var geometry = new THREE.BoxGeometry(width, height, depth);

    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, height / 2, 0));

    return geometry;
};

R2D.ObjectViewer3D.getDashedLine = function (vectorA = { }, vectorB = { }, material) {
    var geometry = new THREE.BufferGeometry();

    const vertices = new Float32Array([
        vectorA.x,
        vectorA.y,
        vectorA.z,
        vectorB.x,
        vectorB.y,
        vectorB.z,
    ]);

    geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

    return new THREE.LineSegments(geometry, material || R2D.ObjectViewer3D.__lineDashedMaterial);
};
R2D.ObjectViewer3D.getBoundGeometry = function (width, height, depth) {
    var w = width / 2;
    var h = height / 2;
    var d = depth / 2;
    var geometry = new THREE.BufferGeometry();

    geometry.vertices.push(
        new THREE.Vector3(-w, -h, -d),
        new THREE.Vector3(-w, h, -d),

        new THREE.Vector3(-w, h, -d),
        new THREE.Vector3(w, h, -d),

        new THREE.Vector3(w, h, -d),
        new THREE.Vector3(w, -h, -d),

        new THREE.Vector3(w, -h, -d),
        new THREE.Vector3(-w, -h, -d),

        new THREE.Vector3(-w, -h, d),
        new THREE.Vector3(-w, h, d),

        new THREE.Vector3(-w, h, d),
        new THREE.Vector3(w, h, d),

        new THREE.Vector3(w, h, d),
        new THREE.Vector3(w, -h, d),

        new THREE.Vector3(w, -h, d),
        new THREE.Vector3(-w, -h, d),

        new THREE.Vector3(-w, -h, -d),
        new THREE.Vector3(-w, -h, d),

        new THREE.Vector3(-w, h, -d),
        new THREE.Vector3(-w, h, d),

        new THREE.Vector3(w, h, -d),
        new THREE.Vector3(w, h, d),

        new THREE.Vector3(w, -h, -d),
        new THREE.Vector3(w, -h, d)
    );

    geometry.computeLineDistances();
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, height / 2, 0));

    return geometry;
};

R2D.ObjectViewer3D.make = function (sceneObject) {
    switch (Number(sceneObject.getType())) {
        case R2D.ProductType.MATERIAL:
            return null;
        case R2D.ProductType.MODEL:
            return new R2D.ObjectViewer3DModel(sceneObject);
        case R2D.ProductType.POSTER:
            if (sceneObject.isGLTF) {
                return new R2D.ObjectViewer3DModel(sceneObject);
            } else {
                return new R2D.ObjectViewer3DPoster(sceneObject);
            }
        case R2D.ProductType.CARPET:
            return new R2D.ObjectViewer3DCarpet(sceneObject);
        default:
            throw "Error type of object!";
    }
};

R2D.ObjectViewer3D.addSizes = function (object3d, isStartCoordInModelCenter = false) {
    const box = new THREE.Box3().setFromObject(object3d);

    const width = parseInt(box.max.x - box.min.x);
    const height = parseInt(box.max.y - box.min.y);
    const depth = parseInt(box.max.z - box.min.z);

    const maxSide = Math.max(width, height, depth);
    const minSide = Math.min(width, height, depth);

    const w2 = width / 2;
    const h2 = height / 2;
    const d2 = depth / 2;

    //--------------
    const sizePoint = 50;
    const space = maxSide > sizePoint ? 10 : 8;
    const tail = maxSide > sizePoint ? 5 : 3;
    const arrowLength = maxSide > sizePoint ? 7 : 3;
    const arrowWidth = minSide < 7 ? 0 : maxSide > sizePoint ? 3 : 1;
    const arrowWidth2 = arrowWidth / 2;
    const fromTextToArrow = maxSide > sizePoint ? 5 : 2;
    const fontSize = minSide < 7 ? 4 : maxSide > sizePoint ? 8 : 6;

    //--------------

    // --------------- LINES --------------------
    const points = [
        // width
        new THREE.Vector3(-w2, -h2, d2 + space),
        new THREE.Vector3(w2, -h2, d2 + space),
        new THREE.Vector3(-w2, -h2, d2),
        new THREE.Vector3(-w2, -h2, d2 + space + tail),
        new THREE.Vector3(w2, -h2, d2),
        new THREE.Vector3(w2, -h2, d2 + space + tail),

        // height
        new THREE.Vector3(-w2 - space, -h2, -d2),
        new THREE.Vector3(-w2 - space, h2, -d2),
        new THREE.Vector3(-w2, -h2, -d2),
        new THREE.Vector3(-w2 - space - tail, -h2, -d2),
        new THREE.Vector3(-w2, h2, -d2),
        new THREE.Vector3(-w2 - space - tail, h2, -d2),

        //depth
        new THREE.Vector3(w2 + space, -h2, d2),
        new THREE.Vector3(w2 + space, -h2, -d2),
        new THREE.Vector3(w2, -h2, d2),
        new THREE.Vector3(w2 + space + tail, -h2, d2),
        new THREE.Vector3(w2, -h2, -d2),
        new THREE.Vector3(w2 + space + tail, -h2, -d2),
    ];

    const linesGeometry = new THREE.BufferGeometry().setFromPoints(points);

    const linesMaterial = new THREE.LineBasicMaterial({ color: 0x999999 });

    const linesMesh = new THREE.LineSegments(linesGeometry, linesMaterial);

    // --------------- ARROWS --------------------

    const pos = [
        // width
        { x: -w2, y: -h2, z: d2 + space },
        { x: -w2 + arrowLength, y: -h2, z: d2 + space + arrowWidth2 },
        { x: -w2 + arrowLength, y: -h2, z: d2 + space - arrowWidth2 },

        { x: w2, y: -h2, z: d2 + space },
        { x: w2 - arrowLength, y: -h2, z: d2 + space + arrowWidth2 },
        { x: w2 - arrowLength, y: -h2, z: d2 + space - arrowWidth2 },

        //height
        { x: -w2 - space, y: -h2, z: -d2 },
        { x: -w2 - space + arrowWidth2, y: -h2 + arrowLength, z: -d2 },
        { x: -w2 - space - arrowWidth2, y: -h2 + arrowLength, z: -d2 },

        { x: -w2 - space, y: h2, z: -d2 },
        { x: -w2 - space + arrowWidth2, y: h2 - arrowLength, z: -d2 },
        { x: -w2 - space - arrowWidth2, y: h2 - arrowLength, z: -d2 },

        //depth
        { x: w2 + space, y: -h2, z: d2 },
        { x: w2 + space + arrowWidth2, y: -h2, z: d2 - arrowLength },
        { x: w2 + space - arrowWidth2, y: -h2, z: d2 - arrowLength },

        { x: w2 + space, y: -h2, z: -d2 },
        { x: w2 + space - arrowWidth2, y: -h2, z: -d2 + arrowLength },
        { x: w2 + space + arrowWidth2, y: -h2, z: -d2 + arrowLength },
    ];

    const numVertices = pos.length;

    const positions = new Float32Array(numVertices * 3);
    let index = 0;
    pos.forEach((p) => {
        positions.set([p.x, p.y, p.z], index);
        index += 3;
    });

    const arrowsGeometry = new THREE.BufferGeometry();
    arrowsGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    const arrowsMaterial = new THREE.LineBasicMaterial({
        color: 0x999999,
        side: THREE.DoubleSide,
    });

    const arrowsMesh = new THREE.Mesh(arrowsGeometry, arrowsMaterial);

    // -------------- TEXT -----------------

    let textWidth = 0;
    let bbox = null;

    var loader = new THREE.FontLoader();

    loader.load("/src_designer/merchant-matconfig/fonts/Arial_Regular.json", function (font) {
        const textParams = { font: font, size: fontSize, height: 0 };

        const textMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
        });

        // width
        const textWidthGeometry = new THREE.TextGeometry(`${width}`, textParams);

        textWidthGeometry.computeBoundingBox();
        bbox = textWidthGeometry.boundingBox;

        textWidth = bbox.max.x - bbox.min.x;

        const textWidthMesh = new THREE.Mesh(textWidthGeometry, textMaterial);
        textWidthMesh.rotateX(-Math.PI / 2);
        textWidthMesh.position.x = -textWidth / 2;
        textWidthMesh.position.y = -h2;
        textWidthMesh.position.z = d2 + space + textParams.size + fromTextToArrow;

        // height
        const textHeightGeometry = new THREE.TextGeometry(`${height}`, textParams);
        textHeightGeometry.computeBoundingBox();
        bbox = textHeightGeometry.boundingBox;

        textWidth = bbox.max.x - bbox.min.x;

        const textHeighthMesh = new THREE.Mesh(textHeightGeometry, textMaterial);
        textHeighthMesh.rotateZ(Math.PI / 2);
        textHeighthMesh.position.x = -w2 - space - fromTextToArrow;
        textHeighthMesh.position.y = -textWidth / 2;
        textHeighthMesh.position.z = -d2;

        // depth
        const textDepthGeometry = new THREE.TextGeometry(`${depth}`, textParams);
        textDepthGeometry.computeBoundingBox();
        bbox = textDepthGeometry.boundingBox;

        textWidth = bbox.max.x - bbox.min.x;

        const textDepthMesh = new THREE.Mesh(textDepthGeometry, textMaterial);
        textDepthMesh.rotateX(-Math.PI / 2);
        textDepthMesh.rotateZ(Math.PI / 2);
        textDepthMesh.position.x = w2 + space + textParams.size + fromTextToArrow;
        textDepthMesh.position.y = -h2;
        textDepthMesh.position.z = textWidth / 2;

        sizes3D.add(textWidthMesh, textHeighthMesh, textDepthMesh);

        R2D.view3d.rendererUpdate();
    });

    let sizes3D = new THREE.Object3D().add(arrowsMesh, linesMesh);
    sizes3D.name = "size_container";
    if (!isStartCoordInModelCenter) {
        sizes3D.position.x = object3d.position.x;
        sizes3D.position.y = object3d.position.y + h2;
        sizes3D.position.z = object3d.position.z;
    }
    let group = new THREE.Group();
    group.add(sizes3D);
    object3d.parent.add(group);
    group.add(object3d);

    R2D.view3d.rendererUpdate();
};

// viewers

R2D.ObjectViewer3DMaterial = function (productId, color) {
    EventDispatcher.call(this);

    let scope = this;
    let material = null;
    let ready = false;
    let productData = null;
    let isMaterialLoaded = false;

    scope.scalability = true;

    scope.getMaterialLoadState = () => isMaterialLoaded;

    function createMaterial() {
        material = new THREE.MeshPhongMaterial({ color: 0x999999 });

        material.side = THREE.DoubleSide;

    }
    function needsUpdate() {
        scope.dispatchEvent(new Event(Event.UPDATE, scope));
    }
    function completeMaterialDataHandler(event) {
        if (event.data == productId) {
            R2D.Pool3D.removeEventListener(Event.FINISH, completeMaterialDataHandler);
            let data = R2D.Pool3D.getData(productId);
            if (!data || !productData) return loadProductData();
            isMaterialLoaded = true;
            if (productData.isGLTF) {
                R2D.Pool3D.clearData(productId);
                let done = false;
                data.scene.traverse(function (obj) {
                    if (done) return;
                    if (obj.type == "Mesh") {
                        material = obj.material;
                        done = true;
                    }
                });

                // -------------- downscaling textures -------------
                const SIZE = 512 * (R2D.OPTIONS.TEXTURE_MULTIPLIER || 1);

                if (R2D.OPTIONS.NEED_DOWNSCALE_TEXTURES) {
                    for (let mapName of R2D.ObjectViewer3DMaterial.mapNames) {
                        if (!material[mapName]) continue;

                        if (
                            material[mapName].image.width <= SIZE &&
                            material[mapName].image.height <= SIZE
                        ) {
                            continue;
                        }

                        material[mapName].image = R2D.Tool.getDownscaledImageFromMap(
                            material[mapName],
                            SIZE
                        );
                        material[mapName].needsUpdate = true;
                    }
                }
                // ---------------------------------

                if (material.roughness < 0.5 || material.metalness > 0.1) {
                    material.envMapIntensity = 1;
                    material.envMap = R2D.EnvironmentMetal.getTexture();
                }
                if (color) material.color = new THREE.Color(color);
                ready = true;
            } else {
                let raw = R2D.ProductPackageParser.parseMaterial(data);
                scope.scalability = raw.scalability;
                let repeatU;
                let repeatV;

                if (raw.scalability) {
                    repeatU = raw.scaleX;
                    repeatV = raw.scaleY;
                } else {
                    repeatU = 1;
                    repeatV = 1;

                    material.userData.scaleX = raw.scaleX;
                    material.userData.scaleY = raw.scaleY;
                }
                // let repeatU = raw.scalability ? raw.scaleX : 1;
                // let repeatV = raw.scalability ? raw.scaleY : 1;
                let image;

                R2D.Pool3D.clearData(productId);

                if (raw.diffuseData) {
                    material.color = new THREE.Color(0xffffff);
                    image = R2D.Tool.arrayBufferToImage(raw.diffuseData);

                    R2D.Tool.makeTextureMap(
                        material,
                        "map",
                        image,
                        repeatU,
                        repeatV,
                        needsUpdate
                    );
                }
                if (raw.normalData) {
                    image = R2D.Tool.arrayBufferToImage(raw.normalData);

                    R2D.Tool.makeTextureMap(
                        material,
                        "normalMap",
                        image,
                        repeatU,
                        repeatV,
                        needsUpdate
                    );
                }
                if (raw.specularData) {
                    image = R2D.Tool.arrayBufferToImage(raw.specularData);

                    R2D.Tool.makeTextureMap(
                        material,
                        "specularMap",
                        image,
                        repeatU,
                        repeatV,
                        needsUpdate
                    );
                }

                if (raw.materialType) {
                    switch (raw.materialType) {
                        case R2D.EnvironmentBase.GLOSS:
                            material.envMap = R2D.EnvironmentMetal.getTexture();
                            material.reflectivity = R2D.EnvironmentMetal.getReflectivity(
                                raw.materialReflectivity
                            );
                            break;

                        case R2D.EnvironmentBase.METAL:
                            material.envMap = R2D.EnvironmentMetal.getTexture();
                            material.reflectivity = R2D.EnvironmentMetal.getReflectivity(
                                raw.materialReflectivity
                            );
                            break;

                        default:
                            console.error("Unknown type of material type!");
                    }
                }
                if (raw.metal) {
                    material.envMap = R2D.EnvironmentMetal.getTexture();
                    material.reflectivity = R2D.EnvironmentMetal.getReflectivity(
                        raw.intensityMetal
                    );
                    material.needsUpdate = true;
                } else if (raw.gloss) {
                    material.envMap = R2D.EnvironmentMetal.getTexture();
                    material.reflectivity = R2D.EnvironmentMetal.getReflectivity(
                        raw.intensityGloss
                    );
                    material.needsUpdate = true;
                }

                material.transparent = raw.transparent;
                if (color) material.color = new THREE.Color(color);

                ready = true;
            }
            needsUpdate();
        }
    }
    function loadMaterialData() {
        
        R2D.Pool3D.addEventListener(Event.FINISH, completeMaterialDataHandler);
        R2D.Pool3D.load(productId);
    }
    function loadProductDataEventHandler(event) {
        let dataLoader = event.currentTarget;

        dataLoader.removeEventListener(Event.COMPLETE, loadProductDataEventHandler);
        dataLoader.removeEventListener(Event.ERROR, loadProductDataEventHandler);
        try {
            let response = JSON.parse(dataLoader.data);
            if (response.status == "error") {
                R2D.PoolMaterials.remove(productId);
                scope.error = true;
                needsUpdate();
            }
        } catch (err) {}

        checkGLTF();

        loadMaterialData();
    }
    function loadProductData() {
        let dataLoader = R2D.Pool.loadProductData(productId);

        dataLoader.addEventListener(Event.COMPLETE, loadProductDataEventHandler);
        dataLoader.addEventListener(Event.ERROR, loadProductDataEventHandler);
    }

    scope.getProductId = function () {
        return productId;
    };
    scope.getMaterial = function () {
        return scope.type === "skybox" ? material : material.clone();
    };
    scope.isReady = function () {
        return ready;
    };

    scope.setColor = function (color) {
        material.color = new THREE.Color(color);
    }

    //init
    if (R2D.PoolMaterials.isMaterial(productId)) {
        material = R2D.PoolMaterials.getMaterial(productId);
    }
    else if (R2D.Pool.isProductData(productId)) {
        checkGLTF();
        createMaterial();
        loadMaterialData();
    } else {
        createMaterial();
        loadProductData();
    }

    function checkGLTF() {
        productData = R2D.Pool.getProductData(productId);
        if (!productData) return;

        if (productData.id == "4128") {
            productData.source.body.package = "/scene.glb";
        }

        productData.isGLTF = productData.source.body.package.endsWith(".glb");
    }
};

R2D.ObjectViewer3DMaterial.mapNames = [
    "alphaMap",
    "aoMap",
    "bumpMap",
    "emissiveMap",
    "lightMap",
    "map",
    "metalnessMap",
    "normalMap",
    "roughnessMap",
    "displacementMap",
    "specularMap"
];

R2D.extend(R2D.ObjectViewer3DMaterial, EventDispatcher);

// viewers

R2D.ObjectViewerColorMaterial = function(productId)
{
    var me = this;
    var material = new THREE.MeshPhongMaterial({color: productId, side: THREE.DoubleSide});

    me.getProductId = function() {
        return productId;
    };
    me.getMaterial = function() {
        return material;
    };
    me.isReady = function()
    {
        return true;
    };
    me.addEventListener = function() {};
    me.removeEventListener = function() {};
};
//viewers

R2D.ObjectViewer3DBox = function(sceneObject) {
    R2D.ObjectViewer3D.call(this, Number(sceneObject.getType()), sceneObject);

    var scope = this;

    Object.defineProperties(scope, {
        "forWall":{
            get() { return sceneObject.forWall; }
        }
    });

    scope.getForWall = function() {
        return sceneObject.forWall;
    };
};

R2D.extend(R2D.ObjectViewer3DBox, R2D.ObjectViewer3D);
//viewers

R2D.ObjectViewer3DModel = function (sceneObject) {
    // sceneObject - [R2D.SceneObjectModel]
    R2D.ObjectViewer3D.call(this, R2D.ProductType.MODEL, sceneObject);

    var scope = this;
    var productId = sceneObject.getProductId();
    var object3d = scope.getObject3d();
    var geometriesHash = [];
    var materialsIds = [];
    var materials3d = [];
    var geometryUpdated = false;
    var flipX = false;
    var flipZ = false;

    function needsUpdateHandler(e) {
        scope._needsUpdate();

        updateMaterials(); // TODO: may be recursion!!!
    }
    function updateMaterials() {
        var materials = sceneObject.getMaterials();
        //var children = object3d.children;
        var children = [];
        object3d.traverse(function (obj) {
            if (obj.type == "Mesh") {
                children.push(obj);
            }
        });

        if (materials.length != children.length) {
            //console.warn("Length of materials isn't equal to length of children! " + productId);
            return;
        }

        for (let i = 0, l = materials3d.length; i < l; i++) {
            if (!materials3d[i]) continue;

            materials3d[i].removeEventListener(Event.UPDATE, needsUpdateHandler);
        }

        materialsIds = [];
        materials3d = [];

        if (sceneObject.isGLTF) {
            for (let i = 0; i < materials.length; i++) {
                if (materials[i].current == "0") continue;
                for (let j = 0; j < children.length; j++) {
                    let child = children[j];
                    if (child.userData.md5 != materials[i].hash) continue;
                    let materialViewer3d = materials[i].addMaterial ? R2D.PoolMaterials.getMaterial(
                        materials[i].current, materials[i].addMaterial
                    ) : R2D.PoolMaterials.getMaterial(
                        materials[i].current
                    )
                    if (materialViewer3d) {
                        child.material = materialViewer3d.getMaterial();
                    } else {
                        console.warn("Material is null!");
                    }
                    materials3d.push(materialViewer3d);
                }
            }
        } else {
            // setup materials ids from array
            for (let i = 0, l = Math.min(materials.length, children.length); i < l; i++) {
                let materialData = materials[i];
                let materialId = materialData["current"];

                materialsIds.push(materialId);
            }

            //setup materials ids by hash link of geometry
            for (let i = 0, l = geometriesHash.length; i < l; i++) {
                let gHash = geometriesHash[i];

                if (!gHash) continue;

                for (let j = 0, k = materials.length; j < k; j++) {
                    let materialData = materials[i];
                    let mId = materialData["current"];
                    let mHash = materialData["hash"];

                    if (!mHash || gHash != mHash) continue;

                    materialsIds[i] = mId;
                }
            }

            //apply materials to geometries
            for (let i = 0, l = Math.min(materials.length, children.length); i < l; i++) {
                let child = children[i];
                if (materialsIds[i] == "0") continue;
                let materialViewer3d = R2D.PoolMaterials.getMaterial(materialsIds[i]);

                if (materialViewer3d) {
                    child.material = materialViewer3d.getMaterial();
                } else {
                    console.warn("Material is null!");
                }

                materials3d.push(materialViewer3d);
            }
        }

        for (let i = 0, l = materials3d.length; i < l; i++) {
            if (!materials3d[i]) continue;

            if (materials3d[i].getMaterial().userData.blockScalingUV) {
                R2D.Tool.resetUV(children[i], i, sceneObject.productId);
            }

            materials3d[i].addEventListener(Event.UPDATE, needsUpdateHandler);
        }

        scope._needsUpdate();
    }
    function updateGeometry() {
        if (geometryUpdated && sceneObject.flipX == flipX && sceneObject.flipZ == flipZ) {
            return;
        }

        if (sceneObject.isGLTF) {
            const scale = new THREE.Vector3(1, 1, 1);
            if (sceneObject.flipX != flipX) {
                scale.x *= -1;
            }
            if (sceneObject.flipZ != flipZ) {
                scale.z *= -1;
            }
            for (var ch of object3d.children) {
                ch.scale.multiply(scale);
                ch.position.multiply(scale);
            }

            geometryUpdated = true;
            flipX = sceneObject.flipX;
            flipZ = sceneObject.flipZ;

            scope._needsUpdate();
        } else {
            let raw = R2D.ObjectViewer3DModel.__geometriesRAW[productId];

            let geometriesRaw = raw.geometries;
            let children = object3d.children;
            let geometries = null;

            if (geometriesRaw.length != children.length) {
                console.warn(
                    "Amount geometries isn't equal to length of children! " + productId
                );
            }
            if (sceneObject.flipX) {
                geometriesRaw = R2D.Tool.flipGeometriesByX(geometriesRaw);
            }
            if (sceneObject.flipZ) {
                geometriesRaw = R2D.Tool.flipGeometriesByZ(geometriesRaw);
            }

            geometries = R2D.Tool.makeModelGeometries(geometriesRaw);

            for (
                let i = 0, l = Math.min(geometries.length, children.length);
                i < l;
                i++
            ) {
                let mesh = children[i];

                mesh.geometry = geometries[i];
            }

            geometryUpdated = true;
            flipX = sceneObject.flipX;
            flipZ = sceneObject.flipZ;

            scope._needsUpdate();
        }
    }
    function productIsLoaded() {
        while (object3d.children.length > 0) {
            object3d.remove(object3d.children[0]);
        }

        if (sceneObject.isGLTF) {
            var data = R2D.Pool3D.getData(productId);
            
            sceneObject.isFirstLoading = true;
            sceneObject.isLoaded = true;

            let children = null;
            let geometries = null;

            if (data.scene?.children[0].type === "Mesh") {
                children = data.scene.clone().children;
                geometries = children?.map((el) => el.geometry.clone());
            } else {
                children = data.scene?.children[0].clone().children;
                geometries = children?.map((el) => el.geometry.clone());             
            }

            children.forEach((child, index) => {
                child.geometry = geometries[index];
            });

            object3d.add(...children);

            geometriesHash = [];

            object3d.traverse(function (obj) {
                if (obj.type == "Mesh") {
                    if (obj.userData.md5) geometriesHash.push(obj.userData.md5);
                }
            });

            scope.updateUV();                      

            updateGeometry();
            updateMaterials();
            
            // -------------------------------------------------
            let svgRealName = object3d.children[0].userData.svgRealName?.split(".")[0];

            if (svgRealName || sceneObject.forWall) {
                //      
                svgRealName = svgRealName || "default_for_wall";
                const viewerPlane = new R2D.ObjectViewer3DModelPlane(sceneObject, svgRealName);
                scope.viewerPlane = viewerPlane;
                const objectsViewers3dPlanes = R2D.view2d.getObjectsViewers3dPlanes();
                objectsViewers3dPlanes.set(sceneObject, viewerPlane);
                R2D.commonSceneHelper.productHelper.addAlias(
                    viewerPlane.object3d.getObjectByName("planeForClick"),
                    sceneObject
                );

                if (R2D.Viewers.getCurrentViewerType && R2D.Viewers.getCurrentViewerType() === "2d") {
                    R2D.commonSceneHelper.commonSceneObject.view2DObjects.add(viewerPlane.object3d);
                    scope.object3d.visible = false;
                }
            }
            // -------------------------------------------------
        } else {
            var raw;
            if (R2D.ObjectViewer3DModel.__geometriesRAW.hasOwnProperty(productId)) {
                raw = R2D.ObjectViewer3DModel.__geometriesRAW[productId];
            } else {
                raw = R2D.ProductPackageParser.parseModel(R2D.Pool3D.getData(productId));

                R2D.Pool3D.clearData(productId);
                R2D.ObjectViewer3DModel.__geometriesRAW[productId] = raw;
            }

            geometriesHash = [];

            for (let i = 0, l = raw.geometries.length; i < l; i++) {
                let material = R2D.ObjectViewer3D.__defaultMaterial;
                let geometry = new THREE.BufferGeometry();
                let mesh = new THREE.Mesh(geometry, material);

                material.side = THREE.DoubleSide;

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.needsUpdate = true;

                object3d.add(mesh);
                geometriesHash.push(raw.geometries[i]["md5"]);
            }

            updateGeometry();
            updateMaterials();
        }
    }

    function completeLoadModelDataHandler(event) {
        if (event.data == productId) {
            R2D.Pool3D.removeEventListener(Event.FINISH, completeLoadModelDataHandler);

            productIsLoaded();
        }
    }
    function sceneObjectUpdateEventHandler(event) {
        if (sceneObject.isGLTF || R2D.ObjectViewer3DModel.__geometriesRAW[productId]) {
            updateGeometry();
        }

        updateMaterials();
    }

    Object.defineProperties(scope, {
        forWall: {
            get() {
                return sceneObject.forWall;
            },
        },
    });

    scope.getForWall = function () {
        return sceneObject.forWall;
    };

    scope.getMeshByHash = function (hash) {
        const model3d = scope.getObject3d();
        const meshes = model3d.children;
        for (let i = 0; i < meshes.length; i += 1) {
            if (meshes[i].userData.md5 === hash) return meshes[i];
        }
    };

    if (R2D.Pool3D.isLoaded(productId)) {
        productIsLoaded();
    } else {
        R2D.Pool3D.addEventListener(Event.FINISH, completeLoadModelDataHandler);
        R2D.Pool3D.load(productId);
    }

    sceneObject.addEventListener(Event.UPDATE, sceneObjectUpdateEventHandler);
};

R2D.extend(R2D.ObjectViewer3DModel, R2D.ObjectViewer3D);

R2D.ObjectViewer3DModel.__geometriesRAW = {}; //pool geometries raw

//viewers

R2D.ObjectViewer3DPoster = function (sceneObject) {
    R2D.ObjectViewer3D.call(this, R2D.ProductType.POSTER, sceneObject);

    var scope = this;
    var productId = sceneObject.getProductId();
    var object3d = scope.getObject3d(); //scope.getMeshes()[0];

    function updateMaterial() {
        R2D.ObjectViewer3DPoster.__updateMaterial(object3d, productId);

        scope._needsUpdate();
    }
    function completeLoadPosterDataHandler(event) {
        if (event.data == productId) {
            R2D.Pool3D.removeEventListener(Event.FINISH, completeLoadPosterDataHandler);

            updateMaterial();
        }
    }

    if (R2D.Pool3D.isLoaded(productId)) {
        updateMaterial();
    } else {
        R2D.Pool3D.addEventListener(Event.FINISH, completeLoadPosterDataHandler);
        R2D.Pool3D.load(productId);
    }
};

R2D.extend(R2D.ObjectViewer3DPoster, R2D.ObjectViewer3D);

R2D.ObjectViewer3DPoster.__poolPoster = {};
R2D.ObjectViewer3DPoster.__geometryFace = function (width, height, depth) {
    var w2 = width / 2;
    var d2 = depth / 2;
    var vertices = new Float32Array([
        w2,
        height,
        d2,
        -w2,
        height,
        d2,
        -w2,
        0,
        d2,
        w2,
        0,
        d2,
    ]);
    var uvs = new Float32Array([1, 0, 0, 0, 0, 1, 1, 1]);
    var indices = new Uint32Array([0, 1, 3, 1, 2, 3]);
    var geometry = new THREE.BufferGeometry();

    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));

    geometry.computeVertexNormals();

    return geometry;
};
R2D.ObjectViewer3DPoster.__geometryBox = function (width, height, depth) {
    var w2 = width / 2;
    var d2 = depth / 2;
    var vertices = new Float32Array([
        w2,
        height,
        -d2,
        -w2,
        height,
        -d2,
        -w2,
        height,
        d2,
        w2,
        height,
        d2,
        w2,
        0,
        -d2,
        -w2,
        0,
        -d2,
        -w2,
        0,
        d2,
        w2,
        0,
        d2,
    ]);
    var uvs = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    var indices = new Uint32Array([
        0, 1, 2, 0, 2, 3, 2, 1, 5, 2, 5, 6, 1, 0, 4, 1, 4, 5, 0, 3, 4, 3, 7, 4, 7, 6, 5,
        7, 5, 4,
    ]);
    var geometry = new THREE.BufferGeometry();

    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));

    geometry.computeVertexNormals();

    return geometry;
};
R2D.ObjectViewer3DPoster.__updateMaterial = function (object3d, productId) {
    var posterPoolData;
    var meshFace;
    var meshBox;

    if (R2D.ObjectViewer3DPoster.__poolPoster.hasOwnProperty(productId)) {
        posterPoolData = R2D.ObjectViewer3DPoster.__poolPoster[productId];
    } else {
        var posterDefaultData = R2D.Pool.getProductData(productId);
        var posterBytesData = R2D.Pool3D.getData(productId);
        var rawData = R2D.ProductPackageParser.parsePoster(posterBytesData);
        var width = posterDefaultData.property.sizes.width;
        var height = posterDefaultData.property.sizes.height;
        var depth = posterDefaultData.property.sizes.depth;
        var face = R2D.ObjectViewer3DPoster.__geometryFace(width, height, depth);
        var box = R2D.ObjectViewer3DPoster.__geometryBox(width, height, depth);
        var materialFace = new THREE.MeshPhongMaterial({ color: 0xffffff });
        var materialBox = new THREE.MeshPhongMaterial({ color: 0xdddddd });
        var image;

        if (rawData.materialData.diffuseData) {
            materialFace.color = new THREE.Color(0xffffff);
            image = R2D.Tool.arrayBufferToImage(rawData.materialData.diffuseData);

            R2D.Tool.makeTextureMap(materialFace, "map", image, 1, 1);
        }
        if (rawData.materialData.normalData) {
            image = R2D.Tool.arrayBufferToImage(rawData.materialData.normalData);

            R2D.Tool.makeTextureMap(materialFace, "normalMap", image, 1, 1);
        }
        if (rawData.materialData.specularData) {
            image = R2D.Tool.arrayBufferToImage(rawData.materialData.specularData);

            R2D.Tool.makeTextureMap(materialFace, "specularMap", image, 1, 1);
        }

        R2D.Pool3D.clearData(productId);

        materialFace.side = THREE.DoubleSide;
        materialBox.side = THREE.DoubleSide;

        posterPoolData = {
            width: width,
            height: height,
            depth: depth,
            geometryFace: face,
            geometryBox: box,
            materialFace: materialFace,
            materialBox: materialBox,
        };

        R2D.ObjectViewer3DPoster.__poolPoster[productId] = posterPoolData;
    }

    //remove all children
    while (object3d.children.length > 0) {
        object3d.remove(object3d.children[0]);
    }

    meshFace = new THREE.Mesh(posterPoolData.geometryFace, posterPoolData.materialFace);
    meshBox = new THREE.Mesh(posterPoolData.geometryBox, posterPoolData.materialBox);

    object3d.add(meshFace);
    object3d.add(meshBox);
};

//viewers

// ---------NEW VERSION
R2D.ObjectViewer3DCarpet = function (sceneObject) {
    R2D.ObjectViewer3D.call(this, R2D.ProductType.CARPET, sceneObject);

    var scope = this;
    var productId = sceneObject.getProductId();
    var object3d = scope.getObject3d(); //scope.getMeshes()[0];

    function updateMaterial() {
        R2D.ObjectViewer3DCarpet.__updateMaterial(object3d, productId);

        scope._needsUpdate();
    }
    function completeLoadPosterDataHandler(event) {
        if ( event.data == productId ) {
            R2D.Pool3D.removeEventListener(Event.FINISH, completeLoadPosterDataHandler);

            updateMaterial();
        }
    }

    if ( R2D.Pool3D.isLoaded(productId) ) {
        updateMaterial();
    } else {
        R2D.Pool3D.addEventListener(Event.FINISH, completeLoadPosterDataHandler);
        R2D.Pool3D.load(productId);
    }
};

R2D.extend(R2D.ObjectViewer3DCarpet, R2D.ObjectViewer3D);

R2D.ObjectViewer3DCarpet.__poolCarpet = {};

// -------------------------------
R2D.ObjectViewer3DCarpet.__geometryFaceSquare = function (width, height, depth) {
    var w2 = width / 2;
    var d2 = depth / 2;

    var points = [
        [-w2, height, d2], //0
        [w2, height, d2], //1
        [w2, height, -d2], //2
        [-w2, height, -d2], //3
        [-w2, 0, d2], //4
        [w2, 0, d2], //5
        [w2, 0, -d2], //6
        [-w2, 0, -d2], //7
    ];

    var vertices = new Float32Array([
        ...points[0],
        ...points[1],
        ...points[2],
        ...points[3],
    ]);
    // var uvs = new Float32Array([1, 0, 0, 0, 0, 1, 1, 1]);
    var uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]);
    var indices = new Uint32Array([0, 1, 3, 1, 2, 3]);
    var geometry = new THREE.BufferGeometry();

    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));

    geometry.computeVertexNormals();

    return geometry;
};

R2D.ObjectViewer3DCarpet.__geometryBoxSquare = function (width, height, depth) {
    var w2 = width / 2;
    var d2 = depth / 2;

    var points = [
        [-w2, height, d2], //0
        [w2, height, d2], //1
        [w2, height, -d2], //2
        [-w2, height, -d2], //3
        [-w2, 0, d2], //4
        [w2, 0, d2], //5
        [w2, 0, -d2], //6
        [-w2, 0, -d2], //7
    ];

    var vertices = new Float32Array([
        ...points[0],
        ...points[1],
        ...points[2],
        ...points[3],
        ...points[4],
        ...points[5],
        ...points[6],
        ...points[7],
    ]);
    // var uvs = new Float32Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    var indices = new Uint32Array([
        0, 4, 1, 4, 5, 1, 1, 5, 6, 1, 6, 2, 6, 7, 2, 2, 7, 3, 3, 7, 4, 3, 4, 0, 4, 7, 5,
        5, 7, 6,
    ]);
    // var indices = new Uint32Array([
    //     0, 1, 2, 0, 2, 3, 2, 1, 5, 2, 5, 6, 1, 0, 4, 1, 4, 5, 0, 3, 4, 3, 7, 4,
    // ]);
    var geometry = new THREE.BufferGeometry();

    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));
    // geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2));

    geometry.computeVertexNormals();

    return geometry;
};
// -------------------------------

R2D.ObjectViewer3DCarpet.__updateMaterial = function (object3d, productId) {
    var carpetPoolData;
    var meshFace;
    var meshBox;

    if ( R2D.ObjectViewer3DCarpet.__poolCarpet.hasOwnProperty(productId) ) {
        carpetPoolData = R2D.ObjectViewer3DCarpet.__poolCarpet[productId];
    } else {
        var carpetDefaultData = R2D.Pool.getProductData(productId);
        var carpetBytesData = R2D.Pool3D.getData(productId);
        var rawData = R2D.ProductPackageParser.parseCarpet(carpetBytesData);
        var width = carpetDefaultData.property.sizes.width;
        var height = carpetDefaultData.property.sizes.height;
        var depth = carpetDefaultData.property.sizes.depth;
        var scaleX = 1, scaleY = 1, scaleZ = 1;
        var carpetType = rawData.carpetType;
        var geometries = null;
        var geometryFace, geometryBox;
        var materialFace = new THREE.MeshPhongMaterial({color:0xffffff});
        var materialBox = new THREE.MeshPhongMaterial({color:0xdddddd});
        var image;

        switch ( carpetType ) {
            case 1:
                geometryFace = R2D.ObjectViewer3DCarpet.__geometryFaceSquare(
                    width,
                    height,
                    depth
                );
                geometryBox = R2D.ObjectViewer3DCarpet.__geometryBoxSquare(
                    width,
                    height,
                    depth
                );
                materialBox = materialFace;
                // geometries = R2D.ObjectViewer3DCarpet.getSquareGeometry();
                // scaleX = width / R2D.ObjectViewer3DCarpet.__squareWidth;
                // scaleY = height / R2D.ObjectViewer3DCarpet.__squareHeight;
                // scaleZ = depth / R2D.ObjectViewer3DCarpet.__squareDepth;
                break;

            case 2:
                geometries = R2D.ObjectViewer3DCarpet.getRoundGeometry();
                scaleX = width / R2D.ObjectViewer3DCarpet.__roundWidth;
                scaleY = height / R2D.ObjectViewer3DCarpet.__roundHeight;
                scaleZ = depth / R2D.ObjectViewer3DCarpet.__roundDepth;

                geometryFace = geometries[0];
                geometryBox = geometries[1];
                break;

            default:
                throw "Unknown type of carpet! Current type " + carpetType;
        }

        if ( rawData.materialData.diffuseData ) {
            materialFace.color = new THREE.Color(0xffffff);
            image = R2D.Tool.arrayBufferToImage(rawData.materialData.diffuseData);

            R2D.Tool.makeTextureMap(materialFace, "map", image, 1, 1);
        }
        if ( rawData.materialData.normalData ) {
            image = R2D.Tool.arrayBufferToImage(rawData.materialData.normalData);

            R2D.Tool.makeTextureMap(materialFace, "normalMap", image, 1, 1);
        }
        if ( rawData.materialData.specularData ) {
            image = R2D.Tool.arrayBufferToImage(rawData.materialData.normalData);

            R2D.Tool.makeTextureMap(materialFace, "specularMap", image, 1, 1);
        }

        R2D.Pool3D.clearData(productId);

        materialFace.side = THREE.DoubleSide;
        materialBox.side = THREE.DoubleSide;

        // geometryFace = geometries[0];
        // geometryBox = geometries[1];

        carpetPoolData = {
            width:width,
            height:height,
            depth:depth,
            scaleX:scaleX,
            scaleY:scaleY,
            scaleZ:scaleZ,
            geometryFace:geometryFace,
            geometryBox:geometryBox,
            materialFace:materialFace,
            materialBox:materialBox
        };

        R2D.ObjectViewer3DCarpet.__poolCarpet[productId] = carpetPoolData;
    }

    //remove all children
    while ( object3d.children.length > 0 ) {
        object3d.remove(object3d.children[0]);
    }

    meshFace = new THREE.Mesh(carpetPoolData.geometryFace, carpetPoolData.materialFace);
    meshBox = new THREE.Mesh(carpetPoolData.geometryBox, carpetPoolData.materialBox);

    meshFace.castShadow = true;
    meshFace.receiveShadow = true;

    meshFace.scale.set(carpetPoolData.scaleX, carpetPoolData.scaleY, carpetPoolData.scaleZ);
    meshBox.scale.set(carpetPoolData.scaleX, carpetPoolData.scaleY, carpetPoolData.scaleZ);

    object3d.add(meshFace);
    object3d.add(meshBox);
};

// ---------OLD VERSION

// R2D.ObjectViewer3DCarpet = function (sceneObject) {
//     R2D.ObjectViewer3D.call(this, R2D.ProductType.CARPET, sceneObject);

//     var scope = this;
//     var productId = sceneObject.getProductId();
//     var object3d = scope.getObject3d(); //scope.getMeshes()[0];

//     function updateMaterial() {
//         R2D.ObjectViewer3DCarpet.__updateMaterial(object3d, productId);

//         scope._needsUpdate();
//     }
//     function completeLoadPosterDataHandler(event) {
//         if (event.data == productId) {
//             R2D.Pool3D.removeEventListener(Event.FINISH, completeLoadPosterDataHandler);

//             updateMaterial();
//         }
//     }

//     if (R2D.Pool3D.isLoaded(productId)) {
//         updateMaterial();
//     } else {
//         R2D.Pool3D.addEventListener(Event.FINISH, completeLoadPosterDataHandler);
//         R2D.Pool3D.load(productId);
//     }
// };

// R2D.extend(R2D.ObjectViewer3DCarpet, R2D.ObjectViewer3D);

// R2D.ObjectViewer3DCarpet.__poolCarpet = {};
// R2D.ObjectViewer3DCarpet.__updateMaterial = function (object3d, productId) {
//     var carpetPoolData;
//     var meshFace;
//     var meshBox;

//     if (R2D.ObjectViewer3DCarpet.__poolCarpet.hasOwnProperty(productId)) {
//         carpetPoolData = R2D.ObjectViewer3DCarpet.__poolCarpet[productId];
//     } else {
//         var carpetDefaultData = R2D.Pool.getProductData(productId);
//         var carpetBytesData = R2D.Pool3D.getData(productId);
//         var rawData = R2D.ProductPackageParser.parseCarpet(carpetBytesData);
//         var width = carpetDefaultData.property.sizes.width;
//         var height = carpetDefaultData.property.sizes.height;
//         var depth = carpetDefaultData.property.sizes.depth;
//         var scaleX = 1,
//             scaleY = 1,
//             scaleZ = 1;
//         var carpetType = rawData.carpetType;
//         var geometries = null;
//         var geometryFace, geometryBox;
//         var materialFace = new THREE.MeshPhongMaterial({ color: 0xffffff });
//         var materialBox = new THREE.MeshPhongMaterial({ color: 0xdddddd });
//         var image;

//         switch (carpetType) {
//             case 1:
//                 geometries = R2D.ObjectViewer3DCarpet.getSquareGeometry();
//                 scaleX = width / R2D.ObjectViewer3DCarpet.__squareWidth;
//                 scaleY = height / R2D.ObjectViewer3DCarpet.__squareHeight;
//                 scaleZ = depth / R2D.ObjectViewer3DCarpet.__squareDepth;
//                 break;

//             case 2:
//                 geometries = R2D.ObjectViewer3DCarpet.getRoundGeometry();
//                 scaleX = width / R2D.ObjectViewer3DCarpet.__roundWidth;
//                 scaleY = height / R2D.ObjectViewer3DCarpet.__roundHeight;
//                 scaleZ = depth / R2D.ObjectViewer3DCarpet.__roundDepth;
//                 break;

//             default:
//                 throw "Unknown type of carpet! Current type " + carpetType;
//         }

//         if (rawData.materialData.diffuseData) {
//             materialFace.color = new THREE.Color(0xffffff);
//             image = R2D.Tool.arrayBufferToImage(rawData.materialData.diffuseData);

//             R2D.Tool.makeTextureMap(materialFace, "map", image, 1, 1);
//         }
//         if (rawData.materialData.normalData) {
//             image = R2D.Tool.arrayBufferToImage(rawData.materialData.normalData);

//             R2D.Tool.makeTextureMap(materialFace, "normalMap", image, 1, 1);
//         }
//         if (rawData.materialData.specularData) {
//             image = R2D.Tool.arrayBufferToImage(rawData.materialData.normalData);

//             R2D.Tool.makeTextureMap(materialFace, "specularMap", image, 1, 1);
//         }

//         R2D.Pool3D.clearData(productId);

//         materialFace.side = THREE.DoubleSide;
//         materialBox.side = THREE.DoubleSide;

//         geometryFace = geometries[0];
//         geometryBox = geometries[1];

//         carpetPoolData = {
//             width: width,
//             height: height,
//             depth: depth,
//             scaleX: scaleX,
//             scaleY: scaleY,
//             scaleZ: scaleZ,
//             geometryFace: geometryFace,
//             geometryBox: geometryBox,
//             materialFace: materialFace,
//             materialBox: materialBox,
//         };

//         R2D.ObjectViewer3DCarpet.__poolCarpet[productId] = carpetPoolData;
//     }

//     //remove all children
//     while (object3d.children.length > 0) {
//         object3d.remove(object3d.children[0]);
//     }

//     meshFace = new THREE.Mesh(carpetPoolData.geometryFace, carpetPoolData.materialFace);
//     meshBox = new THREE.Mesh(carpetPoolData.geometryBox, carpetPoolData.materialBox);

//     meshFace.castShadow = true;
//     meshFace.receiveShadow = true;

//     meshFace.scale.set(
//         carpetPoolData.scaleX,
//         carpetPoolData.scaleY,
//         carpetPoolData.scaleZ
//     );
//     meshBox.scale.set(
//         carpetPoolData.scaleX,
//         carpetPoolData.scaleY,
//         carpetPoolData.scaleZ
//     );

//     object3d.add(meshFace);
//     object3d.add(meshBox);
// };

//viewers
class ObjectViewer3DModelPlane extends EventDispatcher {
    static planeSize = 100;

    static imgMakersMap = {
        window_01: this.drawWindow01,
        window_02: this.drawWindow02,
        window_03: this.drawWindow03,
        window_04: this.drawWindow04,
        window_05: this.drawWindow05,
        window_06: this.drawWindow06,
        window_07: this.drawWindow07,
        window_08: this.drawWindow08,
        window_09: this.drawWindow09,
        window_10: this.drawWindow10,
        window_11: this.drawWindow11,
        door_01: this.drawDoor01,
        door_02: this.drawDoor02,
        door_03: this.drawDoor03,
        door_04: this.drawDoor04,
        door_05: this.drawDoor05,
        door_06: this.drawDoor06,
        door_07: this.drawDoor07,
        door_08: this.drawDoor08,
        door_09: this.drawDoor09,
        door_10: this.drawDoor10,
        door_11: this.drawDoor11,
        door_12: this.drawDoor12,
        door_13: this.drawWindow09,
        door_14: this.drawDoor14,
        door_15: this.drawDoor15,
        door_16: this.drawDoor16,
        door_17: this.drawDoor17,
        door_18: this.drawDoor18,
        door_19: this.drawDoor19,
        door_20: this.drawDoor20,
        door_21: this.drawDoor21,

        default_for_wall: this.drawDefaultForWall,
    };

    static totalSizesMap = {
        door_03: this.calcTotalSizesOneSwing,
        door_14: this.calcTotalSizesOneSwing,
        door_15: this.calcTotalSizesTwoSwings,
        door_17: this.calcTotalSizesTwoSwings,
        door_20: this.calcTotalSizesOneSwing,
        door_21: this.calcTotalSizesDoor_21,
    };

    static offsetMap = {
        //    
        door_01: 3,
        door_06: 11,
        door_07: 8,
        door_08: 8,
        door_10: 6,
        door_11: 11,
        door_12: 15,
        door_16: 11,
        door_18: 6,
        door_19: 8,
    };

    static angleMap = {
        door_03: 20,
    };

    // --------------functions for drawing img-----------
    static drawDefaultForWall() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);

        //
        this.createNewTexture();
    }

    static drawWindow01() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow02() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2) / 2 - th2, h2 - th2, th, th);
        this.ctx.strokeRect((2 * w2) / 2 - th2, h2 - th2, th, th);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow03() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2) / 3 - th2, h2 - th2, th, th);
        this.ctx.strokeRect((2 * w2) / 3 - th2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2 * 2) / 3 - th2, h2 - th2, th, th);
        this.ctx.strokeRect((2 * w2 * 2) / 3 - th2, h2 - th2, th, th);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow04() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const a2 = (5 * k) / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2) / 4 - a2, h2 - a2, 2 * a2, 2 * a2);
        this.ctx.strokeRect((2 * w2) / 4 - a2, h2 - a2, 2 * a2, 2 * a2);

        this.ctx.fillRect((2 * w2 * 2) / 4 - a2, h2 - a2, 2 * a2, 2 * a2);
        this.ctx.strokeRect((2 * w2 * 2) / 4 - a2, h2 - a2, 2 * a2, 2 * a2);

        this.ctx.fillRect((2 * w2 * 3) / 4 - a2, h2 - a2, 2 * a2, 2 * a2);
        this.ctx.strokeRect((2 * w2 * 3) / 4 - a2, h2 - a2, 2 * a2, 2 * a2);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow05() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2);
        this.ctx.lineTo(2 * w2, h2);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawWindow06() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const rectW2 = (3 * k) / 2;
        const rectH2 = (5 * k) / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2) / 4 - rectW2, h2 - rectH2, 2 * rectW2, 2 * rectH2);
        this.ctx.strokeRect((2 * w2) / 4 - rectW2, h2 - rectH2, 2 * rectW2, 2 * rectH2);

        this.ctx.fillRect((2 * w2 * 3) / 4 - rectW2, h2 - rectH2, 2 * rectW2, 2 * rectH2);
        this.ctx.strokeRect((2 * w2 * 3) / 4 - rectW2, h2 - rectH2, 2 * rectW2, 2 * rectH2);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow07() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const a2 = (5 * k) / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2) / 3 - a2, h2 - a2, 2 * a2, 2 * a2);
        this.ctx.strokeRect((2 * w2) / 3 - a2, h2 - a2, 2 * a2, 2 * a2);

        this.ctx.fillRect((2 * w2 * 2) / 3 - a2, h2 - a2, 2 * a2, 2 * a2);
        this.ctx.strokeRect((2 * w2 * 2) / 3 - a2, h2 - a2, 2 * a2, 2 * a2);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow08() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const a2 = (5 * k) / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - th / 6);
        this.ctx.lineTo(2 * w2, h2 - th / 6);

        this.ctx.moveTo(0, h2 + th / 6);
        this.ctx.lineTo(2 * w2, h2 + th / 6);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect((2 * w2) / 2 - a2, h2 - a2, 2 * a2, 2 * a2);
        this.ctx.strokeRect((2 * w2) / 2 - a2, h2 - a2, 2 * a2, 2 * a2);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawWindow09() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const a2 = (5 * k) / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2);
        this.ctx.lineTo(2 * w2, h2);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, 2 * a2, th);
        this.ctx.strokeRect(k / 2, h2 - th2, 2 * a2, th);

        this.ctx.fillRect(2 * w2 - k / 2 - 2 * a2, h2 - th2, 2 * a2, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - 2 * a2, h2 - th2, 2 * a2, th);
        //
        this.createNewTexture();
    }

    static drawWindow10() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(k / 2, h2 - th2);
        this.ctx.lineTo(k / 2, h2 + th2);

        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2);
        this.ctx.lineTo(2 * w2, h2);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(2 * w2 - k / 2, h2 - th2);
        this.ctx.lineTo(2 * w2 - k / 2, h2 + th2);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawWindow11() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th = this.mainThickness * k;
        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(k / 2, h2 - th2);
        this.ctx.lineTo(k / 2, h2 + th2);

        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);

        this.ctx.moveTo(0, h2 - 1 * k);
        this.ctx.lineTo(2 * w2, h2 - 1 * k);

        this.ctx.moveTo(0, h2 + 1 * k);
        this.ctx.lineTo(2 * w2, h2 + 1 * k);

        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(2 * w2 - k / 2, h2 - th2);
        this.ctx.lineTo(2 * w2 - k / 2, h2 + th2);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    // --------------

    static drawDoor01() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th6 = th / 6;
        const gap = 25 * k;
        const dx = (this.sceneObject.width * k - 2 * th - gap) / 8;
        const dy = 6 * k;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;
        this.ctx.scale(-1, 1);
        this.ctx.translate(-this.canvas.width, 0);

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(th, h2 - th6);

        for (let i = 0; i < 4; i += 1) {
            this.ctx.lineTo(th + i * 2 * dx + dx, h2 - th6 - dy);
            this.ctx.lineTo(th + i * 2 * dx + 2 * dx, h2 - th6);
        }

        this.ctx.lineTo(2 * w2 - th - gap, h2 + th6);

        for (let i = 0; i < 4; i += 1) {
            this.ctx.lineTo(2 * w2 - th - gap - i * 2 * dx - dx, h2 + th6 - dy);
            this.ctx.lineTo(2 * w2 - th - gap - i * 2 * dx - 2 * dx, h2 + th6);
        }
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor02() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const w2 = this.canvas.width / 2;
        const w10 = this.canvas.width / 10;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(k / 2, 0);
        this.ctx.lineTo(k / 2, 2 * h2);
        this.ctx.moveTo(w10, 0);
        this.ctx.lineTo(w10, 2 * h2);
        this.ctx.moveTo(w10 / 4, 0);
        this.ctx.lineTo(w10 / 4, 2 * h2);
        this.ctx.moveTo((3 * w10) / 4, 0);
        this.ctx.lineTo((3 * w10) / 4, 2 * h2);
        this.ctx.moveTo(2 * w10, 0);
        this.ctx.lineTo(2 * w10, 2 * h2);
        this.ctx.moveTo(3 * w10, 0);
        this.ctx.lineTo(3 * w10, 2 * h2);
        this.ctx.moveTo(5 * w10, 0);
        this.ctx.lineTo(5 * w10, 2 * h2);
        this.ctx.moveTo(7 * w10, 0);
        this.ctx.lineTo(7 * w10, 2 * h2);
        this.ctx.moveTo(8 * w10, 0);
        this.ctx.lineTo(8 * w10, 2 * h2);
        this.ctx.moveTo(9 * w10, 0);
        this.ctx.lineTo(9 * w10, 2 * h2);
        this.ctx.moveTo(9 * w10 + w10 / 4, 0);
        this.ctx.lineTo(9 * w10 + w10 / 4, 2 * h2);
        this.ctx.moveTo(9 * w10 + (3 * w10) / 4, 0);
        this.ctx.lineTo(9 * w10 + (3 * w10) / 4, 2 * h2);
        this.ctx.moveTo(2 * w2 - k / 2, 0);
        this.ctx.lineTo(2 * w2 - k / 2, 2 * h2);
        this.ctx.stroke();

        //
        this.createNewTexture();
    }

    static drawDoor03() {
        const k = this.k;
        const th = this.mainThickness * k;
        const topOffset = 9 * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2);
        this.ctx.lineTo(2 * w2, h2);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(th / 3, h2 - th2);
        this.ctx.lineTo(th / 3, h2 - th2 - topOffset);
        this.ctx.lineTo(2 * w2 - th / 3, h2 - th2 - topOffset);
        this.ctx.lineTo(2 * w2 - th / 3, h2 - th2);

        this.ctx.moveTo(2 * w2 - th - k / 2, h2);
        this.ctx.arc(
            2 * w2 - k / 2 - th,
            h2,
            2 * (w2 - th - k / 2),
            (Math.PI / 180) * (180 - this.angle),
            Math.PI
        );
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor04() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const w = this.canvas.width;
        const h = this.canvas.height;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;
        this.ctx.setLineDash([8 * k, 8 * k]);

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.beginPath();
        this.ctx.moveTo(k / 2, k / 2);
        this.ctx.lineTo(w - k / 2, k / 2);
        this.ctx.moveTo(k / 2, h - k / 2);
        this.ctx.lineTo(w - k / 2, h - k / 2);
        this.ctx.moveTo(k / 2, k / 2);
        this.ctx.lineTo(k / 2, h - k / 2);
        this.ctx.moveTo(w - k / 2, k / 2);
        this.ctx.lineTo(w - k / 2, h - k / 2);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawDoor05() {
        const k = this.k;
        const th = this.mainThickness * k;
        const th2 = th / 2;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const w6 = this.canvas.width / 6;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.strokeRect(k / 2, h2 - th2, this.canvas.width - k, th);

        this.ctx.beginPath();
        this.ctx.moveTo(w6, h2 - th2);
        this.ctx.lineTo(w6, h2 + th2);
        this.ctx.moveTo(w6 * 2, h2 - th2);
        this.ctx.lineTo(w6 * 2, h2 + th2);
        this.ctx.moveTo(w6 * 3, h2 - th2);
        this.ctx.lineTo(w6 * 3, h2 + th2);
        this.ctx.moveTo(w6 * 4, h2 - th2);
        this.ctx.lineTo(w6 * 4, h2 + th2);
        this.ctx.moveTo(w6 * 5, h2 - th2);
        this.ctx.lineTo(w6 * 5, h2 + th2);
        this.ctx.stroke();

        //
        this.createNewTexture();
    }

    static drawDoor06() {
        const k = this.k;
        const th = this.mainThickness * k;
        const offset = this.offset * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th6 = th / 6;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const distArrows = 30 * k;
        const arrowLen = 20 * k;
        const thArr2 = 4 * k;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2 - th6);
        this.ctx.lineTo(2 * w2, h2 - th6);
        this.ctx.moveTo(0, h2 + th6);
        this.ctx.lineTo(2 * w2, h2 + th6);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(th, h2 - th2);
        this.ctx.lineTo(th, h2 - th6);
        this.ctx.moveTo(th, h2 + th6);
        this.ctx.lineTo(th, h2 + th2);
        this.ctx.moveTo(w2, h2 - th6);
        this.ctx.lineTo(w2, h2 + th6);
        this.ctx.moveTo(2 * w2 - th, h2 - th2);
        this.ctx.lineTo(2 * w2 - th, h2 - th6);
        this.ctx.moveTo(2 * w2 - th, h2 + th6);
        this.ctx.lineTo(2 * w2 - th, h2 + th2);

        this.ctx.moveTo(k / 2, h2 - th2);
        this.ctx.lineTo(k / 2, h2 + th2);
        this.ctx.moveTo(2 * w2 - k / 2, h2 - th2);
        this.ctx.lineTo(2 * w2 - k / 2, h2 + th2);

        this.ctx.moveTo(w2 - distArrows / 2, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(w2 - distArrows / 2 - arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.moveTo(
            w2 - distArrows / 2 - arrowLen + thArr2,
            h2 + th2 + offset - 2 * thArr2 + k
        );
        this.ctx.lineTo(w2 - distArrows / 2 - arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(w2 - distArrows / 2 - arrowLen + thArr2, h2 + th2 + offset - k);

        this.ctx.moveTo(w2 + distArrows / 2, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(w2 + distArrows / 2 + arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.moveTo(
            w2 + distArrows / 2 + arrowLen - thArr2,
            h2 + th2 + offset - 2 * thArr2 + k
        );
        this.ctx.lineTo(w2 + distArrows / 2 + arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(w2 + distArrows / 2 + arrowLen - thArr2, h2 + th2 + offset - k);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawDoor07() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const distArrows = 15 * k;
        const arrowLen = 20 * k;
        const thArr2 = 4 * k;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.strokeRect(0, h2 - 2 * k, w2 / 2, 2 * k);
        this.ctx.strokeRect(w2 / 2, h2, w2 / 2, 2 * k);
        this.ctx.strokeRect(w2, h2, w2 / 2, 2 * k);
        this.ctx.strokeRect((w2 / 2) * 3, h2 - 2 * k, w2 / 2, 2 * k);

        this.ctx.beginPath();
        this.ctx.moveTo(w2 - distArrows / 2, h2 - th2 - thArr2);
        this.ctx.lineTo(w2 - distArrows / 2 - arrowLen, h2 - th2 - thArr2);
        this.ctx.moveTo(w2 - distArrows / 2 - arrowLen + thArr2, h2 - th2 - 2 * thArr2 + k);
        this.ctx.lineTo(w2 - distArrows / 2 - arrowLen, h2 - th2 - thArr2);
        this.ctx.lineTo(w2 - distArrows / 2 - arrowLen + thArr2, h2 - th2 - k);

        this.ctx.moveTo(w2 + distArrows / 2, h2 - th2 - thArr2);
        this.ctx.lineTo(w2 + distArrows / 2 + arrowLen, h2 - th2 - thArr2);
        this.ctx.moveTo(w2 + distArrows / 2 + arrowLen - thArr2, h2 - th2 - 2 * thArr2 + k);
        this.ctx.lineTo(w2 + distArrows / 2 + arrowLen, h2 - th2 - thArr2);
        this.ctx.lineTo(w2 + distArrows / 2 + arrowLen - thArr2, h2 - th2 - k);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor08() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const arrowLen = 20 * k;
        const thArr2 = 4 * k;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.strokeRect(k / 2, h2, w2 - k / 2, 2 * k);
        this.ctx.strokeRect(w2, h2 - 2 * k, w2 - k / 2, 2 * k);

        this.ctx.beginPath();
        this.ctx.moveTo(w2 - arrowLen / 2, h2 - th2 - thArr2);
        this.ctx.lineTo(w2 + arrowLen / 2, h2 - th2 - thArr2);
        this.ctx.moveTo(w2 + arrowLen / 2 - thArr2, h2 - th2 - 2 * thArr2 + k);
        this.ctx.lineTo(w2 + arrowLen / 2, h2 - th2 - thArr2);
        this.ctx.lineTo(w2 + arrowLen / 2 - thArr2, h2 - th2 - k);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawDoor09() {
        const k = this.k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const w = this.canvas.width;
        const h = this.canvas.height;
        const w2 = w / 2;
        const h2 = h / 2;
        const gap = 10 * k;
        const rectTh2 = 6 * k;
        const angleY = (Math.PI / 180) * 30;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = "white";
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(gap, h2 - rectTh2, w2 - gap, 2 * rectTh2);
        this.ctx.strokeRect(gap, h2 - rectTh2, w2 - gap, 2 * rectTh2);
        this.ctx.fillRect(w2 - rectTh2, gap, 2 * rectTh2, h2 - gap);
        this.ctx.strokeRect(w2 - rectTh2, gap, 2 * rectTh2, h2 - gap);
        this.ctx.fillRect(w2, h2 - rectTh2, w2 - gap, 2 * rectTh2);
        this.ctx.strokeRect(w2, h2 - rectTh2, w2 - gap, 2 * rectTh2);
        this.ctx.fillRect(w2 - rectTh2, h2, 2 * rectTh2, h2 - gap);
        this.ctx.strokeRect(w2 - rectTh2, h2, 2 * rectTh2, h2 - gap);

        this.ctx.beginPath();
        this.ctx.arc(w2, h2, 3 * rectTh2, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.stroke();

        this.ctx.beginPath();
        this.ctx.moveTo(w2 - w2 * Math.sin(angleY), h2 - w2 * Math.cos(angleY));
        this.ctx.arc(w2, h2, w2 - k, -(Math.PI / 2 + angleY), Math.PI / 2 + angleY, true);
        this.ctx.moveTo(w2 + w2 * Math.sin(angleY), h2 - w2 * Math.cos(angleY));
        this.ctx.arc(w2, h2, w2 - k, -(Math.PI / 2 - angleY), Math.PI / 2 - angleY);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawDoor10() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th6 = th / 6;
        const gap = 15 * k;
        const dx = (this.sceneObject.width * k - 2 * th - gap) / 4;
        const dy = 9 * k;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(th, h2 - th6);
        this.ctx.lineTo(th + dx, h2 - th6 - dy);
        this.ctx.lineTo(th + 2 * dx, h2 - th6);
        this.ctx.lineTo(th + 2 * dx, h2 + th6);
        this.ctx.lineTo(th + dx, h2 + th6 - dy);
        this.ctx.lineTo(th, h2 + th6);

        this.ctx.moveTo(2 * w2 - th, h2 - th6);
        this.ctx.lineTo(2 * w2 - th - dx, h2 - th6 - dy);
        this.ctx.lineTo(2 * w2 - th - 2 * dx, h2 - th6);
        this.ctx.lineTo(2 * w2 - th - 2 * dx, h2 + th6);
        this.ctx.lineTo(2 * w2 - th - dx, h2 + th6 - dy);
        this.ctx.lineTo(2 * w2 - th, h2 + th6);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor11() {
        const k = this.k;
        const th = this.mainThickness * k;
        const offset = this.offset * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th6 = th / 6;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const distArrow = 20 * k;
        const arrowLen = 20 * k;
        const thArr2 = 4 * k;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2 - th6);
        this.ctx.lineTo(2 * w2, h2 - th6);
        this.ctx.moveTo(0, h2 + th6);
        this.ctx.lineTo(2 * w2, h2 + th6);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(k / 2, h2 - th2);
        this.ctx.lineTo(k / 2, h2 + th2);
        this.ctx.moveTo(2 * w2 - k / 2, h2 - th2);
        this.ctx.lineTo(2 * w2 - k / 2, h2 + th2);

        this.ctx.moveTo(2 * w2 - distArrow, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(2 * w2 - distArrow - arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.moveTo(2 * w2 - distArrow - arrowLen + thArr2, h2 + th2 + offset - 2 * thArr2 + k);
        this.ctx.lineTo(2 * w2 - distArrow - arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(2 * w2 - distArrow - arrowLen + thArr2, h2 + th2 + offset - k);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawDoor12() {
        const k = this.k;
        const th = this.mainThickness * k;
        const offset = this.offset * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th6 = th / 6;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2 - th6);
        this.ctx.lineTo(2 * w2, h2 - th6);
        this.ctx.moveTo(0, h2 + th6);
        this.ctx.lineTo(2 * w2, h2 + th6);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(w2, h2 - th2 - offset);
        this.ctx.lineTo(w2, h2 + th2 + offset);
        this.ctx.stroke();
        //
        this.createNewTexture();
    }

    static drawDoor14() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th5 = th / 5;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2 - th5);
        this.ctx.lineTo(2 * w2, h2 - th5);
        this.ctx.moveTo(0, h2 + th5);
        this.ctx.lineTo(2 * w2, h2 + th5);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(2 * w2 - th - k / 2, h2);
        this.ctx.arc(
            2 * w2 - k / 2 - th,
            h2,
            2 * (w2 - th - k / 2),
            (Math.PI / 180) * (180 - this.angle),
            Math.PI
        );
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor15() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th5 = th / 5;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const r = w2 - th - k / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2 - th5);
        this.ctx.lineTo(2 * w2, h2 - th5);
        this.ctx.moveTo(0, h2 + th5);
        this.ctx.lineTo(2 * w2, h2 + th5);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(th + k / 2, h2 - th5);
        this.ctx.arc(th + k / 2, h2 - th5, r, (Math.PI / 180) * this.angle, 0, true);
        this.ctx.moveTo(2 * w2 - th - k / 2, h2 - th5);
        this.ctx.arc(
            2 * w2 - k / 2 - th,
            h2 - th5,
            w2 - th - k / 2,
            (Math.PI / 180) * this.angle,
            Math.PI
        );
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor16() {
        const k = this.k;
        const th = this.mainThickness * k;
        const offset = this.offset * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th10 = th / 10;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const w10 = w2 / 5;
        const arrowLen = 20 * k;
        const thArr2 = 4 * k;
        const commonDist2 = 20 * k;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = (k * 3) / 4;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.strokeRect(0, h2 - th2, 2 * w2, th);
        this.ctx.strokeRect(0, h2 + th10, w2 + commonDist2, 2 * k);
        this.ctx.strokeRect(w2 - commonDist2, h2 - 3 * th10, w2 + commonDist2, 2 * k);

        this.ctx.beginPath();
        this.ctx.moveTo(w10, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(w10 + arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.moveTo(w10 + arrowLen - thArr2, h2 + th2 + offset - 2 * thArr2 + k);
        this.ctx.lineTo(w10 + arrowLen, h2 + th2 + offset - thArr2);
        this.ctx.lineTo(w10 + arrowLen - thArr2, h2 + th2 + offset - k);

        this.ctx.moveTo(2 * w2 - w10, h2 - th2 - offset + thArr2);
        this.ctx.lineTo(2 * w2 - w10 - arrowLen, h2 - th2 - offset + thArr2);
        this.ctx.moveTo(2 * w2 - w10 - arrowLen + thArr2, h2 - th2 - offset + 2 * thArr2 - k);
        this.ctx.lineTo(2 * w2 - w10 - arrowLen, h2 - th2 - offset + thArr2);
        this.ctx.lineTo(2 * w2 - w10 - arrowLen + thArr2, h2 - th2 - offset + k);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor17() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th5 = th / 5;
        const w = this.canvas.width;
        const w2 = w / 2;
        const h2 = this.canvas.height / 2;
        const r = w2 - th - k / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(0, h2 - (this.sceneObject.depth * k) / 2, w, this.sceneObject.depth * k);

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(w, h2 - th2);
        this.ctx.moveTo(0, h2 - th5);
        this.ctx.lineTo(w, h2 - th5);
        this.ctx.moveTo(0, h2 + th5);
        this.ctx.lineTo(w, h2 + th5);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(w, h2 + th2);

        this.ctx.moveTo(th + k / 2, h2 + r);
        this.ctx.arc(
            th + k / 2,
            h2,
            r,
            -(Math.PI / 180) * this.angle,
            (Math.PI / 180) * this.angle
        );

        this.ctx.moveTo(w - th - k / 2, h2 - r);

        this.ctx.arc(
            w - th - k / 2,
            h2,
            r,
            (Math.PI / 180) * this.angle,
            -(Math.PI / 180) * this.angle
        );
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(w - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(w - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor18() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th6 = th / 6;
        const gap = 10 * k;
        const dx = (this.sceneObject.width * k - 2 * th - gap) / 2;
        const dy = 9 * k;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(th, h2 - th6);
        this.ctx.lineTo(th + dx, h2 - th6 - dy);
        this.ctx.lineTo(th + 2 * dx, h2 - th6);
        this.ctx.lineTo(th + 2 * dx, h2 + th6);
        this.ctx.lineTo(th + dx, h2 + th6 - dy);
        this.ctx.lineTo(th, h2 + th6);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor19() {
        const k = this.k;
        const th = this.mainThickness * k;
        const offset = this.offset * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2);
        this.ctx.lineTo(2 * w2, h2);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);
        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);

        this.ctx.setLineDash([5 * k, 5 * k]);
        this.ctx.beginPath();
        this.ctx.moveTo(th / 3, h2 + th2);
        this.ctx.lineTo(th / 3, h2 + th2 + offset);
        this.ctx.lineTo(2 * w2 - th / 3, h2 + th2 + offset);
        this.ctx.lineTo(2 * w2 - th / 3, h2 + th2);
        this.ctx.stroke();

        //
        this.createNewTexture();
    }

    static drawDoor20() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const th2 = th / 2;
        const th5 = th / 5;
        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;
        const w4 = w2 / 2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(
            0,
            h2 - (this.sceneObject.depth * k) / 2,
            2 * w2,
            this.sceneObject.depth * k
        );

        this.ctx.beginPath();
        this.ctx.moveTo(0, h2 - th2);
        this.ctx.lineTo(2 * w2, h2 - th2);
        this.ctx.moveTo(0, h2 - th5);
        this.ctx.lineTo(2 * w2, h2 - th5);
        this.ctx.moveTo(0, h2 + th5);
        this.ctx.lineTo(2 * w2, h2 + th5);
        this.ctx.moveTo(0, h2 + th2);
        this.ctx.lineTo(2 * w2, h2 + th2);

        this.ctx.moveTo(3 * w4 - th / 2, h2);
        this.ctx.arc(3 * w4 - th / 2, h2, w2 - th, (Math.PI / 180) * (180 - this.angle), Math.PI);
        this.ctx.stroke();

        this.ctx.fillRect(k / 2, h2 - th2, th, th);
        this.ctx.strokeRect(k / 2, h2 - th2, th, th);

        this.ctx.fillRect(w4 - th2, h2 - th2, th, th);
        this.ctx.strokeRect(w4 - th2, h2 - th2, th, th);

        this.ctx.fillRect(3 * w4 - th2, h2 - th2, th, th);
        this.ctx.strokeRect(3 * w4 - th2, h2 - th2, th, th);

        this.ctx.fillRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        this.ctx.strokeRect(2 * w2 - k / 2 - th, h2 - th2, th, th);
        //
        this.createNewTexture();
    }

    static drawDoor21() {
        const k = this.k;
        const th = this.mainThickness * k;

        this.canvas.width = this.canvasWidth * k;
        this.canvas.height = this.canvasHeight * k;

        const w2 = this.canvas.width / 2;
        const h2 = this.canvas.height / 2;

        const objWidth2 = (this.sceneObject.width * k) / 2;
        const objDepth2 = (this.sceneObject.depth * k) / 2;
        const gap = 15 * k;
        const x0 = w2 - objWidth2 + k / 2;
        const th2 = th / 2;
        const th4 = th / 4;
        const objMoveWidth = objWidth2 * 2 - th2 - th2;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = this.colors.fill;
        this.ctx.strokeStyle = this.colors.stroke;
        this.ctx.lineWidth = k;

        this.ctx.fillRect(w2 - objWidth2, h2 - objDepth2, objWidth2 * 2, objDepth2 * 2);

        this.ctx.fillRect(x0, h2 - objDepth2 + k / 2, th2, objDepth2 * 2 - k);
        this.ctx.strokeRect(x0, h2 - objDepth2 + k / 2, th2, objDepth2 * 2 - k);
        this.ctx.fillRect(w2 + objWidth2 - th2, h2 - objDepth2 + k / 2, th2, objDepth2 * 2 - k);
        this.ctx.strokeRect(w2 + objWidth2 - th2, h2 - objDepth2 + k / 2, th2, objDepth2 * 2 - k);

        this.ctx.strokeRect(x0 + th2 + gap, h2 - th4, objMoveWidth, th2);

        this.ctx.beginPath();
        this.ctx.lineWidth = k / 2;
        this.ctx.moveTo(x0 + th2 + gap + gap, h2 - th4);
        this.ctx.lineTo(x0 + th2 + gap + gap, h2 + th4);
        this.ctx.moveTo(x0 + th2 + gap + gap, h2);
        this.ctx.lineTo(x0 + th2 + objMoveWidth, h2);
        this.ctx.stroke();

        this.ctx.strokeRect(x0 + th2 + objMoveWidth, h2 - th4, objMoveWidth, th2);
        //
        this.createNewTexture();
    }

    // ----------------------------

    static calcTotalSizesOneSwing() {
        const th = this.mainThickness;
        const newR = this.sceneObject.width - 2 * th;
        this.offset = newR * Math.sin((this.angle * Math.PI) / 180) - th / 2;

        ObjectViewer3DModelPlane.calcTotalSize.call(this);
    }

    static calcTotalSizesTwoSwings() {
        const th = this.mainThickness;
        const newRWidth = (this.sceneObject.width - 2 * th) / 2;
        const newRDepth = (this.sceneObject.depth - 2 * th) / 2;
        const newR = Math.max(newRWidth, newRDepth);

        this.offset = newR * Math.sin((this.angle * Math.PI) / 180) - th / 2;

        ObjectViewer3DModelPlane.calcTotalSize.call(this);
    }

    static calcTotalSizesDoor_21() {
        this.canvasWidth = this.sceneObject.width * 3;
        this.canvasHeight = this.sceneObject.depth;
        if (this.canvasHeight < this.mainThickness) {
            this.canvasHeight = this.mainThickness + 1;
        }
    }

    static calcTotalSize() {
        this.canvasWidth = this.sceneObject.width;
        this.canvasHeight = this.sceneObject.depth;
        if (this.canvasHeight < this.mainThickness + this.offset * 2) {
            this.canvasHeight = this.mainThickness + this.offset * 2 + 1;
        }
    }

    constructor(sceneObject, imgId) {
        super();

        this.sceneObject = sceneObject;
        this.imgId = imgId;

        if (this.imgId && ObjectViewer3DModelPlane.imgMakersMap[this.imgId]) {
            this.updateTexture = ObjectViewer3DModelPlane.imgMakersMap[this.imgId].bind(this);
        }

        if (ObjectViewer3DModelPlane.totalSizesMap[this.imgId]) {
            this.calcTotalSizes = ObjectViewer3DModelPlane.totalSizesMap[this.imgId].bind(this);
        } else {
            this.calcTotalSizes = ObjectViewer3DModelPlane.calcTotalSize.bind(this);
        }

        this.mainThickness = 9;
        this.angle = ObjectViewer3DModelPlane.angleMap[this.imgId] || 90;
        this.offset = ObjectViewer3DModelPlane.offsetMap[this.imgId] || 0;

        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");

        this.colors = {};
        this.resetColors();

        this.canvasWidth = this.sceneObject.width;
        this.canvasHeight = this.sceneObject.depth;

        this.k = 5; //for better quality

        this.flipX = 1;
        this.flipZ = 1;

        const planeMesh = new THREE.Mesh(
            createGeometry(),
            new THREE.MeshBasicMaterial({
                transparent: true,
            })
        );
        planeMesh.name = "plane";

        const planeForClickMesh = new THREE.Mesh(
            createGeometry(),
            new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
            })
        );
        planeForClickMesh.position.y = 1;
        planeForClickMesh.name = "planeForClick";

        this.object3d = new THREE.Object3D().add(planeMesh, planeForClickMesh);

        this.updateObject();
        this.sceneObject.addEventListener(
            Event.UPDATE,
            this.sceneObjectUpdateEventHandler.bind(this)
        );

        this.updateTexture();

        function createGeometry() {
            const w2 = ObjectViewer3DModelPlane.planeSize / 2;
            const d2 = ObjectViewer3DModelPlane.planeSize / 2;

            const vertices = [w2, 0, d2, -w2, 0, d2, -w2, 0, -d2, w2, 0, -d2];
            const uvs = [1, 1, 0, 1, 0, 0, 1, 0];
            const indices = [0, 2, 1, 0, 3, 2];

            return R2D.Tool.makeBufferGeometry(indices, vertices, uvs, null);
        }
    }

    resetColors() {
        this.colors.fill = "#e6e6e6";
        this.colors.stroke = "black";
    }

    updatePosition() {
        this.object3d.position.set(this.sceneObject.x, 700, this.sceneObject.z);
    }

    updateRotation() {
        const rotationX = (this.sceneObject.rotationX * Math.PI) / 180;
        const rotationY = (this.sceneObject.rotationY * Math.PI) / 180;
        const rotationZ = (this.sceneObject.rotationZ * Math.PI) / 180;
        this.object3d.rotation.x = rotationX;
        this.object3d.rotation.y = rotationY;
        this.object3d.rotation.z = rotationZ;
    }

    updateScale() {
        this.calcTotalSizes();

        this.flipX = this.sceneObject.flipX ? -1 : 1;
        this.flipZ = this.sceneObject.flipZ ? -1 : 1;

        this.object3d
            .getObjectByName("plane")
            .scale.set(
                ((this.canvasWidth - 1) * this.flipX) / ObjectViewer3DModelPlane.planeSize,
                1,
                ((this.canvasHeight - 1) * this.flipZ) / ObjectViewer3DModelPlane.planeSize
            );
        this.object3d
            .getObjectByName("planeForClick")
            .scale.set(
                this.sceneObject.width / ObjectViewer3DModelPlane.planeSize,
                1,
                this.sceneObject.depth / ObjectViewer3DModelPlane.planeSize
            );
    }

    updateObject() {
        if (R2D.Viewers.getCurrentViewerType && R2D.Viewers.getCurrentViewerType() === "3d") return;

        this.updateScale();
        this.updatePosition();
        this.updateRotation();

        if (
            (R2D.mouseInteractionHelper.state.name === "stateDraggingProduct" ||
                R2D.mouseInteractionHelper.state.name === "stateDraggingProdFromCatalog") &&
            !this.imgId
        )
            return;

        this.updateTexture();
    }

    sceneObjectUpdateEventHandler() {
        if (!this.sceneObject) return;

        this.updateObject();
    }

    destroy() {
        this.sceneObject.removeEventListener(Event.UPDATE, this.sceneObjectUpdateEventHandler);
        this.object3d = null;
        this.sceneObject = null;
    }

    createNewTexture() {
        const mesh = this.object3d.getObjectByName("plane");
        const texture = new THREE.Texture(this.canvas);
        if (mesh.material.map) {
            mesh.material.map.dispose();
        }
        mesh.material.map = texture;
        texture.flipY = false;
        texture.needsUpdate = true;
        mesh.material.needsUpdate = true;
    }

    updateTexture() {}

    calcTotalSizes() {}

    makeCanvasLighter() {
        this.colors.fill = "#c5c5c5";
        this.colors.stroke = "#dedede";
        this.updateTexture();
        this.resetColors();
    }
}

R2D.ObjectViewer3DModelPlane = ObjectViewer3DModelPlane;

R2D.ObjectViewer3DGroup = function() {
    EventDispatcher.call(this);

    var me = this;
    me.objectType = 'group';

    var objViews = [];
    var container = new THREE.Object3D();
    var bbox;
    me._x = 0;
    me._y = 0;
    me._z = 0;
    me._rotation = 0;
    me._fx = false;
    me._fz = false;
    me._sx = 1;
    me._sy = 1;
    me._sz = 1;
    me.isLockedOnScene = false;

    me.merged = true;

    me.addUnchanged = function(objView)
    {
        if(!objView) return;
        objViews.push(objView);
        if(objView) objView.group = me;

        R2D.commonSceneObject.productObjects.remove(objView.object3d);
        container.add(objView.object3d);

        objView.object3d.group = container;

        bbox = new THREE.Box3().setFromObject(container);

        objView.sceneObject.update(); // ?

        me.dispatchEvent(new Event(Event.CHANGE));
        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.removeUnchanged = function(objView)
    {
        if(!objView) return;
        var i = objViews.indexOf(objView);
        if (i < 0) return;

        objViews.splice(i, 1);
        if(objView) objView.group = null;

        container.remove(objView.object3d);
        R2D.commonSceneObject.productObjects.add(objView.object3d);

        objView.object3d.group = null;

        bbox = new THREE.Box3().setFromObject(container);

        objView.sceneObject.update();

        me.dispatchEvent(new Event(Event.CHANGE));
        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.add = function(objView)
    {
        for (var i = 0; i < objViews.length; i++)
        {
            //THREE.SceneUtils.detach(objViews[i].object3d, container,  R2D.commonSceneObject.productObjects);
            R2D.commonSceneObject.productObjects.attach(objViews[i].object3d);
        }

        objViews.push(objView);
        if(objView) objView.group = me;
        objView.object3d.group = container;

        var minX = Number.POSITIVE_INFINITY;
        var maxX = Number.NEGATIVE_INFINITY;
        var minZ = Number.POSITIVE_INFINITY;
        var maxZ = Number.NEGATIVE_INFINITY;
        var minY = Number.POSITIVE_INFINITY;
        var maxY = Number.NEGATIVE_INFINITY;

        for (i = 0; i < objViews.length; i++)
        {
            var box = new THREE.Box3().setFromObject(objViews[i].object3d);
            if (box.min.x < minX) minX = box.min.x;
            if (box.max.x > maxX) maxX = box.max.x;
            if (box.min.z < minZ) minZ = box.min.z;
            if (box.max.z > maxZ) maxZ = box.max.z;
            if (box.min.y < minY) {
                minY = box.min.y;
                if(minY < 0) minY = 0;
            }
            if (box.max.y > maxY) maxY = box.max.y;
        }

        me._x = (minX + maxX) / 2;
        me._z = (minZ + maxZ) / 2;
        me._y = minY;
        container.position.set(me._x, me._y, me._z);
        bbox = new THREE.Box3().setFromObject(container); // for recalc

        for (i = 0; i < objViews.length; i++)
        {
            //THREE.SceneUtils.attach(objViews[i].object3d, R2D.commonSceneObject.productObjects, container);
            container.attach(objViews[i].object3d);
        }

        bbox = new THREE.Box3().setFromObject(container); // for recalc

        if (me._fx) objView.sceneObject.flipX = ! objView.sceneObject.flipX;
        if (me._fz) objView.sceneObject.flipZ = ! objView.sceneObject.flipZ;
        var k = 1;
        if (me._fx ^ me._fz) k = -1;

        objView.sceneObject.rotationY = k * objView.sceneObject.rotationY;
        objView.sceneObject.rotationY -= k * Math.floor(GEOM.toDeg(me._rotation));

        objView.sceneObject.setWidth(objView.sceneObject.getWidth() / me._sx);
        objView.sceneObject.setHeight(objView.sceneObject.getHeight() / me._sy);
        objView.sceneObject.setDepth(objView.sceneObject.getDepth() / me._sz);

        for (i = 0; i < objViews.length; i++)
        {
            objViews[i].sceneObject.x = objViews[i].object3d.position.x;
            objViews[i].sceneObject.y = objViews[i].object3d.position.y;
            objViews[i].sceneObject.z = objViews[i].object3d.position.z;

            objViews[i].sceneObject.update();
        }

        me.dispatchEvent(new Event(Event.CHANGE));
        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.remove = function(objView)
    {
        var ind = objViews.indexOf(objView);
        if (ind < 0) return;

        for (var i = 0; i < objViews.length; i++)
        {
            //THREE.SceneUtils.detach(objViews[i].object3d, container,  R2D.commonSceneObject.productObjects);
            R2D.commonSceneObject.productObjects.attach(objViews[i].object3d);
        }

        objViews.splice(ind, 1);
        objView.group = null;
        objView.object3d.group = null;

        objView.sceneObject.x = objView.object3d.position.x;
        objView.sceneObject.y = objView.object3d.position.y;
        objView.sceneObject.z = objView.object3d.position.z;

        if (me._fx) objView.sceneObject.flipX = ! objView.sceneObject.flipX;
        if (me._fz) objView.sceneObject.flipZ = ! objView.sceneObject.flipZ;
        var k = 1;
        if (me._fx ^ me._fz) k = -1;

        objView.sceneObject.rotationY += k * Math.floor(GEOM.toDeg(me._rotation));
        objView.sceneObject.rotationY = k * objView.sceneObject.rotationY;

        objView.sceneObject.setWidth(objView.sceneObject.getWidth() * me._sx);
        objView.sceneObject.setHeight(objView.sceneObject.getHeight() * me._sy);
        objView.sceneObject.setDepth(objView.sceneObject.getDepth() * me._sz);

        objView.sceneObject.update();

        // ---

        var minX = Number.POSITIVE_INFINITY;
        var maxX = Number.NEGATIVE_INFINITY;
        var minZ = Number.POSITIVE_INFINITY;
        var maxZ = Number.NEGATIVE_INFINITY;
        var minY = Number.POSITIVE_INFINITY;
        var maxY = Number.NEGATIVE_INFINITY;

        for (i = 0; i < objViews.length; i++)
        {
            var box = new THREE.Box3().setFromObject(objViews[i].object3d);
            if (box.min.x < minX) minX = box.min.x;
            if (box.max.x > maxX) maxX = box.max.x;
            if (box.min.z < minZ) minZ = box.min.z;
            if (box.max.z > maxZ) maxZ = box.max.z;
            if (box.min.y < minY) minY = box.min.y;
            if (box.max.y > maxY) maxY = box.max.y;
        }

        me._x = (minX + maxX) / 2;
        me._z = (minZ + maxZ) / 2;
        me._y = minY;
        container.position.set(me._x, me._y, me._z);
        bbox = new THREE.Box3().setFromObject(container); // for recalc

        for (i = 0; i < objViews.length; i++)
        {
            //THREE.SceneUtils.attach(objViews[i].object3d, R2D.commonSceneObject.productObjects, container);
            container.attach(objViews[i].object3d)
        }

        bbox = new THREE.Box3().setFromObject(container); // for recalc

        for (i = 0; i < objViews.length; i++)
        {
            objViews[i].sceneObject.x = objViews[i].object3d.position.x;
            objViews[i].sceneObject.y = objViews[i].object3d.position.y;
            objViews[i].sceneObject.z = objViews[i].object3d.position.z;

            objViews[i].sceneObject.update();
        }

        me.dispatchEvent(new Event(Event.CHANGE));
        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.clearUnchanged = function()
    {
        while (objViews.length > 0) me.removeUnchanged(objViews[0]);

        me.dispatchEvent(new Event(Event.CHANGE));
        me.dispatchEvent(new Event(Event.UPDATE));
    };


    me.clear = function()
    {
        while (objViews.length > 0) me.remove(objViews[0]);

        me.dispatchEvent(new Event(Event.CHANGE));
        me.dispatchEvent(new Event(Event.UPDATE));
    };


    me.getObjViews = function()
    {
        return [].concat(objViews);
    };

    me.getContainer = function()
    {
        return container;
    };

    me.get2DRectPoints = function()
    {
        bbox = new THREE.Box3().setFromObject(container);
        return [
            new GEOM.Point(bbox.min.x - container.position.x, bbox.min.z - container.position.z),
            new GEOM.Point(bbox.max.x - container.position.x, bbox.min.z - container.position.z),
            new GEOM.Point(bbox.max.x - container.position.x, bbox.max.z - container.position.z),
            new GEOM.Point(bbox.min.x - container.position.x, bbox.max.z - container.position.z)
        ];
    };

    me.getGeomBox = function()
    {
        if (! bbox) return null;
        return new GEOM.Box(new GEOM.Point(me.x, me.z), bbox.max.x - bbox.min.x, bbox.max.z - bbox.min.z, 0);
    };

    //R2D.ObjectViewer3D.prototype.getGeomBox = function() {
    //    return new GEOM.Box(new GEOM.Point(this.sceneObject.x, this.sceneObject.z), this.sceneObject.width, this.sceneObject.depth, -GEOM.toRad(this.sceneObject.rotationY));
    //};

    //me.getHeight = function()
    //{
    //    return bbox.max.y - bbox.min.y;
    //};

    me.setX = function(x)
    {
        me._x = x;
        container.position.setX(x);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.setY = function(y)
    {
        me._y = y;
        container.position.setY(y);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.setZ = function(z)
    {
        me._z = z;
        container.position.setZ(z);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    Object.defineProperties(me, {
        "x":{
            get() { return me._x; },
            set(val) {
                me._x = val;
                container.position.setX(val);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "y":{
            get() { return me._y; },
            set(val) {
                me._y = val;
                container.position.setY(val);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "z":{
            get() { return me._z; },
            set(val) {
                me._z = val;
                container.position.setZ(val);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "rotation":{
            get() { return me._rotation; },
            set(val) {
                me._rotation = val;
                container.rotation.set(0, val, 0);
                bbox = new THREE.Box3().setFromObject(container);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "rotationY":{
            get() { return me._rotation; },
            set(val) {
                me._rotation = val;
                container.rotation.set(0, val, 0);
                bbox = new THREE.Box3().setFromObject(container);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "fx":{
            get() { return me._fx; },
            set(val) {
                me._fx = val;
                var s = 1;
                if (val) s = -1;
                container.scale.set(s * container.scale.x, container.scale.y, container.scale.z);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "fz":{
            get() { return me._fz; },
            set(val) {
                me._fz = val;
                var s = 1;
                if (val) s = -1;
                container.scale.set(container.scale.x, container.scale.y, s * container.scale.z);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "sx":{
            get() { return me._sx; },
            set(val) {
                me._sx = val;
                var s = 1;
                if (me._fx) s = -1;
                container.scale.set(s * me._sx, container.scale.y, container.scale.z);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "sz":{
            get() { return me._sz; },
            set(val) {
                me._sz = val;
                var s = 1;
                if (me._fz) s = -1;
                container.scale.set(container.scale.x, container.scale.y, s * me._sz);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        },

        "sy":{
            get() { return me._sy; },
            set(val) {
                me._sy = val;
                container.scale.set(container.scale.x, me._sy, container.scale.z);

                me.dispatchEvent(new Event(Event.UPDATE));
            }
        }
    });

    me.setRotation = function(r)
    {
        me.rotation = r;
        container.rotation.set(0, r, 0);

        bbox = new THREE.Box3().setFromObject(container);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.flipX = function()
    {
        me._fx = ! me._fx;
        container.scale.set(-container.scale.x, container.scale.y, container.scale.z);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.flipZ = function()
    {
        me._fz = ! me._fz;
        container.scale.set(container.scale.x, container.scale.y, -container.scale.z);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.update = function() // ?
    {
        for (var i = 0; i < objViews.length; i++)
        {
            objViews[i].sceneObject.update();
        }
    };

    me.copyFrom = function(gr)
    {
        var productHelper = R2D.commonSceneHelper.productHelper;
        var views = gr.getObjViews();

        for (var i = 0; i < views.length; i++)
        {
            var sceneObj = views[i].sceneObject.clone();
            R2D.scene.add(sceneObj);
            var objView = productHelper.findObjectView3dBySceneObject(sceneObj);
            me.addUnchanged(objView);

            //objView.object3d.position.copy(views[i].object3d.position);
            //objView.object3d.rotation.copy(views[i].object3d.rotation);
            //objView.object3d.scale.copy(views[i].object3d.scale);
        }

        bbox = new THREE.Box3().setFromObject(container);

        me.fx = gr.fx;
        me.fz = gr.fz;
        me.rotation = gr.rotation;
        me.setX(gr.x + bbox.max.x - bbox.min.x);
        me.setY(gr.y);
        me.setZ(gr.z);

        me.update();
    };

    me.getType = function()
    {
        return 2;
    };

    me.setHeight = function(val)
    {
        bbox = new THREE.Box3().setFromObject(container);
        var oldHeight = bbox.max.y - bbox.min.y;
        me._sy = me._sy * val / oldHeight;
        container.scale.set(container.scale.x, me._sy, container.scale.z);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.setWidth = function(val)
    {
        bbox = new THREE.Box3().setFromObject(container);
        var oldWidth = bbox.max.x - bbox.min.x;
        me._sx = me._sx * val / oldWidth;
    //    me._sz = me._sz * val / oldWidth;
        container.scale.set(me._sx, container.scale.y, container.scale.z);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.setDepth = function(val)
    {
        bbox = new THREE.Box3().setFromObject(container);
        var oldDepth = bbox.max.z - bbox.min.z;
    //    me._sx = me._sx * val / oldDepth;
        me._sz = me._sz * val / oldDepth;
        container.scale.set(container.scale.x, container.scale.y, me._sx);

        me.dispatchEvent(new Event(Event.UPDATE));
    };

    me.getHeight = function()
    {
        bbox = new THREE.Box3().setFromObject(container);
        return (bbox.max.y - bbox.min.y);
    };

    me.getWidth = function()
    {
        bbox = new THREE.Box3().setFromObject(container);
        return (bbox.max.x - bbox.min.x);
    };

    me.getDepth = function()
    {
        bbox = new THREE.Box3().setFromObject(container);
        return (bbox.max.z - bbox.min.z);
    };
};

R2D.extend(R2D.ObjectViewer3D, EventDispatcher);

R2D.ObjectViewer3DGroup.validSceneObject = function(obj)
{
    if(!obj) return;
    return /*(obj.type == '2' || obj.type == '4') &&*/ !obj.forWall;
};

//viewers

R2D.ObjectViewer3DCarpet.__squareWidth = 250;
R2D.ObjectViewer3DCarpet.__squareHeight = 4;
R2D.ObjectViewer3DCarpet.__squareDepth = 250;
R2D.ObjectViewer3DCarpet.getSquareGeometry = function() {
    if ( !R2D.ObjectViewer3DCarpet.__squareRAW ) {
        var arrayBuffer = R2D.Tool.stringDataToArrayBuffer(R2D.ObjectViewer3DCarpet.__dataSquare);

        R2D.ObjectViewer3DCarpet.__squareRAW = R2D.ProductPackageParser.parseModel(arrayBuffer);
    }

    return R2D.Tool.makeModelGeometries(R2D.ObjectViewer3DCarpet.__squareRAW.geometries);
};

R2D.ObjectViewer3DCarpet.__squareRAW = null;
R2D.ObjectViewer3DCarpet.__dataSquare = "82,79,79,77,84,79,68,79,0,0,0,2,0,0,0,1,0,0,0,10,0,0,0,2,66,69,71,73,78,0,0,0,20,0,0,0,192,194,250,0,0,63,190,71,183,194,206,74,79,194,250,0,0,62,160,94,1,194,221,140,162,194,192,163,186,62,160,94,1,194,206,74,79,194,192,163,186,0,0,0,0,194,221,140,162,194,129,67,219,62,160,94,1,194,206,74,79,194,129,67,219,63,187,92,119,194,221,140,162,191,161,7,40,62,160,94,1,194,206,74,79,191,161,7,40,62,160,94,1,194,221,140,162,66,138,112,152,63,185,176,141,194,194,127,248,66,138,112,152,62,160,94,1,194,154,135,110,66,7,236,124,63,185,176,141,194,194,127,248,66,7,236,124,62,160,94,1,194,154,135,110,66,208,234,243,62,160,94,1,194,101,29,226,66,208,234,243,62,160,94,1,194,174,131,179,66,229,82,111,63,190,39,200,194,101,29,226,66,229,82,111,62,160,94,1,194,174,131,179,194,250,0,0,64,6,47,29,193,138,119,117,194,250,0,0,63,232,132,122,194,21,44,206,194,192,163,186,62,160,94,1,193,138,119,117,194,192,163,186,62,160,94,1,194,21,44,206,194,129,67,219,62,160,94,1,64,43,85,146,194,129,67,219,62,160,94,1,194,101,29,226,191,161,7,40,62,160,94,1,64,43,85,146,191,161,7,40,62,160,94,1,194,101,29,226,66,7,236,124,62,160,94,1,194,101,29,226,66,138,112,152,62,160,94,1,194,101,29,226,66,208,234,243,62,160,94,1,193,218,104,137,66,208,234,243,62,160,94,1,64,43,85,146,66,229,82,111,63,129,158,87,64,43,85,146,66,229,82,111,62,160,94,1,193,218,104,137,194,250,0,0,62,160,94,1,66,219,66,249,194,250,0,0,64,37,139,65,66,190,249,182,194,192,163,186,62,160,94,1,66,219,66,249,194,192,163,186,62,160,94,1,66,190,249,182,194,46,7,226,62,223,239,111,66,190,249,182,193,179,16,27,63,15,192,111,66,190,249,182,194,46,7,226,63,185,119,18,66,219,66,249,193,179,16,27,63,217,63,201,66,219,66,249,65,201,94,144,63,23,181,206,66,190,249,182,66,78,102,227,62,255,184,38,66,190,249,182,65,201,94,144,63,95,54,56,66,219,66,249,66,78,102,227,63,47,137,38,66,219,66,249,66,208,234,243,63,162,61,3,66,219,66,249,66,208,234,243,62,160,94,1,66,190,249,182,66,229,82,111,63,159,30,171,66,219,66,249,66,229,82,111,62,160,94,1,66,190,249,182,194,250,0,0,62,160,94,1,66,250,0,0,194,192,163,186,63,167,77,133,66,250,0,0,194,46,7,226,64,4,22,161,66,250,0,0,193,179,16,27,64,19,250,252,66,250,0,0,65,201,94,144,63,95,54,56,66,250,0,0,66,78,102,227,63,205,165,243,66,250,0,0,66,208,234,243,62,160,94,1,66,250,0,0,66,229,82,111,62,160,94,1,66,250,0,0,194,192,163,186,62,160,94,1,64,43,85,146,194,192,163,186,62,160,94,1,194,101,29,226,194,129,67,219,62,160,94,1,66,190,249,182,194,192,163,186,62,160,94,1,66,129,26,13,194,192,163,186,62,160,94,1,66,6,116,199,194,129,67,219,62,160,94,1,66,219,66,249,194,129,67,219,62,160,94,1,66,250,0,0,66,229,82,111,63,215,16,242,194,249,255,217,66,249,254,210,62,160,94,1,194,249,255,217,66,249,254,210,62,160,94,1,194,174,131,179,66,249,254,210,64,23,204,40,194,101,29,226,66,249,254,210,62,160,94,1,193,218,104,137,66,249,254,210,63,216,13,57,64,43,85,146,66,229,82,111,62,160,94,1,66,68,84,112,66,249,254,210,62,160,94,1,66,68,84,112,66,249,254,210,63,179,182,237,66,219,66,249,66,249,254,210,63,86,180,87,66,250,0,0,194,250,0,0,64,64,206,95,66,129,26,13,194,250,0,0,62,160,94,1,66,6,116,199,191,161,7,40,63,47,137,38,66,190,249,182,66,208,234,243,62,160,94,1,66,68,84,112,66,156,15,63,62,208,17,119,66,190,249,182,66,249,254,210,62,160,94,1,66,190,249,182,66,208,234,243,63,215,16,242,194,249,255,217,66,208,234,243,62,160,94,1,194,214,124,60,66,208,234,243,62,160,94,1,194,194,127,248,66,156,15,63,62,255,184,38,66,219,66,249,191,161,7,40,63,135,113,165,66,219,66,249,66,156,15,63,62,255,184,38,66,250,0,0,191,161,7,40,63,135,113,165,66,250,0,0,194,250,0,0,62,160,94,1,194,249,255,217,194,192,163,186,0,0,0,0,194,249,255,217,194,192,163,186,62,160,94,1,194,175,182,133,194,192,163,186,62,160,94,1,194,145,34,187,194,250,0,0,63,198,211,45,194,175,182,133,194,250,0,0,62,160,94,1,194,145,34,187,194,129,67,219,63,187,92,119,194,249,255,217,191,161,7,40,62,160,94,1,194,249,255,217,66,7,236,124,63,178,110,2,194,249,255,217,66,138,112,152,63,178,110,2,194,249,255,217,194,250,0,0,63,164,200,118,64,43,85,146,194,250,0,0,62,160,94,1,194,101,29,226,194,249,254,210,64,30,85,124,194,206,74,119,194,192,162,153,63,166,122,194,194,206,74,119,194,249,254,210,63,166,122,194,194,221,140,201,194,192,162,153,63,124,198,131,194,221,140,201,194,129,66,186,63,166,122,194,194,206,74,119,191,160,187,191,63,166,122,194,194,206,74,119,194,129,66,186,64,28,223,220,194,221,140,201,191,160,187,191,63,166,122,194,194,221,140,201,66,138,113,198,64,28,9,232,194,194,128,31,66,7,238,215,64,28,9,232,194,194,128,31,66,138,113,198,63,166,122,194,194,154,135,149,66,7,238,215,63,166,122,194,194,154,135,149,66,208,236,32,63,166,122,194,194,101,30,48,66,229,83,144,64,30,69,133,194,101,30,48,66,208,236,32,63,166,122,194,194,174,131,218,66,229,83,144,63,166,122,194,194,174,131,218,194,249,254,210,64,69,96,190,193,138,120,18,194,192,162,153,63,166,122,194,193,138,120,18,194,249,254,210,64,51,115,222,194,21,45,29,194,192,162,153,63,166,122,194,194,21,45,29,194,129,66,186,63,166,122,194,64,43,80,169,191,160,187,191,63,166,122,194,64,43,80,169,194,129,66,186,63,166,122,194,194,101,30,48,191,160,187,191,63,166,122,194,194,101,30,48,66,138,113,198,63,166,122,194,194,101,30,48,66,208,236,32,63,166,122,194,193,218,105,38,66,7,238,215,63,166,122,194,194,101,30,48,66,208,236,32,63,166,122,194,64,43,80,169,66,229,83,144,64,0,0,204,64,43,80,169,66,229,83,144,63,166,122,194,193,218,105,38,194,249,254,210,63,166,122,194,66,219,66,210,194,192,162,153,63,166,122,194,66,219,66,210,194,249,254,210,64,100,188,226,66,190,249,143,194,192,162,153,63,166,122,194,66,190,249,143,194,46,5,134,63,182,95,29,66,190,249,143,194,46,5,134,64,27,237,42,66,219,66,210,193,179,11,100,63,198,67,121,66,190,249,143,193,179,11,100,64,43,209,133,66,219,66,210,65,201,99,18,63,202,62,41,66,190,249,143,65,201,99,18,63,237,254,94,66,219,66,210,66,78,105,36,63,190,81,75,66,190,249,143,66,78,105,36,63,214,39,212,66,219,66,210,66,208,236,32,64,16,80,34,66,219,66,210,66,229,83,144,64,14,192,246,66,219,66,210,66,208,236,32,63,166,122,194,66,190,249,143,66,229,83,144,63,166,122,194,66,190,249,143,194,249,254,210,63,166,122,194,66,249,255,217,194,192,162,153,64,18,216,99,66,249,255,217,194,46,5,134,64,67,72,66,66,249,255,217,193,179,11,100,64,83,44,157,66,249,255,217,65,201,99,18,63,237,254,94,66,249,255,217,66,78,105,36,64,38,4,154,66,249,255,217,66,208,236,32,63,166,122,194,66,249,255,217,66,229,83,144,63,166,122,194,66,249,255,217,194,192,162,153,63,166,122,194,64,43,80,169,194,192,162,153,63,166,122,194,194,101,30,48,194,129,66,186,63,166,122,194,66,190,249,143,194,192,162,153,63,166,122,194,66,129,25,230,194,192,162,153,63,166,122,194,66,6,116,120,194,129,66,186,63,166,122,194,66,219,66,210,194,129,66,186,63,166,122,194,66,249,255,217,66,229,83,144,64,42,186,26,194,250,0,0,66,250,0,0,63,166,122,194,194,250,0,0,66,250,0,0,63,166,122,194,194,174,131,218,66,250,0,0,64,86,253,201,194,101,30,48,66,250,0,0,63,166,122,194,193,218,105,38,66,229,83,144,63,166,122,194,66,68,84,34,66,250,0,0,64,43,56,61,64,43,80,169,66,250,0,0,63,166,122,194,66,68,84,34,66,250,0,0,64,25,13,23,66,219,66,210,66,250,0,0,63,233,189,109,66,249,255,217,194,249,254,210,64,128,0,0,66,129,25,230,194,249,254,210,63,166,122,194,66,6,116,120,191,160,187,191,63,214,39,212,66,190,249,143,66,208,236,32,63,166,122,194,66,68,84,34,66,156,16,96,63,178,103,159,66,190,249,143,66,250,0,0,63,166,122,194,66,190,249,143,66,208,236,32,63,166,122,194,194,214,124,100,66,208,236,32,64,42,186,26,194,250,0,0,66,208,236,32,63,166,122,194,194,194,128,31,66,156,16,96,63,190,81,75,66,219,66,210,191,160,187,191,64,2,234,115,66,219,66,210,66,156,16,96,63,190,81,75,66,249,255,217,191,160,187,191,64,2,234,115,66,249,255,217,194,249,254,210,63,166,122,194,194,250,0,0,194,192,162,153,63,124,198,131,194,250,0,0,194,192,162,153,63,166,122,194,194,175,182,173,194,249,254,210,64,34,155,55,194,175,182,173,194,192,162,153,63,166,122,194,194,145,34,226,194,249,254,210,63,166,122,194,194,145,34,226,194,129,66,186,64,28,223,220,194,250,0,0,191,160,187,191,63,166,122,194,194,250,0,0,66,7,238,215,64,24,104,162,194,250,0,0,66,138,113,198,64,24,104,162,194,250,0,0,194,249,254,210,64,17,149,220,64,43,80,169,194,249,254,210,63,166,122,194,194,101,30,48,0,0,0,21,0,0,0,192,63,125,79,223,63,105,186,94,63,125,79,223,63,113,117,142,63,96,65,137,63,105,186,94,63,96,65,137,63,113,117,142,63,64,45,224,63,105,186,94,63,64,45,224,63,113,117,142,63,0,0,0,63,105,186,94,63,0,0,0,63,113,117,142,62,98,130,65,63,99,195,97,62,98,130,65,63,79,138,9,62,184,160,144,63,99,195,97,62,184,160,144,63,79,138,9,61,167,134,194,63,59,74,35,61,167,134,194,63,89,166,181,61,41,147,12,63,59,74,35,61,41,147,12,63,89,166,181,63,125,79,223,63,18,208,229,63,125,79,223,63,39,10,61,63,96,65,137,63,18,208,229,63,96,65,137,63,39,10,61,63,64,45,224,62,253,33,255,63,64,45,224,63,59,74,35,63,0,0,0,62,253,33,255,63,0,0,0,63,59,74,35,62,184,160,144,63,59,74,35,62,98,130,65,63,59,74,35,61,167,134,194,63,28,237,145,61,167,134,194,62,253,33,255,61,41,147,12,62,253,33,255,61,41,147,12,63,28,237,145,63,125,79,223,61,146,5,188,63,125,79,223,62,2,64,184,63,96,65,137,61,146,5,188,63,96,65,137,62,2,64,184,63,42,199,17,62,2,64,184,63,21,96,66,62,2,64,184,63,42,199,17,61,146,5,188,63,21,96,66,61,146,5,188,62,202,113,222,62,2,64,184,62,148,240,216,62,2,64,184,62,202,113,222,61,146,5,188,62,148,240,216,61,146,5,188,61,167,134,194,61,146,5,188,61,167,134,194,62,2,64,184,61,41,147,12,61,146,5,188,61,41,147,12,62,2,64,184,63,125,79,223,60,44,8,49,63,96,65,137,60,44,8,49,63,42,199,17,60,44,8,49,63,21,96,66,60,44,8,49,62,202,113,222,60,44,8,49,62,148,240,216,60,44,8,49,61,167,134,194,60,44,8,49,61,41,147,12,60,44,8,49,63,96,65,137,62,253,33,255,63,96,65,137,63,59,74,35,63,64,45,224,62,2,64,184,63,96,65,137,62,127,151,36,63,96,65,137,62,190,118,201,63,64,45,224,61,146,5,188,63,64,45,224,60,44,8,49,61,41,147,12,63,127,223,59,58,3,18,111,63,127,223,59,58,3,18,111,63,89,166,181,58,3,18,111,63,59,74,35,58,3,18,111,63,28,237,145,58,3,18,111,62,253,33,255,61,41,147,12,62,159,33,45,58,3,18,111,62,159,33,45,58,3,18,111,61,146,5,188,58,3,18,111,60,44,8,49,63,125,79,223,62,127,151,36,63,125,79,223,62,190,118,201,63,0,0,0,62,2,64,184,61,167,134,194,62,159,33,45,62,62,197,109,62,2,64,184,58,3,18,111,62,2,64,184,61,167,134,194,63,127,223,59,61,167,134,194,63,109,230,155,61,167,134,194,63,99,195,97,62,62,197,109,61,146,5,188,63,0,0,0,61,146,5,188,62,62,197,109,60,44,8,49,63,0,0,0,60,44,8,49,63,125,79,223,63,127,223,59,63,96,65,137,63,127,223,59,63,96,65,137,63,90,67,254,63,96,65,137,63,74,199,17,63,125,79,223,63,90,67,254,63,125,79,223,63,74,199,17,63,64,45,224,63,127,223,59,63,0,0,0,63,127,223,59,62,184,160,144,63,127,223,59,62,98,130,65,63,127,223,59,63,125,79,223,62,253,33,255,63,125,79,223,63,59,74,35,58,3,18,111,63,105,186,94,61,233,120,213,63,105,186,94,58,3,18,111,63,113,117,142,61,233,120,213,63,113,117,142,62,117,11,15,63,105,186,94,62,250,225,72,63,105,186,94,62,117,11,15,63,113,117,142,62,250,225,72,63,113,117,142,63,68,208,20,63,99,195,97,63,33,32,92,63,99,195,97,63,68,208,20,63,79,138,9,63,33,32,92,63,79,138,9,63,104,134,89,63,59,74,35,63,114,215,115,63,59,74,35,63,104,134,89,63,89,166,181,63,114,215,115,63,89,166,181,58,3,18,111,63,18,208,229,61,233,120,213,63,18,208,229,58,3,18,111,63,39,10,61,61,233,120,213,63,39,10,61,62,117,11,15,62,253,33,255,62,250,225,72,62,253,33,255,62,117,11,15,63,59,74,35,62,250,225,72,63,59,74,35,63,68,208,20,63,59,74,35,63,104,134,89,63,28,237,145,63,33,32,92,63,59,74,35,63,104,134,89,62,253,33,255,63,114,215,115,62,253,33,255,63,114,215,115,63,28,237,145,58,3,18,111,61,146,5,188,61,233,120,213,61,146,5,188,58,3,18,111,62,2,64,184,61,233,120,213,62,2,64,184,62,165,83,38,62,2,64,184,62,165,83,38,61,146,5,188,62,208,32,197,62,2,64,184,62,208,32,197,61,146,5,188,63,24,55,181,62,2,64,184,63,24,55,181,61,146,5,188,63,50,248,56,62,2,64,184,63,50,248,56,61,146,5,188,63,104,134,89,61,146,5,188,63,114,215,115,61,146,5,188,63,104,134,89,62,2,64,184,63,114,215,115,62,2,64,184,58,3,18,111,60,44,8,49,61,233,120,213,60,44,8,49,62,165,83,38,60,44,8,49,62,208,32,197,60,44,8,49,63,24,55,181,60,44,8,49,63,50,248,56,60,44,8,49,63,104,134,89,60,44,8,49,63,114,215,115,60,44,8,49,61,233,120,213,62,253,33,255,61,233,120,213,63,59,74,35,62,117,11,15,62,2,64,184,61,233,120,213,62,127,151,36,61,233,120,213,62,190,118,201,62,117,11,15,61,146,5,188,62,117,11,15,60,44,8,49,63,114,215,115,63,127,223,59,63,125,79,223,63,127,223,59,63,125,79,223,63,89,166,181,63,125,79,223,63,59,74,35,63,125,79,223,63,28,237,145,63,114,215,115,62,159,33,45,63,125,79,223,62,253,33,255,63,125,79,223,62,159,33,45,63,125,79,223,61,146,5,188,63,125,79,223,60,44,8,49,58,3,18,111,62,127,151,36,58,3,18,111,62,190,118,201,62,250,225,72,62,2,64,184,63,104,134,89,62,159,33,45,63,77,191,72,62,2,64,184,63,125,79,223,62,2,64,184,63,104,134,89,63,109,230,155,63,104,134,89,63,127,223,59,63,104,134,89,63,99,195,97,63,77,191,72,61,146,5,188,62,250,225,72,61,146,5,188,63,77,191,72,60,44,8,49,62,250,225,72,60,44,8,49,58,3,18,111,63,127,223,59,61,233,120,213,63,127,223,59,61,233,120,213,63,90,67,254,58,3,18,111,63,90,67,254,61,233,120,213,63,74,199,17,58,3,18,111,63,74,199,17,62,117,11,15,63,127,223,59,62,250,225,72,63,127,223,59,63,33,32,92,63,127,223,59,63,68,208,20,63,127,223,59,58,3,18,111,62,253,33,255,58,3,18,111,63,59,74,35,0,0,0,23,0,0,3,132,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,1,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,6,0,0,0,5,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,10,0,0,0,9,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,14,0,0,0,13,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,18,0,0,0,17,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,22,0,0,0,22,0,0,0,21,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,26,0,0,0,25,0,0,0,12,0,0,0,23,0,0,0,24,0,0,0,27,0,0,0,27,0,0,0,24,0,0,0,26,0,0,0,27,0,0,0,22,0,0,0,23,0,0,0,27,0,0,0,26,0,0,0,28,0,0,0,28,0,0,0,26,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,32,0,0,0,32,0,0,0,31,0,0,0,33,0,0,0,34,0,0,0,35,0,0,0,36,0,0,0,36,0,0,0,35,0,0,0,37,0,0,0,38,0,0,0,39,0,0,0,40,0,0,0,40,0,0,0,39,0,0,0,41,0,0,0,42,0,0,0,43,0,0,0,44,0,0,0,44,0,0,0,43,0,0,0,45,0,0,0,46,0,0,0,30,0,0,0,47,0,0,0,47,0,0,0,30,0,0,0,32,0,0,0,36,0,0,0,37,0,0,0,48,0,0,0,48,0,0,0,37,0,0,0,49,0,0,0,40,0,0,0,41,0,0,0,50,0,0,0,50,0,0,0,41,0,0,0,51,0,0,0,52,0,0,0,42,0,0,0,53,0,0,0,53,0,0,0,42,0,0,0,44,0,0,0,5,0,0,0,4,0,0,0,3,0,0,0,3,0,0,0,4,0,0,0,2,0,0,0,21,0,0,0,20,0,0,0,18,0,0,0,18,0,0,0,20,0,0,0,54,0,0,0,55,0,0,0,21,0,0,0,19,0,0,0,19,0,0,0,21,0,0,0,18,0,0,0,20,0,0,0,56,0,0,0,57,0,0,0,57,0,0,0,56,0,0,0,33,0,0,0,54,0,0,0,20,0,0,0,58,0,0,0,58,0,0,0,20,0,0,0,57,0,0,0,32,0,0,0,59,0,0,0,47,0,0,0,47,0,0,0,59,0,0,0,60,0,0,0,61,0,0,0,62,0,0,0,15,0,0,0,15,0,0,0,62,0,0,0,63,0,0,0,14,0,0,0,64,0,0,0,29,0,0,0,29,0,0,0,64,0,0,0,65,0,0,0,28,0,0,0,66,0,0,0,67,0,0,0,67,0,0,0,66,0,0,0,68,0,0,0,44,0,0,0,69,0,0,0,53,0,0,0,53,0,0,0,69,0,0,0,70,0,0,0,71,0,0,0,72,0,0,0,57,0,0,0,57,0,0,0,72,0,0,0,58,0,0,0,20,0,0,0,22,0,0,0,35,0,0,0,35,0,0,0,22,0,0,0,73,0,0,0,56,0,0,0,20,0,0,0,34,0,0,0,34,0,0,0,20,0,0,0,35,0,0,0,43,0,0,0,22,0,0,0,74,0,0,0,74,0,0,0,22,0,0,0,27,0,0,0,39,0,0,0,22,0,0,0,75,0,0,0,75,0,0,0,22,0,0,0,43,0,0,0,73,0,0,0,22,0,0,0,38,0,0,0,38,0,0,0,22,0,0,0,39,0,0,0,43,0,0,0,74,0,0,0,45,0,0,0,45,0,0,0,74,0,0,0,67,0,0,0,56,0,0,0,59,0,0,0,33,0,0,0,33,0,0,0,59,0,0,0,32,0,0,0,76,0,0,0,69,0,0,0,45,0,0,0,45,0,0,0,69,0,0,0,44,0,0,0,68,0,0,0,76,0,0,0,67,0,0,0,67,0,0,0,76,0,0,0,45,0,0,0,74,0,0,0,27,0,0,0,67,0,0,0,67,0,0,0,27,0,0,0,28,0,0,0,77,0,0,0,61,0,0,0,78,0,0,0,78,0,0,0,61,0,0,0,15,0,0,0,13,0,0,0,79,0,0,0,15,0,0,0,15,0,0,0,79,0,0,0,78,0,0,0,63,0,0,0,64,0,0,0,15,0,0,0,15,0,0,0,64,0,0,0,14,0,0,0,26,0,0,0,12,0,0,0,29,0,0,0,29,0,0,0,12,0,0,0,14,0,0,0,65,0,0,0,66,0,0,0,29,0,0,0,29,0,0,0,66,0,0,0,28,0,0,0,75,0,0,0,43,0,0,0,80,0,0,0,80,0,0,0,43,0,0,0,42,0,0,0,39,0,0,0,75,0,0,0,41,0,0,0,41,0,0,0,75,0,0,0,80,0,0,0,40,0,0,0,81,0,0,0,38,0,0,0,38,0,0,0,81,0,0,0,73,0,0,0,80,0,0,0,42,0,0,0,82,0,0,0,82,0,0,0,42,0,0,0,52,0,0,0,41,0,0,0,80,0,0,0,51,0,0,0,51,0,0,0,80,0,0,0,82,0,0,0,50,0,0,0,83,0,0,0,40,0,0,0,40,0,0,0,83,0,0,0,81,0,0,0,1,0,0,0,84,0,0,0,3,0,0,0,3,0,0,0,84,0,0,0,85,0,0,0,86,0,0,0,87,0,0,0,88,0,0,0,88,0,0,0,87,0,0,0,89,0,0,0,5,0,0,0,90,0,0,0,7,0,0,0,7,0,0,0,90,0,0,0,91,0,0,0,6,0,0,0,23,0,0,0,4,0,0,0,4,0,0,0,23,0,0,0,21,0,0,0,86,0,0,0,21,0,0,0,87,0,0,0,87,0,0,0,21,0,0,0,55,0,0,0,21,0,0,0,86,0,0,0,4,0,0,0,4,0,0,0,86,0,0,0,2,0,0,0,3,0,0,0,85,0,0,0,5,0,0,0,5,0,0,0,85,0,0,0,90,0,0,0,78,0,0,0,79,0,0,0,8,0,0,0,8,0,0,0,79,0,0,0,9,0,0,0,7,0,0,0,24,0,0,0,6,0,0,0,6,0,0,0,24,0,0,0,23,0,0,0,24,0,0,0,7,0,0,0,11,0,0,0,11,0,0,0,7,0,0,0,91,0,0,0,11,0,0,0,91,0,0,0,10,0,0,0,10,0,0,0,91,0,0,0,92,0,0,0,9,0,0,0,25,0,0,0,11,0,0,0,11,0,0,0,25,0,0,0,24,0,0,0,10,0,0,0,92,0,0,0,8,0,0,0,8,0,0,0,92,0,0,0,93,0,0,0,79,0,0,0,13,0,0,0,25,0,0,0,25,0,0,0,13,0,0,0,12,0,0,0,9,0,0,0,79,0,0,0,25,0,0,0,8,0,0,0,93,0,0,0,78,0,0,0,78,0,0,0,93,0,0,0,77,0,0,0,35,0,0,0,73,0,0,0,37,0,0,0,37,0,0,0,73,0,0,0,81,0,0,0,36,0,0,0,59,0,0,0,34,0,0,0,34,0,0,0,59,0,0,0,56,0,0,0,37,0,0,0,81,0,0,0,49,0,0,0,49,0,0,0,81,0,0,0,83,0,0,0,48,0,0,0,60,0,0,0,36,0,0,0,36,0,0,0,60,0,0,0,59,0,0,0,72,0,0,0,94,0,0,0,58,0,0,0,58,0,0,0,94,0,0,0,54,0,0,0,57,0,0,0,33,0,0,0,71,0,0,0,71,0,0,0,33,0,0,0,31,0,0,0,17,0,0,0,95,0,0,0,19,0,0,0,19,0,0,0,95,0,0,0,55,0,0,0,18,0,0,0,54,0,0,0,16,0,0,0,16,0,0,0,54,0,0,0,94,0,0,0,87,0,0,0,55,0,0,0,89,0,0,0,89,0,0,0,55,0,0,0,95,0,0,0,88,0,0,0,0,0,0,0,86,0,0,0,86,0,0,0,0,0,0,0,2,0,0,0,96,0,0,0,97,0,0,0,98,0,0,0,98,0,0,0,97,0,0,0,99,0,0,0,100,0,0,0,101,0,0,0,102,0,0,0,102,0,0,0,101,0,0,0,103,0,0,0,104,0,0,0,105,0,0,0,106,0,0,0,106,0,0,0,105,0,0,0,107,0,0,0,108,0,0,0,109,0,0,0,110,0,0,0,110,0,0,0,109,0,0,0,111,0,0,0,112,0,0,0,113,0,0,0,114,0,0,0,114,0,0,0,113,0,0,0,115,0,0,0,116,0,0,0,117,0,0,0,118,0,0,0,118,0,0,0,117,0,0,0,119,0,0,0,108,0,0,0,120,0,0,0,121,0,0,0,121,0,0,0,120,0,0,0,122,0,0,0,121,0,0,0,122,0,0,0,123,0,0,0,123,0,0,0,122,0,0,0,119,0,0,0,119,0,0,0,117,0,0,0,123,0,0,0,123,0,0,0,124,0,0,0,121,0,0,0,121,0,0,0,124,0,0,0,125,0,0,0,126,0,0,0,127,0,0,0,128,0,0,0,128,0,0,0,127,0,0,0,129,0,0,0,130,0,0,0,131,0,0,0,132,0,0,0,132,0,0,0,131,0,0,0,133,0,0,0,134,0,0,0,135,0,0,0,136,0,0,0,136,0,0,0,135,0,0,0,137,0,0,0,138,0,0,0,139,0,0,0,140,0,0,0,140,0,0,0,139,0,0,0,141,0,0,0,142,0,0,0,143,0,0,0,126,0,0,0,126,0,0,0,143,0,0,0,127,0,0,0,131,0,0,0,144,0,0,0,133,0,0,0,133,0,0,0,144,0,0,0,145,0,0,0,135,0,0,0,146,0,0,0,137,0,0,0,137,0,0,0,146,0,0,0,147,0,0,0,148,0,0,0,149,0,0,0,138,0,0,0,138,0,0,0,149,0,0,0,139,0,0,0,102,0,0,0,99,0,0,0,100,0,0,0,100,0,0,0,99,0,0,0,97,0,0,0,150,0,0,0,116,0,0,0,113,0,0,0,113,0,0,0,116,0,0,0,118,0,0,0,113,0,0,0,118,0,0,0,115,0,0,0,115,0,0,0,118,0,0,0,151,0,0,0,129,0,0,0,152,0,0,0,153,0,0,0,153,0,0,0,152,0,0,0,116,0,0,0,153,0,0,0,116,0,0,0,154,0,0,0,154,0,0,0,116,0,0,0,150,0,0,0,127,0,0,0,143,0,0,0,155,0,0,0,155,0,0,0,143,0,0,0,156,0,0,0,157,0,0,0,111,0,0,0,158,0,0,0,158,0,0,0,111,0,0,0,159,0,0,0,109,0,0,0,125,0,0,0,160,0,0,0,160,0,0,0,125,0,0,0,161,0,0,0,124,0,0,0,162,0,0,0,163,0,0,0,163,0,0,0,162,0,0,0,164,0,0,0,139,0,0,0,149,0,0,0,165,0,0,0,165,0,0,0,149,0,0,0,166,0,0,0,167,0,0,0,153,0,0,0,168,0,0,0,168,0,0,0,153,0,0,0,154,0,0,0,169,0,0,0,117,0,0,0,132,0,0,0,132,0,0,0,117,0,0,0,116,0,0,0,132,0,0,0,116,0,0,0,130,0,0,0,130,0,0,0,116,0,0,0,152,0,0,0,123,0,0,0,117,0,0,0,170,0,0,0,170,0,0,0,117,0,0,0,140,0,0,0,140,0,0,0,117,0,0,0,171,0,0,0,171,0,0,0,117,0,0,0,136,0,0,0,136,0,0,0,117,0,0,0,134,0,0,0,134,0,0,0,117,0,0,0,169,0,0,0,140,0,0,0,141,0,0,0,170,0,0,0,170,0,0,0,141,0,0,0,162,0,0,0,152,0,0,0,129,0,0,0,155,0,0,0,155,0,0,0,129,0,0,0,127,0,0,0,172,0,0,0,141,0,0,0,165,0,0,0,165,0,0,0,141,0,0,0,139,0,0,0,164,0,0,0,162,0,0,0,172,0,0,0,172,0,0,0,162,0,0,0,141,0,0,0,170,0,0,0,162,0,0,0,123,0,0,0,123,0,0,0,162,0,0,0,124,0,0,0,111,0,0,0,157,0,0,0,173,0,0,0,173,0,0,0,157,0,0,0,174,0,0,0,173,0,0,0,175,0,0,0,111,0,0,0,111,0,0,0,175,0,0,0,110,0,0,0,159,0,0,0,111,0,0,0,160,0,0,0,160,0,0,0,111,0,0,0,109,0,0,0,121,0,0,0,125,0,0,0,108,0,0,0,108,0,0,0,125,0,0,0,109,0,0,0,161,0,0,0,125,0,0,0,163,0,0,0,163,0,0,0,125,0,0,0,124,0,0,0,171,0,0,0,176,0,0,0,140,0,0,0,140,0,0,0,176,0,0,0,138,0,0,0,136,0,0,0,137,0,0,0,171,0,0,0,171,0,0,0,137,0,0,0,176,0,0,0,135,0,0,0,134,0,0,0,177,0,0,0,177,0,0,0,134,0,0,0,169,0,0,0,176,0,0,0,178,0,0,0,138,0,0,0,138,0,0,0,178,0,0,0,148,0,0,0,137,0,0,0,147,0,0,0,176,0,0,0,176,0,0,0,147,0,0,0,178,0,0,0,146,0,0,0,135,0,0,0,179,0,0,0,179,0,0,0,135,0,0,0,177,0,0,0,98,0,0,0,99,0,0,0,180,0,0,0,180,0,0,0,99,0,0,0,181,0,0,0,182,0,0,0,183,0,0,0,184,0,0,0,184,0,0,0,183,0,0,0,185,0,0,0,102,0,0,0,103,0,0,0,186,0,0,0,186,0,0,0,103,0,0,0,187,0,0,0,101,0,0,0,100,0,0,0,119,0,0,0,119,0,0,0,100,0,0,0,118,0,0,0,151,0,0,0,118,0,0,0,184,0,0,0,184,0,0,0,118,0,0,0,182,0,0,0,97,0,0,0,182,0,0,0,100,0,0,0,100,0,0,0,182,0,0,0,118,0,0,0,99,0,0,0,102,0,0,0,181,0,0,0,181,0,0,0,102,0,0,0,186,0,0,0,106,0,0,0,175,0,0,0,104,0,0,0,104,0,0,0,175,0,0,0,173,0,0,0,119,0,0,0,122,0,0,0,101,0,0,0,101,0,0,0,122,0,0,0,103,0,0,0,187,0,0,0,103,0,0,0,107,0,0,0,107,0,0,0,103,0,0,0,122,0,0,0,188,0,0,0,187,0,0,0,105,0,0,0,105,0,0,0,187,0,0,0,107,0,0,0,106,0,0,0,107,0,0,0,120,0,0,0,120,0,0,0,107,0,0,0,122,0,0,0,105,0,0,0,104,0,0,0,188,0,0,0,188,0,0,0,104,0,0,0,189,0,0,0,108,0,0,0,110,0,0,0,120,0,0,0,120,0,0,0,110,0,0,0,175,0,0,0,120,0,0,0,175,0,0,0,106,0,0,0,174,0,0,0,189,0,0,0,173,0,0,0,173,0,0,0,189,0,0,0,104,0,0,0,132,0,0,0,133,0,0,0,169,0,0,0,169,0,0,0,133,0,0,0,177,0,0,0,131,0,0,0,130,0,0,0,155,0,0,0,155,0,0,0,130,0,0,0,152,0,0,0,133,0,0,0,145,0,0,0,177,0,0,0,177,0,0,0,145,0,0,0,179,0,0,0,144,0,0,0,131,0,0,0,156,0,0,0,156,0,0,0,131,0,0,0,155,0,0,0,168,0,0,0,154,0,0,0,190,0,0,0,190,0,0,0,154,0,0,0,150,0,0,0,153,0,0,0,167,0,0,0,129,0,0,0,129,0,0,0,167,0,0,0,128,0,0,0,114,0,0,0,115,0,0,0,191,0,0,0,191,0,0,0,115,0,0,0,151,0,0,0,113,0,0,0,112,0,0,0,150,0,0,0,150,0,0,0,112,0,0,0,190,0,0,0,184,0,0,0,185,0,0,0,151,0,0,0,151,0,0,0,185,0,0,0,191,0,0,0,183,0,0,0,182,0,0,0,96,0,0,0,96,0,0,0,182,0,0,0,97,69,78,68,66,69,71,73,78,0,0,0,20,0,0,0,88,194,249,254,210,64,30,85,124,194,206,74,119,194,249,254,210,63,166,122,194,194,221,140,201,194,250,0,0,63,191,237,61,194,206,74,79,194,250,0,0,62,166,244,27,194,221,140,162,194,250,0,0,62,166,244,27,194,249,255,217,194,249,254,210,63,166,122,194,194,250,0,0,194,250,0,0,62,166,244,27,194,249,255,217,194,249,254,210,63,166,122,194,194,250,0,0,194,192,163,186,60,82,195,59,194,249,255,217,194,192,162,153,63,124,198,131,194,250,0,0,194,129,67,219,63,189,1,253,194,249,255,217,194,129,66,186,64,28,223,220,194,250,0,0,191,161,7,40,62,166,244,27,194,249,255,217,191,160,187,191,63,166,122,194,194,250,0,0,66,7,236,124,63,180,19,137,194,249,255,217,66,7,238,215,64,24,104,162,194,250,0,0,66,138,112,152,63,180,19,137,194,249,255,217,66,138,113,198,64,24,104,162,194,250,0,0,66,208,234,243,63,216,182,121,194,249,255,217,66,208,236,32,64,42,186,26,194,250,0,0,66,229,82,111,63,216,182,121,194,249,255,217,66,229,83,144,64,42,186,26,194,250,0,0,66,250,0,0,63,166,122,194,194,250,0,0,66,249,254,210,62,166,244,27,194,249,255,217,66,249,254,210,62,166,244,27,194,249,255,217,66,250,0,0,63,166,122,194,194,250,0,0,66,249,254,210,62,166,244,27,194,174,131,179,66,250,0,0,63,166,122,194,194,174,131,218,66,249,254,210,64,24,158,236,194,101,29,226,66,250,0,0,64,86,253,201,194,101,30,48,66,249,254,210,62,166,244,27,193,218,104,137,66,250,0,0,63,166,122,194,193,218,105,38,66,249,254,210,63,217,178,191,64,43,85,146,66,250,0,0,64,43,56,61,64,43,80,169,66,249,254,210,62,166,244,27,66,68,84,112,66,250,0,0,63,166,122,194,66,68,84,34,66,249,254,210,62,166,244,27,66,190,249,182,66,250,0,0,63,166,122,194,66,190,249,143,66,249,254,210,63,181,92,116,66,219,66,249,66,250,0,0,64,25,13,23,66,219,66,210,66,249,254,210,63,89,255,100,66,250,0,0,66,250,0,0,63,233,189,109,66,249,255,217,66,250,0,0,63,233,189,109,66,249,255,217,66,229,83,144,63,166,122,194,66,249,255,217,66,249,254,210,63,89,255,100,66,250,0,0,66,229,82,111,62,166,244,27,66,250,0,0,66,208,234,243,62,166,244,27,66,250,0,0,66,208,236,32,63,166,122,194,66,249,255,217,66,156,15,63,63,3,39,32,66,250,0,0,66,156,16,96,63,190,81,75,66,249,255,217,66,78,102,227,63,207,75,122,66,250,0,0,66,78,105,36,64,38,4,154,66,249,255,217,65,201,94,144,63,98,129,69,66,250,0,0,65,201,99,18,63,237,254,94,66,249,255,217,191,161,7,40,63,137,23,44,66,250,0,0,191,160,187,191,64,2,234,115,66,249,255,217,193,179,16,27,64,20,205,191,66,250,0,0,193,179,11,100,64,83,44,157,66,249,255,217,194,46,7,226,64,4,233,100,66,250,0,0,194,46,5,134,64,67,72,66,66,249,255,217,194,129,66,186,63,166,122,194,66,249,255,217,194,129,67,219,62,166,244,27,66,250,0,0,194,192,163,186,63,168,243,12,66,250,0,0,194,192,162,153,64,18,216,99,66,249,255,217,194,250,0,0,62,166,244,27,66,250,0,0,194,249,254,210,63,166,122,194,66,249,255,217,194,250,0,0,62,166,244,27,66,250,0,0,194,249,254,210,63,166,122,194,66,249,255,217,194,250,0,0,62,166,244,27,66,219,66,249,194,249,254,210,63,166,122,194,66,219,66,210,194,250,0,0,64,38,94,4,66,190,249,182,194,249,254,210,64,100,188,226,66,190,249,143,194,250,0,0,64,65,161,34,66,129,26,13,194,249,254,210,64,128,0,0,66,129,25,230,194,249,254,210,63,166,122,194,66,6,116,120,194,250,0,0,62,166,244,27,66,6,116,199,194,250,0,0,63,166,109,252,64,43,85,146,194,249,254,210,64,17,149,220,64,43,80,169,194,250,0,0,64,7,1,225,193,138,119,117,194,249,254,210,64,69,96,190,193,138,120,18,194,250,0,0,63,234,42,0,194,21,44,206,194,249,254,210,64,51,115,222,194,21,45,29,194,249,254,210,63,166,122,194,194,101,30,48,194,250,0,0,62,166,244,27,194,101,29,226,194,250,0,0,62,166,244,27,194,145,34,187,194,249,254,210,63,166,122,194,194,145,34,226,194,250,0,0,63,200,120,179,194,175,182,133,194,249,254,210,64,34,155,55,194,175,182,173,0,0,0,21,0,0,0,88,63,103,43,2,62,198,141,185,63,110,230,50,63,45,138,219,63,103,43,2,63,32,249,9,63,110,230,50,63,107,61,8,63,125,79,223,63,107,61,8,63,125,79,223,63,45,138,219,58,3,18,111,63,107,61,8,58,3,18,111,63,45,138,219,61,233,120,213,63,127,13,132,61,233,120,213,63,65,97,229,62,117,11,15,63,34,104,10,62,117,11,15,62,201,107,186,62,250,225,72,63,107,61,8,62,250,225,72,63,45,138,219,63,33,32,92,63,38,213,208,63,33,32,92,62,210,71,69,63,68,208,20,63,38,213,208,63,68,208,20,62,210,71,69,63,104,127,204,63,20,181,221,63,104,134,89,62,174,7,95,63,114,215,115,63,20,181,221,63,114,215,115,62,174,7,95,63,125,79,223,63,45,138,219,63,125,79,223,63,107,61,8,58,3,18,111,63,107,61,8,58,3,18,111,63,45,138,219,62,25,101,44,63,107,61,8,62,25,101,44,63,45,138,219,62,137,107,186,62,209,222,106,62,137,107,186,62,44,244,31,62,198,36,221,63,107,61,8,62,198,36,221,63,45,138,219,63,1,111,0,63,20,57,88,63,1,111,0,62,173,14,86,63,48,111,105,63,107,61,8,63,48,111,105,63,45,138,219,63,95,111,210,63,107,61,8,63,95,111,210,63,45,138,219,63,109,191,72,63,38,49,249,63,109,191,72,62,208,255,151,63,125,79,223,63,73,251,231,63,125,79,223,63,12,73,186,58,3,18,111,63,12,73,186,61,41,147,12,63,45,138,219,58,3,18,111,63,73,251,231,61,41,147,12,63,107,61,8,61,167,134,194,63,107,61,8,61,167,82,84,63,45,138,219,62,62,197,109,63,95,111,210,62,62,197,109,63,33,196,51,62,148,240,216,63,25,94,158,62,148,240,216,62,183,88,226,62,202,113,222,63,71,219,245,62,202,113,222,63,10,48,85,63,0,0,0,63,60,21,77,63,0,0,0,62,252,198,63,63,21,96,66,62,217,101,44,63,21,96,66,62,60,27,218,63,42,199,17,62,248,212,254,63,42,199,17,62,122,251,127,63,64,45,224,63,45,138,219,63,64,45,224,63,107,61,8,63,96,65,137,63,44,86,214,63,96,65,137,62,221,73,82,63,125,79,223,63,107,61,8,63,125,79,223,63,45,138,219,58,3,18,111,63,107,61,8,58,3,18,111,63,45,138,219,61,123,21,181,63,107,61,8,61,123,21,181,63,45,138,219,61,240,6,142,62,182,174,125,61,240,6,142,61,237,40,141,62,117,89,180,62,128,196,156,62,117,89,180,60,44,8,49,62,185,88,16,63,45,138,219,62,185,88,16,63,107,61,8,62,248,3,71,63,45,145,104,62,248,3,71,62,223,203,146,63,16,65,137,62,244,175,79,63,16,65,137,62,114,176,33,63,36,122,225,63,12,21,77,63,36,122,225,62,156,198,63,63,56,186,199,63,45,138,219,63,56,186,199,63,107,61,8,63,72,55,181,63,107,61,8,63,72,55,181,63,45,138,219,63,87,180,162,63,28,191,177,63,87,180,162,62,190,27,9,0,0,0,23,0,0,0,240,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,1,0,0,0,3,0,0,0,3,0,0,0,1,0,0,0,4,0,0,0,4,0,0,0,1,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,8,0,0,0,7,0,0,0,9,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,10,0,0,0,9,0,0,0,11,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,12,0,0,0,11,0,0,0,13,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,14,0,0,0,13,0,0,0,15,0,0,0,14,0,0,0,15,0,0,0,16,0,0,0,16,0,0,0,15,0,0,0,17,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,18,0,0,0,17,0,0,0,19,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,20,0,0,0,19,0,0,0,21,0,0,0,21,0,0,0,22,0,0,0,20,0,0,0,20,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,26,0,0,0,25,0,0,0,27,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,28,0,0,0,27,0,0,0,29,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,30,0,0,0,29,0,0,0,31,0,0,0,30,0,0,0,31,0,0,0,32,0,0,0,32,0,0,0,31,0,0,0,33,0,0,0,32,0,0,0,33,0,0,0,34,0,0,0,34,0,0,0,33,0,0,0,35,0,0,0,34,0,0,0,35,0,0,0,36,0,0,0,36,0,0,0,35,0,0,0,37,0,0,0,36,0,0,0,37,0,0,0,38,0,0,0,38,0,0,0,37,0,0,0,39,0,0,0,38,0,0,0,39,0,0,0,40,0,0,0,40,0,0,0,39,0,0,0,41,0,0,0,42,0,0,0,43,0,0,0,44,0,0,0,44,0,0,0,43,0,0,0,45,0,0,0,45,0,0,0,43,0,0,0,46,0,0,0,46,0,0,0,43,0,0,0,47,0,0,0,46,0,0,0,47,0,0,0,48,0,0,0,48,0,0,0,47,0,0,0,49,0,0,0,48,0,0,0,49,0,0,0,50,0,0,0,50,0,0,0,49,0,0,0,51,0,0,0,50,0,0,0,51,0,0,0,52,0,0,0,52,0,0,0,51,0,0,0,53,0,0,0,52,0,0,0,53,0,0,0,54,0,0,0,54,0,0,0,53,0,0,0,55,0,0,0,54,0,0,0,55,0,0,0,56,0,0,0,56,0,0,0,55,0,0,0,57,0,0,0,56,0,0,0,57,0,0,0,58,0,0,0,58,0,0,0,57,0,0,0,59,0,0,0,59,0,0,0,60,0,0,0,58,0,0,0,58,0,0,0,60,0,0,0,61,0,0,0,61,0,0,0,60,0,0,0,62,0,0,0,62,0,0,0,60,0,0,0,63,0,0,0,62,0,0,0,63,0,0,0,64,0,0,0,64,0,0,0,63,0,0,0,65,0,0,0,66,0,0,0,67,0,0,0,68,0,0,0,68,0,0,0,67,0,0,0,69,0,0,0,68,0,0,0,69,0,0,0,70,0,0,0,70,0,0,0,69,0,0,0,71,0,0,0,70,0,0,0,71,0,0,0,72,0,0,0,72,0,0,0,71,0,0,0,73,0,0,0,73,0,0,0,74,0,0,0,72,0,0,0,72,0,0,0,74,0,0,0,75,0,0,0,75,0,0,0,74,0,0,0,76,0,0,0,76,0,0,0,74,0,0,0,77,0,0,0,76,0,0,0,77,0,0,0,78,0,0,0,78,0,0,0,77,0,0,0,79,0,0,0,78,0,0,0,79,0,0,0,80,0,0,0,80,0,0,0,79,0,0,0,81,0,0,0,81,0,0,0,82,0,0,0,80,0,0,0,80,0,0,0,82,0,0,0,83,0,0,0,83,0,0,0,82,0,0,0,84,0,0,0,84,0,0,0,82,0,0,0,85,0,0,0,84,0,0,0,85,0,0,0,86,0,0,0,86,0,0,0,85,0,0,0,87,0,0,0,86,0,0,0,87,0,0,0,2,0,0,0,2,0,0,0,87,0,0,0,0,69,78,68,0,0,0,50,0,0,0,38,194,243,234,181,190,143,92,41,194,192,163,186,0,0,0,0,194,130,0,0,190,158,129,233,66,249,254,210,190,163,215,10,66,250,0,0,192,86,253,201,66,234,39,193,192,43,133,31,66,225,0,0,192,42,186,26,66,210,0,0,192,42,186,26,66,145,0,0,192,26,28,212,66,140,0,0,192,26,110,144,66,135,0,0,192,28,9,232,66,93,30,64,192,28,40,246,66,81,168,253,192,35,215,10,66,72,0,0,192,35,42,167,66,56,63,67,192,28,40,246,66,12,0,0,192,28,9,232,66,2,0,0,192,24,249,122,65,153,95,150,191,250,225,72,65,112,0,0,191,247,43,107,190,238,247,23,192,2,143,92,191,234,254,121,192,5,30,184,193,180,0,0,192,83,21,157,194,46,144,248,192,66,143,92,194,82,0,0,192,19,147,158,194,92,0,0,192,17,235,133,194,128,7,230,192,28,40,246,194,130,0,0,192,27,200,20,194,155,0,0,191,237,167,29,194,165,0,0,191,235,133,31,194,165,0,0,191,238,56,1,194,191,182,151,192,17,235,133,194,193,120,54,192,17,235,133,194,205,0,0,192,5,34,89,194,210,11,230,192,7,174,20,194,245,0,0,192,112,244,99,194,249,255,16,192,115,51,51,194,250,0,0,190,163,215,10,194,245,0,0,190,146,99,104";
//viewers

R2D.ObjectViewer3DCarpet.__roundWidth = 250;
R2D.ObjectViewer3DCarpet.__roundHeight = 1;
R2D.ObjectViewer3DCarpet.__roundDepth = 250;
R2D.ObjectViewer3DCarpet.getRoundGeometry = function() {
    if ( !R2D.ObjectViewer3DCarpet.__roundRAW ) {
        var arrayBuffer = R2D.Tool.stringDataToArrayBuffer(R2D.ObjectViewer3DCarpet.__dataRound);

        R2D.ObjectViewer3DCarpet.__roundRAW = R2D.ProductPackageParser.parseModel(arrayBuffer);
    }

    return R2D.Tool.makeModelGeometries(R2D.ObjectViewer3DCarpet.__roundRAW.geometries);
};

R2D.ObjectViewer3DCarpet.__roundRAW = null;
R2D.ObjectViewer3DCarpet.__dataRound = "82,79,79,77,84,79,68,79,0,0,0,2,0,0,0,1,0,0,0,10,0,0,0,2,66,69,71,73,78,0,0,0,20,0,0,1,233,66,248,84,215,60,155,66,6,128,0,0,0,66,247,136,167,60,155,66,6,193,32,44,61,66,248,61,244,60,155,66,6,192,86,254,197,66,247,136,167,60,155,66,6,193,32,44,61,66,247,249,180,60,155,66,6,192,214,74,140,194,224,64,26,60,155,66,6,66,85,110,73,194,226,231,82,60,155,66,6,66,73,240,33,194,221,116,202,60,155,66,6,66,96,195,150,194,218,133,240,60,155,66,6,66,107,238,204,194,229,105,226,60,155,66,6,66,62,74,61,194,231,199,43,60,155,66,6,66,50,125,191,194,233,254,158,60,155,66,6,66,38,139,199,194,236,15,158,60,155,66,6,66,26,117,142,194,237,249,167,60,155,66,6,66,14,60,54,194,239,188,28,60,155,66,6,66,1,224,249,194,241,86,109,60,155,66,6,65,234,201,134,194,215,116,31,60,155,66,6,66,118,238,204,194,242,199,253,60,155,66,6,65,209,146,6,194,244,16,72,60,155,66,6,65,184,29,73,194,245,46,165,60,155,66,6,65,158,109,250,194,246,34,143,60,155,66,6,65,132,134,37,194,246,235,107,60,155,66,6,65,84,208,20,194,247,136,167,60,155,66,6,65,32,44,61,194,247,249,180,60,155,66,6,64,214,74,140,194,248,61,244,60,155,66,6,64,86,254,197,194,248,84,215,60,155,66,6,128,0,0,0,194,248,61,244,60,155,66,6,192,86,254,197,194,247,249,180,60,155,66,6,192,214,74,140,194,247,136,167,60,155,66,6,193,32,44,61,194,246,235,107,60,155,66,6,193,84,208,20,194,246,34,143,60,155,66,6,193,132,134,37,194,245,46,165,60,155,66,6,193,158,109,250,194,244,16,72,60,155,66,6,193,184,29,73,194,242,199,253,60,155,66,6,193,209,146,6,194,241,86,109,60,155,66,6,193,234,201,186,194,239,188,28,60,155,66,6,194,1,224,249,194,237,249,167,60,155,66,6,194,14,60,54,194,236,15,158,60,155,66,6,194,26,117,142,194,233,254,158,60,155,66,6,194,38,139,225,194,231,199,43,60,155,66,6,194,50,125,191,194,229,105,226,60,155,66,6,194,62,74,61,194,226,231,82,60,155,66,6,194,73,240,33,194,224,64,26,60,155,66,6,194,85,110,99,194,221,116,202,60,155,66,6,194,96,195,150,194,218,133,240,60,155,66,6,194,107,238,204,194,215,116,31,60,155,66,6,194,118,238,204,194,212,63,243,60,155,66,6,66,128,225,59,194,212,63,243,60,155,66,6,194,128,225,59,194,208,233,252,60,155,66,6,194,134,52,70,194,205,114,202,60,155,66,6,194,139,111,249,194,201,218,251,60,155,66,6,194,144,147,182,194,198,35,32,60,155,66,6,194,149,158,250,194,194,75,199,60,155,66,6,194,154,145,39,194,190,85,142,60,155,66,6,194,159,105,160,194,186,65,6,60,155,66,6,194,164,39,227,194,182,14,191,60,155,66,6,194,168,203,68,194,177,191,72,60,155,66,6,194,173,83,77,194,173,83,77,60,155,66,6,194,177,191,72,194,168,203,68,60,155,66,6,194,182,14,191,194,164,39,227,60,155,66,6,194,186,65,6,194,159,105,160,60,155,66,6,194,190,85,142,194,154,145,39,60,155,66,6,194,194,75,199,194,149,158,250,60,155,66,6,194,198,35,32,194,144,147,182,60,155,66,6,194,201,218,251,194,139,111,249,60,155,66,6,194,205,114,202,194,134,52,70,60,155,66,6,194,208,233,252,194,128,225,59,60,155,66,6,194,212,63,243,194,118,238,204,60,155,66,6,194,215,116,31,194,107,238,204,60,155,66,6,194,218,133,240,194,96,195,150,60,155,66,6,194,221,116,202,194,85,110,99,60,155,66,6,194,224,64,26,194,73,240,59,60,155,66,6,194,226,231,82,194,62,74,61,60,155,66,6,194,229,105,226,194,50,125,191,60,155,66,6,194,231,199,43,194,38,139,199,60,155,66,6,194,233,254,158,194,26,117,168,60,155,66,6,194,236,15,158,194,14,60,80,60,155,66,6,194,237,249,167,194,1,224,249,60,155,66,6,194,239,188,28,193,234,201,186,60,155,66,6,194,241,86,109,193,209,146,6,60,155,66,6,194,242,199,253,193,184,29,73,60,155,66,6,194,244,16,72,193,158,109,250,60,155,66,6,194,245,46,165,193,132,134,37,60,155,66,6,194,246,34,143,193,84,208,20,60,155,66,6,194,246,235,107,193,32,44,61,60,155,66,6,194,247,136,167,192,214,74,140,60,155,66,6,194,247,249,180,192,86,254,197,60,155,66,6,194,248,61,244,128,0,0,0,60,155,66,6,194,248,84,215,64,86,254,197,60,155,66,6,194,248,61,244,64,214,74,140,60,155,66,6,194,247,249,180,65,32,44,61,60,155,66,6,194,247,136,167,65,84,208,20,60,155,66,6,194,246,235,107,65,132,134,37,60,155,66,6,194,246,34,143,65,158,109,250,60,155,66,6,194,245,46,165,65,184,29,73,60,155,66,6,194,244,16,72,65,209,146,6,60,155,66,6,194,242,199,253,65,234,201,134,60,155,66,6,194,241,86,109,66,1,224,249,60,155,66,6,194,239,188,28,66,14,60,54,60,155,66,6,194,237,249,167,66,26,117,142,60,155,66,6,194,236,15,158,66,38,139,199,60,155,66,6,194,233,254,158,66,50,125,191,60,155,66,6,194,231,199,43,66,62,74,61,60,155,66,6,194,229,105,226,66,73,240,33,60,155,66,6,194,226,231,82,66,85,110,73,60,155,66,6,194,224,64,26,66,96,195,150,60,155,66,6,194,221,116,202,66,107,238,204,60,155,66,6,194,218,133,240,66,118,238,204,60,155,66,6,194,215,116,31,66,128,225,59,60,155,66,6,194,212,63,243,66,134,52,70,60,155,66,6,194,208,233,252,194,208,233,252,60,155,66,6,66,134,52,70,194,201,218,251,60,155,66,6,66,144,147,182,194,205,114,202,60,155,66,6,66,139,111,236,194,194,75,199,60,155,66,6,66,154,145,26,194,198,35,32,60,155,66,6,66,149,158,250,194,186,65,6,60,155,66,6,66,164,39,227,194,190,85,142,60,155,66,6,66,159,105,160,194,177,191,72,60,155,66,6,66,173,83,64,194,182,14,191,60,155,66,6,66,168,203,68,194,168,203,68,60,155,66,6,66,182,14,191,194,173,83,77,60,155,66,6,66,177,191,72,194,159,105,160,60,155,66,6,66,190,85,142,194,164,39,227,60,155,66,6,66,186,65,6,194,149,158,250,60,155,66,6,66,198,35,32,194,154,145,39,60,155,66,6,66,194,75,199,194,139,111,249,60,155,66,6,66,205,114,202,194,144,147,182,60,155,66,6,66,201,218,251,194,128,225,59,60,155,66,6,66,212,63,243,194,134,52,70,60,155,66,6,66,208,233,252,194,107,238,204,60,155,66,6,66,218,133,240,194,118,238,204,60,155,66,6,66,215,116,31,194,85,110,99,60,155,66,6,66,224,64,26,194,96,195,150,60,155,66,6,66,221,116,202,194,62,74,61,60,155,66,6,66,229,105,226,194,73,240,33,60,155,66,6,66,226,231,82,194,38,139,199,60,155,66,6,66,233,254,158,194,50,125,191,60,155,66,6,66,231,199,43,194,14,60,54,60,155,66,6,66,237,249,167,194,26,117,142,60,155,66,6,66,236,15,158,193,234,201,134,60,155,66,6,66,241,86,109,194,1,224,249,60,155,66,6,66,239,188,28,193,184,29,73,60,155,66,6,66,244,16,72,193,209,146,6,60,155,66,6,66,242,199,253,193,132,134,37,60,155,66,6,66,246,34,143,193,158,109,250,60,155,66,6,66,245,46,165,193,32,44,61,60,155,66,6,66,247,136,167,193,84,208,20,60,155,66,6,66,246,235,107,192,86,254,197,60,155,66,6,66,248,61,244,192,214,74,140,60,155,66,6,66,247,249,180,64,86,254,197,60,155,66,6,66,248,61,244,128,0,0,0,60,155,66,6,66,248,84,215,65,32,44,61,60,155,66,6,66,247,136,167,64,214,74,140,60,155,66,6,66,247,249,180,65,132,134,37,60,155,66,6,66,246,34,143,65,84,208,20,60,155,66,6,66,246,235,107,65,184,29,73,60,155,66,6,66,244,16,72,65,158,109,250,60,155,66,6,66,245,46,165,65,234,201,134,60,155,66,6,66,241,86,109,65,209,146,6,60,155,66,6,66,242,199,253,66,14,60,54,60,155,66,6,66,237,249,167,66,1,224,249,60,155,66,6,66,239,188,28,66,38,139,199,60,155,66,6,66,233,254,158,66,26,117,142,60,155,66,6,66,236,15,158,66,62,74,61,60,155,66,6,66,229,105,226,66,50,125,191,60,155,66,6,66,231,199,43,66,85,110,73,60,155,66,6,66,224,64,26,66,73,240,33,60,155,66,6,66,226,231,82,66,107,238,204,60,155,66,6,66,218,133,240,66,96,195,150,60,155,66,6,66,221,116,202,66,128,225,59,60,155,66,6,66,212,63,243,66,118,238,204,60,155,66,6,66,215,116,31,66,139,111,236,60,155,66,6,66,205,114,202,66,134,52,70,60,155,66,6,66,208,233,252,66,139,111,236,60,155,66,6,194,205,114,202,66,144,147,182,60,155,66,6,194,201,218,251,66,149,158,250,60,155,66,6,66,198,35,32,66,144,147,182,60,155,66,6,66,201,218,251,66,149,158,250,60,155,66,6,194,198,35,32,66,154,145,26,60,155,66,6,194,194,75,199,66,159,105,160,60,155,66,6,66,190,85,142,66,154,145,39,60,155,66,6,66,194,75,199,66,159,105,160,60,155,66,6,194,190,85,142,66,164,39,227,60,155,66,6,194,186,65,6,66,168,203,68,60,155,66,6,194,182,14,191,66,164,39,227,60,155,66,6,66,186,65,6,66,173,83,64,60,155,66,6,194,177,191,72,66,168,203,68,60,155,66,6,66,182,14,178,66,177,191,72,60,155,66,6,66,173,83,64,66,173,83,64,60,155,66,6,66,177,191,72,66,177,191,72,60,155,66,6,194,173,83,77,66,182,14,178,60,155,66,6,194,168,203,68,66,186,65,6,60,155,66,6,194,164,39,227,66,182,14,191,60,155,66,6,66,168,203,68,66,190,85,142,60,155,66,6,66,159,105,160,66,186,65,6,60,155,66,6,66,164,39,227,66,198,35,32,60,155,66,6,66,149,158,250,66,194,75,199,60,155,66,6,66,154,145,26,66,205,114,202,60,155,66,6,66,139,111,236,66,201,218,251,60,155,66,6,66,144,147,182,66,212,63,243,60,155,66,6,66,128,225,59,66,208,233,252,60,155,66,6,66,134,52,70,66,218,133,240,60,155,66,6,66,107,238,204,66,215,116,31,60,155,66,6,66,118,238,204,66,224,64,26,60,155,66,6,66,85,110,73,66,221,116,202,60,155,66,6,66,96,195,150,66,229,105,226,60,155,66,6,66,62,74,61,66,226,231,82,60,155,66,6,66,73,240,33,66,233,254,158,60,155,66,6,66,38,139,199,66,231,199,43,60,155,66,6,66,50,125,191,66,237,249,167,60,155,66,6,66,14,60,54,66,236,15,158,60,155,66,6,66,26,117,142,66,241,86,109,60,155,66,6,65,234,201,134,66,239,188,28,60,155,66,6,66,1,224,249,66,244,16,72,60,155,66,6,65,184,29,73,66,242,199,253,60,155,66,6,65,209,146,6,66,246,34,143,60,155,66,6,65,132,134,37,66,245,46,165,60,155,66,6,65,158,109,250,66,247,136,167,60,155,66,6,65,32,44,61,66,246,235,107,60,155,66,6,65,84,208,20,66,190,85,142,60,155,66,6,194,159,105,160,66,247,249,180,60,155,66,6,64,214,74,140,66,194,75,199,60,155,66,6,194,154,145,39,66,248,61,244,60,155,66,6,64,86,254,197,66,198,35,32,60,155,66,6,194,149,158,250,66,201,218,251,60,155,66,6,194,144,147,182,66,205,114,202,60,155,66,6,194,139,111,249,66,208,233,252,60,155,66,6,194,134,52,70,66,212,63,243,60,155,66,6,194,128,225,59,66,215,116,31,60,155,66,6,194,118,238,204,66,218,133,240,60,155,66,6,194,107,238,204,66,221,116,202,60,155,66,6,194,96,195,150,66,224,64,26,60,155,66,6,194,85,110,99,66,226,231,82,60,155,66,6,194,73,240,59,66,229,105,226,60,155,66,6,194,62,74,61,66,231,199,43,60,155,66,6,194,50,125,191,66,233,254,158,60,155,66,6,194,38,139,199,66,236,15,158,60,155,66,6,194,26,117,168,66,237,249,167,60,155,66,6,194,14,60,80,66,239,188,28,60,155,66,6,194,1,224,249,66,241,86,109,60,155,66,6,193,234,201,186,66,242,199,253,60,155,66,6,193,209,146,6,66,244,16,72,60,155,66,6,193,184,29,73,66,245,46,165,60,155,66,6,193,158,109,250,66,246,34,143,60,155,66,6,193,132,134,37,66,246,235,107,60,155,66,6,193,84,208,20,194,218,133,240,63,128,0,0,66,107,238,204,194,226,231,82,63,128,0,0,66,73,240,33,194,221,116,202,63,128,0,0,66,96,195,150,194,224,64,26,63,128,0,0,66,85,110,73,194,231,199,43,63,128,0,0,66,50,125,191,194,229,105,226,63,128,0,0,66,62,74,61,194,236,15,158,63,128,0,0,66,26,117,142,194,233,254,158,63,128,0,0,66,38,139,199,194,239,188,28,63,128,0,0,66,1,224,249,194,237,249,167,63,128,0,0,66,14,60,54,194,215,116,31,63,128,0,0,66,118,238,204,194,241,86,109,63,128,0,0,65,234,201,134,194,244,16,72,63,128,0,0,65,184,29,73,194,242,199,253,63,128,0,0,65,209,146,6,194,246,34,143,63,128,0,0,65,132,134,37,194,245,46,165,63,128,0,0,65,158,109,250,194,247,136,167,63,128,0,0,65,32,44,61,194,246,235,107,63,128,0,0,65,84,208,20,194,248,61,244,63,128,0,0,64,86,254,197,194,247,249,180,63,128,0,0,64,214,74,140,194,248,61,244,63,128,0,0,192,86,254,197,194,248,84,215,63,128,0,0,128,0,0,0,194,247,136,167,63,128,0,0,193,32,44,61,194,247,249,180,63,128,0,0,192,214,74,140,194,246,34,143,63,128,0,0,193,132,134,37,194,246,235,107,63,128,0,0,193,84,208,20,194,244,16,72,63,128,0,0,193,184,29,73,194,245,46,165,63,128,0,0,193,158,109,250,194,241,86,109,63,128,0,0,193,234,201,186,194,242,199,253,63,128,0,0,193,209,146,6,194,237,249,167,63,128,0,0,194,14,60,54,194,239,188,28,63,128,0,0,194,1,224,249,194,233,254,158,63,128,0,0,194,38,139,225,194,236,15,158,63,128,0,0,194,26,117,142,194,229,105,226,63,128,0,0,194,62,74,61,194,231,199,43,63,128,0,0,194,50,125,191,194,224,64,26,63,128,0,0,194,85,110,99,194,226,231,82,63,128,0,0,194,73,240,33,194,218,133,240,63,128,0,0,194,107,238,204,194,221,116,202,63,128,0,0,194,96,195,150,194,212,63,243,63,128,0,0,66,128,225,59,194,215,116,31,63,128,0,0,194,118,238,204,194,208,233,252,63,128,0,0,194,134,52,70,194,212,63,243,63,128,0,0,194,128,225,59,194,201,218,251,63,128,0,0,194,144,147,182,194,205,114,202,63,128,0,0,194,139,111,249,194,194,75,199,63,128,0,0,194,154,145,39,194,198,35,32,63,128,0,0,194,149,158,250,194,186,65,6,63,128,0,0,194,164,39,227,194,190,85,142,63,128,0,0,194,159,105,160,194,177,191,72,63,128,0,0,194,173,83,77,194,182,14,191,63,128,0,0,194,168,203,68,194,168,203,68,63,128,0,0,194,182,14,191,194,173,83,77,63,128,0,0,194,177,191,72,194,159,105,160,63,128,0,0,194,190,85,142,194,164,39,227,63,128,0,0,194,186,65,6,194,149,158,250,63,128,0,0,194,198,35,32,194,154,145,39,63,128,0,0,194,194,75,199,194,139,111,249,63,128,0,0,194,205,114,202,194,144,147,182,63,128,0,0,194,201,218,251,194,128,225,59,63,128,0,0,194,212,63,243,194,134,52,70,63,128,0,0,194,208,233,252,194,107,238,204,63,128,0,0,194,218,133,240,194,118,238,204,63,128,0,0,194,215,116,31,194,85,110,99,63,128,0,0,194,224,64,26,194,96,195,150,63,128,0,0,194,221,116,202,194,62,74,61,63,128,0,0,194,229,105,226,194,73,240,59,63,128,0,0,194,226,231,82,194,38,139,199,63,128,0,0,194,233,254,158,194,50,125,191,63,128,0,0,194,231,199,43,194,14,60,80,63,128,0,0,194,237,249,167,194,26,117,168,63,128,0,0,194,236,15,158,193,234,201,186,63,128,0,0,194,241,86,109,194,1,224,249,63,128,0,0,194,239,188,28,193,184,29,73,63,128,0,0,194,244,16,72,193,209,146,6,63,128,0,0,194,242,199,253,193,132,134,37,63,128,0,0,194,246,34,143,193,158,109,250,63,128,0,0,194,245,46,165,193,32,44,61,63,128,0,0,194,247,136,167,193,84,208,20,63,128,0,0,194,246,235,107,192,86,254,197,63,128,0,0,194,248,61,244,192,214,74,140,63,128,0,0,194,247,249,180,64,86,254,197,63,128,0,0,194,248,61,244,128,0,0,0,63,128,0,0,194,248,84,215,65,32,44,61,63,128,0,0,194,247,136,167,64,214,74,140,63,128,0,0,194,247,249,180,65,132,134,37,63,128,0,0,194,246,34,143,65,84,208,20,63,128,0,0,194,246,235,107,65,184,29,73,63,128,0,0,194,244,16,72,65,158,109,250,63,128,0,0,194,245,46,165,65,234,201,134,63,128,0,0,194,241,86,109,65,209,146,6,63,128,0,0,194,242,199,253,66,14,60,54,63,128,0,0,194,237,249,167,66,1,224,249,63,128,0,0,194,239,188,28,66,38,139,199,63,128,0,0,194,233,254,158,66,26,117,142,63,128,0,0,194,236,15,158,66,62,74,61,63,128,0,0,194,229,105,226,66,50,125,191,63,128,0,0,194,231,199,43,66,85,110,73,63,128,0,0,194,224,64,26,66,73,240,33,63,128,0,0,194,226,231,82,66,107,238,204,63,128,0,0,194,218,133,240,66,96,195,150,63,128,0,0,194,221,116,202,66,128,225,59,63,128,0,0,194,212,63,243,66,118,238,204,63,128,0,0,194,215,116,31,194,208,233,252,63,128,0,0,66,134,52,70,66,134,52,70,63,128,0,0,194,208,233,252,194,205,114,202,63,128,0,0,66,139,111,236,194,201,218,251,63,128,0,0,66,144,147,182,194,198,35,32,63,128,0,0,66,149,158,250,194,194,75,199,63,128,0,0,66,154,145,26,194,190,85,142,63,128,0,0,66,159,105,160,194,186,65,6,63,128,0,0,66,164,39,227,194,182,14,191,63,128,0,0,66,168,203,68,194,177,191,72,63,128,0,0,66,173,83,64,194,173,83,77,63,128,0,0,66,177,191,72,194,168,203,68,63,128,0,0,66,182,14,191,194,164,39,227,63,128,0,0,66,186,65,6,194,159,105,160,63,128,0,0,66,190,85,142,194,154,145,39,63,128,0,0,66,194,75,199,194,149,158,250,63,128,0,0,66,198,35,32,194,144,147,182,63,128,0,0,66,201,218,251,194,139,111,249,63,128,0,0,66,205,114,202,194,134,52,70,63,128,0,0,66,208,233,252,194,128,225,59,63,128,0,0,66,212,63,243,194,118,238,204,63,128,0,0,66,215,116,31,194,107,238,204,63,128,0,0,66,218,133,240,194,96,195,150,63,128,0,0,66,221,116,202,194,85,110,99,63,128,0,0,66,224,64,26,194,73,240,33,63,128,0,0,66,226,231,82,194,62,74,61,63,128,0,0,66,229,105,226,194,50,125,191,63,128,0,0,66,231,199,43,194,38,139,199,63,128,0,0,66,233,254,158,194,26,117,142,63,128,0,0,66,236,15,158,194,14,60,54,63,128,0,0,66,237,249,167,194,1,224,249,63,128,0,0,66,239,188,28,193,234,201,134,63,128,0,0,66,241,86,109,193,209,146,6,63,128,0,0,66,242,199,253,193,184,29,73,63,128,0,0,66,244,16,72,193,158,109,250,63,128,0,0,66,245,46,165,193,132,134,37,63,128,0,0,66,246,34,143,193,84,208,20,63,128,0,0,66,246,235,107,193,32,44,61,63,128,0,0,66,247,136,167,192,214,74,140,63,128,0,0,66,247,249,180,192,86,254,197,63,128,0,0,66,248,61,244,128,0,0,0,63,128,0,0,66,248,84,215,64,86,254,197,63,128,0,0,66,248,61,244,64,214,74,140,63,128,0,0,66,247,249,180,65,32,44,61,63,128,0,0,66,247,136,167,65,84,208,20,63,128,0,0,66,246,235,107,65,132,134,37,63,128,0,0,66,246,34,143,65,158,109,250,63,128,0,0,66,245,46,165,65,184,29,73,63,128,0,0,66,244,16,72,65,209,146,6,63,128,0,0,66,242,199,253,65,234,201,134,63,128,0,0,66,241,86,109,66,1,224,249,63,128,0,0,66,239,188,28,66,14,60,54,63,128,0,0,66,237,249,167,66,26,117,142,63,128,0,0,66,236,15,158,66,38,139,199,63,128,0,0,66,233,254,158,66,50,125,191,63,128,0,0,66,231,199,43,66,62,74,61,63,128,0,0,66,229,105,226,66,73,240,33,63,128,0,0,66,226,231,82,66,85,110,73,63,128,0,0,66,224,64,26,66,96,195,150,63,128,0,0,66,221,116,202,66,107,238,204,63,128,0,0,66,218,133,240,66,118,238,204,63,128,0,0,66,215,116,31,66,128,225,59,63,128,0,0,66,212,63,243,66,134,52,70,63,128,0,0,66,208,233,252,66,139,111,236,63,128,0,0,66,205,114,202,66,144,147,182,63,128,0,0,194,201,218,251,66,139,111,236,63,128,0,0,194,205,114,202,66,144,147,182,63,128,0,0,66,201,218,251,66,149,158,250,63,128,0,0,66,198,35,32,66,154,145,26,63,128,0,0,194,194,75,199,66,149,158,250,63,128,0,0,194,198,35,32,66,154,145,39,63,128,0,0,66,194,75,199,66,159,105,160,63,128,0,0,66,190,85,142,66,164,39,227,63,128,0,0,194,186,65,6,66,159,105,160,63,128,0,0,194,190,85,142,66,164,39,227,63,128,0,0,66,186,65,6,66,168,203,68,63,128,0,0,194,182,14,191,66,168,203,68,63,128,0,0,66,182,14,178,66,173,83,64,63,128,0,0,194,177,191,72,66,173,83,64,63,128,0,0,66,177,191,72,66,177,191,72,63,128,0,0,66,173,83,64,66,182,14,178,63,128,0,0,194,168,203,68,66,177,191,72,63,128,0,0,194,173,83,77,66,182,14,191,63,128,0,0,66,168,203,68,66,186,65,6,63,128,0,0,194,164,39,227,66,186,65,6,63,128,0,0,66,164,39,227,66,190,85,142,63,128,0,0,66,159,105,160,66,194,75,199,63,128,0,0,66,154,145,26,66,198,35,32,63,128,0,0,66,149,158,250,66,201,218,251,63,128,0,0,66,144,147,182,66,205,114,202,63,128,0,0,66,139,111,236,66,208,233,252,63,128,0,0,66,134,52,70,66,212,63,243,63,128,0,0,66,128,225,59,66,215,116,31,63,128,0,0,66,118,238,204,66,218,133,240,63,128,0,0,66,107,238,204,66,221,116,202,63,128,0,0,66,96,195,150,66,224,64,26,63,128,0,0,66,85,110,73,66,226,231,82,63,128,0,0,66,73,240,33,66,229,105,226,63,128,0,0,66,62,74,61,66,231,199,43,63,128,0,0,66,50,125,191,66,233,254,158,63,128,0,0,66,38,139,199,66,236,15,158,63,128,0,0,66,26,117,142,66,237,249,167,63,128,0,0,66,14,60,54,66,239,188,28,63,128,0,0,66,1,224,249,66,241,86,109,63,128,0,0,65,234,201,134,66,242,199,253,63,128,0,0,65,209,146,6,66,244,16,72,63,128,0,0,65,184,29,73,66,245,46,165,63,128,0,0,65,158,109,250,66,246,34,143,63,128,0,0,65,132,134,37,66,246,235,107,63,128,0,0,65,84,208,20,66,247,136,167,63,128,0,0,65,32,44,61,66,247,249,180,63,128,0,0,64,214,74,140,66,190,85,142,63,128,0,0,194,159,105,160,66,248,61,244,63,128,0,0,64,86,254,197,66,194,75,199,63,128,0,0,194,154,145,39,66,201,218,251,63,128,0,0,194,144,147,182,66,198,35,32,63,128,0,0,194,149,158,250,66,248,84,215,63,128,0,0,128,0,0,0,66,205,114,202,63,128,0,0,194,139,111,249,66,212,63,243,63,128,0,0,194,128,225,59,66,208,233,252,63,128,0,0,194,134,52,70,66,218,133,240,63,128,0,0,194,107,238,204,66,215,116,31,63,128,0,0,194,118,238,204,66,224,64,26,63,128,0,0,194,85,110,99,66,221,116,202,63,128,0,0,194,96,195,150,66,229,105,226,63,128,0,0,194,62,74,61,66,226,231,82,63,128,0,0,194,73,240,59,66,233,254,158,63,128,0,0,194,38,139,199,66,231,199,43,63,128,0,0,194,50,125,191,66,237,249,167,63,128,0,0,194,14,60,80,66,236,15,158,63,128,0,0,194,26,117,168,66,241,86,109,63,128,0,0,193,234,201,186,66,239,188,28,63,128,0,0,194,1,224,249,66,244,16,72,63,128,0,0,193,184,29,73,66,242,199,253,63,128,0,0,193,209,146,6,66,246,34,143,63,128,0,0,193,132,134,37,66,245,46,165,63,128,0,0,193,158,109,250,66,247,136,167,63,128,0,0,193,32,44,61,66,246,235,107,63,128,0,0,193,84,208,20,66,248,61,244,63,128,0,0,192,86,254,197,66,247,249,180,63,128,0,0,192,214,74,140,0,0,0,21,0,0,1,233,63,124,139,68,63,0,0,0,63,124,34,104,63,10,9,3,63,124,126,40,63,3,97,19,63,124,34,104,63,10,9,3,63,124,93,100,63,6,181,11,61,120,160,144,62,148,253,244,61,99,83,248,62,154,185,245,61,135,147,222,62,143,79,14,61,147,64,79,62,137,173,67,61,79,65,242,62,160,144,46,61,60,1,163,62,166,128,157,61,42,100,195,62,172,126,40,61,26,2,117,62,178,136,206,61,10,113,222,62,184,173,172,60,249,9,108,62,190,223,164,60,222,210,137,62,197,30,184,61,159,138,9,62,132,50,202,60,199,226,130,62,203,120,3,60,179,103,161,62,209,209,78,60,161,97,229,62,216,68,208,60,145,209,78,62,222,197,109,60,133,135,148,62,229,83,38,60,119,101,254,62,235,237,250,60,104,167,30,62,242,149,234,60,96,117,247,62,249,61,217,60,93,47,27,63,0,0,0,60,96,117,247,63,3,97,19,60,104,167,30,63,6,181,11,60,119,101,254,63,10,9,3,60,133,135,148,63,13,86,109,60,145,209,78,63,16,157,73,60,161,97,229,63,19,221,152,60,179,103,161,63,23,23,89,60,199,226,130,63,26,67,254,60,222,210,137,63,29,112,164,60,249,9,108,63,32,144,46,61,10,113,222,63,35,169,42,61,26,2,117,63,38,187,153,61,42,100,195,63,41,192,236,61,60,1,163,63,44,191,177,61,79,65,242,63,47,183,233,61,99,83,248,63,50,163,5,61,120,160,144,63,53,129,6,61,135,147,222,63,56,88,121,61,147,64,79,63,59,41,95,61,159,138,9,63,61,230,155,61,172,113,13,62,125,138,219,61,172,113,13,63,64,157,73,61,185,192,236,63,67,77,106,61,199,174,20,63,69,233,226,61,214,56,134,63,72,127,204,61,228,247,102,63,75,8,154,61,244,135,253,63,77,125,191,62,2,38,129,63,79,236,87,62,10,87,168,63,82,77,211,62,18,189,60,63,84,162,52,62,27,113,118,63,86,233,121,62,36,90,29,63,89,29,21,62,45,92,251,63,91,74,35,62,54,174,125,63,93,99,136,62,64,52,110,63,95,111,210,62,73,238,204,63,97,111,0,62,83,221,152,63,99,90,134,62,94,0,210,63,101,56,239,62,104,62,66,63,103,3,176,62,114,202,88,63,104,193,85,62,125,112,164,63,106,107,81,62,132,37,175,63,108,8,49,62,137,173,67,63,109,145,104,62,143,65,242,63,111,13,132,62,148,240,216,63,112,111,105,62,154,185,245,63,113,196,51,62,160,144,46,63,115,5,83,62,166,128,157,63,116,57,88,62,172,126,40,63,117,83,38,62,178,136,206,63,118,95,217,62,184,173,172,63,119,82,84,62,190,223,164,63,120,55,181,62,197,30,184,63,121,2,222,62,203,120,3,63,121,186,94,62,209,209,78,63,122,94,53,62,216,68,208,63,122,238,99,62,222,197,109,63,123,106,232,62,229,83,38,63,123,205,54,62,235,237,250,63,124,27,218,62,242,149,234,63,124,86,214,62,249,61,217,63,124,119,154,63,0,0,0,63,124,132,182,63,3,97,19,63,124,119,154,63,6,181,11,63,124,86,214,63,10,9,3,63,124,27,218,63,13,86,109,63,123,205,54,63,16,157,73,63,123,106,232,63,19,221,152,63,122,238,99,63,23,23,89,63,122,94,53,63,26,67,254,63,121,186,94,63,29,112,164,63,121,2,222,63,32,144,46,63,120,55,181,63,35,169,42,63,119,82,84,63,38,187,153,63,118,95,217,63,41,192,236,63,117,83,38,63,44,191,177,63,116,57,88,63,47,183,233,63,115,5,83,63,50,163,5,63,113,196,51,63,53,135,148,63,112,111,105,63,56,95,7,63,111,13,132,63,59,41,95,63,109,145,104,63,61,237,41,63,108,8,49,63,64,163,215,63,106,107,81,63,67,77,106,63,104,193,85,61,185,192,236,62,114,202,88,61,214,56,134,62,94,0,210,61,199,174,20,62,104,88,121,61,244,135,253,62,74,9,3,61,228,247,102,62,83,221,152,62,10,87,168,62,54,200,180,62,2,38,129,62,64,78,165,62,27,113,118,62,36,90,29,62,18,189,60,62,45,119,50,62,45,92,251,62,18,215,115,62,36,90,29,62,27,139,172,62,64,52,110,62,2,64,184,62,54,174,125,62,10,113,222,62,83,221,152,61,229,43,212,62,73,238,204,61,244,135,253,62,104,62,66,61,199,226,130,62,94,0,210,61,214,56,134,62,125,112,164,61,172,165,122,62,114,202,88,61,185,245,90,62,137,173,67,61,147,116,188,62,132,37,175,61,159,190,119,62,148,240,216,61,121,9,108,62,143,65,242,61,135,147,222,62,160,144,46,61,79,170,206,62,154,185,245,61,99,188,211,62,172,126,40,61,42,205,159,62,166,128,157,61,60,106,127,62,184,173,172,61,10,218,186,62,178,136,206,61,26,2,117,62,197,30,184,60,223,164,64,62,190,223,164,60,249,9,108,62,209,209,78,60,180,57,88,62,203,120,3,60,200,180,57,62,222,197,109,60,146,163,5,62,216,68,208,60,162,51,156,62,235,237,250,60,121,9,108,62,229,83,38,60,134,89,75,62,249,61,217,60,98,25,101,62,242,149,234,60,106,74,140,63,3,97,19,60,98,25,101,63,0,0,0,60,94,210,137,63,10,9,3,60,121,9,108,63,6,181,11,60,106,74,140,63,16,157,73,60,146,163,5,63,13,86,109,60,134,89,75,63,23,23,89,60,180,57,88,63,19,221,152,60,162,51,156,63,29,112,164,60,223,164,64,63,26,67,254,60,200,180,57,63,35,169,42,61,10,218,186,63,32,144,46,60,249,9,108,63,41,192,236,61,42,205,159,63,38,187,153,61,26,2,117,63,47,183,233,61,79,170,206,63,44,191,177,61,60,106,127,63,53,135,148,61,121,9,108,63,50,163,5,61,99,188,211,63,59,41,95,61,147,116,188,63,56,95,7,61,135,147,222,63,64,163,215,61,172,165,122,63,61,237,41,61,159,190,119,63,69,240,111,61,199,226,130,63,67,77,106,61,185,245,90,63,69,240,111,63,103,3,176,63,72,127,204,63,101,56,239,63,75,8,154,61,229,43,212,63,72,127,204,61,214,56,134,63,75,8,154,63,99,90,134,63,77,132,77,63,97,111,0,63,79,242,229,62,2,64,184,63,77,132,77,61,244,135,253,63,79,242,229,63,95,111,210,63,82,84,97,63,93,99,136,63,84,168,193,63,91,74,35,63,82,84,97,62,10,113,222,63,86,233,121,63,89,29,21,63,84,168,193,62,18,215,115,63,89,35,163,62,36,90,29,63,86,233,121,62,27,139,172,63,89,35,163,63,86,233,121,63,91,80,177,63,84,162,52,63,93,106,22,63,82,77,211,63,91,80,177,62,45,119,50,63,95,118,96,62,64,78,165,63,93,106,22,62,54,200,180,63,99,97,19,62,83,221,152,63,97,111,0,62,74,9,3,63,103,10,61,62,104,88,121,63,101,56,239,62,94,0,210,63,106,113,222,62,125,138,219,63,104,199,227,62,114,202,88,63,109,151,246,62,137,173,67,63,108,14,191,62,132,50,202,63,112,117,247,62,148,253,244,63,111,13,132,62,143,79,14,63,115,11,225,62,160,144,46,63,113,202,193,62,154,185,245,63,117,89,180,62,172,126,40,63,116,63,230,62,166,128,157,63,119,88,226,62,184,173,172,63,118,95,217,62,178,136,206,63,121,9,108,62,197,30,184,63,120,55,181,62,190,223,164,63,122,100,195,62,209,209,78,63,121,192,236,62,203,120,3,63,123,113,118,62,222,197,109,63,122,244,241,62,216,68,208,63,124,34,104,62,235,237,250,63,123,211,195,62,229,83,38,63,95,118,96,63,79,236,87,63,124,93,100,62,242,149,234,63,97,111,0,63,77,125,191,63,124,126,40,62,249,61,217,63,99,97,19,63,75,8,154,63,101,56,239,63,72,127,204,63,103,10,61,63,69,233,226,63,104,199,227,63,67,77,106,63,106,113,222,63,64,157,73,63,108,14,191,63,61,230,155,63,109,151,246,63,59,41,95,63,111,13,132,63,56,88,121,63,112,117,247,63,53,129,6,63,113,202,193,63,50,163,5,63,115,11,225,63,47,183,233,63,116,63,230,63,44,191,177,63,117,89,180,63,41,192,236,63,118,95,217,63,38,187,153,63,119,88,226,63,35,169,42,63,120,55,181,63,32,144,46,63,121,9,108,63,29,112,164,63,121,192,236,63,26,67,254,63,122,100,195,63,23,23,89,63,122,244,241,63,19,221,152,63,123,113,118,63,16,157,73,63,123,211,195,63,13,86,109,61,147,64,79,62,137,173,67,61,99,83,248,62,154,185,245,61,135,147,222,62,143,79,14,61,120,160,144,62,148,253,244,61,60,1,163,62,166,128,157,61,79,65,242,62,160,144,46,61,26,2,117,62,178,136,206,61,42,100,195,62,172,126,40,60,249,9,108,62,190,223,164,61,10,113,222,62,184,173,172,61,159,138,9,62,132,50,202,60,222,210,137,62,197,30,184,60,179,103,161,62,209,209,78,60,199,226,130,62,203,120,3,60,145,209,78,62,222,197,109,60,161,97,229,62,216,68,208,60,119,101,254,62,235,237,250,60,133,135,148,62,229,83,38,60,96,117,247,62,249,61,217,60,104,167,30,62,242,149,234,60,96,117,247,63,3,97,19,60,93,47,27,63,0,0,0,60,119,101,254,63,10,9,3,60,104,167,30,63,6,181,11,60,145,209,78,63,16,157,73,60,133,135,148,63,13,86,109,60,179,103,161,63,23,23,89,60,161,97,229,63,19,221,152,60,222,210,137,63,29,112,164,60,199,226,130,63,26,67,254,61,10,113,222,63,35,169,42,60,249,9,108,63,32,144,46,61,42,100,195,63,41,192,236,61,26,2,117,63,38,187,153,61,79,65,242,63,47,183,233,61,60,1,163,63,44,191,177,61,120,160,144,63,53,129,6,61,99,83,248,63,50,163,5,61,147,64,79,63,59,41,95,61,135,147,222,63,56,88,121,61,172,113,13,62,125,138,219,61,159,138,9,63,61,230,155,61,185,192,236,63,67,77,106,61,172,113,13,63,64,157,73,61,214,56,134,63,72,127,204,61,199,174,20,63,69,233,226,61,244,135,253,63,77,125,191,61,228,247,102,63,75,8,154,62,10,87,168,63,82,77,211,62,2,38,129,63,79,236,87,62,27,113,118,63,86,233,121,62,18,189,60,63,84,162,52,62,45,92,251,63,91,74,35,62,36,90,29,63,89,29,21,62,64,52,110,63,95,111,210,62,54,174,125,63,93,99,136,62,83,221,152,63,99,90,134,62,73,238,204,63,97,111,0,62,104,62,66,63,103,3,176,62,94,0,210,63,101,56,239,62,125,112,164,63,106,107,81,62,114,202,88,63,104,193,85,62,137,173,67,63,109,145,104,62,132,37,175,63,108,8,49,62,148,240,216,63,112,111,105,62,143,65,242,63,111,13,132,62,160,144,46,63,115,5,83,62,154,185,245,63,113,196,51,62,172,126,40,63,117,83,38,62,166,128,157,63,116,57,88,62,184,173,172,63,119,82,84,62,178,136,206,63,118,95,217,62,197,30,184,63,121,2,222,62,190,223,164,63,120,55,181,62,209,209,78,63,122,94,53,62,203,120,3,63,121,186,94,62,222,197,109,63,123,106,232,62,216,68,208,63,122,238,99,62,235,237,250,63,124,27,218,62,229,83,38,63,123,205,54,62,249,61,217,63,124,119,154,62,242,149,234,63,124,86,214,63,3,97,19,63,124,119,154,63,0,0,0,63,124,132,182,63,10,9,3,63,124,27,218,63,6,181,11,63,124,86,214,63,16,157,73,63,123,106,232,63,13,86,109,63,123,205,54,63,23,23,89,63,122,94,53,63,19,221,152,63,122,238,99,63,29,112,164,63,121,2,222,63,26,67,254,63,121,186,94,63,35,169,42,63,119,82,84,63,32,144,46,63,120,55,181,63,41,192,236,63,117,83,38,63,38,187,153,63,118,95,217,63,47,183,233,63,115,5,83,63,44,191,177,63,116,57,88,63,53,135,148,63,112,111,105,63,50,163,5,63,113,196,51,63,59,41,95,63,109,145,104,63,56,95,7,63,111,13,132,63,64,163,215,63,106,107,81,63,61,237,41,63,108,8,49,61,185,192,236,62,114,202,88,63,67,77,106,63,104,193,85,61,199,174,20,62,104,88,121,61,214,56,134,62,94,0,210,61,228,247,102,62,83,221,152,61,244,135,253,62,74,9,3,62,2,38,129,62,64,78,165,62,10,87,168,62,54,200,180,62,18,189,60,62,45,119,50,62,27,113,118,62,36,90,29,62,36,90,29,62,27,139,172,62,45,92,251,62,18,215,115,62,54,174,125,62,10,113,222,62,64,52,110,62,2,64,184,62,73,238,204,61,244,135,253,62,83,221,152,61,229,43,212,62,94,0,210,61,214,56,134,62,104,62,66,61,199,226,130,62,114,202,88,61,185,245,90,62,125,112,164,61,172,165,122,62,132,37,175,61,159,190,119,62,137,173,67,61,147,116,188,62,143,65,242,61,135,147,222,62,148,240,216,61,121,9,108,62,154,185,245,61,99,188,211,62,160,144,46,61,79,170,206,62,166,128,157,61,60,106,127,62,172,126,40,61,42,205,159,62,178,136,206,61,26,2,117,62,184,173,172,61,10,218,186,62,190,223,164,60,249,9,108,62,197,30,184,60,223,164,64,62,203,120,3,60,200,180,57,62,209,209,78,60,180,57,88,62,216,68,208,60,162,51,156,62,222,197,109,60,146,163,5,62,229,83,38,60,134,89,75,62,235,237,250,60,121,9,108,62,242,149,234,60,106,74,140,62,249,61,217,60,98,25,101,63,0,0,0,60,94,210,137,63,3,97,19,60,98,25,101,63,6,181,11,60,106,74,140,63,10,9,3,60,121,9,108,63,13,86,109,60,134,89,75,63,16,157,73,60,146,163,5,63,19,221,152,60,162,51,156,63,23,23,89,60,180,57,88,63,26,67,254,60,200,180,57,63,29,112,164,60,223,164,64,63,32,144,46,60,249,9,108,63,35,169,42,61,10,218,186,63,38,187,153,61,26,2,117,63,41,192,236,61,42,205,159,63,44,191,177,61,60,106,127,63,47,183,233,61,79,170,206,63,50,163,5,61,99,188,211,63,53,135,148,61,121,9,108,63,56,95,7,61,135,147,222,63,59,41,95,61,147,116,188,63,61,237,41,61,159,190,119,63,64,163,215,61,172,165,122,63,67,77,106,61,185,245,90,63,69,240,111,61,199,226,130,63,72,127,204,63,101,56,239,63,69,240,111,63,103,3,176,63,72,127,204,61,214,56,134,63,75,8,154,61,229,43,212,63,77,132,77,63,97,111,0,63,75,8,154,63,99,90,134,63,77,132,77,61,244,135,253,63,79,242,229,62,2,64,184,63,82,84,97,63,93,99,136,63,79,242,229,63,95,111,210,63,82,84,97,62,10,113,222,63,84,168,193,63,91,74,35,63,84,168,193,62,18,215,115,63,86,233,121,63,89,29,21,63,86,233,121,62,27,139,172,63,89,35,163,62,36,90,29,63,91,80,177,63,84,162,52,63,89,35,163,63,86,233,121,63,91,80,177,62,45,119,50,63,93,106,22,63,82,77,211,63,93,106,22,62,54,200,180,63,95,118,96,62,64,78,165,63,97,111,0,62,74,9,3,63,99,97,19,62,83,221,152,63,101,56,239,62,94,0,210,63,103,10,61,62,104,88,121,63,104,199,227,62,114,202,88,63,106,113,222,62,125,138,219,63,108,14,191,62,132,50,202,63,109,151,246,62,137,173,67,63,111,13,132,62,143,79,14,63,112,117,247,62,148,253,244,63,113,202,193,62,154,185,245,63,115,11,225,62,160,144,46,63,116,63,230,62,166,128,157,63,117,89,180,62,172,126,40,63,118,95,217,62,178,136,206,63,119,88,226,62,184,173,172,63,120,55,181,62,190,223,164,63,121,9,108,62,197,30,184,63,121,192,236,62,203,120,3,63,122,100,195,62,209,209,78,63,122,244,241,62,216,68,208,63,123,113,118,62,222,197,109,63,123,211,195,62,229,83,38,63,124,34,104,62,235,237,250,63,124,93,100,62,242,149,234,63,95,118,96,63,79,236,87,63,124,126,40,62,249,61,217,63,97,111,0,63,77,125,191,63,101,56,239,63,72,127,204,63,99,97,19,63,75,8,154,63,124,139,68,63,0,0,0,63,103,10,61,63,69,233,226,63,106,113,222,63,64,157,73,63,104,199,227,63,67,77,106,63,109,151,246,63,59,41,95,63,108,14,191,63,61,230,155,63,112,117,247,63,53,129,6,63,111,13,132,63,56,88,121,63,115,11,225,63,47,183,233,63,113,202,193,63,50,163,5,63,117,89,180,63,41,192,236,63,116,63,230,63,44,191,177,63,119,88,226,63,35,169,42,63,118,95,217,63,38,187,153,63,121,9,108,63,29,112,164,63,120,55,181,63,32,144,46,63,122,100,195,63,23,23,89,63,121,192,236,63,26,67,254,63,123,113,118,63,16,157,73,63,122,244,241,63,19,221,152,63,124,34,104,63,10,9,3,63,123,211,195,63,13,86,109,63,124,126,40,63,3,97,19,63,124,93,100,63,6,181,11,0,0,0,23,0,0,5,172,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,7,0,0,0,6,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,6,0,0,0,6,0,0,0,10,0,0,0,8,0,0,0,11,0,0,0,12,0,0,0,10,0,0,0,10,0,0,0,12,0,0,0,8,0,0,0,13,0,0,0,14,0,0,0,12,0,0,0,12,0,0,0,14,0,0,0,8,0,0,0,15,0,0,0,16,0,0,0,14,0,0,0,14,0,0,0,16,0,0,0,8,0,0,0,17,0,0,0,18,0,0,0,15,0,0,0,15,0,0,0,18,0,0,0,16,0,0,0,19,0,0,0,20,0,0,0,18,0,0,0,18,0,0,0,20,0,0,0,16,0,0,0,21,0,0,0,22,0,0,0,20,0,0,0,20,0,0,0,22,0,0,0,16,0,0,0,23,0,0,0,24,0,0,0,22,0,0,0,22,0,0,0,24,0,0,0,16,0,0,0,25,0,0,0,26,0,0,0,24,0,0,0,24,0,0,0,26,0,0,0,16,0,0,0,27,0,0,0,28,0,0,0,26,0,0,0,26,0,0,0,28,0,0,0,16,0,0,0,29,0,0,0,30,0,0,0,28,0,0,0,28,0,0,0,30,0,0,0,16,0,0,0,31,0,0,0,32,0,0,0,30,0,0,0,30,0,0,0,32,0,0,0,16,0,0,0,33,0,0,0,34,0,0,0,32,0,0,0,32,0,0,0,34,0,0,0,16,0,0,0,35,0,0,0,36,0,0,0,34,0,0,0,34,0,0,0,36,0,0,0,16,0,0,0,37,0,0,0,38,0,0,0,36,0,0,0,36,0,0,0,38,0,0,0,16,0,0,0,39,0,0,0,40,0,0,0,38,0,0,0,38,0,0,0,40,0,0,0,16,0,0,0,41,0,0,0,42,0,0,0,40,0,0,0,40,0,0,0,42,0,0,0,16,0,0,0,43,0,0,0,44,0,0,0,42,0,0,0,42,0,0,0,44,0,0,0,16,0,0,0,45,0,0,0,46,0,0,0,44,0,0,0,44,0,0,0,46,0,0,0,16,0,0,0,47,0,0,0,48,0,0,0,45,0,0,0,45,0,0,0,48,0,0,0,46,0,0,0,49,0,0,0,50,0,0,0,48,0,0,0,48,0,0,0,50,0,0,0,46,0,0,0,51,0,0,0,52,0,0,0,50,0,0,0,50,0,0,0,52,0,0,0,46,0,0,0,53,0,0,0,54,0,0,0,52,0,0,0,52,0,0,0,54,0,0,0,46,0,0,0,55,0,0,0,56,0,0,0,54,0,0,0,54,0,0,0,56,0,0,0,46,0,0,0,57,0,0,0,58,0,0,0,56,0,0,0,56,0,0,0,58,0,0,0,46,0,0,0,59,0,0,0,60,0,0,0,58,0,0,0,58,0,0,0,60,0,0,0,46,0,0,0,61,0,0,0,62,0,0,0,60,0,0,0,60,0,0,0,62,0,0,0,46,0,0,0,63,0,0,0,64,0,0,0,62,0,0,0,62,0,0,0,64,0,0,0,46,0,0,0,65,0,0,0,66,0,0,0,64,0,0,0,64,0,0,0,66,0,0,0,46,0,0,0,67,0,0,0,68,0,0,0,66,0,0,0,66,0,0,0,68,0,0,0,46,0,0,0,69,0,0,0,70,0,0,0,68,0,0,0,68,0,0,0,70,0,0,0,46,0,0,0,71,0,0,0,72,0,0,0,70,0,0,0,70,0,0,0,72,0,0,0,46,0,0,0,73,0,0,0,74,0,0,0,72,0,0,0,72,0,0,0,74,0,0,0,46,0,0,0,75,0,0,0,76,0,0,0,74,0,0,0,74,0,0,0,76,0,0,0,46,0,0,0,77,0,0,0,78,0,0,0,76,0,0,0,76,0,0,0,78,0,0,0,46,0,0,0,79,0,0,0,80,0,0,0,78,0,0,0,78,0,0,0,80,0,0,0,46,0,0,0,81,0,0,0,82,0,0,0,80,0,0,0,80,0,0,0,82,0,0,0,46,0,0,0,83,0,0,0,84,0,0,0,82,0,0,0,82,0,0,0,84,0,0,0,46,0,0,0,85,0,0,0,86,0,0,0,84,0,0,0,84,0,0,0,86,0,0,0,46,0,0,0,87,0,0,0,88,0,0,0,86,0,0,0,86,0,0,0,88,0,0,0,46,0,0,0,89,0,0,0,90,0,0,0,88,0,0,0,88,0,0,0,90,0,0,0,46,0,0,0,91,0,0,0,92,0,0,0,90,0,0,0,90,0,0,0,92,0,0,0,46,0,0,0,93,0,0,0,94,0,0,0,92,0,0,0,92,0,0,0,94,0,0,0,46,0,0,0,95,0,0,0,96,0,0,0,94,0,0,0,94,0,0,0,96,0,0,0,46,0,0,0,97,0,0,0,98,0,0,0,96,0,0,0,96,0,0,0,98,0,0,0,46,0,0,0,99,0,0,0,100,0,0,0,98,0,0,0,98,0,0,0,100,0,0,0,46,0,0,0,101,0,0,0,102,0,0,0,100,0,0,0,100,0,0,0,102,0,0,0,46,0,0,0,103,0,0,0,104,0,0,0,102,0,0,0,102,0,0,0,104,0,0,0,46,0,0,0,105,0,0,0,106,0,0,0,104,0,0,0,104,0,0,0,106,0,0,0,46,0,0,0,107,0,0,0,108,0,0,0,106,0,0,0,106,0,0,0,108,0,0,0,46,0,0,0,109,0,0,0,110,0,0,0,108,0,0,0,108,0,0,0,110,0,0,0,46,0,0,0,109,0,0,0,111,0,0,0,110,0,0,0,110,0,0,0,111,0,0,0,112,0,0,0,109,0,0,0,113,0,0,0,111,0,0,0,111,0,0,0,113,0,0,0,114,0,0,0,109,0,0,0,115,0,0,0,113,0,0,0,113,0,0,0,115,0,0,0,116,0,0,0,109,0,0,0,117,0,0,0,115,0,0,0,115,0,0,0,117,0,0,0,118,0,0,0,109,0,0,0,119,0,0,0,117,0,0,0,117,0,0,0,119,0,0,0,120,0,0,0,109,0,0,0,121,0,0,0,119,0,0,0,119,0,0,0,121,0,0,0,122,0,0,0,109,0,0,0,123,0,0,0,121,0,0,0,121,0,0,0,123,0,0,0,124,0,0,0,109,0,0,0,125,0,0,0,123,0,0,0,123,0,0,0,125,0,0,0,126,0,0,0,109,0,0,0,127,0,0,0,125,0,0,0,125,0,0,0,127,0,0,0,128,0,0,0,109,0,0,0,129,0,0,0,127,0,0,0,127,0,0,0,129,0,0,0,130,0,0,0,109,0,0,0,131,0,0,0,129,0,0,0,129,0,0,0,131,0,0,0,132,0,0,0,109,0,0,0,133,0,0,0,131,0,0,0,131,0,0,0,133,0,0,0,134,0,0,0,109,0,0,0,135,0,0,0,133,0,0,0,133,0,0,0,135,0,0,0,136,0,0,0,109,0,0,0,137,0,0,0,135,0,0,0,135,0,0,0,137,0,0,0,138,0,0,0,109,0,0,0,139,0,0,0,137,0,0,0,137,0,0,0,139,0,0,0,140,0,0,0,109,0,0,0,141,0,0,0,139,0,0,0,139,0,0,0,141,0,0,0,142,0,0,0,109,0,0,0,143,0,0,0,141,0,0,0,141,0,0,0,143,0,0,0,144,0,0,0,109,0,0,0,145,0,0,0,143,0,0,0,143,0,0,0,145,0,0,0,146,0,0,0,109,0,0,0,147,0,0,0,145,0,0,0,145,0,0,0,147,0,0,0,148,0,0,0,109,0,0,0,149,0,0,0,147,0,0,0,147,0,0,0,149,0,0,0,150,0,0,0,109,0,0,0,151,0,0,0,149,0,0,0,149,0,0,0,151,0,0,0,152,0,0,0,109,0,0,0,153,0,0,0,151,0,0,0,151,0,0,0,153,0,0,0,154,0,0,0,109,0,0,0,155,0,0,0,153,0,0,0,153,0,0,0,155,0,0,0,156,0,0,0,109,0,0,0,157,0,0,0,155,0,0,0,155,0,0,0,157,0,0,0,158,0,0,0,109,0,0,0,159,0,0,0,157,0,0,0,157,0,0,0,159,0,0,0,160,0,0,0,109,0,0,0,161,0,0,0,159,0,0,0,159,0,0,0,161,0,0,0,162,0,0,0,109,0,0,0,163,0,0,0,161,0,0,0,161,0,0,0,163,0,0,0,164,0,0,0,109,0,0,0,165,0,0,0,163,0,0,0,163,0,0,0,165,0,0,0,166,0,0,0,109,0,0,0,167,0,0,0,165,0,0,0,165,0,0,0,167,0,0,0,168,0,0,0,109,0,0,0,169,0,0,0,167,0,0,0,167,0,0,0,169,0,0,0,170,0,0,0,109,0,0,0,171,0,0,0,169,0,0,0,169,0,0,0,171,0,0,0,172,0,0,0,173,0,0,0,174,0,0,0,109,0,0,0,109,0,0,0,174,0,0,0,171,0,0,0,174,0,0,0,175,0,0,0,171,0,0,0,171,0,0,0,175,0,0,0,176,0,0,0,177,0,0,0,178,0,0,0,174,0,0,0,174,0,0,0,178,0,0,0,175,0,0,0,178,0,0,0,179,0,0,0,175,0,0,0,175,0,0,0,179,0,0,0,180,0,0,0,181,0,0,0,182,0,0,0,178,0,0,0,178,0,0,0,182,0,0,0,179,0,0,0,182,0,0,0,183,0,0,0,179,0,0,0,179,0,0,0,183,0,0,0,184,0,0,0,183,0,0,0,185,0,0,0,184,0,0,0,184,0,0,0,185,0,0,0,186,0,0,0,185,0,0,0,187,0,0,0,186,0,0,0,186,0,0,0,187,0,0,0,188,0,0,0,189,0,0,0,190,0,0,0,185,0,0,0,185,0,0,0,190,0,0,0,187,0,0,0,190,0,0,0,191,0,0,0,187,0,0,0,187,0,0,0,191,0,0,0,192,0,0,0,191,0,0,0,193,0,0,0,192,0,0,0,192,0,0,0,193,0,0,0,194,0,0,0,191,0,0,0,195,0,0,0,193,0,0,0,193,0,0,0,195,0,0,0,196,0,0,0,191,0,0,0,197,0,0,0,195,0,0,0,195,0,0,0,197,0,0,0,198,0,0,0,191,0,0,0,199,0,0,0,197,0,0,0,197,0,0,0,199,0,0,0,200,0,0,0,191,0,0,0,201,0,0,0,199,0,0,0,199,0,0,0,201,0,0,0,202,0,0,0,191,0,0,0,203,0,0,0,201,0,0,0,201,0,0,0,203,0,0,0,204,0,0,0,191,0,0,0,205,0,0,0,203,0,0,0,203,0,0,0,205,0,0,0,206,0,0,0,191,0,0,0,207,0,0,0,205,0,0,0,205,0,0,0,207,0,0,0,208,0,0,0,191,0,0,0,209,0,0,0,207,0,0,0,207,0,0,0,209,0,0,0,210,0,0,0,191,0,0,0,211,0,0,0,209,0,0,0,209,0,0,0,211,0,0,0,212,0,0,0,191,0,0,0,213,0,0,0,211,0,0,0,211,0,0,0,213,0,0,0,214,0,0,0,191,0,0,0,215,0,0,0,213,0,0,0,213,0,0,0,215,0,0,0,216,0,0,0,191,0,0,0,217,0,0,0,215,0,0,0,215,0,0,0,217,0,0,0,218,0,0,0,219,0,0,0,220,0,0,0,191,0,0,0,191,0,0,0,220,0,0,0,217,0,0,0,221,0,0,0,222,0,0,0,219,0,0,0,219,0,0,0,222,0,0,0,220,0,0,0,223,0,0,0,224,0,0,0,221,0,0,0,221,0,0,0,224,0,0,0,222,0,0,0,224,0,0,0,225,0,0,0,222,0,0,0,222,0,0,0,225,0,0,0,0,0,0,0,226,0,0,0,227,0,0,0,225,0,0,0,225,0,0,0,227,0,0,0,0,0,0,0,228,0,0,0,229,0,0,0,227,0,0,0,227,0,0,0,229,0,0,0,0,0,0,0,230,0,0,0,231,0,0,0,229,0,0,0,229,0,0,0,231,0,0,0,0,0,0,0,232,0,0,0,233,0,0,0,231,0,0,0,231,0,0,0,233,0,0,0,0,0,0,0,234,0,0,0,235,0,0,0,233,0,0,0,233,0,0,0,235,0,0,0,0,0,0,0,236,0,0,0,237,0,0,0,235,0,0,0,235,0,0,0,237,0,0,0,0,0,0,0,238,0,0,0,239,0,0,0,237,0,0,0,237,0,0,0,239,0,0,0,0,0,0,0,240,0,0,0,241,0,0,0,239,0,0,0,239,0,0,0,241,0,0,0,0,0,0,0,242,0,0,0,243,0,0,0,241,0,0,0,241,0,0,0,243,0,0,0,0,0,0,0,244,0,0,0,1,0,0,0,243,0,0,0,243,0,0,0,1,0,0,0,0,0,0,0,245,0,0,0,246,0,0,0,247,0,0,0,247,0,0,0,246,0,0,0,248,0,0,0,245,0,0,0,249,0,0,0,246,0,0,0,246,0,0,0,249,0,0,0,250,0,0,0,245,0,0,0,251,0,0,0,249,0,0,0,249,0,0,0,251,0,0,0,252,0,0,0,245,0,0,0,253,0,0,0,251,0,0,0,251,0,0,0,253,0,0,0,254,0,0,0,245,0,0,0,255,0,0,0,253,0,0,0,253,0,0,0,255,0,0,1,0,0,0,0,255,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,2,0,0,0,255,0,0,1,3,0,0,1,1,0,0,1,1,0,0,1,3,0,0,1,4,0,0,0,255,0,0,1,5,0,0,1,3,0,0,1,3,0,0,1,5,0,0,1,6,0,0,0,255,0,0,1,7,0,0,1,5,0,0,1,5,0,0,1,7,0,0,1,8,0,0,0,255,0,0,1,9,0,0,1,7,0,0,1,7,0,0,1,9,0,0,1,10,0,0,0,255,0,0,1,11,0,0,1,9,0,0,1,9,0,0,1,11,0,0,1,12,0,0,0,255,0,0,1,13,0,0,1,11,0,0,1,11,0,0,1,13,0,0,1,14,0,0,0,255,0,0,1,15,0,0,1,13,0,0,1,13,0,0,1,15,0,0,1,16,0,0,0,255,0,0,1,17,0,0,1,15,0,0,1,15,0,0,1,17,0,0,1,18,0,0,0,255,0,0,1,19,0,0,1,17,0,0,1,17,0,0,1,19,0,0,1,20,0,0,0,255,0,0,1,21,0,0,1,19,0,0,1,19,0,0,1,21,0,0,1,22,0,0,0,255,0,0,1,23,0,0,1,21,0,0,1,21,0,0,1,23,0,0,1,24,0,0,0,255,0,0,1,25,0,0,1,23,0,0,1,23,0,0,1,25,0,0,1,26,0,0,0,255,0,0,1,27,0,0,1,25,0,0,1,25,0,0,1,27,0,0,1,28,0,0,0,255,0,0,1,29,0,0,1,27,0,0,1,27,0,0,1,29,0,0,1,30,0,0,1,29,0,0,1,31,0,0,1,30,0,0,1,30,0,0,1,31,0,0,1,32,0,0,1,29,0,0,1,33,0,0,1,31,0,0,1,31,0,0,1,33,0,0,1,34,0,0,1,29,0,0,1,35,0,0,1,33,0,0,1,33,0,0,1,35,0,0,1,36,0,0,1,29,0,0,1,37,0,0,1,35,0,0,1,35,0,0,1,37,0,0,1,38,0,0,1,29,0,0,1,39,0,0,1,37,0,0,1,37,0,0,1,39,0,0,1,40,0,0,1,29,0,0,1,41,0,0,1,39,0,0,1,39,0,0,1,41,0,0,1,42,0,0,1,29,0,0,1,43,0,0,1,41,0,0,1,41,0,0,1,43,0,0,1,44,0,0,1,29,0,0,1,45,0,0,1,43,0,0,1,43,0,0,1,45,0,0,1,46,0,0,1,29,0,0,1,47,0,0,1,45,0,0,1,45,0,0,1,47,0,0,1,48,0,0,1,29,0,0,1,49,0,0,1,47,0,0,1,47,0,0,1,49,0,0,1,50,0,0,1,29,0,0,1,51,0,0,1,49,0,0,1,49,0,0,1,51,0,0,1,52,0,0,1,29,0,0,1,53,0,0,1,51,0,0,1,51,0,0,1,53,0,0,1,54,0,0,1,29,0,0,1,55,0,0,1,53,0,0,1,53,0,0,1,55,0,0,1,56,0,0,1,29,0,0,1,57,0,0,1,55,0,0,1,55,0,0,1,57,0,0,1,58,0,0,1,29,0,0,1,59,0,0,1,57,0,0,1,57,0,0,1,59,0,0,1,60,0,0,1,29,0,0,1,61,0,0,1,59,0,0,1,59,0,0,1,61,0,0,1,62,0,0,1,29,0,0,1,63,0,0,1,61,0,0,1,61,0,0,1,63,0,0,1,64,0,0,1,29,0,0,1,65,0,0,1,63,0,0,1,63,0,0,1,65,0,0,1,66,0,0,1,29,0,0,1,67,0,0,1,65,0,0,1,65,0,0,1,67,0,0,1,68,0,0,1,29,0,0,1,69,0,0,1,67,0,0,1,67,0,0,1,69,0,0,1,70,0,0,1,29,0,0,1,71,0,0,1,69,0,0,1,69,0,0,1,71,0,0,1,72,0,0,1,29,0,0,1,73,0,0,1,71,0,0,1,71,0,0,1,73,0,0,1,74,0,0,1,29,0,0,1,75,0,0,1,73,0,0,1,73,0,0,1,75,0,0,1,76,0,0,1,29,0,0,1,77,0,0,1,75,0,0,1,75,0,0,1,77,0,0,1,78,0,0,1,29,0,0,1,79,0,0,1,77,0,0,1,77,0,0,1,79,0,0,1,80,0,0,1,29,0,0,1,81,0,0,1,79,0,0,1,79,0,0,1,81,0,0,1,82,0,0,1,29,0,0,1,83,0,0,1,81,0,0,1,81,0,0,1,83,0,0,1,84,0,0,1,29,0,0,1,85,0,0,1,83,0,0,1,83,0,0,1,85,0,0,1,86,0,0,1,29,0,0,1,87,0,0,1,85,0,0,1,85,0,0,1,87,0,0,1,88,0,0,1,29,0,0,1,89,0,0,1,87,0,0,1,87,0,0,1,89,0,0,1,90,0,0,1,29,0,0,1,91,0,0,1,89,0,0,1,89,0,0,1,91,0,0,1,92,0,0,1,29,0,0,1,93,0,0,1,91,0,0,1,91,0,0,1,93,0,0,1,94,0,0,1,95,0,0,1,96,0,0,1,93,0,0,1,93,0,0,1,96,0,0,1,94,0,0,1,97,0,0,1,98,0,0,1,96,0,0,1,96,0,0,1,98,0,0,1,94,0,0,1,99,0,0,1,100,0,0,1,98,0,0,1,98,0,0,1,100,0,0,1,94,0,0,1,101,0,0,1,102,0,0,1,100,0,0,1,100,0,0,1,102,0,0,1,94,0,0,1,103,0,0,1,104,0,0,1,102,0,0,1,102,0,0,1,104,0,0,1,94,0,0,1,105,0,0,1,106,0,0,1,104,0,0,1,104,0,0,1,106,0,0,1,94,0,0,1,107,0,0,1,108,0,0,1,106,0,0,1,106,0,0,1,108,0,0,1,94,0,0,1,109,0,0,1,110,0,0,1,108,0,0,1,108,0,0,1,110,0,0,1,94,0,0,1,111,0,0,1,112,0,0,1,110,0,0,1,110,0,0,1,112,0,0,1,94,0,0,1,113,0,0,1,114,0,0,1,112,0,0,1,112,0,0,1,114,0,0,1,94,0,0,1,115,0,0,1,116,0,0,1,114,0,0,1,114,0,0,1,116,0,0,1,94,0,0,1,117,0,0,1,118,0,0,1,116,0,0,1,116,0,0,1,118,0,0,1,94,0,0,1,119,0,0,1,120,0,0,1,118,0,0,1,118,0,0,1,120,0,0,1,94,0,0,1,121,0,0,1,122,0,0,1,120,0,0,1,120,0,0,1,122,0,0,1,94,0,0,1,123,0,0,1,124,0,0,1,122,0,0,1,122,0,0,1,124,0,0,1,94,0,0,1,125,0,0,1,126,0,0,1,124,0,0,1,124,0,0,1,126,0,0,1,94,0,0,1,127,0,0,1,128,0,0,1,126,0,0,1,126,0,0,1,128,0,0,1,94,0,0,1,129,0,0,1,130,0,0,1,128,0,0,1,128,0,0,1,130,0,0,1,94,0,0,1,131,0,0,1,132,0,0,1,130,0,0,1,130,0,0,1,132,0,0,1,94,0,0,1,133,0,0,1,134,0,0,1,132,0,0,1,132,0,0,1,134,0,0,1,94,0,0,1,135,0,0,1,136,0,0,1,134,0,0,1,134,0,0,1,136,0,0,1,94,0,0,1,137,0,0,1,138,0,0,1,136,0,0,1,136,0,0,1,138,0,0,1,94,0,0,1,139,0,0,1,140,0,0,1,138,0,0,1,138,0,0,1,140,0,0,1,94,0,0,1,141,0,0,1,142,0,0,1,140,0,0,1,140,0,0,1,142,0,0,1,94,0,0,1,143,0,0,1,144,0,0,1,142,0,0,1,142,0,0,1,144,0,0,1,94,0,0,1,145,0,0,1,146,0,0,1,144,0,0,1,144,0,0,1,146,0,0,1,94,0,0,1,147,0,0,1,148,0,0,1,146,0,0,1,146,0,0,1,148,0,0,1,94,0,0,1,149,0,0,1,150,0,0,1,148,0,0,1,148,0,0,1,150,0,0,1,94,0,0,1,151,0,0,1,152,0,0,1,150,0,0,1,150,0,0,1,152,0,0,1,94,0,0,1,153,0,0,1,154,0,0,1,152,0,0,1,152,0,0,1,154,0,0,1,94,0,0,1,155,0,0,1,156,0,0,1,154,0,0,1,154,0,0,1,156,0,0,1,94,0,0,1,156,0,0,1,157,0,0,1,94,0,0,1,94,0,0,1,157,0,0,1,158,0,0,1,159,0,0,1,160,0,0,1,156,0,0,1,156,0,0,1,160,0,0,1,157,0,0,1,160,0,0,1,161,0,0,1,157,0,0,1,157,0,0,1,161,0,0,1,162,0,0,1,163,0,0,1,164,0,0,1,160,0,0,1,160,0,0,1,164,0,0,1,161,0,0,1,164,0,0,1,165,0,0,1,161,0,0,1,161,0,0,1,165,0,0,1,166,0,0,1,167,0,0,1,168,0,0,1,164,0,0,1,164,0,0,1,168,0,0,1,165,0,0,1,169,0,0,1,170,0,0,1,167,0,0,1,167,0,0,1,170,0,0,1,168,0,0,1,171,0,0,1,172,0,0,1,169,0,0,1,169,0,0,1,172,0,0,1,170,0,0,1,172,0,0,1,173,0,0,1,170,0,0,1,170,0,0,1,173,0,0,1,174,0,0,1,175,0,0,1,176,0,0,1,172,0,0,1,172,0,0,1,176,0,0,1,173,0,0,1,177,0,0,1,178,0,0,1,175,0,0,1,175,0,0,1,178,0,0,1,176,0,0,1,179,0,0,1,180,0,0,1,178,0,0,1,178,0,0,1,180,0,0,1,176,0,0,1,181,0,0,1,182,0,0,1,180,0,0,1,180,0,0,1,182,0,0,1,176,0,0,1,183,0,0,1,184,0,0,1,182,0,0,1,182,0,0,1,184,0,0,1,176,0,0,1,185,0,0,1,186,0,0,1,184,0,0,1,184,0,0,1,186,0,0,1,176,0,0,1,187,0,0,1,188,0,0,1,186,0,0,1,186,0,0,1,188,0,0,1,176,0,0,1,189,0,0,1,190,0,0,1,188,0,0,1,188,0,0,1,190,0,0,1,176,0,0,1,191,0,0,1,192,0,0,1,190,0,0,1,190,0,0,1,192,0,0,1,176,0,0,1,193,0,0,1,194,0,0,1,192,0,0,1,192,0,0,1,194,0,0,1,176,0,0,1,195,0,0,1,196,0,0,1,194,0,0,1,194,0,0,1,196,0,0,1,176,0,0,1,197,0,0,1,198,0,0,1,196,0,0,1,196,0,0,1,198,0,0,1,176,0,0,1,199,0,0,1,200,0,0,1,198,0,0,1,198,0,0,1,200,0,0,1,176,0,0,1,201,0,0,1,202,0,0,1,200,0,0,1,200,0,0,1,202,0,0,1,176,0,0,1,202,0,0,1,203,0,0,1,176,0,0,1,176,0,0,1,203,0,0,1,204,0,0,1,203,0,0,1,205,0,0,1,204,0,0,1,204,0,0,1,205,0,0,1,206,0,0,1,205,0,0,1,207,0,0,1,206,0,0,1,206,0,0,1,207,0,0,1,208,0,0,1,209,0,0,1,210,0,0,1,205,0,0,1,205,0,0,1,210,0,0,1,207,0,0,1,209,0,0,1,211,0,0,1,210,0,0,1,210,0,0,1,211,0,0,1,212,0,0,1,209,0,0,1,213,0,0,1,211,0,0,1,211,0,0,1,213,0,0,1,214,0,0,1,209,0,0,1,215,0,0,1,213,0,0,1,213,0,0,1,215,0,0,1,216,0,0,1,209,0,0,1,217,0,0,1,215,0,0,1,215,0,0,1,217,0,0,1,218,0,0,1,209,0,0,1,219,0,0,1,217,0,0,1,217,0,0,1,219,0,0,1,220,0,0,1,209,0,0,1,221,0,0,1,219,0,0,1,219,0,0,1,221,0,0,1,222,0,0,1,209,0,0,1,223,0,0,1,221,0,0,1,221,0,0,1,223,0,0,1,224,0,0,1,209,0,0,1,225,0,0,1,223,0,0,1,223,0,0,1,225,0,0,1,226,0,0,1,209,0,0,1,227,0,0,1,225,0,0,1,225,0,0,1,227,0,0,1,228,0,0,1,209,0,0,1,229,0,0,1,227,0,0,1,227,0,0,1,229,0,0,1,230,0,0,1,209,0,0,1,231,0,0,1,229,0,0,1,229,0,0,1,231,0,0,1,232,69,78,68,66,69,71,73,78,0,0,0,20,0,0,4,80,66,246,235,107,63,128,0,0,193,84,208,20,66,247,92,28,63,123,218,241,193,85,48,85,66,245,46,165,63,128,0,0,193,158,109,250,193,235,52,162,63,123,218,241,66,241,196,143,193,235,143,40,63,111,101,134,66,242,33,190,193,184,113,13,63,123,218,241,66,244,127,164,194,190,172,100,63,123,218,241,194,159,178,124,194,186,65,6,63,128,0,0,194,164,39,227,194,182,97,203,63,123,218,241,194,169,24,95,193,158,242,176,63,111,101,134,194,245,253,60,193,184,241,222,63,90,165,252,194,245,43,2,193,210,66,39,63,111,101,134,194,243,148,136,194,240,134,11,63,111,101,134,66,2,78,60,194,239,71,200,63,61,150,23,66,15,3,254,194,236,214,122,63,111,101,134,66,26,247,207,194,247,201,252,0,0,0,0,65,133,104,115,194,247,167,109,63,24,60,19,65,133,85,208,194,248,148,44,0,0,0,0,65,86,58,251,66,241,54,201,63,24,60,19,66,2,173,250,66,241,88,108,0,0,0,0,66,2,192,52,66,242,211,156,63,24,60,19,65,236,59,205,66,224,252,238,63,111,101,134,66,86,34,156,66,229,210,137,63,123,218,241,66,62,161,72,66,219,61,231,63,111,101,134,66,108,182,17,66,2,173,250,63,24,60,19,194,241,54,201,66,2,192,52,0,0,0,0,194,241,88,108,65,236,59,205,63,24,60,19,194,242,211,156,66,86,34,156,63,111,101,134,194,224,252,238,66,62,161,72,63,123,218,241,194,229,210,137,66,108,182,17,63,111,101,134,194,219,61,231,65,84,208,20,63,128,0,0,66,246,235,107,65,85,48,85,63,123,218,241,66,247,92,28,65,158,109,250,63,128,0,0,66,245,46,165,192,215,152,200,63,24,60,19,66,249,129,111,192,215,63,125,63,90,165,252,66,249,24,252,193,33,38,129,63,24,60,19,66,249,15,184,66,249,129,111,63,24,60,19,64,215,152,200,66,249,24,252,63,90,165,252,64,215,63,125,66,249,15,184,63,24,60,19,65,33,38,129,66,246,74,179,63,90,165,252,65,159,36,116,66,246,177,249,63,24,60,19,65,159,102,207,66,247,63,177,63,90,165,252,65,133,30,132,194,150,76,139,63,90,165,252,66,199,8,128,194,145,120,121,63,24,60,19,66,203,25,167,194,140,17,209,63,90,165,252,66,206,96,157,194,203,25,167,63,24,60,19,194,145,120,121,194,203,53,247,0,0,0,0,194,145,140,218,194,206,183,23,63,24,60,19,194,140,76,165,194,230,43,15,63,111,101,134,194,62,234,232,194,232,211,143,63,90,165,252,194,51,76,231,194,234,195,176,63,111,101,134,194,39,24,95,66,199,8,128,63,90,165,252,66,150,76,139,66,203,25,167,63,24,60,19,66,145,120,121,66,206,96,157,63,90,165,252,66,140,17,196,66,150,76,139,63,90,165,252,194,199,8,128,66,145,120,121,63,24,60,19,194,203,25,167,66,140,17,196,63,90,165,252,194,206,96,157,194,232,211,143,63,90,165,252,66,51,76,231,194,232,138,88,63,111,101,134,66,51,20,97,194,235,71,17,63,61,150,23,66,39,117,247,194,216,109,132,63,90,165,252,66,120,13,132,194,213,105,186,63,61,150,23,66,129,150,148,194,209,219,205,63,90,165,252,66,134,208,20,66,232,211,143,63,90,165,252,194,51,76,231,66,232,138,88,63,111,101,134,194,51,20,97,66,235,71,17,63,61,150,23,194,39,117,247,66,216,109,132,63,90,165,252,194,120,13,132,66,213,105,186,63,61,150,23,194,129,150,148,66,209,219,205,63,90,165,252,194,134,208,20,66,51,76,231,63,90,165,252,66,232,211,143,66,51,20,97,63,111,101,134,66,232,138,88,66,39,117,247,63,61,150,23,66,235,71,17,66,120,13,132,63,90,165,252,66,216,109,132,66,129,150,148,63,61,150,23,66,213,105,186,66,134,208,20,63,90,165,252,66,209,219,205,194,249,15,27,63,111,101,134,192,87,177,91,194,249,177,144,63,61,150,23,128,0,0,0,194,249,93,139,63,90,165,252,64,87,242,229,194,248,148,44,0,0,0,0,193,86,58,251,194,248,113,131,63,24,60,19,193,86,29,21,194,247,201,239,0,0,0,0,193,133,104,115,194,15,28,251,63,24,60,19,66,239,113,131,194,15,3,254,63,61,150,23,66,239,71,187,194,27,105,199,63,24,60,19,66,237,132,103,194,109,0,210,63,90,165,252,66,219,130,222,194,98,0,0,63,61,150,23,66,222,171,133,194,86,102,50,63,90,165,252,66,225,67,176,194,244,127,164,63,123,218,241,193,184,113,13,194,242,199,253,63,128,0,0,193,209,146,6,194,241,196,143,63,123,218,241,193,235,52,162,194,98,39,135,63,24,60,19,194,222,210,97,194,97,200,154,63,90,165,252,194,222,117,37,194,86,192,79,63,24,60,19,194,225,162,39,194,145,59,127,63,90,165,252,194,202,196,169,194,150,113,104,63,61,150,23,194,199,57,49,194,155,68,103,63,90,165,252,194,195,44,192,194,51,76,231,63,90,165,252,194,232,211,143,194,51,20,97,63,111,101,134,194,232,138,88,194,39,117,247,63,61,150,23,194,235,71,17,194,74,218,160,63,90,165,252,194,227,238,7,64,215,152,200,63,24,60,19,194,249,129,111,64,215,63,125,63,90,165,252,194,249,24,252,65,33,38,129,63,24,60,19,194,249,15,184,65,159,36,116,63,90,165,252,194,246,74,179,65,159,102,207,63,24,60,19,194,246,177,249,65,133,30,132,63,90,165,252,194,247,63,177,194,210,51,195,63,24,60,19,66,135,8,180,194,187,24,187,63,90,165,252,66,164,230,50,194,186,221,231,63,111,101,134,66,164,178,71,194,195,44,192,63,90,165,252,66,155,68,103,66,135,8,180,63,24,60,19,66,210,51,195,66,164,230,50,63,90,165,252,66,187,24,187,66,164,178,71,63,111,101,134,66,186,221,231,66,155,68,103,63,90,165,252,66,195,44,192,66,210,51,195,63,24,60,19,194,135,8,180,66,187,24,187,63,90,165,252,194,164,230,50,66,186,221,231,63,111,101,134,194,164,178,71,66,195,44,192,63,90,165,252,194,155,68,103,194,248,84,215,63,128,0,0,128,0,0,0,194,248,106,232,63,123,218,241,64,214,171,54,194,247,249,180,63,128,0,0,64,214,74,140,194,246,74,179,63,90,165,252,65,159,36,116,194,245,253,60,63,111,101,134,65,158,242,176,194,247,63,177,63,90,165,252,65,133,30,132,193,133,104,115,0,0,0,0,194,247,201,252,193,133,86,4,63,24,60,19,194,247,167,109,193,86,58,251,0,0,0,0,194,248,148,44,64,87,177,91,63,111,101,134,194,249,15,27,128,0,0,0,63,61,150,23,194,249,177,144,192,87,244,136,63,90,165,252,194,249,93,139,65,133,85,208,63,24,60,19,66,247,167,95,65,133,104,115,0,0,0,0,66,247,201,239,65,159,102,207,63,24,60,19,66,246,177,249,66,2,78,86,63,111,101,134,66,240,134,11,66,15,3,254,63,61,150,23,66,239,71,187,66,26,247,207,63,111,101,134,66,236,214,122,66,247,167,95,63,24,60,19,193,133,86,4,66,247,201,239,0,0,0,0,193,133,104,115,66,246,177,249,63,24,60,19,193,159,102,207,66,240,134,11,63,111,101,134,194,2,78,86,66,239,71,187,63,61,150,23,194,15,3,254,66,236,214,122,63,111,101,134,194,26,247,207,194,109,58,225,63,61,150,23,66,219,184,134,194,135,8,180,63,24,60,19,66,210,51,195,194,140,52,31,63,61,150,23,66,206,147,25,66,98,71,43,0,0,0,0,194,222,241,118,66,98,39,135,63,24,60,19,194,222,210,97,66,109,133,162,0,0,0,0,194,219,253,139,66,15,48,242,0,0,0,0,194,239,146,229,66,239,146,229,0,0,0,0,66,15,48,242,66,222,241,118,0,0,0,0,66,98,71,43,66,222,210,97,63,24,60,19,66,98,39,135,66,219,253,139,0,0,0,0,66,109,133,162,193,159,36,116,63,90,165,252,66,246,74,179,193,159,102,207,63,24,60,19,66,246,177,249,193,133,30,132,63,90,165,252,66,247,63,177,66,178,85,11,63,111,101,134,194,173,229,96,66,169,184,108,63,61,150,23,194,183,14,86,66,169,142,243,63,90,165,252,194,182,225,163,66,178,184,239,63,61,150,23,194,174,70,194,194,178,85,24,63,111,101,134,66,173,229,96,194,169,184,108,63,61,150,23,66,183,14,86,194,169,142,243,63,90,165,252,66,182,225,163,194,178,184,239,63,61,150,23,66,174,70,194,66,173,229,96,63,111,101,134,66,178,85,11,66,183,14,86,63,61,150,23,66,169,184,108,66,182,225,163,63,90,165,252,66,169,142,243,66,174,70,194,63,61,150,23,66,178,184,239,194,235,112,33,63,24,60,19,194,39,147,64,194,235,13,145,63,90,165,252,194,39,77,1,194,233,53,37,63,24,60,19,194,51,152,43,194,240,209,209,63,90,165,252,194,2,119,76,194,241,54,201,63,24,60,19,194,2,173,250,194,242,169,68,63,61,150,23,193,236,18,215,66,249,24,252,63,90,165,252,192,215,63,125,66,249,129,111,63,24,60,19,192,215,152,200,66,248,228,64,63,61,150,23,193,33,10,166,66,248,148,44,0,0,0,0,193,86,58,251,64,215,63,125,63,90,165,252,66,249,24,252,64,215,152,200,63,24,60,19,66,249,129,111,65,33,10,166,63,61,150,23,66,248,228,64,65,86,58,251,0,0,0,0,66,248,148,44,194,198,201,252,63,111,101,134,194,150,29,60,194,205,208,125,63,123,218,241,194,139,175,184,194,190,245,221,63,111,101,134,194,159,240,20,194,219,184,134,63,61,150,23,194,109,58,251,194,219,130,222,63,90,165,252,194,109,0,210,194,216,162,104,63,61,150,23,194,120,74,88,194,216,200,62,63,24,60,19,194,120,117,221,194,216,230,116,0,0,0,0,194,120,152,147,194,219,222,224,63,24,60,19,194,109,100,116,194,228,109,106,0,0,0,0,194,75,76,74,194,228,77,145,63,24,60,19,194,75,47,236,194,225,193,150,0,0,0,0,194,86,222,79,194,169,214,17,63,24,60,19,194,183,46,86,194,169,237,198,0,0,0,0,194,183,71,227,194,174,101,44,63,24,60,19,194,178,216,29,194,199,119,194,0,0,0,0,194,150,160,184,194,174,28,41,63,90,165,252,194,178,141,54,194,173,229,96,63,111,101,134,194,178,85,24,194,164,230,50,63,90,165,252,194,187,24,187,194,155,19,130,63,111,101,134,194,194,239,105,193,159,102,207,63,24,60,19,194,246,177,249,194,39,170,179,0,0,0,0,194,235,144,242,194,39,147,64,63,24,60,19,194,235,112,33,194,27,127,125,0,0,0,0,194,237,165,149,194,235,144,242,0,0,0,0,66,39,170,179,194,235,112,33,63,24,60,19,66,39,147,64,194,237,165,149,0,0,0,0,66,27,127,125,194,246,177,249,63,24,60,19,65,159,102,207,66,222,171,133,63,61,150,23,66,98,0,0,66,219,130,222,63,90,165,252,66,109,0,210,66,219,184,134,63,61,150,23,66,109,58,225,66,210,51,195,63,24,60,19,66,135,8,180,66,206,147,25,63,61,150,23,66,140,52,31,66,135,8,180,63,24,60,19,194,210,51,195,66,140,52,31,63,61,150,23,194,206,147,25,66,98,0,0,63,61,150,23,194,222,171,133,66,109,0,210,63,90,165,252,194,219,130,222,66,109,58,225,63,61,150,23,194,219,184,134,66,242,33,190,63,111,101,134,65,235,143,40,66,241,196,143,63,123,218,241,65,235,52,162,66,238,194,25,63,111,101,134,66,14,180,31,66,244,127,164,63,123,218,241,65,184,113,13,65,235,143,40,63,111,101,134,194,242,33,190,65,235,52,162,63,123,218,241,194,241,196,143,66,14,180,31,63,111,101,134,194,238,194,25,65,184,113,13,63,123,218,241,194,244,127,164,194,222,171,133,63,61,150,23,66,98,0,0,194,222,117,37,63,90,165,252,66,97,200,154,194,225,162,39,63,24,60,19,66,86,192,79,66,222,210,97,63,24,60,19,194,98,39,135,66,222,117,37,63,90,165,252,194,97,200,154,66,225,162,39,63,24,60,19,194,86,192,79,66,98,0,0,63,61,150,23,66,222,171,133,66,97,200,154,63,90,165,252,66,222,117,37,66,86,192,79,63,24,60,19,66,225,162,39,194,63,119,128,63,24,60,19,66,230,212,18,194,63,86,4,63,61,150,23,66,230,171,212,194,75,47,236,63,24,60,19,66,228,77,145,193,33,10,166,63,61,150,23,66,248,228,64,193,32,177,196,63,111,101,134,66,248,89,62,193,85,248,56,63,61,150,23,66,248,70,37,66,248,228,64,63,61,150,23,65,33,10,166,66,248,89,62,63,111,101,134,65,32,177,196,66,248,70,37,63,61,150,23,65,85,248,56,194,135,8,180,63,24,60,19,194,210,51,195,194,134,208,20,63,90,165,252,194,209,219,205,194,129,150,148,63,61,150,23,194,213,105,186,194,191,130,25,63,24,60,19,66,160,101,188,194,191,156,211,0,0,0,0,66,160,124,28,194,187,103,43,63,24,60,19,66,165,43,94,194,213,142,243,63,24,60,19,66,129,173,67,194,213,172,192,0,0,0,0,66,129,191,99,66,191,130,25,63,24,60,19,194,160,101,188,66,191,156,211,0,0,0,0,194,160,124,28,66,187,103,43,63,24,60,19,194,165,43,107,66,213,142,243,63,24,60,19,194,129,173,67,66,213,172,192,0,0,0,0,194,129,191,112,66,160,101,188,63,24,60,19,66,191,130,25,66,160,124,28,0,0,0,0,66,191,156,211,66,165,43,107,63,24,60,19,66,187,103,43,66,129,173,67,63,24,60,19,66,213,142,243,66,129,191,99,0,0,0,0,66,213,172,192,194,206,31,190,63,111,101,134,194,139,229,162,194,212,160,184,63,123,218,241,194,129,28,41,65,236,59,205,63,24,60,19,66,242,211,156,65,236,92,198,0,0,0,0,66,242,245,129,66,2,173,250,63,24,60,19,66,241,54,201,66,39,170,179,0,0,0,0,66,235,144,242,66,39,147,64,63,24,60,19,66,235,112,33,66,27,127,125,0,0,0,0,66,237,165,149,66,242,211,156,63,24,60,19,193,236,60,2,66,242,245,129,0,0,0,0,193,236,92,198,66,241,54,201,63,24,60,19,194,2,173,250,66,235,144,242,0,0,0,0,194,39,170,179,66,235,112,33,63,24,60,19,194,39,147,64,66,237,165,149,0,0,0,0,194,27,127,125,194,249,129,111,63,24,60,19,64,215,152,200,194,249,164,64,0,0,0,0,64,215,182,70,194,249,15,184,63,24,60,19,65,33,38,129,66,62,234,232,63,111,101,134,194,230,43,15,66,75,47,236,63,24,60,19,194,228,77,145,66,75,76,74,0,0,0,0,194,228,109,106,66,63,119,128,63,24,60,19,194,230,212,31,66,230,43,15,63,111,101,134,66,62,234,232,66,228,77,145,63,24,60,19,66,75,47,236,66,228,109,106,0,0,0,0,66,75,76,74,66,230,212,18,63,24,60,19,66,63,119,128,194,246,74,179,63,90,165,252,193,159,36,116,194,244,221,231,63,111,101,134,193,184,183,233,194,245,43,2,63,90,165,252,193,184,241,222,194,249,24,252,63,90,165,252,192,215,63,125,194,248,89,62,63,111,101,134,193,32,177,196,194,248,228,64,63,61,150,23,193,33,10,166,194,242,211,156,63,24,60,19,65,236,59,205,194,242,245,129,0,0,0,0,65,236,92,198,194,241,54,201,63,24,60,19,66,2,173,250,194,240,209,209,63,90,165,252,66,2,119,76,194,242,169,68,63,61,150,23,65,236,18,215,194,2,119,76,63,90,165,252,194,240,209,209,194,2,78,86,63,111,101,134,194,240,134,24,193,236,18,215,63,61,150,23,194,242,169,68,193,236,60,2,63,24,60,19,194,242,211,156,193,236,92,198,0,0,0,0,194,242,245,129,194,2,173,250,63,24,60,19,194,241,54,201,192,214,171,54,63,123,218,241,194,248,106,232,192,86,254,197,63,128,0,0,194,248,61,244,64,87,95,112,63,123,218,241,194,248,175,66,193,159,36,116,63,90,165,252,194,246,74,179,193,133,30,132,63,90,165,252,194,247,63,177,194,51,76,231,63,90,165,252,66,232,211,143,194,51,152,43,63,24,60,19,66,233,53,37,194,39,77,1,63,90,165,252,66,235,13,145,194,85,207,249,63,123,218,241,66,224,166,89,194,86,34,156,63,111,101,134,66,224,252,238,194,38,215,246,63,123,218,241,66,234,105,95,66,240,209,209,63,90,165,252,194,2,119,76,66,242,169,68,63,61,150,23,193,236,18,215,66,245,253,60,63,111,101,134,193,158,242,176,66,245,43,2,63,90,165,252,193,184,241,222,66,243,148,136,63,111,101,134,193,210,66,39,66,2,119,76,63,90,165,252,66,240,209,209,65,236,18,215,63,61,150,23,66,242,169,68,65,158,242,176,63,111,101,134,66,245,253,60,65,184,241,170,63,90,165,252,66,245,43,2,65,210,66,39,63,111,101,134,66,243,148,136,194,244,105,160,0,0,0,0,193,210,249,114,194,244,71,135,63,24,60,19,193,210,220,41,194,242,245,129,0,0,0,0,193,236,92,198,194,245,145,209,63,24,60,19,193,185,63,20,194,245,180,18,0,0,0,0,193,185,88,226,194,246,177,249,63,24,60,19,193,159,102,207,194,182,168,23,63,111,101,134,194,169,89,154,194,182,225,163,63,90,165,252,194,169,142,243,194,187,103,43,63,24,60,19,194,165,43,107,194,187,129,85,0,0,0,0,194,165,66,117,194,191,130,39,63,24,60,19,194,160,101,188,193,185,63,20,63,24,60,19,66,245,145,209,193,185,88,174,0,0,0,0,66,245,180,18,194,2,119,76,63,90,165,252,66,240,209,209,194,2,173,250,63,24,60,19,66,241,54,201,193,236,18,215,63,61,150,23,66,242,169,68,66,199,57,49,63,61,150,23,66,150,113,91,66,191,96,184,63,61,150,23,66,160,73,173,66,187,129,85,0,0,0,0,66,165,66,117,66,187,103,43,63,24,60,19,66,165,43,107,66,183,71,227,0,0,0,0,66,169,237,198,66,150,113,91,63,61,150,23,194,199,57,49,66,160,73,173,63,61,150,23,194,191,96,184,66,165,66,117,0,0,0,0,194,187,129,85,66,165,43,107,63,24,60,19,194,187,103,43,66,169,237,198,0,0,0,0,194,183,71,227,194,150,113,104,63,61,150,23,66,199,57,49,194,160,73,186,63,61,150,23,66,191,96,184,194,165,66,117,0,0,0,0,66,187,129,85,194,165,43,107,63,24,60,19,66,187,103,43,194,169,237,198,0,0,0,0,66,183,71,227,66,227,238,7,63,90,165,252,194,74,218,160,66,74,218,160,63,90,165,252,66,227,238,7,194,227,238,7,63,90,165,252,66,74,218,160,64,87,242,229,63,90,165,252,194,249,93,139,64,88,77,1,63,24,60,19,194,249,198,24,192,87,244,136,63,90,165,252,66,249,93,139,192,88,77,1,63,24,60,19,66,249,198,24,128,0,0,0,63,61,150,23,66,249,177,144,66,249,93,139,63,90,165,252,64,87,242,229,66,249,198,24,63,24,60,19,64,88,77,1,66,249,177,144,63,61,150,23,128,0,0,0,66,245,145,209,63,24,60,19,65,185,63,20,66,245,180,18,0,0,0,0,65,185,88,174,65,185,63,20,63,24,60,19,194,245,145,209,65,185,88,174,0,0,0,0,194,245,180,18,65,33,10,166,63,61,150,23,194,248,228,64,65,32,177,196,63,111,101,134,194,248,89,62,65,85,248,56,63,61,150,23,194,248,70,37,194,15,3,254,63,61,150,23,194,239,71,200,194,26,247,207,63,111,101,134,194,236,214,122,194,120,13,132,63,90,165,252,194,216,109,132,194,150,139,172,63,24,60,19,194,199,91,245,194,150,160,184,0,0,0,0,194,199,119,194,194,155,133,162,63,24,60,19,194,195,126,145,194,165,66,117,0,0,0,0,194,187,129,85,66,234,105,95,63,123,218,241,66,38,215,246,66,38,215,246,63,123,218,241,194,234,105,95,192,87,177,91,63,111,101,134,66,249,15,27,128,0,0,0,63,61,150,23,66,249,177,144,64,87,244,136,63,90,165,252,66,249,93,139,66,249,15,27,63,111,101,134,64,87,177,91,66,249,93,139,63,90,165,252,192,87,244,136,194,233,85,181,0,0,0,0,194,51,177,91,194,249,15,184,63,24,60,19,193,33,38,129,194,249,50,124,0,0,0,0,193,33,60,159,194,249,129,111,63,24,60,19,192,215,152,200,194,249,232,246,0,0,0,0,64,88,106,127,194,249,198,24,63,24,60,19,64,88,77,1,194,250,0,0,0,0,0,0,128,0,0,0,193,210,249,114,0,0,0,0,194,244,105,160,194,244,105,160,0,0,0,0,65,210,249,114,66,244,105,147,0,0,0,0,193,210,249,114,65,210,249,114,0,0,0,0,66,244,105,147,194,139,175,184,63,123,218,241,66,205,208,125,194,139,111,249,63,128,0,0,66,205,114,202,194,149,227,97,63,123,218,241,66,198,125,126,194,108,182,17,63,111,101,134,66,219,61,231,194,160,34,130,63,90,165,252,66,191,49,249,66,160,34,130,63,90,165,252,194,191,49,249,66,191,49,249,63,90,165,252,66,160,34,130,66,233,85,168,0,0,0,0,66,51,177,65,66,233,53,37,63,24,60,19,66,51,152,43,66,230,244,70,0,0,0,0,66,63,146,58,66,51,177,65,0,0,0,0,194,233,85,181,66,51,152,43,63,24,60,19,194,233,53,37,66,63,146,58,0,0,0,0,194,230,244,70,194,213,172,192,0,0,0,0,194,129,191,112,194,199,119,194,0,0,0,0,66,150,160,184,194,199,91,245,63,24,60,19,66,150,139,172,194,203,53,247,0,0,0,0,66,145,140,218,66,150,160,184,0,0,0,0,66,199,119,194,66,150,139,172,63,24,60,19,66,199,91,245,66,145,140,218,0,0,0,0,66,203,53,247,66,199,119,194,0,0,0,0,194,150,160,184,66,199,91,245,63,24,60,19,194,150,139,172,66,203,53,247,0,0,0,0,194,145,140,218,194,86,222,79,0,0,0,0,194,225,193,150,194,75,76,74,0,0,0,0,194,228,109,106,194,51,152,43,63,24,60,19,194,233,53,37,194,233,53,37,63,24,60,19,66,51,152,43,194,225,193,150,0,0,0,0,66,86,222,79,194,228,109,106,0,0,0,0,66,75,76,74,66,233,53,37,63,24,60,19,194,51,152,43,66,225,193,150,0,0,0,0,194,86,222,79,66,228,109,106,0,0,0,0,194,75,76,74,66,51,152,43,63,24,60,19,66,233,53,37,66,86,222,79,0,0,0,0,66,225,193,150,66,75,76,74,0,0,0,0,66,228,109,106,194,183,71,227,0,0,0,0,194,169,237,198,194,14,180,31,63,111,101,134,66,238,194,25,194,39,24,69,63,111,101,134,66,234,195,176,194,62,234,232,63,111,101,134,66,230,43,15,194,225,67,189,63,90,165,252,194,86,102,50,194,224,252,238,63,111,101,134,194,86,34,156,194,245,43,2,63,90,165,252,65,184,241,170,194,243,148,136,63,111,101,134,65,210,66,39,66,174,101,44,63,24,60,19,194,178,216,29,66,174,125,139,0,0,0,0,194,178,241,26,66,169,214,17,63,24,60,19,194,183,46,86,66,183,71,227,0,0,0,0,194,169,237,198,66,183,46,86,63,24,60,19,194,169,214,17,66,187,129,85,0,0,0,0,194,165,66,117,194,174,101,44,63,24,60,19,66,178,216,29,194,174,125,139,0,0,0,0,66,178,241,26,194,169,214,17,63,24,60,19,66,183,46,86,194,183,71,227,0,0,0,0,66,169,237,198,194,183,46,86,63,24,60,19,66,169,214,17,194,187,129,85,0,0,0,0,66,165,66,117,66,178,216,29,63,24,60,19,66,174,101,44,66,178,241,26,0,0,0,0,66,174,125,139,66,183,46,86,63,24,60,19,66,169,214,17,66,169,237,198,0,0,0,0,66,183,71,227,66,169,214,17,63,24,60,19,66,183,46,86,66,165,66,117,0,0,0,0,66,187,129,85,194,230,171,225,63,61,150,23,66,63,86,4,194,227,166,102,63,111,101,134,66,74,154,186,66,230,171,212,63,61,150,23,194,63,86,4,66,227,166,102,63,111,101,134,194,74,154,186,66,63,86,4,63,61,150,23,66,230,171,212,66,74,154,186,63,111,101,134,66,227,166,102,66,216,230,116,0,0,0,0,194,120,152,147,66,120,152,147,0,0,0,0,66,216,230,116,66,98,39,135,63,24,60,19,66,222,210,97,194,129,191,112,0,0,0,0,194,213,172,192,194,129,173,67,63,24,60,19,194,213,143,0,194,120,152,147,0,0,0,0,194,216,230,116,194,222,210,97,63,24,60,19,66,98,39,135,194,216,230,116,0,0,0,0,66,120,152,147,194,145,140,218,0,0,0,0,194,203,53,247,194,164,178,71,63,111,101,134,194,186,221,231,194,234,105,95,63,123,218,241,194,38,215,246,194,238,102,63,63,123,218,241,194,14,125,34,194,238,194,25,63,111,101,134,194,14,180,31,194,194,239,105,63,111,101,134,66,155,19,130,194,202,196,169,63,90,165,252,66,145,59,127,66,155,19,130,63,111,101,134,66,194,239,105,66,145,59,127,63,90,165,252,66,202,196,169,66,194,239,105,63,111,101,134,194,155,19,130,66,202,196,169,63,90,165,252,194,145,59,127,192,88,106,127,0,0,0,0,194,249,232,246,192,88,77,1,63,24,60,19,194,249,198,24,128,0,0,0,0,0,0,0,194,250,0,0,192,215,152,200,63,24,60,19,194,249,129,111,192,215,182,70,0,0,0,0,194,249,164,64,193,33,38,129,63,24,60,19,194,249,15,184,66,249,164,64,0,0,0,0,192,215,182,70,66,249,15,184,63,24,60,19,193,33,38,129,66,249,232,246,0,0,0,0,192,88,106,127,66,249,198,24,63,24,60,19,192,88,77,1,66,250,0,0,0,0,0,0,128,0,0,0,64,215,182,70,0,0,0,0,66,249,164,64,65,33,38,129,63,24,60,19,66,249,15,184,64,88,106,127,0,0,0,0,66,249,232,246,64,88,77,1,63,24,60,19,66,249,198,24,128,0,0,0,0,0,0,0,66,250,0,0,66,160,101,188,63,24,60,19,194,191,130,39,66,160,124,28,0,0,0,0,194,191,156,211,66,155,133,162,63,24,60,19,194,195,126,145,66,140,76,165,63,24,60,19,194,206,183,23,66,140,96,66,0,0,0,0,194,206,211,248,66,191,130,39,63,24,60,19,66,160,101,188,66,191,156,211,0,0,0,0,66,160,124,28,66,195,126,145,63,24,60,19,66,155,133,162,66,206,183,23,63,24,60,19,66,140,76,165,66,206,211,235,0,0,0,0,66,140,96,66,194,140,76,165,63,24,60,19,66,206,183,23,194,140,96,66,0,0,0,0,66,206,211,235,194,160,101,188,63,24,60,19,66,191,130,39,194,160,124,28,0,0,0,0,66,191,156,211,194,155,133,162,63,24,60,19,66,195,126,145,194,246,241,236,63,111,101,134,193,132,244,241,194,248,70,37,63,61,150,23,193,85,248,56,193,159,124,238,0,0,0,0,66,246,212,97,193,33,60,159,0,0,0,0,66,249,50,124,66,246,212,97,0,0,0,0,65,159,124,238,66,249,50,124,0,0,0,0,65,33,60,159,65,159,124,238,0,0,0,0,194,246,212,110,65,33,60,159,0,0,0,0,194,249,50,124,66,27,105,199,63,24,60,19,194,237,132,116,66,27,127,125,0,0,0,0,194,237,165,149,66,15,28,251,63,24,60,19,194,239,113,131,66,39,24,69,63,111,101,134,194,234,195,176,66,27,40,167,63,90,165,252,194,237,33,6,66,237,132,103,63,24,60,19,66,27,105,199,66,237,165,149,0,0,0,0,66,27,127,125,66,239,113,131,63,24,60,19,66,15,28,251,66,234,195,176,63,111,101,134,66,39,24,69,66,237,33,6,63,90,165,252,66,27,40,167,66,210,81,13,0,0,0,0,66,135,27,153,66,219,222,224,63,24,60,19,66,109,100,116,66,135,27,153,0,0,0,0,194,210,81,13,66,109,100,116,63,24,60,19,194,219,222,224,194,135,27,153,0,0,0,0,66,210,81,13,194,109,100,116,63,24,60,19,66,219,222,224,194,109,133,162,0,0,0,0,66,219,253,139,194,98,39,135,63,24,60,19,66,222,210,97,193,85,48,85,63,123,218,241,194,247,92,28,193,32,44,61,63,128,0,0,194,247,136,167,194,206,147,25,63,61,150,23,194,140,52,31,194,206,96,157,63,90,165,252,194,140,17,209,194,210,51,195,63,24,60,19,194,135,8,180,194,213,53,168,63,90,165,252,194,129,118,214,66,205,208,125,63,123,218,241,66,139,175,184,66,205,114,202,63,128,0,0,66,139,111,236,66,198,125,126,63,123,218,241,66,149,227,84,66,218,133,240,63,128,0,0,66,107,238,204,66,218,233,147,63,123,218,241,66,108,90,186,66,226,231,82,63,128,0,0,66,73,240,33,66,139,175,184,63,123,218,241,194,205,208,125,66,139,111,236,63,128,0,0,194,205,114,202,66,149,227,84,63,123,218,241,194,198,125,126,66,107,238,204,63,128,0,0,194,218,133,240,66,108,90,186,63,123,218,241,194,218,233,147,66,73,240,33,63,128,0,0,194,226,231,82,194,249,93,139,63,90,165,252,192,87,244,136,194,249,198,24,63,24,60,19,192,88,77,1,194,249,232,246,0,0,0,0,192,88,106,127,194,249,221,34,63,24,60,19,128,0,0,0,194,230,212,31,63,24,60,19,194,63,119,128,194,230,171,212,63,61,150,23,194,63,86,4,194,227,238,7,63,90,165,252,194,74,218,160,194,14,125,34,63,123,218,241,66,238,102,63,194,199,57,49,63,61,150,23,66,150,113,91,194,195,126,145,63,24,60,19,66,155,133,162,66,150,113,104,63,61,150,23,66,199,57,49,66,155,133,162,63,24,60,19,66,195,126,145,66,199,57,49,63,61,150,23,194,150,113,104,66,195,126,145,63,24,60,19,194,155,133,162,194,128,225,59,63,128,0,0,66,212,63,243,194,129,28,41,63,123,218,241,66,212,160,184,194,96,195,150,63,128,0,0,66,221,116,202,66,247,249,167,63,123,218,241,65,32,116,188,66,247,136,167,63,128,0,0,65,32,44,61,66,246,146,229,63,123,218,241,65,132,194,39,193,32,116,188,63,123,218,241,66,247,249,167,193,32,44,61,63,128,0,0,66,247,136,167,193,132,194,39,63,123,218,241,66,246,146,229,192,87,177,91,63,111,101,134,66,249,15,27,65,32,116,188,63,123,218,241,194,247,249,167,65,32,44,61,63,128,0,0,194,247,136,167,65,132,194,39,63,123,218,241,194,246,146,229,193,184,29,73,63,128,0,0,66,244,16,72,193,132,134,37,63,128,0,0,66,246,34,143,66,244,16,72,63,128,0,0,65,184,29,73,66,246,34,143,63,128,0,0,65,132,134,37,65,132,134,37,63,128,0,0,194,246,34,143,65,184,29,73,63,128,0,0,194,244,16,72,194,199,57,49,63,61,150,23,194,150,113,104,194,199,8,128,63,90,165,252,194,150,76,139,194,191,96,184,63,61,150,23,194,160,73,186,194,249,24,252,63,90,165,252,64,215,63,125,194,248,228,64,63,61,150,23,65,33,10,166,194,248,202,166,63,111,101,134,64,214,252,80,194,247,187,127,63,111,101,134,65,85,129,216,192,215,63,125,63,90,165,252,194,249,24,252,193,33,10,166,63,61,150,23,194,248,228,64,192,214,253,34,63,111,101,134,194,248,202,166,193,85,129,216,63,111,101,134,194,247,187,127,194,241,88,108,0,0,0,0,194,2,192,52,194,242,211,156,63,24,60,19,193,236,60,2,194,237,165,149,0,0,0,0,194,27,127,125,194,237,132,116,63,24,60,19,194,27,105,199,194,235,144,242,0,0,0,0,194,39,170,179,194,27,127,125,0,0,0,0,66,237,165,149,194,51,177,91,0,0,0,0,66,233,85,168,194,63,146,58,0,0,0,0,66,230,244,70,66,248,106,219,63,123,218,241,192,214,171,54,66,248,61,244,63,128,0,0,192,86,254,197,66,248,175,66,63,123,218,241,64,87,95,112,64,214,171,54,63,123,218,241,66,248,106,219,64,86,254,197,63,128,0,0,66,248,61,244,192,87,95,112,63,123,218,241,66,248,175,66,194,75,76,74,0,0,0,0,66,228,109,106,194,98,71,43,0,0,0,0,66,222,241,118,194,221,217,193,63,123,218,241,66,97,42,101,194,221,116,202,63,128,0,0,66,96,195,150,194,227,78,204,63,123,218,241,66,74,76,126,194,215,116,31,63,128,0,0,66,118,238,204,194,215,214,96,63,123,218,241,66,119,95,190,194,208,233,252,63,128,0,0,66,134,52,70,66,221,217,193,63,123,218,241,194,97,42,127,66,221,116,202,63,128,0,0,194,96,195,150,66,227,78,204,63,123,218,241,194,74,76,126,66,215,116,31,63,128,0,0,194,118,238,204,66,215,214,96,63,123,218,241,194,119,95,190,66,208,233,252,63,128,0,0,194,134,52,70,66,97,42,101,63,123,218,241,66,221,217,193,66,96,195,150,63,128,0,0,66,221,116,202,66,74,76,126,63,123,218,241,66,227,78,204,66,118,238,204,63,128,0,0,66,215,116,31,66,119,95,190,63,123,218,241,66,215,214,96,66,134,52,70,63,128,0,0,66,208,233,252,194,201,218,251,63,128,0,0,66,144,147,182,194,202,55,10,63,123,218,241,66,144,213,208,194,194,75,199,63,128,0,0,66,154,145,26,194,209,73,68,63,123,218,241,66,134,113,157,66,144,147,182,63,128,0,0,66,201,218,251,66,144,213,208,63,123,218,241,66,202,55,10,66,154,145,39,63,128,0,0,66,194,75,199,66,134,113,157,63,123,218,241,66,209,73,55,66,201,218,251,63,128,0,0,194,144,147,182,66,202,55,10,63,123,218,241,194,144,213,208,66,194,75,199,63,128,0,0,194,154,145,39,66,209,73,55,63,123,218,241,194,134,113,170,66,198,201,252,63,111,101,134,66,150,29,60,66,190,245,221,63,111,101,134,66,159,240,20,66,182,168,23,63,111,101,134,66,169,89,140,66,150,29,60,63,111,101,134,194,198,201,252,66,159,240,20,63,111,101,134,194,190,245,221,66,169,89,140,63,111,101,134,194,182,168,23,194,150,29,60,63,111,101,134,66,198,201,252,194,159,240,20,63,111,101,134,66,190,245,221,194,169,89,154,63,111,101,134,66,182,168,23,66,169,24,95,63,123,218,241,194,182,97,203,66,182,97,203,63,123,218,241,66,169,24,95,194,169,24,95,63,123,218,241,66,182,97,203,194,62,74,61,63,128,0,0,194,229,105,226,194,74,76,126,63,123,218,241,194,227,78,204,194,85,110,99,63,128,0,0,194,224,64,26,194,14,60,80,63,128,0,0,194,237,249,167,194,26,188,28,63,123,218,241,194,236,123,87,194,38,139,199,63,128,0,0,194,233,254,158,194,215,116,31,63,128,0,0,194,118,238,204,194,218,233,147,63,123,218,241,194,108,90,186,194,221,116,202,63,128,0,0,194,96,195,150,194,212,63,243,63,128,0,0,194,128,225,59,194,97,42,127,63,123,218,241,194,221,217,193,194,107,238,204,63,128,0,0,194,218,133,240,194,119,95,190,63,123,218,241,194,215,214,96,194,128,225,59,63,128,0,0,194,212,63,243,194,139,111,249,63,128,0,0,194,205,114,202,194,144,213,208,63,123,218,241,194,202,55,10,194,149,158,250,63,128,0,0,194,198,35,32,194,134,113,157,63,123,218,241,194,209,73,68,66,248,202,166,63,111,101,134,192,214,253,34,66,247,187,113,63,111,101,134,193,85,129,216,66,246,74,179,63,90,165,252,193,159,36,116,66,247,63,177,63,90,165,252,193,133,30,132,65,159,36,116,63,90,165,252,66,246,74,179,65,133,30,132,63,90,165,252,66,247,63,177,64,214,253,34,63,111,101,134,66,248,202,166,65,85,129,216,63,111,101,134,66,247,187,113,194,249,164,64,0,0,0,0,192,215,182,70,66,155,155,87,0,0,0,0,194,195,153,219,66,195,153,219,0,0,0,0,66,155,155,87,194,155,155,87,0,0,0,0,66,195,153,219,194,2,192,52,0,0,0,0,66,241,88,108,194,15,48,242,0,0,0,0,66,239,146,229,193,236,59,205,63,24,60,19,66,242,211,156,194,239,188,28,63,128,0,0,194,1,224,249,66,230,171,212,63,61,150,23,66,63,86,4,66,232,211,143,63,90,165,252,66,51,76,231,66,239,71,187,63,61,150,23,66,15,3,254,66,15,3,254,63,61,150,23,194,239,71,187,66,63,86,4,63,61,150,23,194,230,171,212,66,51,76,231,63,90,165,252,194,232,211,143,66,242,169,68,63,61,150,23,65,236,18,163,66,240,209,209,63,90,165,252,66,2,119,76,65,236,18,163,63,61,150,23,194,242,169,68,66,2,119,76,63,90,165,252,194,240,209,209,194,247,167,95,63,24,60,19,193,133,86,4,194,247,63,177,63,90,165,252,193,133,30,132,193,185,63,20,63,24,60,19,194,245,145,209,193,185,88,174,0,0,0,0,194,245,180,18,193,210,220,41,63,24,60,19,194,244,71,135,193,210,132,25,63,90,165,252,194,243,225,59,66,245,145,209,63,24,60,19,193,185,63,20,66,245,180,18,0,0,0,0,193,185,88,174,66,244,71,135,63,24,60,19,193,210,220,41,66,243,225,59,63,90,165,252,193,210,132,25,194,245,145,209,63,24,60,19,65,185,63,20,194,245,180,18,0,0,0,0,65,185,88,174,194,244,71,135,63,24,60,19,65,210,220,41,194,243,225,59,63,90,165,252,65,210,132,25,65,210,132,25,63,90,165,252,66,243,225,59,65,185,63,20,63,24,60,19,66,245,145,209,65,185,88,174,0,0,0,0,66,245,180,18,65,210,220,41,63,24,60,19,66,244,71,135,194,237,33,6,63,90,165,252,66,27,40,167,194,239,113,131,63,24,60,19,66,15,28,251,194,239,146,242,0,0,0,0,66,15,48,242,194,237,132,116,63,24,60,19,66,27,105,199,66,15,28,251,63,24,60,19,66,239,113,131,66,15,48,242,0,0,0,0,66,239,146,242,66,27,105,199,63,24,60,19,66,237,132,116,66,27,40,167,63,90,165,252,66,237,33,6,66,239,113,131,63,24,60,19,194,15,28,251,66,239,146,242,0,0,0,0,194,15,48,242,66,237,132,116,63,24,60,19,194,27,105,199,66,237,33,6,63,90,165,252,194,27,40,167,194,15,28,251,63,24,60,19,194,239,113,131,194,15,48,242,0,0,0,0,194,239,146,242,194,27,105,199,63,24,60,19,194,237,132,116,194,27,40,167,63,90,165,252,194,237,33,6,194,242,33,190,63,111,101,134,193,235,143,40,66,86,102,50,63,90,165,252,194,225,67,189,66,225,67,176,63,90,165,252,66,86,102,50,66,238,102,63,63,123,218,241,66,14,125,34,66,14,125,34,63,123,218,241,194,238,102,63,194,160,101,188,63,24,60,19,194,191,130,25,194,160,124,28,0,0,0,0,194,191,156,211,194,165,43,107,63,24,60,19,194,187,103,43,194,178,216,29,63,24,60,19,194,174,101,44,194,178,241,26,0,0,0,0,194,174,125,139,194,183,46,86,63,24,60,19,194,169,214,17,194,75,47,236,63,24,60,19,194,228,77,145,194,63,86,4,63,61,150,23,194,230,171,225,194,63,119,128,63,24,60,19,194,230,212,31,194,63,146,58,0,0,0,0,194,230,244,84,194,228,77,145,63,24,60,19,66,75,47,236,194,230,212,31,63,24,60,19,66,63,119,128,194,230,244,84,0,0,0,0,66,63,146,58,66,230,212,18,63,24,60,19,194,63,119,128,66,230,244,70,0,0,0,0,194,63,146,58,66,228,77,145,63,24,60,19,194,75,47,236,66,75,47,236,63,24,60,19,66,228,77,145,66,63,119,128,63,24,60,19,66,230,212,18,66,63,146,58,0,0,0,0,66,230,244,70,194,248,175,66,63,123,218,241,192,87,95,112,194,246,235,107,63,128,0,0,193,84,208,20,194,247,249,167,63,123,218,241,193,32,116,188,194,247,249,180,63,128,0,0,192,214,74,140,66,178,216,29,63,24,60,19,194,174,101,44,66,178,141,54,63,90,165,252,194,174,28,41,66,187,70,116,63,61,150,23,194,165,14,138,66,174,101,44,63,24,60,19,66,178,216,29,66,174,28,28,63,90,165,252,66,178,141,54,66,165,14,138,63,61,150,23,66,187,70,116,194,178,216,29,63,24,60,19,66,174,101,44,194,178,141,54,63,90,165,252,66,174,28,28,194,187,70,129,63,61,150,23,66,165,14,138,194,246,146,229,63,123,218,241,193,132,194,39,194,245,46,165,63,128,0,0,193,158,109,250,193,209,241,118,63,123,218,241,194,243,54,201,193,184,29,73,63,128,0,0,194,244,16,72,193,158,181,221,63,123,218,241,194,245,158,132,193,132,134,37,63,128,0,0,194,246,34,143,194,2,28,41,63,123,218,241,194,240,41,134,193,234,201,186,63,128,0,0,194,241,86,109,194,226,231,82,63,128,0,0,66,73,240,33,194,232,48,229,63,123,218,241,66,50,207,92,66,226,231,82,63,128,0,0,194,73,240,59,66,232,48,229,63,123,218,241,194,50,207,92,66,73,240,33,63,128,0,0,66,226,231,82,66,50,207,92,63,123,218,241,66,232,48,229,66,129,118,214,63,90,165,252,194,213,53,168,66,120,74,88,63,61,150,23,194,216,162,104,66,129,28,41,63,123,218,241,194,212,160,184,66,213,53,168,63,90,165,252,66,129,118,214,66,216,162,104,63,61,150,23,66,120,74,88,66,212,160,184,63,123,218,241,66,129,28,41,194,222,171,133,63,61,150,23,194,98,0,0,194,222,210,97,63,24,60,19,194,98,39,135,194,222,241,118,0,0,0,0,194,98,71,43,194,225,162,39,63,24,60,19,194,86,192,79,194,246,235,107,63,128,0,0,65,84,208,20,194,247,92,28,63,123,218,241,65,85,48,85,194,245,46,165,63,128,0,0,65,158,109,250,194,129,78,20,63,111,101,134,66,212,242,163,194,129,118,214,63,90,165,252,66,213,53,168,194,120,74,88,63,61,150,23,66,216,162,104,66,243,54,201,63,123,218,241,193,209,241,118,66,242,199,253,63,128,0,0,193,209,146,6,66,245,158,132,63,123,218,241,193,158,181,221,66,239,188,28,63,128,0,0,194,1,224,249,65,209,241,118,63,123,218,241,66,243,54,201,65,209,146,6,63,128,0,0,66,242,199,253,65,158,181,221,63,123,218,241,66,245,158,132,66,1,224,249,63,128,0,0,66,239,188,28,194,243,54,201,63,123,218,241,65,209,241,118,194,242,199,253,63,128,0,0,65,209,146,6,194,245,158,132,63,123,218,241,65,158,181,221,194,239,188,28,63,128,0,0,66,1,224,249,194,236,15,158,63,128,0,0,66,26,117,142,194,236,123,87,63,123,218,241,66,26,188,28,194,231,199,43,63,128,0,0,66,50,125,191,194,240,41,134,63,123,218,241,66,2,28,41,66,236,15,158,63,128,0,0,194,26,117,168,66,236,123,87,63,123,218,241,194,26,188,28,66,231,199,43,63,128,0,0,194,50,125,191,66,240,41,134,63,123,218,241,194,2,28,41,66,26,117,142,63,128,0,0,66,236,15,158,66,26,188,28,63,123,218,241,66,236,123,87,66,50,125,191,63,128,0,0,66,231,199,43,66,2,28,41,63,123,218,241,66,240,41,134,194,50,207,92,63,123,218,241,194,232,48,229,194,74,154,186,63,111,101,134,194,227,166,102,194,120,74,88,63,61,150,23,194,216,162,104,194,109,58,251,63,61,150,23,194,219,184,134,194,109,100,116,63,24,60,19,194,219,222,224,194,109,133,162,0,0,0,0,194,219,253,139,194,120,117,221,63,24,60,19,194,216,200,49,194,219,222,224,63,24,60,19,66,109,100,116,194,219,253,139,0,0,0,0,66,109,133,162,194,216,200,49,63,24,60,19,66,120,117,221,194,216,162,104,63,61,150,23,66,120,74,88,194,219,184,134,63,61,150,23,66,109,58,225,66,109,100,116,63,24,60,19,66,219,222,224,66,109,133,162,0,0,0,0,66,219,253,139,66,120,117,221,63,24,60,19,66,216,200,49,66,120,74,88,63,61,150,23,66,216,162,104,66,109,58,225,63,61,150,23,66,219,184,134,66,219,222,224,63,24,60,19,194,109,100,116,66,219,253,139,0,0,0,0,194,109,133,162,66,216,200,49,63,24,60,19,194,120,117,221,66,216,162,104,63,61,150,23,194,120,74,88,66,219,184,134,63,61,150,23,194,109,58,251,66,213,143,0,63,24,60,19,66,129,173,67,66,213,172,192,0,0,0,0,66,129,191,99,66,216,200,49,63,24,60,19,66,120,117,221,66,213,105,199,63,61,150,23,66,129,150,148,66,129,173,67,63,24,60,19,194,213,143,0,66,129,191,99,0,0,0,0,194,213,172,192,66,120,117,221,63,24,60,19,194,216,200,62,66,129,150,148,63,61,150,23,194,213,105,199,194,129,150,161,63,61,150,23,66,213,105,199,194,129,173,67,63,24,60,19,66,213,143,0,194,129,191,112,0,0,0,0,66,213,172,192,194,120,117,221,63,24,60,19,66,216,200,49,65,133,85,208,63,24,60,19,194,247,167,95,65,133,104,115,0,0,0,0,194,247,201,239,65,86,29,21,63,24,60,19,194,248,113,131,66,247,167,95,63,24,60,19,65,133,85,208,66,247,201,239,0,0,0,0,65,133,104,115,66,248,113,131,63,24,60,19,65,86,29,21,193,86,29,21,63,24,60,19,66,248,113,131,193,133,86,4,63,24,60,19,66,247,167,95,193,133,104,115,0,0,0,0,66,247,201,239,194,210,81,13,0,0,0,0,194,135,27,153,194,213,143,0,63,24,60,19,194,129,173,67,194,213,105,199,63,61,150,23,194,129,150,161,194,202,246,57,63,61,150,23,66,145,95,20,194,206,147,12,63,61,150,23,66,140,52,31,194,206,183,23,63,24,60,19,66,140,76,165,194,206,211,235,0,0,0,0,66,140,96,66,194,203,25,167,63,24,60,19,66,145,120,121,66,145,95,20,63,61,150,23,66,202,246,57,66,140,52,31,63,61,150,23,66,206,147,12,66,140,76,165,63,24,60,19,66,206,183,23,66,140,96,66,0,0,0,0,66,206,211,235,66,145,120,121,63,24,60,19,66,203,25,167,194,140,76,165,63,24,60,19,194,206,183,23,194,140,96,66,0,0,0,0,194,206,211,235,194,145,120,134,63,24,60,19,194,203,25,167,194,145,95,20,63,61,150,23,194,202,246,57,194,140,52,31,63,61,150,23,194,206,147,12,66,202,246,57,63,61,150,23,194,145,95,20,66,206,147,12,63,61,150,23,194,140,52,31,66,206,183,23,63,24,60,19,194,140,76,165,66,206,211,235,0,0,0,0,194,140,96,66,66,203,25,167,63,24,60,19,194,145,120,134,64,215,182,70,0,0,0,0,194,249,164,64,64,88,106,127,0,0,0,0,194,249,232,246,128,0,0,0,63,24,60,19,194,249,221,34,192,88,106,127,0,0,0,0,66,249,232,246,128,0,0,0,63,24,60,19,66,249,221,34,192,215,182,70,0,0,0,0,66,249,164,64,66,249,164,64,0,0,0,0,64,215,182,70,66,249,232,246,0,0,0,0,64,88,106,127,66,249,221,34,63,24,60,19,128,0,0,0,194,194,75,199,63,128,0,0,194,154,145,39,194,150,139,172,63,24,60,19,66,199,91,245,194,150,160,184,0,0,0,0,66,199,119,194,66,199,91,245,63,24,60,19,66,150,139,172,66,199,119,194,0,0,0,0,66,150,160,184,66,150,139,172,63,24,60,19,194,199,91,245,66,150,160,184,0,0,0,0,194,199,119,194,194,239,113,131,63,24,60,19,194,15,28,251,194,239,71,187,63,61,150,23,194,15,3,254,194,194,164,103,63,123,218,241,66,154,215,194,194,186,65,6,63,128,0,0,66,164,39,227,194,186,149,247,63,123,218,241,66,164,114,215,194,177,191,72,63,128,0,0,66,173,83,64,66,194,164,103,63,123,218,241,194,154,215,194,66,186,65,6,63,128,0,0,194,164,39,227,66,186,149,247,63,123,218,241,194,164,114,215,66,177,191,72,63,128,0,0,194,173,83,77,66,154,215,194,63,123,218,241,66,194,164,103,66,164,39,227,63,128,0,0,66,186,65,6,66,164,114,215,63,123,218,241,66,186,149,247,66,173,83,64,63,128,0,0,66,177,191,72,66,235,112,33,63,24,60,19,66,39,147,64,66,235,13,145,63,90,165,252,66,39,77,1,66,39,147,64,63,24,60,19,194,235,112,33,66,39,77,1,63,90,165,252,194,235,13,145,194,39,147,64,63,24,60,19,66,235,112,33,194,195,126,145,63,24,60,19,194,155,133,162,194,195,153,219,0,0,0,0,194,155,155,87,194,199,91,245,63,24,60,19,194,150,139,172,194,226,231,82,63,128,0,0,194,73,240,33,194,229,210,137,63,123,218,241,194,62,161,72,194,231,199,43,63,128,0,0,194,50,125,191,194,224,166,102,63,123,218,241,194,85,207,249,194,154,215,194,63,123,218,241,194,194,164,103,194,159,105,160,63,128,0,0,194,190,85,142,194,164,114,215,63,123,218,241,194,186,149,247,194,168,203,68,63,128,0,0,194,182,14,191,194,177,191,72,63,128,0,0,194,173,83,77,194,173,162,104,63,123,218,241,194,178,16,111,66,249,50,124,0,0,0,0,193,33,60,159,193,33,60,159,0,0,0,0,194,249,50,124,65,33,60,159,0,0,0,0,66,249,50,124,194,249,50,124,0,0,0,0,65,33,60,159,193,86,58,251,0,0,0,0,66,248,148,44,66,248,148,44,0,0,0,0,65,86,58,251,65,86,58,251,0,0,0,0,194,248,148,44,194,246,212,110,0,0,0,0,193,159,124,238,65,159,124,238,0,0,0,0,66,246,212,97,194,246,212,97,0,0,0,0,65,159,124,238,66,246,212,97,0,0,0,0,193,159,124,238,193,159,124,238,0,0,0,0,194,246,212,97,65,210,249,114,0,0,0,0,194,244,105,160,65,210,220,41,63,24,60,19,194,244,71,135,65,236,92,198,0,0,0,0,194,242,245,129,66,244,105,160,0,0,0,0,65,210,249,114,66,244,71,135,63,24,60,19,65,210,220,41,66,242,245,129,0,0,0,0,65,236,92,198,193,210,249,114,0,0,0,0,66,244,105,160,193,210,220,41,63,24,60,19,66,244,71,135,193,236,92,198,0,0,0,0,66,242,245,129,194,239,146,229,0,0,0,0,194,15,48,242,194,2,192,52,0,0,0,0,194,241,88,108,66,2,192,52,0,0,0,0,66,241,88,108,66,241,88,108,0,0,0,0,194,2,192,52,194,241,88,108,0,0,0,0,66,2,192,52,66,247,249,180,63,128,0,0,192,214,74,140,64,214,74,140,63,128,0,0,66,247,249,180,66,235,144,242,0,0,0,0,66,39,170,179,66,39,170,179,0,0,0,0,194,235,144,242,194,39,170,179,0,0,0,0,66,235,144,242,66,212,63,243,63,128,0,0,66,128,225,59,66,128,225,59,63,128,0,0,194,212,63,243,194,230,244,70,0,0,0,0,194,63,146,58,194,233,85,168,0,0,0,0,66,51,177,65,194,51,177,91,0,0,0,0,194,233,85,168,66,51,177,65,0,0,0,0,66,233,85,168,66,233,85,168,0,0,0,0,194,51,177,91,194,86,222,79,0,0,0,0,66,225,193,150,66,225,193,150,0,0,0,0,66,86,222,79,66,86,222,79,0,0,0,0,194,225,193,150,194,219,253,139,0,0,0,0,194,109,133,162,66,222,241,118,0,0,0,0,194,98,71,43,66,98,71,43,0,0,0,0,66,222,241,118,194,222,241,118,0,0,0,0,66,98,71,43,194,98,71,43,0,0,0,0,194,222,241,118,66,120,152,147,0,0,0,0,194,216,230,116,66,216,230,116,0,0,0,0,66,120,152,147,194,120,152,147,0,0,0,0,66,216,230,116,194,248,70,37,63,61,150,23,65,85,248,56,194,248,113,131,63,24,60,19,65,86,29,21,193,85,248,56,63,61,150,23,194,248,70,37,193,86,29,21,63,24,60,19,194,248,113,131,66,248,70,37,63,61,150,23,193,85,248,56,66,248,113,131,63,24,60,19,193,86,29,21,65,85,248,56,63,61,150,23,66,248,70,37,65,86,29,21,63,24,60,19,66,248,113,131,194,206,211,248,0,0,0,0,194,140,96,66,66,210,81,13,0,0,0,0,194,135,27,153,66,135,27,153,0,0,0,0,66,210,81,13,194,135,27,153,0,0,0,0,194,210,81,13,194,210,81,13,0,0,0,0,66,135,27,153,66,203,53,247,0,0,0,0,66,145,140,205,66,145,140,205,0,0,0,0,194,203,53,247,194,145,140,218,0,0,0,0,66,203,53,247,194,191,156,211,0,0,0,0,194,160,124,28,66,155,155,87,0,0,0,0,66,195,153,219,194,195,153,219,0,0,0,0,66,155,155,87,66,195,153,219,0,0,0,0,194,155,155,87,194,155,155,87,0,0,0,0,194,195,153,219,194,174,125,139,0,0,0,0,194,178,241,26,194,178,241,26,0,0,0,0,66,174,125,139,66,174,125,139,0,0,0,0,66,178,241,26,66,178,241,26,0,0,0,0,194,174,125,139,193,132,244,241,63,111,101,134,66,246,241,236,66,246,241,236,63,111,101,134,65,132,244,241,65,132,244,241,63,111,101,134,194,246,241,236,128,0,0,0,63,24,60,19,66,249,221,34,66,248,61,244,63,128,0,0,64,86,254,197,64,86,254,197,63,128,0,0,194,248,61,244,192,86,254,197,63,128,0,0,66,248,61,244,192,87,95,112,63,123,218,241,66,248,175,66,192,86,254,197,63,128,0,0,66,248,61,244,194,195,92,120,63,61,150,23,66,155,106,114,66,155,106,114,63,61,150,23,66,195,92,120,194,155,106,114,63,61,150,23,194,195,92,120,194,165,14,138,63,61,150,23,194,187,70,129,66,195,92,120,63,61,150,23,194,155,106,114,194,183,14,86,63,61,150,23,194,169,184,108,194,174,70,194,63,61,150,23,194,178,184,239,194,243,225,59,63,90,165,252,193,210,132,25,65,210,132,25,63,90,165,252,194,243,225,59,66,243,225,59,63,90,165,252,65,210,132,25,193,210,132,25,63,90,165,252,66,243,225,59,66,38,139,199,63,128,0,0,194,233,254,158,66,1,224,249,63,128,0,0,194,239,188,28,66,233,254,158,63,128,0,0,66,38,139,199,66,239,188,28,63,128,0,0,66,1,224,249,193,184,241,222,63,90,165,252,66,245,43,2,193,184,183,233,63,111,101,134,66,244,221,231,66,245,43,2,63,90,165,252,65,184,241,170,66,244,221,231,63,111,101,134,65,184,183,233,65,184,241,170,63,90,165,252,194,245,43,2,65,184,183,233,63,111,101,134,194,244,221,231,194,191,49,249,63,90,165,252,194,160,34,130,194,50,125,191,63,128,0,0,66,231,199,43,194,38,139,199,63,128,0,0,66,233,254,158,194,1,224,249,63,128,0,0,66,239,188,28,193,209,146,6,63,128,0,0,66,242,199,253,66,242,199,253,63,128,0,0,65,209,146,6,65,209,146,6,63,128,0,0,194,242,199,253,194,86,192,79,63,24,60,19,66,225,162,25,66,225,162,25,63,24,60,19,66,86,192,79,66,86,192,79,63,24,60,19,194,225,162,39,66,50,125,191,63,128,0,0,194,231,199,43,66,231,199,43,63,128,0,0,66,50,125,191,66,149,158,250,63,128,0,0,194,198,35,32,66,159,105,160,63,128,0,0,194,190,85,142,66,190,85,142,63,128,0,0,66,159,105,160,66,198,35,32,63,128,0,0,66,149,158,250,194,159,105,160,63,128,0,0,66,190,85,142,194,149,158,250,63,128,0,0,66,198,35,32,66,168,203,68,63,128,0,0,194,182,14,191,66,182,14,191,63,128,0,0,66,168,203,68,194,168,203,68,63,128,0,0,66,182,14,191,194,73,240,33,63,128,0,0,66,226,231,82,194,237,33,6,63,90,165,252,194,27,40,167,194,27,40,167,63,90,165,252,66,237,33,6,66,74,218,160,63,90,165,252,194,227,238,7,66,227,238,7,63,90,165,252,66,74,218,160,194,74,218,160,63,90,165,252,66,227,238,7,128,0,0,0,0,0,0,0,66,250,0,0,194,237,249,167,63,128,0,0,194,14,60,54,194,205,114,202,63,128,0,0,194,139,111,249,194,97,129,111,63,111,101,134,194,222,47,53,66,222,47,53,63,111,101,134,194,97,129,111,194,222,47,53,63,111,101,134,66,97,129,111,66,97,129,111,63,111,101,134,66,222,47,53,194,219,61,231,63,111,101,134,194,108,182,17,66,216,41,121,63,111,101,134,194,119,191,99,194,119,191,99,63,111,101,134,194,216,41,134,194,216,41,134,63,111,101,134,66,119,191,99,66,119,191,99,63,111,101,134,66,216,41,121,66,212,242,163,63,111,101,134,66,129,78,7,66,129,78,7,63,111,101,134,194,212,242,163,194,212,242,163,63,111,101,134,194,129,78,20,194,134,165,149,63,111,101,134,194,209,153,219,66,134,165,149,63,111,101,134,66,209,153,219,66,209,153,219,63,111,101,134,194,134,165,149,194,209,153,219,63,111,101,134,66,134,165,149,66,139,229,162,63,111,101,134,194,206,31,190,194,139,229,162,63,111,101,134,66,206,31,190,66,206,31,190,63,111,101,134,66,139,229,162,66,202,132,234,63,111,101,134,194,145,13,185,66,145,13,185,63,111,101,134,66,202,132,234,194,145,13,185,63,111,101,134,194,202,132,234,194,202,132,234,63,111,101,134,66,145,13,185,0,0,0,21,0,0,4,80,63,59,159,86,62,250,159,190,63,59,159,86,62,250,199,17,63,57,120,213,62,250,159,190,61,27,165,227,62,250,199,17,61,27,165,227,62,251,87,63,60,243,77,106,62,250,199,17,62,184,212,254,62,250,199,17,62,186,225,72,62,250,159,190,62,188,237,145,62,250,199,17,62,242,241,170,62,251,87,63,62,240,203,41,62,252,54,17,62,238,177,196,62,251,87,63,62,84,227,189,62,251,87,63,62,80,176,242,62,253,99,136,62,76,126,40,62,251,87,63,62,106,48,85,63,2,176,33,62,106,48,85,62,254,249,219,62,110,125,86,63,2,176,33,63,74,199,17,62,254,249,219,63,74,199,17,63,2,176,33,63,73,186,94,62,254,249,219,63,82,25,101,62,251,87,63,63,80,6,142,62,250,199,17,63,84,44,61,62,251,87,63,63,10,199,17,62,254,249,219,63,10,199,17,63,2,176,33,63,9,186,94,62,254,249,219,63,18,25,101,62,251,87,63,63,16,6,142,62,250,199,17,63,20,44,61,62,251,87,63,63,123,159,86,62,250,159,190,63,123,159,86,62,250,199,17,63,121,120,213,62,250,159,190,60,12,231,4,62,254,249,219,60,12,231,4,62,252,54,17,60,81,183,23,62,254,249,219,63,66,51,156,62,254,249,219,63,66,51,156,62,252,54,17,63,67,70,220,62,254,249,219,63,70,135,43,62,252,54,17,63,70,135,43,62,254,249,219,63,69,115,235,62,252,54,17,61,210,189,60,62,252,54,17,61,202,140,21,62,254,249,219,61,194,90,238,62,252,54,17,62,178,163,5,62,254,249,219,62,178,163,5,63,2,176,33,62,176,150,188,62,254,249,219,62,160,13,27,62,251,87,63,62,157,243,182,62,252,54,17,62,155,218,81,62,251,87,63,63,90,87,168,62,252,54,17,63,89,81,131,62,254,249,219,63,88,75,94,62,252,54,17,63,26,87,168,62,252,54,17,63,25,81,131,62,254,249,219,63,24,75,94,62,252,54,17,62,68,24,147,62,252,54,17,62,68,24,147,62,251,87,63,62,72,75,94,62,253,99,136,62,43,54,122,62,252,54,17,62,39,3,176,62,253,99,136,62,34,235,28,62,252,54,17,63,49,6,37,62,252,54,17,63,49,6,37,62,251,87,63,63,50,18,215,62,253,99,136,63,42,205,159,62,252,54,17,63,41,192,236,62,253,99,136,63,40,186,199,62,252,54,17,63,113,6,37,62,252,54,17,63,113,6,37,62,251,87,63,63,114,18,215,62,253,99,136,63,106,205,159,62,252,54,17,63,105,192,236,62,253,99,136,63,104,186,199,62,252,54,17,62,130,51,156,62,251,87,63,62,128,0,0,62,253,99,136,62,123,152,200,62,252,54,17,62,136,193,85,63,2,176,33,62,136,193,85,62,254,249,219,62,138,231,213,63,2,176,33,61,61,60,54,62,254,249,219,61,61,60,54,62,253,99,136,61,78,7,95,62,254,249,219,61,161,97,229,62,252,54,17,61,152,252,80,62,253,99,136,61,144,203,41,62,252,54,17,62,143,52,215,62,250,199,17,62,145,78,60,62,250,159,190,62,147,116,188,62,250,199,17,62,217,192,236,62,254,249,219,62,217,192,236,62,252,54,17,62,219,205,54,62,254,249,219,62,205,92,251,62,252,54,17,62,203,80,177,62,253,99,136,62,201,55,76,62,252,54,17,62,226,12,74,62,252,54,17,62,226,12,74,62,251,87,63,62,228,37,175,62,253,99,136,62,221,230,155,62,252,54,17,63,2,51,156,62,254,249,219,63,2,51,156,62,252,54,17,63,3,70,220,62,254,249,219,63,6,135,43,62,252,54,17,63,6,135,43,62,254,249,219,63,5,115,235,62,252,54,17,62,34,235,28,62,254,249,219,62,10,61,113,62,252,54,17,62,10,61,113,62,251,87,63,62,18,110,152,62,252,54,17,63,104,186,199,62,254,249,219,63,98,143,92,62,252,54,17,63,98,143,92,62,251,87,63,63,100,155,166,62,252,54,17,63,40,186,199,62,254,249,219,63,34,143,92,62,252,54,17,63,34,143,92,62,251,87,63,63,36,155,166,62,252,54,17,62,128,0,0,62,250,159,190,62,119,49,144,62,250,199,17,62,119,49,144,62,250,159,190,62,101,227,84,62,252,54,17,62,101,227,84,62,251,87,63,62,106,48,85,62,252,54,17,62,245,24,43,63,2,176,33,62,245,24,43,62,254,249,219,62,247,62,171,63,2,176,33,63,1,25,206,62,251,87,63,63,0,0,0,62,253,99,136,62,253,204,100,62,252,54,17,63,122,140,21,62,254,249,219,63,122,140,21,63,2,176,33,63,121,120,213,62,254,249,219,63,117,56,239,62,251,87,63,63,116,44,61,62,253,99,136,63,115,31,138,62,251,87,63,63,58,140,21,62,254,249,219,63,58,140,21,63,2,176,33,63,57,120,213,62,254,249,219,63,53,56,239,62,251,87,63,63,52,44,61,62,253,99,136,63,51,31,138,62,251,87,63,61,161,97,229,62,253,99,136,61,186,41,199,62,254,249,219,61,194,90,238,62,253,99,136,63,19,31,138,63,2,176,33,63,19,31,138,62,254,249,219,63,20,44,61,63,2,176,33,63,11,211,195,63,2,176,33,63,75,211,195,63,2,176,33,63,83,31,138,63,2,176,33,63,83,31,138,62,254,249,219,63,84,44,61,63,2,176,33,60,208,229,96,62,252,54,17,60,208,229,96,62,254,249,219,60,174,125,86,62,252,54,17,63,32,131,18,62,251,87,63,63,30,118,201,62,253,99,136,63,30,118,201,62,252,54,17,63,32,131,18,62,253,99,136,62,2,12,74,62,251,87,63,61,243,182,70,62,253,99,136,61,243,182,70,62,252,54,17,62,2,12,74,62,253,99,136,63,96,131,18,62,251,87,63,63,94,118,201,62,253,99,136,63,94,118,201,62,252,54,17,63,96,131,18,62,253,99,136,62,155,218,81,62,254,249,219,62,155,218,81,62,252,54,17,62,157,243,182,62,254,249,219,62,149,142,34,62,252,54,17,62,149,142,34,62,254,249,219,62,147,116,188,62,253,99,136,63,61,204,100,62,252,54,17,63,61,204,100,62,254,249,219,63,60,185,36,62,253,99,136,63,59,159,86,63,2,176,33,63,125,204,100,62,252,54,17,63,125,204,100,62,254,249,219,63,124,185,36,62,253,99,136,63,123,159,86,63,2,176,33,62,180,175,79,62,251,87,63,62,176,150,188,62,250,199,17,62,184,212,254,62,251,87,63,62,168,88,121,62,253,99,136,62,168,88,121,62,252,54,17,62,170,100,195,62,253,99,136,62,170,100,195,62,254,249,219,62,170,100,195,63,2,176,33,62,168,88,121,62,254,249,219,62,162,25,101,63,2,176,33,62,162,25,101,62,254,249,219,62,164,50,202,63,2,176,33,62,195,18,111,62,254,249,219,62,195,18,111,63,2,176,33,62,193,6,37,62,254,249,219,62,180,175,79,63,2,176,33,62,193,6,37,62,252,54,17,62,193,6,37,62,251,87,63,62,197,30,184,62,252,54,17,62,201,55,76,62,251,87,63,62,242,241,170,62,254,249,219,62,228,37,175,63,2,176,33,62,228,37,175,62,254,249,219,62,230,63,20,63,2,176,33,62,72,75,94,63,2,176,33,62,72,75,94,62,254,249,219,62,76,126,40,63,2,176,33,62,101,227,84,62,254,249,219,63,83,31,138,62,253,99,136,63,84,44,61,62,252,54,17,63,84,44,61,62,253,99,136,63,87,69,57,62,254,249,219,63,88,75,94,62,253,99,136,63,23,69,57,62,254,249,219,63,24,75,94,62,253,99,136,63,19,31,138,62,253,99,136,63,20,44,61,62,252,54,17,63,20,44,61,62,253,99,136,63,73,186,94,62,251,87,63,63,73,186,94,62,250,199,17,63,75,211,195,62,251,87,63,63,71,154,107,62,250,199,17,63,9,186,94,62,251,87,63,63,9,186,94,62,250,199,17,63,11,211,195,62,251,87,63,63,7,154,107,62,250,199,17,62,51,129,216,62,253,99,136,62,51,129,216,62,252,54,17,62,55,154,107,62,254,249,219,63,44,224,118,62,254,249,219,63,44,224,118,62,252,54,17,63,45,230,155,62,254,249,219,63,108,224,118,62,253,99,136,63,108,224,118,62,252,54,17,63,109,230,155,62,254,249,219,61,128,52,110,62,254,249,219,61,128,52,110,62,253,99,136,61,136,101,149,62,254,249,219,60,81,183,23,62,253,99,136,60,81,183,23,62,251,87,63,60,140,21,77,62,253,99,136,63,67,70,220,62,253,99,136,63,67,70,220,62,251,87,63,63,68,96,170,62,253,99,136,62,209,117,142,62,254,249,219,62,209,117,142,62,252,54,17,62,211,129,216,62,253,99,136,62,14,86,4,62,254,249,219,62,14,86,4,63,2,176,33,62,10,61,113,62,254,249,219,62,39,3,176,62,254,249,219,62,39,3,176,63,2,176,33,63,35,149,129,62,254,249,219,63,35,149,129,63,2,176,33,63,34,143,92,62,254,249,219,63,41,192,236,62,254,249,219,63,41,192,236,63,2,176,33,63,99,149,129,62,254,249,219,63,99,149,129,63,2,176,33,63,98,143,92,62,254,249,219,63,105,192,236,62,254,249,219,63,105,192,236,63,2,176,33,62,176,150,188,62,251,87,63,62,172,126,40,62,250,199,17,63,118,69,162,62,254,249,219,63,118,69,162,63,2,176,33,63,117,56,239,62,254,249,219,63,114,18,215,63,2,176,33,63,114,18,215,62,254,249,219,63,115,31,138,63,2,176,33,63,54,69,162,62,254,249,219,63,54,69,162,63,2,176,33,63,53,56,239,62,254,249,219,63,50,18,215,63,2,176,33,63,50,18,215,62,254,249,219,63,51,31,138,63,2,176,33,62,119,49,144,62,254,249,219,62,119,49,144,63,2,176,33,62,114,228,143,62,254,249,219,63,16,6,142,62,251,87,63,63,17,12,179,62,254,249,219,63,17,12,179,63,2,176,33,63,16,6,142,62,254,249,219,63,80,6,142,62,251,87,63,63,81,12,179,62,254,249,219,63,81,12,179,63,2,176,33,63,80,6,142,62,254,249,219,62,141,14,86,62,252,54,17,62,143,52,215,62,251,87,63,62,143,52,215,62,252,54,17,62,132,103,56,62,252,54,17,62,134,141,185,62,251,87,63,62,134,141,185,62,253,99,136,62,89,22,135,62,254,249,219,62,89,22,135,63,2,176,33,62,84,227,189,62,254,249,219,62,84,227,189,62,252,54,17,62,89,22,135,62,253,99,136,62,234,113,222,62,252,54,17,62,234,113,222,62,251,87,63,62,236,139,68,62,253,99,136,62,236,139,68,62,254,249,219,62,236,139,68,63,2,176,33,62,234,113,222,62,254,249,219,62,251,152,200,62,250,199,17,62,253,204,100,62,250,159,190,63,1,25,206,62,250,199,17,62,242,241,170,62,252,54,17,62,245,24,43,62,252,54,17,61,111,157,178,62,252,54,17,61,111,157,178,62,254,249,219,61,94,210,137,62,252,54,17,61,144,203,41,62,250,199,17,61,144,203,41,62,251,87,63,61,94,210,137,62,250,199,17,63,53,56,239,62,252,54,17,63,54,69,162,62,253,99,136,63,57,120,213,62,251,87,63,63,56,101,149,62,252,54,17,63,55,88,226,62,251,87,63,63,117,56,239,62,252,54,17,63,118,69,162,62,253,99,136,63,121,120,213,62,251,87,63,63,120,101,149,62,252,54,17,63,119,88,226,62,251,87,63,62,145,78,60,63,2,176,33,62,145,78,60,62,254,249,219,62,147,116,188,63,2,176,33,62,143,52,215,62,254,249,219,62,143,52,215,63,2,176,33,62,141,14,86,62,254,249,219,62,188,237,145,62,251,87,63,62,188,237,145,62,252,54,17,62,186,225,72,62,254,249,219,62,186,225,72,63,2,176,33,62,184,212,254,62,254,249,219,60,243,77,106,62,254,249,219,60,243,77,106,63,2,176,33,61,44,113,13,62,252,54,17,61,44,113,13,62,254,249,219,61,27,165,227,62,253,99,136,63,90,87,168,62,253,99,136,63,92,106,127,62,253,99,136,63,93,112,164,63,2,176,33,63,93,112,164,62,254,249,219,63,94,118,201,63,2,176,33,63,26,87,168,62,253,99,136,63,28,106,127,62,253,99,136,63,29,112,164,63,2,176,33,63,29,112,164,62,254,249,219,63,30,118,201,63,2,176,33,61,210,189,60,62,253,99,136,61,227,83,248,62,253,99,136,61,235,133,31,63,2,176,33,61,235,133,31,62,254,249,219,61,243,182,70,63,2,176,33,63,46,243,77,62,252,54,17,63,110,243,77,62,252,54,17,62,59,205,54,62,252,54,17,63,1,25,206,62,252,54,17,63,1,25,206,62,254,249,219,59,140,231,4,62,252,54,17,59,140,231,4,62,254,249,219,128,0,0,0,62,253,99,136,63,65,25,206,62,252,54,17,63,65,25,206,62,254,249,219,63,64,0,0,62,253,99,136,63,71,154,107,62,254,249,219,63,71,154,107,63,2,176,33,63,7,154,107,62,254,249,219,63,7,154,107,63,2,176,33,63,3,70,220,62,253,99,136,63,3,70,220,62,251,87,63,63,4,96,170,62,253,99,136,62,232,88,121,62,253,99,136,62,230,63,20,62,251,87,63,62,213,155,61,62,252,54,17,62,203,80,177,62,254,249,219,62,203,80,177,63,2,176,33,62,201,55,76,62,254,249,219,62,197,30,184,63,2,176,33,63,77,237,41,62,250,199,17,63,13,237,41,62,250,199,17,63,128,0,0,62,251,87,63,63,128,0,0,62,253,99,136,63,126,230,50,62,252,54,17,63,65,25,206,62,251,87,63,63,62,230,50,62,252,54,17,62,157,243,182,63,2,176,33,62,134,141,185,62,254,249,219,62,134,141,185,63,2,176,33,62,132,103,56,62,254,249,219,62,123,152,200,63,2,176,33,62,123,152,200,62,254,249,219,62,128,0,0,63,2,176,33,62,238,177,196,63,2,176,33,62,93,99,136,63,2,176,33,63,55,88,226,63,2,176,33,63,119,88,226,63,2,176,33,61,194,90,238,62,250,199,17,61,194,90,238,62,250,159,190,61,210,189,60,62,250,199,17,61,161,97,229,62,251,87,63,61,227,83,248,62,252,54,17,63,28,106,127,62,252,54,17,63,92,106,127,62,252,54,17,63,78,249,219,63,2,176,33,63,78,249,219,62,254,249,219,63,80,6,142,63,2,176,33,63,14,249,219,63,2,176,33,63,14,249,219,62,254,249,219,63,16,6,142,63,2,176,33,62,172,126,40,63,2,176,33,62,22,161,98,63,2,176,33,62,22,161,98,62,254,249,219,62,26,185,245,63,2,176,33,63,101,168,88,63,2,176,33,63,101,168,88,62,254,249,219,63,102,174,125,63,2,176,33,63,37,168,88,63,2,176,33,63,37,168,88,62,254,249,219,63,38,174,125,63,2,176,33,62,219,205,54,63,2,176,33,62,221,230,155,63,2,176,33,62,226,12,74,62,254,249,219,62,68,24,147,62,254,249,219,62,55,154,107,63,2,176,33,62,59,205,54,63,2,176,33,63,49,6,37,62,254,249,219,63,45,230,155,63,2,176,33,63,46,243,77,63,2,176,33,63,113,6,37,62,254,249,219,63,109,230,155,63,2,176,33,63,110,243,77,63,2,176,33,62,188,237,145,63,2,176,33,61,61,60,54,62,251,87,63,61,94,210,137,62,251,87,63,61,128,52,110,62,251,87,63,62,164,50,202,62,252,54,17,62,164,50,202,62,251,87,63,62,97,150,83,62,252,54,17,62,93,99,136,62,251,87,63,63,31,124,238,62,254,249,219,63,31,124,238,63,2,176,33,63,30,118,201,62,254,249,219,63,33,137,55,63,2,176,33,63,33,137,55,62,254,249,219,63,34,143,92,63,2,176,33,61,251,231,109,62,254,249,219,61,251,231,109,63,2,176,33,61,243,182,70,62,254,249,219,62,6,36,221,63,2,176,33,62,6,36,221,62,254,249,219,62,10,61,113,63,2,176,33,63,95,124,238,62,254,249,219,63,95,124,238,63,2,176,33,63,94,118,201,62,254,249,219,63,97,137,55,63,2,176,33,63,97,137,55,62,254,249,219,63,98,143,92,63,2,176,33,62,63,229,201,62,253,99,136,62,59,205,54,62,251,87,63,63,47,249,114,62,253,99,136,63,46,243,77,62,251,87,63,63,111,249,114,62,253,99,136,63,110,243,77,62,251,87,63,63,42,205,159,63,2,176,33,63,106,205,159,63,2,176,33,63,108,224,118,62,254,249,219,62,211,129,216,63,2,176,33,62,211,129,216,62,254,249,219,62,213,155,61,63,2,176,33,62,51,129,216,62,254,249,219,62,43,54,122,63,2,176,33,62,205,92,251,63,2,176,33,62,197,30,184,62,251,87,63,62,155,218,81,62,250,199,17,62,151,167,135,62,250,199,17,62,151,167,135,62,251,87,63,62,18,110,152,62,251,87,63,62,26,185,245,62,252,54,17,63,100,155,166,62,251,87,63,63,102,174,125,62,252,54,17,63,36,155,166,62,251,87,63,63,38,174,125,62,252,54,17,62,253,204,100,63,2,176,33,62,253,204,100,62,254,249,219,63,0,0,0,63,2,176,33,62,251,152,200,62,254,249,219,62,251,152,200,63,2,176,33,62,249,114,71,62,254,249,219,63,61,204,100,63,2,176,33,63,60,185,36,62,254,249,219,63,62,230,50,63,2,176,33,63,62,230,50,62,254,249,219,63,64,0,0,63,2,176,33,63,125,204,100,63,2,176,33,63,124,185,36,62,254,249,219,63,126,230,50,63,2,176,33,63,126,230,50,62,254,249,219,63,128,0,0,63,2,176,33,63,28,106,127,62,254,249,219,63,28,106,127,63,2,176,33,63,27,100,90,62,254,249,219,63,24,75,94,62,254,249,219,63,24,75,94,63,2,176,33,63,92,106,127,62,254,249,219,63,92,106,127,63,2,176,33,63,91,100,90,62,254,249,219,63,88,75,94,62,254,249,219,63,88,75,94,63,2,176,33,61,194,90,238,62,254,249,219,61,194,90,238,63,2,176,33,61,227,83,248,62,254,249,219,61,227,83,248,63,2,176,33,61,219,34,209,62,254,249,219,62,138,231,213,62,251,87,63,62,136,193,85,62,253,99,136,60,208,229,96,63,2,176,33,60,81,183,23,63,2,176,33,63,70,135,43,63,2,176,33,63,67,70,220,63,2,176,33,63,6,135,43,63,2,176,33,63,3,70,220,63,2,176,33,63,12,224,118,62,254,249,219,63,12,224,118,63,2,176,33,63,11,211,195,62,254,249,219,63,13,237,41,62,251,87,63,63,12,224,118,62,252,54,17,63,76,224,118,62,254,249,219,63,76,224,118,63,2,176,33,63,75,211,195,62,254,249,219,63,77,237,41,62,251,87,63,63,76,224,118,62,252,54,17,63,87,69,57,63,2,176,33,63,84,44,61,62,254,249,219,63,23,69,57,63,2,176,33,63,20,44,61,62,254,249,219,61,186,41,199,63,2,176,33,61,161,97,229,62,254,249,219,61,161,97,229,63,2,176,33,61,152,252,80,62,254,249,219,62,247,62,171,62,250,199,17,62,249,114,71,62,250,159,190,62,176,150,188,62,253,99,136,62,176,150,188,62,252,54,17,62,174,138,114,62,254,249,219,62,172,126,40,62,252,54,17,63,88,75,94,62,250,199,17,63,88,75,94,62,250,159,190,63,90,87,168,62,250,199,17,63,84,44,61,62,250,159,190,63,84,44,61,62,250,199,17,63,81,12,179,62,250,159,190,63,24,75,94,62,250,199,17,63,24,75,94,62,250,159,190,63,26,87,168,62,250,199,17,63,20,44,61,62,250,159,190,63,20,44,61,62,250,199,17,63,17,12,179,62,250,159,190,62,130,51,156,62,252,54,17,62,130,51,156,62,254,249,219,62,130,51,156,63,2,176,33,62,128,0,0,62,254,249,219,62,160,13,27,62,254,249,219,62,160,13,27,62,253,99,136,62,162,25,101,62,252,54,17,61,61,60,54,62,250,199,17,62,22,161,98,62,253,99,136,62,18,110,152,62,254,249,219,63,101,168,88,62,253,99,136,63,100,155,166,62,254,249,219,63,37,168,88,62,253,99,136,63,36,155,166,62,254,249,219,61,177,248,161,62,250,159,190,61,177,248,161,62,250,199,17,61,152,252,80,62,250,159,190,63,67,70,220,62,250,199,17,63,67,70,220,62,250,159,190,63,69,115,235,62,250,199,17,60,81,183,23,62,250,199,17,60,81,183,23,62,250,159,190,60,174,125,86,62,250,199,17,59,140,231,4,62,251,87,63,63,3,70,220,62,250,199,17,63,3,70,220,62,250,159,190,63,5,115,235,62,250,199,17,60,243,77,106,62,250,159,190,60,174,125,86,62,250,159,190,63,71,154,107,62,250,159,190,63,69,115,235,62,250,159,190,63,5,115,235,62,250,159,190,63,7,154,107,62,250,159,190,62,180,175,79,62,253,99,136,62,180,175,79,62,252,54,17,62,184,212,254,62,253,99,136,62,119,49,144,62,252,54,17,62,114,228,143,62,253,99,136,62,119,49,144,62,251,87,63,62,110,125,86,62,251,87,63,62,251,152,200,62,252,54,17,62,249,114,71,62,253,99,136,62,251,152,200,62,251,87,63,62,247,62,171,62,251,87,63,62,149,142,34,63,2,176,33,62,147,116,188,62,254,249,219,62,153,192,236,63,2,176,33,62,153,192,236,62,254,249,219,62,155,218,81,63,2,176,33,61,78,7,95,63,2,176,33,61,111,157,178,63,2,176,33,61,128,52,110,63,2,176,33,63,61,204,100,62,250,199,17,63,62,230,50,62,250,159,190,63,65,25,206,62,250,199,17,63,125,204,100,62,250,199,17,63,126,230,50,62,250,159,190,63,128,0,0,62,250,199,17,61,136,101,149,63,2,176,33,61,152,252,80,63,2,176,33,62,51,129,216,62,250,199,17,62,51,129,216,62,250,159,190,62,59,205,54,62,250,199,17,62,43,54,122,62,250,159,190,62,43,54,122,62,250,199,17,62,34,235,28,62,250,159,190,63,44,224,118,62,250,199,17,63,44,224,118,62,250,159,190,63,46,243,77,62,250,199,17,63,42,205,159,62,250,159,190,63,42,205,159,62,250,199,17,63,40,186,199,62,250,159,190,63,108,224,118,62,250,199,17,63,108,224,118,62,250,159,190,63,110,243,77,62,250,199,17,63,106,205,159,62,250,159,190,63,106,205,159,62,250,199,17,63,104,186,199,62,250,159,190,62,26,185,245,62,250,159,190,62,26,185,245,62,250,199,17,62,18,110,152,62,250,159,190,62,34,235,28,62,250,199,17,63,102,174,125,62,250,159,190,63,102,174,125,62,250,199,17,63,100,155,166,62,250,159,190,63,104,186,199,62,250,199,17,63,38,174,125,62,250,159,190,63,38,174,125,62,250,199,17,63,36,155,166,62,250,159,190,63,40,186,199,62,250,199,17,63,90,87,168,62,251,87,63,63,92,106,127,62,251,87,63,63,94,118,201,62,251,87,63,63,26,87,168,62,251,87,63,63,28,106,127,62,251,87,63,63,30,118,201,62,251,87,63,61,210,189,60,62,251,87,63,61,227,83,248,62,251,87,63,61,243,182,70,62,251,87,63,63,30,118,201,62,250,199,17,63,94,118,201,62,250,199,17,61,243,182,70,62,250,199,17,62,223,242,229,62,250,159,190,62,221,230,155,62,250,199,17,62,219,205,54,62,250,159,190,62,232,88,121,62,250,159,190,62,230,63,20,62,250,199,17,62,228,37,175,62,250,159,190,62,170,100,195,62,250,159,190,62,168,88,121,62,250,199,17,62,166,63,20,62,250,159,190,62,172,126,40,62,250,159,190,62,217,192,236,62,250,199,17,62,215,167,135,62,250,159,190,62,213,155,61,62,250,199,17,62,211,129,216,62,250,159,190,62,207,105,68,62,250,159,190,62,205,92,251,62,250,199,17,62,203,80,177,62,250,159,190,62,209,117,142,62,250,199,17,63,61,204,100,62,251,87,63,63,59,159,86,62,251,87,63,63,57,120,213,62,252,54,17,63,58,140,21,62,252,54,17,63,121,120,213,62,252,54,17,63,122,140,21,62,252,54,17,63,125,204,100,62,251,87,63,63,123,159,86,62,251,87,63,62,132,103,56,63,2,176,33,63,27,100,90,63,2,176,33,63,91,100,90,63,2,176,33,61,219,34,209,63,2,176,33,61,44,113,13,63,2,176,33,61,61,60,54,63,2,176,33,61,27,165,227,62,254,249,219,62,149,142,34,62,250,159,190,63,80,6,142,62,253,99,136,63,78,249,219,62,252,54,17,63,75,211,195,62,253,99,136,63,11,211,195,62,253,99,136,63,16,6,142,62,253,99,136,63,14,249,219,62,252,54,17,63,73,186,94,62,253,99,136,63,74,199,17,62,252,54,17,63,9,186,94,62,253,99,136,63,10,199,17,62,252,54,17,62,138,231,213,62,254,249,219,62,138,231,213,62,252,54,17,62,240,203,41,62,254,249,219,62,240,203,41,63,2,176,33,62,238,177,196,62,254,249,219,62,238,177,196,62,252,54,17,63,56,101,149,62,254,249,219,63,56,101,149,63,2,176,33,63,55,88,226,62,254,249,219,63,55,88,226,62,252,54,17,62,97,150,83,62,254,249,219,62,97,150,83,63,2,176,33,62,93,99,136,62,254,249,219,62,93,99,136,62,252,54,17,63,119,88,226,62,252,54,17,63,120,101,149,62,254,249,219,63,120,101,149,63,2,176,33,63,119,88,226,62,254,249,219,62,76,126,40,62,252,54,17,62,80,176,242,62,254,249,219,62,80,176,242,63,2,176,33,62,76,126,40,62,254,249,219,63,116,44,61,62,254,249,219,63,116,44,61,63,2,176,33,63,115,31,138,62,254,249,219,63,115,31,138,62,252,54,17,63,52,44,61,62,254,249,219,63,52,44,61,63,2,176,33,63,51,31,138,62,254,249,219,63,51,31,138,62,252,54,17,62,232,88,121,62,254,249,219,62,232,88,121,63,2,176,33,62,230,63,20,62,254,249,219,62,230,63,20,62,252,54,17,62,147,116,188,62,251,87,63,63,18,25,101,62,252,54,17,63,82,25,101,62,252,54,17,63,75,211,195,62,250,199,17,63,11,211,195,62,250,199,17,62,199,43,2,62,254,249,219,62,199,43,2,63,2,176,33,62,197,30,184,62,254,249,219,62,190,249,219,62,254,249,219,62,190,249,219,63,2,176,33,62,188,237,145,62,254,249,219,62,221,230,155,62,254,249,219,62,223,242,229,62,253,99,136,62,223,242,229,62,254,249,219,62,223,242,229,63,2,176,33,62,59,205,54,62,254,249,219,62,63,229,201,62,254,249,219,62,63,229,201,63,2,176,33,63,47,249,114,62,254,249,219,63,47,249,114,63,2,176,33,63,46,243,77,62,254,249,219,63,110,243,77,62,254,249,219,63,111,249,114,62,254,249,219,63,111,249,114,63,2,176,33,62,130,51,156,62,250,199,17,62,136,193,85,62,250,159,190,62,134,141,185,62,250,199,17,62,132,103,56,62,250,159,190,63,32,131,18,62,254,249,219,63,32,131,18,62,252,54,17,63,34,143,92,62,253,99,136,63,96,131,18,62,254,249,219,63,96,131,18,62,252,54,17,63,98,143,92,62,253,99,136,62,2,12,74,62,254,249,219,62,2,12,74,62,252,54,17,62,10,61,113,62,253,99,136,62,138,231,213,62,250,199,17,62,141,14,86,62,250,159,190,62,238,177,196,62,250,199,17,62,240,203,41,62,250,159,190,62,242,241,170,62,250,199,17,62,245,24,43,62,250,159,190,62,234,113,222,62,250,199,17,62,236,139,68,62,250,159,190,62,59,205,54,62,250,159,190,62,68,24,147,62,250,199,17,63,46,243,77,62,250,159,190,63,49,6,37,62,250,199,17,63,110,243,77,62,250,159,190,63,113,6,37,62,250,199,17,63,22,63,20,62,252,54,17,63,21,50,97,62,253,99,136,63,22,63,20,62,250,199,17,63,86,63,20,62,252,54,17,63,85,50,97,62,253,99,136,63,86,63,20,62,250,199,17,62,166,63,20,62,253,99,136,62,166,63,20,62,254,249,219,62,166,63,20,63,2,176,33,62,164,50,202,62,254,249,219,62,110,125,86,62,250,159,190,62,110,125,86,62,250,199,17,62,101,227,84,62,250,159,190,61,177,248,161,62,251,87,63,61,177,248,161,62,252,54,17,61,169,147,12,62,253,99,136,63,55,88,226,62,250,199,17,63,55,88,226,62,250,159,190,63,57,120,213,62,250,199,17,63,53,56,239,62,250,159,190,63,119,88,226,62,250,199,17,63,119,88,226,62,250,159,190,63,121,120,213,62,250,199,17,63,117,56,239,62,250,159,190,62,93,99,136,62,250,199,17,62,93,99,136,62,250,159,190,62,101,227,84,62,250,199,17,62,84,227,189,62,250,159,190,62,76,126,40,62,250,159,190,62,76,126,40,62,250,199,17,62,68,24,147,62,250,159,190,62,84,227,189,62,250,199,17,63,51,31,138,62,250,159,190,63,51,31,138,62,250,199,17,63,49,6,37,62,250,159,190,63,53,56,239,62,250,199,17,63,115,31,138,62,250,159,190,63,115,31,138,62,250,199,17,63,113,6,37,62,250,159,190,63,117,56,239,62,250,199,17,62,226,12,74,62,250,199,17,62,221,230,155,62,251,87,63,62,213,155,61,62,253,99,136,62,215,167,135,62,253,99,136,62,215,167,135,62,254,249,219,62,215,167,135,63,2,176,33,62,213,155,61,62,254,249,219,62,47,79,14,62,254,249,219,62,47,79,14,63,2,176,33,62,43,54,122,62,254,249,219,62,43,54,122,62,253,99,136,62,47,79,14,62,253,99,136,63,107,211,195,62,254,249,219,63,107,211,195,63,2,176,33,63,106,205,159,62,254,249,219,63,106,205,159,62,253,99,136,63,107,211,195,62,253,99,136,63,43,211,195,62,254,249,219,63,43,211,195,63,2,176,33,63,42,205,159,62,254,249,219,63,42,205,159,62,253,99,136,63,43,211,195,62,253,99,136,63,86,63,20,62,254,249,219,63,86,63,20,63,2,176,33,63,85,50,97,62,254,249,219,63,86,63,20,62,253,99,136,63,22,63,20,62,254,249,219,63,22,63,20,63,2,176,33,63,21,50,97,62,254,249,219,63,22,63,20,62,253,99,136,61,177,248,161,62,253,99,136,61,177,248,161,62,254,249,219,61,177,248,161,63,2,176,33,61,169,147,12,62,254,249,219,63,5,115,235,62,254,249,219,63,5,115,235,63,2,176,33,63,4,96,170,62,254,249,219,63,69,115,235,62,254,249,219,63,69,115,235,63,2,176,33,63,68,96,170,62,254,249,219,60,140,21,77,62,254,249,219,60,174,125,86,62,254,249,219,60,174,125,86,63,2,176,33,62,174,138,114,63,2,176,33,62,172,126,40,62,254,249,219,62,172,126,40,62,253,99,136,62,26,185,245,62,253,99,136,62,30,210,137,62,253,99,136,62,30,210,137,62,254,249,219,62,30,210,137,63,2,176,33,62,26,185,245,62,254,249,219,63,102,174,125,62,253,99,136,63,103,180,162,62,253,99,136,63,103,180,162,62,254,249,219,63,103,180,162,63,2,176,33,63,102,174,125,62,254,249,219,62,207,105,68,62,254,249,219,62,207,105,68,63,2,176,33,62,205,92,251,62,254,249,219,62,205,92,251,62,253,99,136,62,207,105,68,62,253,99,136,63,38,174,125,62,253,99,136,63,39,180,162,62,253,99,136,63,39,180,162,62,254,249,219,63,39,180,162,63,2,176,33,63,38,174,125,62,254,249,219,63,2,51,156,63,2,176,33,63,1,25,206,63,2,176,33,63,0,0,0,62,254,249,219,59,140,231,4,63,2,176,33,128,0,0,0,62,254,249,219,60,12,231,4,63,2,176,33,63,66,51,156,63,2,176,33,63,65,25,206,63,2,176,33,63,64,0,0,62,254,249,219,62,182,200,180,62,250,159,190,61,210,189,60,62,254,249,219,61,210,189,60,63,2,176,33,63,90,87,168,62,254,249,219,63,90,87,168,63,2,176,33,63,26,87,168,62,254,249,219,63,26,87,168,63,2,176,33,62,151,167,135,62,254,249,219,62,151,167,135,62,253,99,136,62,18,110,152,62,250,199,17,62,10,61,113,62,250,159,190,62,10,61,113,62,250,199,17,62,2,12,74,62,250,159,190,63,36,155,166,62,250,199,17,63,34,143,92,62,250,159,190,63,34,143,92,62,250,199,17,63,32,131,18,62,250,159,190,63,100,155,166,62,250,199,17,63,98,143,92,62,250,159,190,63,98,143,92,62,250,199,17,63,96,131,18,62,250,159,190,63,77,237,41,62,254,249,219,63,77,237,41,62,252,54,17,63,13,237,41,62,254,249,219,63,13,237,41,62,252,54,17,61,94,210,137,62,254,249,219,62,182,200,180,62,254,249,219,62,182,200,180,63,2,176,33,62,180,175,79,62,254,249,219,62,162,25,101,62,250,159,190,62,160,13,27,62,250,199,17,62,157,243,182,62,250,159,190,62,164,50,202,62,250,199,17,62,201,55,76,62,250,199,17,62,199,43,2,62,250,159,190,62,197,30,184,62,250,199,17,62,195,18,111,62,250,159,190,62,190,249,219,62,250,159,190,62,193,6,37,62,250,199,17,63,60,185,36,63,2,176,33,62,249,114,71,63,2,176,33,63,124,185,36,63,2,176,33,62,114,228,143,63,2,176,33,60,140,21,77,63,2,176,33,63,68,96,170,63,2,176,33,63,4,96,170,63,2,176,33,62,141,14,86,63,2,176,33,63,121,120,213,63,2,176,33,62,101,227,84,63,2,176,33,63,57,120,213,63,2,176,33,62,242,241,170,63,2,176,33,63,8,167,30,63,2,176,33,63,8,167,30,62,254,249,219,63,9,186,94,63,2,176,33,63,72,167,30,63,2,176,33,63,72,167,30,62,254,249,219,63,73,186,94,63,2,176,33,61,10,113,222,63,2,176,33,61,10,113,222,62,254,249,219,61,27,165,227,63,2,176,33,62,151,167,135,63,2,176,33,62,234,113,222,63,2,176,33,63,117,56,239,63,2,176,33,63,53,56,239,63,2,176,33,62,84,227,189,63,2,176,33,63,61,204,100,62,250,159,190,63,125,204,100,62,250,159,190,63,77,237,41,63,2,176,33,63,13,237,41,63,2,176,33,61,94,210,137,63,2,176,33,63,86,63,20,62,250,159,190,63,22,63,20,62,250,159,190,62,160,13,27,63,2,176,33,62,68,24,147,63,2,176,33,62,226,12,74,63,2,176,33,63,113,6,37,63,2,176,33,63,49,6,37,63,2,176,33,61,144,203,41,63,2,176,33,63,82,25,101,63,2,176,33,63,18,25,101,63,2,176,33,62,168,88,121,63,2,176,33,63,44,224,118,63,2,176,33,63,108,224,118,63,2,176,33,62,51,129,216,63,2,176,33,62,217,192,236,63,2,176,33,63,21,50,97,63,2,176,33,63,85,50,97,63,2,176,33,61,169,147,12,63,2,176,33,62,110,125,86,62,253,99,136,62,110,125,86,62,254,249,219,62,247,62,171,62,253,99,136,62,247,62,171,62,254,249,219,63,59,159,86,62,253,99,136,63,59,159,86,62,254,249,219,63,123,159,86,62,253,99,136,63,123,159,86,62,254,249,219,62,176,150,188,63,2,176,33,63,40,186,199,63,2,176,33,63,104,186,199,63,2,176,33,62,209,117,142,63,2,176,33,62,34,235,28,63,2,176,33,63,89,81,131,63,2,176,33,63,25,81,131,63,2,176,33,61,202,140,21,63,2,176,33,62,184,212,254,63,2,176,33,63,100,155,166,63,2,176,33,62,18,110,152,63,2,176,33,63,36,155,166,63,2,176,33,62,201,55,76,63,2,176,33,62,193,6,37,63,2,176,33,62,2,12,74,63,2,176,33,63,96,131,18,63,2,176,33,63,32,131,18,63,2,176,33,60,174,125,86,62,251,87,63,63,69,115,235,62,251,87,63,63,5,115,235,62,251,87,63,63,128,0,0,62,254,249,219,63,65,25,206,62,250,159,190,63,1,25,206,62,250,159,190,63,128,0,0,62,250,159,190,59,140,231,4,62,250,199,17,59,140,231,4,62,250,159,190,62,18,110,152,62,253,99,136,63,100,155,166,62,253,99,136,62,201,55,76,62,253,99,136,62,197,30,184,62,253,99,136,63,36,155,166,62,253,99,136,62,188,237,145,62,253,99,136,62,193,6,37,62,253,99,136,62,145,78,60,62,252,54,17,63,8,167,30,62,252,54,17,63,72,167,30,62,252,54,17,61,10,113,222,62,252,54,17,63,13,237,41,62,250,159,190,63,10,199,17,62,250,159,190,63,77,237,41,62,250,159,190,63,74,199,17,62,250,159,190,60,243,77,106,62,252,54,17,60,243,77,106,62,251,87,63,63,71,154,107,62,252,54,17,63,71,154,107,62,251,87,63,63,7,154,107,62,252,54,17,63,7,154,107,62,251,87,63,62,184,212,254,62,252,54,17,61,111,157,178,62,250,159,190,61,94,210,137,62,250,159,190,61,44,113,13,62,250,159,190,61,10,113,222,62,250,159,190,63,72,167,30,62,250,159,190,63,8,167,30,62,250,159,190,61,144,203,41,62,254,249,219,63,82,25,101,62,254,249,219,63,18,25,101,62,254,249,219,63,14,249,219,62,250,159,190,63,78,249,219,62,250,159,190,63,26,87,168,62,250,159,190,63,28,106,127,62,250,159,190,63,92,106,127,62,250,159,190,63,90,87,168,62,250,159,190,61,227,83,248,62,250,159,190,61,210,189,60,62,250,159,190,63,30,118,201,62,250,159,190,63,94,118,201,62,250,159,190,61,243,182,70,62,250,159,190,61,136,101,149,62,250,159,190,62,153,192,236,62,252,54,17,61,78,7,95,62,252,54,17,63,17,12,179,62,252,54,17,63,81,12,179,62,252,54,17,61,136,101,149,62,252,54,17,128,0,0,0,63,1,150,83,62,151,167,135,62,250,159,190,62,176,150,188,62,250,159,190,62,217,192,236,62,251,87,63,63,44,224,118,62,251,87,63,62,51,129,216,62,251,87,63,63,108,224,118,62,251,87,63,62,168,88,121,62,251,87,63,63,42,205,159,62,251,87,63,62,213,155,61,62,251,87,63,62,43,54,122,62,251,87,63,63,106,205,159,62,251,87,63,63,86,63,20,62,251,87,63,63,22,63,20,62,251,87,63,62,172,126,40,62,251,87,63,62,209,117,142,62,251,87,63,63,104,186,199,62,251,87,63,63,40,186,199,62,251,87,63,62,34,235,28,62,251,87,63,63,24,75,94,62,251,87,63,61,194,90,238,62,251,87,63,63,88,75,94,62,251,87,63,63,38,174,125,62,251,87,63,63,102,174,125,62,251,87,63,62,205,92,251,62,251,87,63,62,26,185,245,62,251,87,63,0,0,0,23,0,0,21,111,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,32,0,0,0,33,0,0,0,34,0,0,0,35,0,0,0,36,0,0,0,37,0,0,0,38,0,0,0,39,0,0,0,40,0,0,0,41,0,0,0,42,0,0,0,43,0,0,0,44,0,0,0,45,0,0,0,46,0,0,0,47,0,0,0,48,0,0,0,49,0,0,0,50,0,0,0,51,0,0,0,52,0,0,0,53,0,0,0,54,0,0,0,55,0,0,0,56,0,0,0,57,0,0,0,58,0,0,0,59,0,0,0,60,0,0,0,61,0,0,0,62,0,0,0,63,0,0,0,64,0,0,0,65,0,0,0,66,0,0,0,67,0,0,0,68,0,0,0,69,0,0,0,70,0,0,0,71,0,0,0,72,0,0,0,73,0,0,0,74,0,0,0,75,0,0,0,76,0,0,0,77,0,0,0,78,0,0,0,79,0,0,0,80,0,0,0,81,0,0,0,82,0,0,0,83,0,0,0,84,0,0,0,85,0,0,0,86,0,0,0,87,0,0,0,88,0,0,0,89,0,0,0,90,0,0,0,91,0,0,0,92,0,0,0,93,0,0,0,94,0,0,0,95,0,0,0,96,0,0,0,97,0,0,0,98,0,0,0,99,0,0,0,92,0,0,0,91,0,0,0,100,0,0,0,101,0,0,0,102,0,0,0,103,0,0,0,104,0,0,0,105,0,0,0,106,0,0,0,62,0,0,0,61,0,0,0,107,0,0,0,108,0,0,0,109,0,0,0,110,0,0,0,74,0,0,0,73,0,0,0,111,0,0,0,112,0,0,0,113,0,0,0,114,0,0,0,68,0,0,0,67,0,0,0,115,0,0,0,116,0,0,0,117,0,0,0,118,0,0,0,119,0,0,0,120,0,0,0,121,0,0,0,122,0,0,0,123,0,0,0,124,0,0,0,125,0,0,0,126,0,0,0,127,0,0,0,128,0,0,0,129,0,0,0,130,0,0,0,131,0,0,0,132,0,0,0,133,0,0,0,134,0,0,0,135,0,0,0,136,0,0,0,137,0,0,0,138,0,0,0,139,0,0,0,140,0,0,0,141,0,0,0,85,0,0,0,84,0,0,0,142,0,0,0,143,0,0,0,44,0,0,0,144,0,0,0,145,0,0,0,146,0,0,0,147,0,0,0,25,0,0,0,24,0,0,0,148,0,0,0,19,0,0,0,18,0,0,0,149,0,0,0,150,0,0,0,151,0,0,0,152,0,0,0,153,0,0,0,154,0,0,0,155,0,0,0,116,0,0,0,115,0,0,0,156,0,0,0,157,0,0,0,158,0,0,0,159,0,0,0,108,0,0,0,107,0,0,0,160,0,0,0,161,0,0,0,162,0,0,0,163,0,0,0,112,0,0,0,111,0,0,0,164,0,0,0,165,0,0,0,166,0,0,0,167,0,0,0,168,0,0,0,169,0,0,0,170,0,0,0,171,0,0,0,172,0,0,0,173,0,0,0,174,0,0,0,175,0,0,0,176,0,0,0,137,0,0,0,136,0,0,0,177,0,0,0,178,0,0,0,179,0,0,0,180,0,0,0,131,0,0,0,130,0,0,0,181,0,0,0,182,0,0,0,183,0,0,0,184,0,0,0,185,0,0,0,186,0,0,0,187,0,0,0,188,0,0,0,189,0,0,0,190,0,0,0,191,0,0,0,192,0,0,0,193,0,0,0,194,0,0,0,195,0,0,0,196,0,0,0,46,0,0,0,45,0,0,0,197,0,0,0,198,0,0,0,199,0,0,0,200,0,0,0,95,0,0,0,201,0,0,0,93,0,0,0,125,0,0,0,124,0,0,0,202,0,0,0,203,0,0,0,204,0,0,0,205,0,0,0,206,0,0,0,207,0,0,0,208,0,0,0,16,0,0,0,15,0,0,0,209,0,0,0,210,0,0,0,211,0,0,0,212,0,0,0,213,0,0,0,53,0,0,0,214,0,0,0,215,0,0,0,56,0,0,0,216,0,0,0,217,0,0,0,218,0,0,0,219,0,0,0,220,0,0,0,221,0,0,0,222,0,0,0,221,0,0,0,220,0,0,0,223,0,0,0,224,0,0,0,225,0,0,0,226,0,0,0,225,0,0,0,224,0,0,0,227,0,0,0,228,0,0,0,229,0,0,0,230,0,0,0,231,0,0,0,232,0,0,0,233,0,0,0,234,0,0,0,235,0,0,0,236,0,0,0,237,0,0,0,238,0,0,0,239,0,0,0,240,0,0,0,241,0,0,0,242,0,0,0,243,0,0,0,244,0,0,0,245,0,0,0,246,0,0,0,247,0,0,0,248,0,0,0,249,0,0,0,250,0,0,0,251,0,0,0,252,0,0,0,253,0,0,0,106,0,0,0,254,0,0,0,255,0,0,1,0,0,0,1,1,0,0,1,2,0,0,0,114,0,0,1,3,0,0,1,4,0,0,1,5,0,0,1,6,0,0,1,7,0,0,0,110,0,0,0,183,0,0,1,8,0,0,1,9,0,0,1,10,0,0,1,11,0,0,1,12,0,0,1,13,0,0,1,14,0,0,1,15,0,0,1,16,0,0,1,17,0,0,1,18,0,0,1,19,0,0,1,20,0,0,1,21,0,0,1,22,0,0,1,23,0,0,1,24,0,0,1,25,0,0,0,28,0,0,0,27,0,0,1,26,0,0,1,27,0,0,1,28,0,0,1,29,0,0,0,22,0,0,0,21,0,0,1,30,0,0,1,31,0,0,1,32,0,0,1,33,0,0,1,34,0,0,1,35,0,0,1,36,0,0,1,37,0,0,1,38,0,0,1,39,0,0,1,40,0,0,1,41,0,0,1,42,0,0,0,12,0,0,1,43,0,0,1,44,0,0,1,45,0,0,1,46,0,0,1,47,0,0,1,48,0,0,1,49,0,0,1,50,0,0,1,51,0,0,1,52,0,0,1,53,0,0,0,9,0,0,1,54,0,0,1,55,0,0,1,56,0,0,1,57,0,0,1,58,0,0,1,59,0,0,1,60,0,0,1,61,0,0,0,139,0,0,1,62,0,0,1,63,0,0,1,64,0,0,1,65,0,0,1,66,0,0,0,133,0,0,1,67,0,0,1,68,0,0,1,69,0,0,1,70,0,0,1,71,0,0,1,72,0,0,1,73,0,0,1,74,0,0,1,75,0,0,1,76,0,0,1,77,0,0,1,78,0,0,0,184,0,0,1,79,0,0,1,80,0,0,1,81,0,0,1,82,0,0,1,83,0,0,0,154,0,0,1,84,0,0,1,85,0,0,1,86,0,0,1,87,0,0,0,51,0,0,1,88,0,0,1,89,0,0,1,90,0,0,1,91,0,0,1,92,0,0,0,54,0,0,1,93,0,0,1,94,0,0,1,95,0,0,1,96,0,0,1,97,0,0,0,42,0,0,1,98,0,0,1,99,0,0,1,100,0,0,1,101,0,0,1,102,0,0,0,233,0,0,0,232,0,0,1,103,0,0,0,236,0,0,0,235,0,0,1,104,0,0,0,230,0,0,0,229,0,0,1,105,0,0,1,106,0,0,0,128,0,0,1,107,0,0,1,108,0,0,1,109,0,0,1,110,0,0,1,111,0,0,1,112,0,0,1,113,0,0,1,114,0,0,0,40,0,0,1,115,0,0,1,116,0,0,0,104,0,0,1,117,0,0,1,118,0,0,1,119,0,0,1,45,0,0,1,120,0,0,1,121,0,0,1,122,0,0,0,248,0,0,0,247,0,0,1,123,0,0,1,124,0,0,1,125,0,0,0,195,0,0,0,194,0,0,1,126,0,0,0,22,0,0,1,29,0,0,1,127,0,0,0,28,0,0,1,25,0,0,1,128,0,0,1,129,0,0,1,130,0,0,1,131,0,0,1,132,0,0,1,112,0,0,1,133,0,0,0,170,0,0,1,134,0,0,0,168,0,0,1,135,0,0,1,136,0,0,1,137,0,0,1,138,0,0,1,139,0,0,1,140,0,0,1,48,0,0,1,47,0,0,1,141,0,0,1,40,0,0,1,39,0,0,1,142,0,0,1,17,0,0,1,16,0,0,1,143,0,0,1,11,0,0,1,10,0,0,1,144,0,0,1,145,0,0,1,146,0,0,1,147,0,0,1,59,0,0,1,58,0,0,1,148,0,0,0,162,0,0,0,161,0,0,1,149,0,0,0,158,0,0,0,157,0,0,1,150,0,0,0,166,0,0,0,165,0,0,1,151,0,0,1,152,0,0,1,153,0,0,1,154,0,0,1,155,0,0,1,156,0,0,1,157,0,0,0,189,0,0,0,188,0,0,1,158,0,0,1,159,0,0,1,160,0,0,1,161,0,0,1,162,0,0,1,163,0,0,1,164,0,0,1,165,0,0,1,166,0,0,1,167,0,0,1,168,0,0,0,92,0,0,1,169,0,0,0,204,0,0,0,203,0,0,1,170,0,0,0,207,0,0,0,206,0,0,1,171,0,0,1,172,0,0,0,230,0,0,1,173,0,0,1,20,0,0,1,19,0,0,1,174,0,0,1,175,0,0,0,233,0,0,1,176,0,0,1,14,0,0,1,13,0,0,1,177,0,0,1,178,0,0,0,236,0,0,1,179,0,0,1,80,0,0,1,79,0,0,1,180,0,0,0,4,0,0,0,3,0,0,1,181,0,0,1,182,0,0,1,60,0,0,1,183,0,0,1,184,0,0,1,185,0,0,0,186,0,0,0,122,0,0,1,186,0,0,1,187,0,0,1,188,0,0,1,189,0,0,1,190,0,0,1,191,0,0,1,192,0,0,1,193,0,0,1,194,0,0,1,195,0,0,1,196,0,0,1,197,0,0,1,198,0,0,1,199,0,0,1,200,0,0,1,201,0,0,1,202,0,0,1,203,0,0,1,204,0,0,1,205,0,0,0,58,0,0,1,206,0,0,1,207,0,0,0,64,0,0,1,208,0,0,1,209,0,0,0,70,0,0,1,210,0,0,1,211,0,0,1,2,0,0,1,1,0,0,1,212,0,0,0,233,0,0,1,175,0,0,0,231,0,0,1,7,0,0,1,6,0,0,1,213,0,0,0,236,0,0,1,178,0,0,1,214,0,0,0,92,0,0,1,168,0,0,0,90,0,0,1,215,0,0,1,216,0,0,1,217,0,0,0,230,0,0,1,172,0,0,1,218,0,0,0,253,0,0,0,252,0,0,1,219,0,0,1,216,0,0,1,215,0,0,0,246,0,0,1,124,0,0,1,123,0,0,1,220,0,0,1,221,0,0,0,200,0,0,0,199,0,0,0,50,0,0,1,222,0,0,0,48,0,0,1,223,0,0,1,224,0,0,0,89,0,0,0,109,0,0,1,225,0,0,1,226,0,0,0,113,0,0,1,227,0,0,1,228,0,0,0,117,0,0,1,229,0,0,1,230,0,0,1,231,0,0,1,232,0,0,1,233,0,0,1,234,0,0,1,235,0,0,1,236,0,0,0,175,0,0,1,237,0,0,1,238,0,0,1,239,0,0,1,240,0,0,1,241,0,0,0,179,0,0,1,242,0,0,1,243,0,0,1,244,0,0,1,245,0,0,1,246,0,0,1,247,0,0,1,248,0,0,1,249,0,0,1,250,0,0,1,251,0,0,0,215,0,0,1,252,0,0,1,253,0,0,1,254,0,0,1,255,0,0,2,0,0,0,0,213,0,0,2,1,0,0,2,2,0,0,0,143,0,0,2,3,0,0,2,4,0,0,2,5,0,0,2,6,0,0,2,7,0,0,1,37,0,0,2,8,0,0,0,154,0,0,1,83,0,0,0,35,0,0,2,9,0,0,0,33,0,0,2,10,0,0,0,40,0,0,1,114,0,0,0,38,0,0,2,11,0,0,0,36,0,0,2,12,0,0,0,104,0,0,1,116,0,0,0,102,0,0,2,13,0,0,0,100,0,0,2,14,0,0,2,15,0,0,2,16,0,0,2,17,0,0,2,18,0,0,0,226,0,0,2,19,0,0,2,20,0,0,2,21,0,0,2,22,0,0,2,23,0,0,0,222,0,0,2,24,0,0,0,213,0,0,2,0,0,0,2,25,0,0,0,152,0,0,0,151,0,0,2,26,0,0,0,215,0,0,1,251,0,0,2,27,0,0,0,147,0,0,0,146,0,0,2,28,0,0,0,143,0,0,2,2,0,0,2,29,0,0,2,30,0,0,2,31,0,0,2,32,0,0,2,33,0,0,1,50,0,0,2,34,0,0,2,35,0,0,0,45,0,0,2,35,0,0,2,36,0,0,2,37,0,0,2,38,0,0,2,39,0,0,2,40,0,0,2,41,0,0,2,42,0,0,2,43,0,0,2,44,0,0,2,45,0,0,2,46,0,0,2,47,0,0,2,48,0,0,2,49,0,0,0,76,0,0,0,75,0,0,2,50,0,0,2,51,0,0,2,52,0,0,2,53,0,0,0,192,0,0,0,191,0,0,2,54,0,0,2,55,0,0,0,48,0,0,2,56,0,0,1,60,0,0,1,182,0,0,2,57,0,0,1,226,0,0,2,58,0,0,0,109,0,0,1,160,0,0,1,159,0,0,2,59,0,0,1,228,0,0,2,60,0,0,0,113,0,0,1,163,0,0,1,162,0,0,2,61,0,0,1,230,0,0,2,62,0,0,0,117,0,0,1,166,0,0,1,165,0,0,2,63,0,0,2,64,0,0,2,65,0,0,2,66,0,0,2,67,0,0,2,68,0,0,2,69,0,0,1,112,0,0,1,132,0,0,1,110,0,0,2,70,0,0,2,71,0,0,2,72,0,0,1,109,0,0,2,73,0,0,1,107,0,0,2,74,0,0,2,75,0,0,2,76,0,0,0,128,0,0,0,127,0,0,1,105,0,0,0,5,0,0,2,77,0,0,0,3,0,0,2,78,0,0,2,72,0,0,2,71,0,0,0,223,0,0,2,79,0,0,0,221,0,0,2,80,0,0,2,69,0,0,2,68,0,0,2,81,0,0,2,76,0,0,2,75,0,0,0,227,0,0,2,82,0,0,0,225,0,0,2,83,0,0,2,84,0,0,2,85,0,0,1,81,0,0,2,85,0,0,1,79,0,0,2,86,0,0,1,22,0,0,2,87,0,0,2,88,0,0,2,87,0,0,2,89,0,0,2,90,0,0,1,234,0,0,2,91,0,0,2,92,0,0,2,91,0,0,2,93,0,0,0,172,0,0,2,94,0,0,2,95,0,0,2,96,0,0,2,97,0,0,2,98,0,0,0,83,0,0,2,99,0,0,0,81,0,0,2,100,0,0,1,56,0,0,2,101,0,0,0,1,0,0,0,0,0,0,2,102,0,0,2,102,0,0,2,103,0,0,2,104,0,0,0,31,0,0,0,30,0,0,2,105,0,0,2,105,0,0,2,106,0,0,2,107,0,0,0,239,0,0,2,108,0,0,0,237,0,0,2,109,0,0,2,31,0,0,2,30,0,0,2,110,0,0,2,111,0,0,2,112,0,0,2,113,0,0,2,114,0,0,2,115,0,0,2,116,0,0,2,117,0,0,2,118,0,0,2,119,0,0,2,120,0,0,2,121,0,0,2,122,0,0,2,123,0,0,2,124,0,0,2,125,0,0,2,126,0,0,2,127,0,0,2,128,0,0,2,129,0,0,2,130,0,0,2,131,0,0,2,115,0,0,2,114,0,0,2,132,0,0,2,133,0,0,2,134,0,0,2,135,0,0,2,127,0,0,2,126,0,0,2,136,0,0,2,137,0,0,2,138,0,0,2,139,0,0,2,121,0,0,2,120,0,0,2,40,0,0,2,140,0,0,2,38,0,0,2,141,0,0,2,40,0,0,2,142,0,0,2,46,0,0,2,143,0,0,2,44,0,0,2,144,0,0,2,46,0,0,2,145,0,0,1,147,0,0,2,146,0,0,1,145,0,0,2,147,0,0,1,147,0,0,2,148,0,0,0,156,0,0,2,149,0,0,0,116,0,0,2,149,0,0,2,145,0,0,2,46,0,0,0,164,0,0,2,150,0,0,0,112,0,0,2,150,0,0,2,142,0,0,2,40,0,0,0,160,0,0,2,151,0,0,0,108,0,0,2,151,0,0,2,148,0,0,1,147,0,0,2,152,0,0,2,153,0,0,2,154,0,0,2,155,0,0,2,156,0,0,2,157,0,0,2,158,0,0,2,159,0,0,2,160,0,0,1,9,0,0,2,161,0,0,0,183,0,0,2,162,0,0,2,154,0,0,2,153,0,0,2,163,0,0,2,164,0,0,2,165,0,0,2,166,0,0,2,167,0,0,2,168,0,0,2,169,0,0,2,165,0,0,2,164,0,0,2,170,0,0,0,176,0,0,2,171,0,0,2,172,0,0,1,63,0,0,2,173,0,0,2,174,0,0,1,68,0,0,2,175,0,0,2,176,0,0,0,180,0,0,2,177,0,0,2,178,0,0,1,137,0,0,1,136,0,0,2,179,0,0,1,249,0,0,1,248,0,0,2,180,0,0,1,254,0,0,1,253,0,0,2,181,0,0,2,5,0,0,2,4,0,0,2,182,0,0,1,85,0,0,2,183,0,0,1,85,0,0,2,182,0,0,2,184,0,0,0,89,0,0,2,185,0,0,1,223,0,0,2,186,0,0,1,32,0,0,2,187,0,0,2,23,0,0,2,19,0,0,2,188,0,0,2,18,0,0,2,14,0,0,2,189,0,0,2,190,0,0,1,28,0,0,2,191,0,0,1,86,0,0,0,4,0,0,1,84,0,0,0,154,0,0,0,153,0,0,1,82,0,0,2,192,0,0,0,220,0,0,2,193,0,0,0,40,0,0,0,39,0,0,1,113,0,0,2,194,0,0,0,224,0,0,2,195,0,0,0,104,0,0,0,103,0,0,1,115,0,0,2,196,0,0,0,80,0,0,0,79,0,0,2,7,0,0,2,6,0,0,2,197,0,0,2,198,0,0,2,199,0,0,2,200,0,0,2,201,0,0,0,11,0,0,0,10,0,0,2,202,0,0,2,203,0,0,2,204,0,0,2,205,0,0,1,65,0,0,1,64,0,0,2,206,0,0,2,207,0,0,2,208,0,0,2,209,0,0,1,187,0,0,1,186,0,0,2,210,0,0,1,70,0,0,1,69,0,0,2,211,0,0,2,212,0,0,2,213,0,0,2,214,0,0,0,14,0,0,0,13,0,0,2,215,0,0,2,216,0,0,2,217,0,0,2,218,0,0,2,219,0,0,2,220,0,0,2,221,0,0,0,135,0,0,0,134,0,0,2,222,0,0,2,223,0,0,2,224,0,0,2,225,0,0,0,141,0,0,0,140,0,0,2,226,0,0,2,227,0,0,2,228,0,0,2,229,0,0,1,121,0,0,1,120,0,0,0,173,0,0,2,230,0,0,0,171,0,0,1,35,0,0,1,74,0,0,1,33,0,0,0,218,0,0,0,217,0,0,2,231,0,0,1,28,0,0,2,190,0,0,1,26,0,0,0,211,0,0,0,210,0,0,2,232,0,0,1,32,0,0,2,186,0,0,1,30,0,0,0,222,0,0,2,233,0,0,2,22,0,0,0,226,0,0,2,234,0,0,2,17,0,0,2,235,0,0,2,236,0,0,2,237,0,0,0,200,0,0,1,221,0,0,0,95,0,0,1,78,0,0,1,77,0,0,0,198,0,0,2,238,0,0,2,239,0,0,2,240,0,0,2,241,0,0,0,99,0,0,2,242,0,0,2,243,0,0,2,244,0,0,2,241,0,0,2,245,0,0,1,104,0,0,1,206,0,0,2,246,0,0,2,247,0,0,2,245,0,0,2,248,0,0,2,249,0,0,2,250,0,0,2,250,0,0,1,102,0,0,1,208,0,0,2,251,0,0,1,103,0,0,1,210,0,0,2,252,0,0,2,253,0,0,2,251,0,0,0,119,0,0,0,118,0,0,2,254,0,0,2,255,0,0,3,0,0,0,3,1,0,0,1,192,0,0,1,191,0,0,3,2,0,0,0,159,0,0,3,3,0,0,3,4,0,0,1,204,0,0,1,203,0,0,3,5,0,0,0,167,0,0,3,6,0,0,3,7,0,0,1,198,0,0,1,197,0,0,3,8,0,0,0,163,0,0,3,9,0,0,3,10,0,0,3,0,0,0,2,255,0,0,3,11,0,0,0,88,0,0,0,87,0,0,3,12,0,0,3,13,0,0,3,14,0,0,3,15,0,0,2,33,0,0,2,32,0,0,3,16,0,0,2,156,0,0,2,155,0,0,3,17,0,0,3,14,0,0,3,13,0,0,3,18,0,0,2,112,0,0,3,19,0,0,3,20,0,0,3,19,0,0,2,112,0,0,2,111,0,0,3,21,0,0,2,118,0,0,2,117,0,0,2,118,0,0,3,21,0,0,3,22,0,0,2,124,0,0,3,23,0,0,3,24,0,0,3,23,0,0,2,124,0,0,2,123,0,0,3,25,0,0,3,26,0,0,0,218,0,0,2,48,0,0,2,47,0,0,3,27,0,0,3,28,0,0,3,29,0,0,0,211,0,0,2,42,0,0,2,41,0,0,3,30,0,0,0,186,0,0,3,31,0,0,1,184,0,0,3,32,0,0,3,33,0,0,3,34,0,0,3,35,0,0,3,36,0,0,3,37,0,0,3,36,0,0,3,35,0,0,0,119,0,0,1,148,0,0,1,58,0,0,3,38,0,0,3,39,0,0,3,40,0,0,0,84,0,0,3,41,0,0,3,42,0,0,3,43,0,0,3,42,0,0,3,41,0,0,3,44,0,0,3,45,0,0,3,46,0,0,3,47,0,0,3,46,0,0,3,45,0,0,3,48,0,0,3,49,0,0,3,50,0,0,3,51,0,0,3,50,0,0,3,49,0,0,3,52,0,0,3,53,0,0,3,54,0,0,3,55,0,0,3,54,0,0,3,53,0,0,3,56,0,0,3,57,0,0,3,58,0,0,3,59,0,0,3,58,0,0,3,57,0,0,3,60,0,0,3,61,0,0,3,62,0,0,3,63,0,0,3,62,0,0,3,61,0,0,3,64,0,0,2,153,0,0,2,152,0,0,3,65,0,0,0,97,0,0,2,242,0,0,3,66,0,0,2,16,0,0,2,189,0,0,2,14,0,0,2,195,0,0,0,24,0,0,2,194,0,0,2,21,0,0,2,188,0,0,2,19,0,0,2,193,0,0,0,18,0,0,2,192,0,0,3,67,0,0,1,122,0,0,3,68,0,0,3,69,0,0,3,70,0,0,3,71,0,0,3,72,0,0,3,73,0,0,3,74,0,0,3,75,0,0,0,60,0,0,3,76,0,0,3,77,0,0,3,78,0,0,3,79,0,0,3,80,0,0,0,72,0,0,3,81,0,0,3,82,0,0,3,83,0,0,3,84,0,0,3,85,0,0,0,66,0,0,3,86,0,0,3,87,0,0,3,88,0,0,3,89,0,0,3,29,0,0,3,28,0,0,3,90,0,0,3,91,0,0,3,92,0,0,3,93,0,0,3,26,0,0,3,25,0,0,3,94,0,0,3,40,0,0,3,39,0,0,3,95,0,0,3,96,0,0,3,97,0,0,3,98,0,0,3,99,0,0,3,100,0,0,3,101,0,0,3,101,0,0,1,119,0,0,3,99,0,0,3,102,0,0,3,103,0,0,3,104,0,0,3,104,0,0,0,245,0,0,3,102,0,0,3,105,0,0,0,242,0,0,3,106,0,0,3,106,0,0,3,107,0,0,3,105,0,0,2,36,0,0,3,108,0,0,3,109,0,0,3,110,0,0,2,37,0,0,2,36,0,0,3,111,0,0,1,226,0,0,3,112,0,0,3,113,0,0,3,114,0,0,3,115,0,0,3,116,0,0,1,228,0,0,3,117,0,0,3,118,0,0,3,119,0,0,3,120,0,0,3,121,0,0,3,122,0,0,3,123,0,0,3,124,0,0,0,93,0,0,3,125,0,0,3,126,0,0,1,230,0,0,3,127,0,0,3,128,0,0,3,129,0,0,3,130,0,0,3,131,0,0,0,100,0,0,2,13,0,0,1,106,0,0,3,132,0,0,3,133,0,0,1,108,0,0,3,134,0,0,3,135,0,0,3,136,0,0,0,33,0,0,2,9,0,0,3,137,0,0,0,36,0,0,2,11,0,0,1,111,0,0,3,138,0,0,3,139,0,0,1,88,0,0,1,151,0,0,0,165,0,0,1,90,0,0,1,89,0,0,1,252,0,0,1,98,0,0,1,149,0,0,0,161,0,0,1,100,0,0,1,99,0,0,2,3,0,0,1,93,0,0,1,150,0,0,0,157,0,0,1,95,0,0,1,94,0,0,1,247,0,0,0,183,0,0,3,140,0,0,0,6,0,0,0,43,0,0,0,42,0,0,1,97,0,0,3,141,0,0,3,142,0,0,0,43,0,0,0,52,0,0,0,51,0,0,1,87,0,0,3,143,0,0,3,144,0,0,0,52,0,0,0,55,0,0,0,54,0,0,1,92,0,0,3,145,0,0,3,146,0,0,0,55,0,0,3,147,0,0,3,148,0,0,2,97,0,0,2,97,0,0,2,96,0,0,3,147,0,0,3,149,0,0,2,130,0,0,2,129,0,0,3,150,0,0,3,151,0,0,3,152,0,0,3,153,0,0,2,138,0,0,2,137,0,0,3,154,0,0,3,155,0,0,3,156,0,0,3,157,0,0,2,134,0,0,2,133,0,0,3,158,0,0,3,159,0,0,3,160,0,0,3,161,0,0,3,162,0,0,1,153,0,0,1,153,0,0,1,152,0,0,3,161,0,0,1,156,0,0,1,155,0,0,3,163,0,0,3,163,0,0,3,164,0,0,1,156,0,0,1,56,0,0,2,100,0,0,3,165,0,0,3,165,0,0,1,57,0,0,1,56,0,0,2,85,0,0,3,166,0,0,2,83,0,0,3,166,0,0,3,167,0,0,3,168,0,0,3,169,0,0,3,170,0,0,3,171,0,0,3,172,0,0,2,160,0,0,2,159,0,0,3,173,0,0,2,168,0,0,2,167,0,0,3,174,0,0,3,175,0,0,3,176,0,0,3,177,0,0,0,8,0,0,0,7,0,0,3,178,0,0,3,176,0,0,3,175,0,0,3,179,0,0,1,238,0,0,1,237,0,0,3,180,0,0,1,236,0,0,1,235,0,0,3,181,0,0,1,243,0,0,1,242,0,0,3,182,0,0,1,24,0,0,1,23,0,0,3,183,0,0,3,105,0,0,3,107,0,0,3,184,0,0,3,104,0,0,3,103,0,0,3,185,0,0,3,101,0,0,3,100,0,0,3,186,0,0,1,76,0,0,1,75,0,0,2,212,0,0,2,211,0,0,3,187,0,0,2,207,0,0,2,206,0,0,3,188,0,0,2,203,0,0,2,202,0,0,3,189,0,0,2,199,0,0,2,198,0,0,3,190,0,0,3,191,0,0,3,192,0,0,3,193,0,0,3,194,0,0,3,195,0,0,3,196,0,0,3,197,0,0,3,198,0,0,3,199,0,0,2,94,0,0,0,172,0,0,3,200,0,0,2,227,0,0,2,226,0,0,3,201,0,0,2,219,0,0,2,218,0,0,3,202,0,0,2,223,0,0,2,222,0,0,3,203,0,0,2,216,0,0,2,215,0,0,3,204,0,0,3,205,0,0,2,102,0,0,0,0,0,0,3,206,0,0,2,105,0,0,0,30,0,0,1,222,0,0,3,171,0,0,3,170,0,0,2,20,0,0,2,19,0,0,3,207,0,0,2,15,0,0,2,14,0,0,3,208,0,0,2,99,0,0,0,83,0,0,3,209,0,0,3,210,0,0,3,30,0,0,2,41,0,0,3,211,0,0,3,27,0,0,2,47,0,0,1,134,0,0,0,170,0,0,3,212,0,0,2,247,0,0,2,246,0,0,3,213,0,0,2,244,0,0,2,243,0,0,3,214,0,0,2,253,0,0,2,252,0,0,3,215,0,0,2,249,0,0,2,248,0,0,3,216,0,0,2,108,0,0,0,239,0,0,3,217,0,0,1,31,0,0,1,30,0,0,3,218,0,0,1,27,0,0,1,26,0,0,3,219,0,0,3,33,0,0,3,32,0,0,3,220,0,0,3,83,0,0,3,82,0,0,3,221,0,0,3,78,0,0,3,77,0,0,3,222,0,0,3,73,0,0,3,72,0,0,3,223,0,0,3,70,0,0,3,69,0,0,3,224,0,0,3,225,0,0,3,93,0,0,3,92,0,0,3,226,0,0,3,89,0,0,3,88,0,0,3,227,0,0,3,98,0,0,3,97,0,0,3,228,0,0,2,89,0,0,2,87,0,0,1,24,0,0,3,182,0,0,3,229,0,0,3,230,0,0,2,93,0,0,2,91,0,0,1,236,0,0,3,180,0,0,3,231,0,0,3,232,0,0,2,171,0,0,0,176,0,0,1,238,0,0,3,179,0,0,3,233,0,0,3,234,0,0,2,177,0,0,0,180,0,0,1,243,0,0,3,181,0,0,3,235,0,0,3,108,0,0,2,36,0,0,3,236,0,0,3,129,0,0,3,128,0,0,3,237,0,0,3,119,0,0,3,118,0,0,3,238,0,0,3,122,0,0,3,121,0,0,3,239,0,0,3,114,0,0,3,113,0,0,3,240,0,0,3,241,0,0,0,52,0,0,3,144,0,0,3,242,0,0,0,55,0,0,3,146,0,0,3,243,0,0,0,43,0,0,3,142,0,0,1,181,0,0,2,57,0,0,1,182,0,0,0,82,0,0,0,81,0,0,1,84,0,0,1,224,0,0,1,223,0,0,0,50,0,0,3,148,0,0,3,147,0,0,0,171,0,0,3,167,0,0,3,166,0,0,3,244,0,0,1,4,0,0,1,3,0,0,3,245,0,0,0,250,0,0,0,249,0,0,3,246,0,0,0,255,0,0,0,254,0,0,3,247,0,0,2,236,0,0,2,235,0,0,3,248,0,0,2,239,0,0,2,238,0,0,3,249,0,0,1,195,0,0,1,194,0,0,3,250,0,0,1,201,0,0,1,200,0,0,3,251,0,0,1,189,0,0,1,188,0,0,3,252,0,0,0,238,0,0,0,237,0,0,1,55,0,0,1,183,0,0,1,60,0,0,1,59,0,0,3,253,0,0,0,242,0,0,0,241,0,0,0,155,0,0,3,253,0,0,0,153,0,0,3,254,0,0,0,245,0,0,0,244,0,0,0,41,0,0,3,254,0,0,0,39,0,0,0,105,0,0,3,255,0,0,0,103,0,0,3,255,0,0,1,119,0,0,1,118,0,0,1,137,0,0,1,36,0,0,1,135,0,0,2,50,0,0,2,51,0,0,0,76,0,0,2,197,0,0,2,196,0,0,2,7,0,0,1,76,0,0,1,33,0,0,1,74,0,0,1,64,0,0,2,202,0,0,2,205,0,0,0,138,0,0,2,172,0,0,0,136,0,0,1,69,0,0,2,211,0,0,2,210,0,0,0,132,0,0,2,174,0,0,0,130,0,0,1,186,0,0,2,206,0,0,2,209,0,0,0,209,0,0,0,121,0,0,0,16,0,0,0,10,0,0,2,198,0,0,2,201,0,0,0,202,0,0,1,53,0,0,0,125,0,0,1,46,0,0,1,47,0,0,1,44,0,0,2,200,0,0,2,201,0,0,2,198,0,0,2,213,0,0,2,210,0,0,2,211,0,0,1,67,0,0,1,10,0,0,1,66,0,0,1,62,0,0,1,16,0,0,1,61,0,0,2,204,0,0,2,205,0,0,2,202,0,0,2,208,0,0,2,209,0,0,2,206,0,0,1,43,0,0,1,39,0,0,1,42,0,0,1,41,0,0,1,42,0,0,1,39,0,0,0,13,0,0,2,215,0,0,2,214,0,0,1,18,0,0,1,61,0,0,1,16,0,0,0,140,0,0,2,222,0,0,2,225,0,0,1,12,0,0,1,66,0,0,1,10,0,0,0,134,0,0,2,218,0,0,2,221,0,0,1,49,0,0,1,44,0,0,1,47,0,0,1,120,0,0,2,226,0,0,2,229,0,0,4,0,0,0,1,246,0,0,1,245,0,0,1,245,0,0,1,131,0,0,1,130,0,0,1,232,0,0,0,129,0,0,0,128,0,0,3,133,0,0,1,233,0,0,1,232,0,0,3,139,0,0,1,241,0,0,1,240,0,0,1,240,0,0,1,133,0,0,1,112,0,0,2,53,0,0,1,140,0,0,1,139,0,0,1,139,0,0,0,77,0,0,0,76,0,0,4,1,0,0,2,104,0,0,2,103,0,0,2,104,0,0,4,1,0,0,2,67,0,0,1,52,0,0,4,2,0,0,2,74,0,0,4,2,0,0,1,52,0,0,1,51,0,0,4,3,0,0,2,107,0,0,2,106,0,0,4,4,0,0,4,5,0,0,2,70,0,0,0,59,0,0,0,207,0,0,0,57,0,0,2,217,0,0,2,214,0,0,2,215,0,0,0,71,0,0,1,14,0,0,0,69,0,0,2,220,0,0,2,221,0,0,2,218,0,0,2,224,0,0,2,225,0,0,2,222,0,0,0,65,0,0,1,20,0,0,0,63,0,0,0,98,0,0,0,204,0,0,0,96,0,0,2,228,0,0,2,229,0,0,2,226,0,0,1,206,0,0,2,246,0,0,2,245,0,0,1,171,0,0,0,57,0,0,0,207,0,0,2,242,0,0,2,243,0,0,2,241,0,0,1,170,0,0,0,96,0,0,0,204,0,0,1,210,0,0,2,252,0,0,2,251,0,0,1,177,0,0,0,69,0,0,1,14,0,0,1,208,0,0,2,248,0,0,2,250,0,0,1,174,0,0,0,63,0,0,1,20,0,0,2,56,0,0,0,192,0,0,2,55,0,0,3,34,0,0,1,184,0,0,3,32,0,0,0,229,0,0,3,76,0,0,0,60,0,0,2,114,0,0,2,113,0,0,2,110,0,0,0,91,0,0,3,68,0,0,1,122,0,0,2,164,0,0,2,163,0,0,2,162,0,0,0,235,0,0,3,81,0,0,0,72,0,0,2,126,0,0,2,125,0,0,2,122,0,0,0,232,0,0,3,86,0,0,0,66,0,0,2,120,0,0,2,119,0,0,2,116,0,0,4,6,0,0,0,249,0,0,3,10,0,0,2,59,0,0,4,6,0,0,1,160,0,0,4,7,0,0,1,3,0,0,3,7,0,0,2,61,0,0,4,7,0,0,1,163,0,0,4,8,0,0,2,235,0,0,4,9,0,0,1,125,0,0,4,8,0,0,1,123,0,0,4,10,0,0,0,254,0,0,3,4,0,0,2,63,0,0,4,10,0,0,1,166,0,0,2,240,0,0,4,11,0,0,2,238,0,0,4,11,0,0,1,79,0,0,2,85,0,0,3,10,0,0,1,198,0,0,0,163,0,0,0,251,0,0,3,10,0,0,0,249,0,0,4,9,0,0,0,194,0,0,4,12,0,0,2,237,0,0,4,9,0,0,2,235,0,0,1,5,0,0,3,7,0,0,1,3,0,0,3,7,0,0,1,204,0,0,0,167,0,0,3,4,0,0,1,192,0,0,0,159,0,0,1,0,0,0,3,4,0,0,0,254,0,0,0,196,0,0,4,12,0,0,0,194,0,0,4,12,0,0,2,238,0,0,4,11,0,0,2,37,0,0,0,187,0,0,0,186,0,0,2,159,0,0,2,158,0,0,1,9,0,0,0,44,0,0,0,143,0,0,3,39,0,0,2,65,0,0,2,64,0,0,1,145,0,0,0,56,0,0,0,215,0,0,3,25,0,0,3,27,0,0,3,211,0,0,2,44,0,0,0,53,0,0,0,213,0,0,3,28,0,0,3,30,0,0,3,210,0,0,2,38,0,0,0,62,0,0,3,112,0,0,1,226,0,0,2,129,0,0,2,128,0,0,2,131,0,0,0,247,0,0,3,125,0,0,0,93,0,0,2,167,0,0,2,166,0,0,2,169,0,0,0,74,0,0,3,117,0,0,1,228,0,0,2,133,0,0,2,132,0,0,2,135,0,0,0,68,0,0,3,127,0,0,1,230,0,0,2,137,0,0,2,136,0,0,2,139,0,0,2,95,0,0,1,73,0,0,1,72,0,0,1,72,0,0,4,13,0,0,2,95,0,0,0,26,0,0,3,193,0,0,3,192,0,0,3,192,0,0,4,14,0,0,0,26,0,0,3,195,0,0,4,15,0,0,0,20,0,0,0,20,0,0,3,196,0,0,3,195,0,0,2,184,0,0,3,199,0,0,3,198,0,0,3,198,0,0,4,16,0,0,2,184,0,0,1,38,0,0,1,135,0,0,1,36,0,0,0,79,0,0,2,7,0,0,2,196,0,0,0,123,0,0,0,16,0,0,0,121,0,0,3,229,0,0,3,228,0,0,1,24,0,0,1,54,0,0,0,125,0,0,1,53,0,0,3,231,0,0,3,230,0,0,1,236,0,0,2,173,0,0,0,136,0,0,2,172,0,0,3,233,0,0,3,232,0,0,1,238,0,0,2,175,0,0,0,130,0,0,2,174,0,0,3,235,0,0,3,234,0,0,1,243,0,0,0,49,0,0,0,170,0,0,0,169,0,0,2,54,0,0,2,55,0,0,0,192,0,0,0,245,0,0,3,104,0,0,0,243,0,0,3,104,0,0,3,184,0,0,0,38,0,0,1,119,0,0,3,101,0,0,1,117,0,0,3,101,0,0,3,185,0,0,0,102,0,0,0,242,0,0,3,105,0,0,0,240,0,0,3,105,0,0,3,183,0,0,0,35,0,0,1,128,0,0,4,17,0,0,0,28,0,0,4,17,0,0,1,128,0,0,4,18,0,0,1,127,0,0,4,19,0,0,0,22,0,0,4,19,0,0,1,127,0,0,4,20,0,0,1,8,0,0,0,183,0,0,0,182,0,0,2,84,0,0,0,45,0,0,2,35,0,0,1,151,0,0,1,88,0,0,0,51,0,0,2,140,0,0,2,40,0,0,2,141,0,0,1,150,0,0,1,93,0,0,0,54,0,0,2,143,0,0,2,46,0,0,2,144,0,0,1,149,0,0,1,98,0,0,0,42,0,0,2,146,0,0,1,147,0,0,2,147,0,0,2,145,0,0,2,149,0,0,0,156,0,0,3,3,0,0,0,159,0,0,0,158,0,0,3,6,0,0,0,167,0,0,0,166,0,0,2,142,0,0,2,150,0,0,0,164,0,0,2,148,0,0,2,151,0,0,0,160,0,0,3,9,0,0,0,163,0,0,0,162,0,0,4,21,0,0,4,22,0,0,4,16,0,0,4,16,0,0,3,198,0,0,4,21,0,0,4,23,0,0,4,24,0,0,4,15,0,0,4,15,0,0,3,195,0,0,4,23,0,0,4,25,0,0,4,26,0,0,4,14,0,0,4,14,0,0,3,192,0,0,4,25,0,0,0,244,0,0,0,37,0,0,1,132,0,0,0,37,0,0,0,244,0,0,0,243,0,0,1,118,0,0,0,101,0,0,0,127,0,0,0,101,0,0,1,118,0,0,1,117,0,0,0,241,0,0,0,34,0,0,2,73,0,0,0,34,0,0,0,241,0,0,0,240,0,0,2,230,0,0,4,13,0,0,1,34,0,0,4,13,0,0,2,230,0,0,0,173,0,0,2,187,0,0,1,153,0,0,3,162,0,0,3,162,0,0,2,22,0,0,2,187,0,0,2,191,0,0,1,156,0,0,3,164,0,0,3,164,0,0,2,17,0,0,2,191,0,0,4,27,0,0,0,184,0,0,1,78,0,0,0,184,0,0,4,27,0,0,0,182,0,0,1,60,0,0,4,28,0,0,1,58,0,0,4,29,0,0,1,60,0,0,4,30,0,0,4,31,0,0,0,3,0,0,2,77,0,0,2,57,0,0,4,30,0,0,1,60,0,0,4,32,0,0,0,221,0,0,2,79,0,0,2,233,0,0,4,20,0,0,1,127,0,0,2,234,0,0,4,18,0,0,1,128,0,0,4,33,0,0,0,225,0,0,2,82,0,0,4,34,0,0,0,86,0,0,2,31,0,0,2,31,0,0,2,109,0,0,4,34,0,0,0,151,0,0,0,150,0,0,4,35,0,0,4,35,0,0,2,232,0,0,0,151,0,0,0,146,0,0,0,145,0,0,4,36,0,0,4,36,0,0,2,231,0,0,0,146,0,0,0,77,0,0,0,119,0,0,0,75,0,0,2,87,0,0,2,88,0,0,2,86,0,0,1,133,0,0,2,102,0,0,1,132,0,0,0,176,0,0,2,170,0,0,0,174,0,0,0,129,0,0,1,50,0,0,0,127,0,0,2,91,0,0,2,92,0,0,2,90,0,0,1,131,0,0,2,105,0,0,1,129,0,0,0,180,0,0,2,176,0,0,0,178,0,0,4,37,0,0,0,28,0,0,4,17,0,0,0,28,0,0,2,49,0,0,2,48,0,0,0,22,0,0,2,43,0,0,2,42,0,0,4,38,0,0,0,22,0,0,4,19,0,0,4,39,0,0,2,46,0,0,2,45,0,0,2,46,0,0,4,40,0,0,2,149,0,0,2,40,0,0,4,41,0,0,2,150,0,0,4,42,0,0,2,40,0,0,2,39,0,0,1,147,0,0,4,43,0,0,2,151,0,0,4,44,0,0,1,147,0,0,1,146,0,0,4,45,0,0,2,149,0,0,4,40,0,0,2,149,0,0,3,156,0,0,3,155,0,0,4,46,0,0,2,150,0,0,4,41,0,0,2,150,0,0,3,160,0,0,3,159,0,0,4,47,0,0,2,151,0,0,4,43,0,0,2,151,0,0,3,152,0,0,3,151,0,0,4,48,0,0,1,58,0,0,4,28,0,0,1,58,0,0,2,66,0,0,2,65,0,0,0,169,0,0,0,168,0,0,4,49,0,0,0,50,0,0,4,49,0,0,1,224,0,0,1,57,0,0,3,165,0,0,4,50,0,0,1,182,0,0,4,50,0,0,1,181,0,0,3,1,0,0,2,254,0,0,0,118,0,0,2,231,0,0,0,27,0,0,0,218,0,0,2,231,0,0,4,36,0,0,4,51,0,0,2,232,0,0,0,21,0,0,0,211,0,0,2,232,0,0,4,35,0,0,4,52,0,0,0,86,0,0,1,59,0,0,0,84,0,0,0,86,0,0,4,34,0,0,4,53,0,0,2,68,0,0,2,67,0,0,4,1,0,0,2,75,0,0,2,74,0,0,4,2,0,0,2,71,0,0,2,70,0,0,4,5,0,0,1,51,0,0,1,50,0,0,2,33,0,0,0,120,0,0,0,119,0,0,3,35,0,0,3,12,0,0,3,11,0,0,2,255,0,0,2,77,0,0,0,5,0,0,2,78,0,0,2,79,0,0,0,223,0,0,2,80,0,0,2,82,0,0,0,227,0,0,2,81,0,0,3,16,0,0,3,15,0,0,3,14,0,0,0,2,0,0,3,43,0,0,3,42,0,0,3,37,0,0,3,51,0,0,3,50,0,0,0,32,0,0,3,47,0,0,3,46,0,0,2,185,0,0,0,89,0,0,0,88,0,0,0,233,0,0,1,102,0,0,2,250,0,0,2,250,0,0,1,176,0,0,0,233,0,0,0,92,0,0,0,99,0,0,2,241,0,0,2,241,0,0,1,169,0,0,0,92,0,0,4,30,0,0,2,57,0,0,4,31,0,0,4,20,0,0,2,233,0,0,4,32,0,0,4,18,0,0,2,234,0,0,4,33,0,0,0,230,0,0,1,104,0,0,2,245,0,0,2,245,0,0,1,173,0,0,0,230,0,0,0,236,0,0,1,103,0,0,2,251,0,0,2,251,0,0,1,179,0,0,0,236,0,0,0,190,0,0,3,220,0,0,3,32,0,0,3,31,0,0,0,186,0,0,0,185,0,0,3,18,0,0,3,17,0,0,2,155,0,0,3,86,0,0,0,232,0,0,0,231,0,0,0,231,0,0,3,221,0,0,3,82,0,0,0,90,0,0,3,224,0,0,3,69,0,0,3,68,0,0,0,91,0,0,0,90,0,0,1,218,0,0,3,223,0,0,3,72,0,0,3,76,0,0,0,229,0,0,0,228,0,0,1,214,0,0,3,222,0,0,3,77,0,0,3,81,0,0,0,235,0,0,0,234,0,0,3,89,0,0,3,226,0,0,2,25,0,0,0,212,0,0,0,211,0,0,3,29,0,0,3,93,0,0,3,225,0,0,2,27,0,0,0,219,0,0,0,218,0,0,3,26,0,0,3,98,0,0,3,227,0,0,2,29,0,0,0,142,0,0,0,84,0,0,3,40,0,0,3,109,0,0,1,158,0,0,0,188,0,0,0,187,0,0,2,37,0,0,3,110,0,0,3,52,0,0,3,56,0,0,3,53,0,0,3,48,0,0,3,64,0,0,3,61,0,0,3,44,0,0,3,60,0,0,3,57,0,0,3,71,0,0,1,217,0,0,1,216,0,0,0,248,0,0,1,122,0,0,3,67,0,0,0,73,0,0,0,72,0,0,3,80,0,0,3,79,0,0,1,213,0,0,1,6,0,0,0,67,0,0,0,66,0,0,3,85,0,0,3,84,0,0,1,212,0,0,1,1,0,0,3,74,0,0,1,219,0,0,0,252,0,0,0,61,0,0,0,60,0,0,3,75,0,0,0,143,0,0,2,28,0,0,3,96,0,0,3,95,0,0,3,39,0,0,0,143,0,0,3,90,0,0,3,28,0,0,0,213,0,0,0,213,0,0,2,24,0,0,3,87,0,0,0,215,0,0,2,26,0,0,3,91,0,0,3,94,0,0,3,25,0,0,0,215,0,0,1,140,0,0,2,53,0,0,2,52,0,0,1,233,0,0,3,133,0,0,3,132,0,0,4,54,0,0,3,135,0,0,3,134,0,0,1,241,0,0,3,139,0,0,3,138,0,0,2,36,0,0,2,35,0,0,2,34,0,0,0,47,0,0,3,236,0,0,2,36,0,0,0,114,0,0,3,237,0,0,3,128,0,0,3,127,0,0,0,68,0,0,0,114,0,0,0,110,0,0,3,238,0,0,3,118,0,0,3,117,0,0,0,74,0,0,0,110,0,0,3,125,0,0,0,247,0,0,0,246,0,0,0,246,0,0,3,239,0,0,3,121,0,0,0,106,0,0,3,240,0,0,3,113,0,0,3,112,0,0,0,62,0,0,0,106,0,0,0,144,0,0,0,44,0,0,0,43,0,0,0,43,0,0,3,243,0,0,2,1,0,0,0,216,0,0,0,56,0,0,0,55,0,0,0,55,0,0,3,242,0,0,1,250,0,0,0,214,0,0,0,53,0,0,0,52,0,0,0,52,0,0,3,241,0,0,1,255,0,0,0,45,0,0,2,84,0,0,2,83,0,0,3,168,0,0,0,197,0,0,0,45,0,0,2,58,0,0,1,226,0,0,3,111,0,0,3,115,0,0,1,161,0,0,1,160,0,0,3,120,0,0,1,164,0,0,1,163,0,0,2,60,0,0,1,228,0,0,3,116,0,0,0,94,0,0,0,93,0,0,3,124,0,0,3,123,0,0,1,220,0,0,1,123,0,0,3,130,0,0,1,167,0,0,1,166,0,0,2,62,0,0,1,230,0,0,3,126,0,0,0,165,0,0,1,90,0,0,1,88,0,0,1,202,0,0,1,91,0,0,1,90,0,0,1,190,0,0,1,96,0,0,1,95,0,0,0,157,0,0,1,95,0,0,1,93,0,0,1,196,0,0,1,101,0,0,1,100,0,0,0,161,0,0,1,100,0,0,1,98,0,0,3,8,0,0,3,250,0,0,1,194,0,0,0,163,0,0,1,194,0,0,0,161,0,0,3,2,0,0,3,252,0,0,1,188,0,0,0,159,0,0,1,188,0,0,0,157,0,0,3,5,0,0,3,251,0,0,1,200,0,0,0,167,0,0,1,200,0,0,0,165,0,0,1,37,0,0,1,36,0,0,0,75,0,0,2,254,0,0,3,1,0,0,3,0,0,0,2,157,0,0,3,65,0,0,2,152,0,0,4,28,0,0,1,60,0,0,4,29,0,0,3,55,0,0,3,20,0,0,3,19,0,0,3,59,0,0,3,22,0,0,3,21,0,0,3,63,0,0,3,24,0,0,3,23,0,0,2,49,0,0,0,28,0,0,4,37,0,0,2,43,0,0,0,22,0,0,4,38,0,0,3,47,0,0,0,32,0,0,0,31,0,0,2,177,0,0,2,175,0,0,1,68,0,0,3,43,0,0,0,2,0,0,0,1,0,0,2,171,0,0,2,173,0,0,1,63,0,0,3,15,0,0,3,16,0,0,2,32,0,0,2,93,0,0,1,54,0,0,0,9,0,0,3,51,0,0,3,37,0,0,3,36,0,0,2,89,0,0,0,123,0,0,0,122,0,0,2,160,0,0,3,172,0,0,3,169,0,0,2,66,0,0,1,58,0,0,4,48,0,0,2,154,0,0,2,162,0,0,2,163,0,0,2,72,0,0,2,78,0,0,0,5,0,0,4,22,0,0,0,153,0,0,3,253,0,0,2,69,0,0,2,80,0,0,0,223,0,0,4,24,0,0,0,39,0,0,3,254,0,0,2,76,0,0,2,81,0,0,0,227,0,0,4,26,0,0,0,103,0,0,3,255,0,0,3,11,0,0,3,12,0,0,0,87,0,0,1,34,0,0,1,33,0,0,2,6,0,0,2,111,0,0,2,110,0,0,2,113,0,0,2,123,0,0,2,122,0,0,2,125,0,0,2,117,0,0,2,116,0,0,2,119,0,0,2,161,0,0,1,9,0,0,2,158,0,0,1,70,0,0,1,67,0,0,0,133,0,0,3,64,0,0,3,48,0,0,3,45,0,0,1,187,0,0,1,43,0,0,0,12,0,0,3,56,0,0,3,52,0,0,3,49,0,0,1,65,0,0,1,62,0,0,0,139,0,0,3,60,0,0,3,44,0,0,3,41,0,0,0,11,0,0,1,46,0,0,1,45,0,0,3,17,0,0,3,18,0,0,3,13,0,0,2,165,0,0,2,169,0,0,2,166,0,0,1,146,0,0,1,145,0,0,2,64,0,0,2,45,0,0,2,44,0,0,3,211,0,0,2,39,0,0,2,38,0,0,3,210,0,0,2,115,0,0,2,131,0,0,2,128,0,0,2,127,0,0,2,135,0,0,2,132,0,0,2,121,0,0,2,139,0,0,2,136,0,0,2,168,0,0,3,173,0,0,3,174,0,0,4,41,0,0,2,40,0,0,4,42,0,0,4,40,0,0,2,46,0,0,4,39,0,0,4,43,0,0,1,147,0,0,4,44,0,0,2,130,0,0,3,149,0,0,3,150,0,0,2,138,0,0,3,153,0,0,3,154,0,0,2,134,0,0,3,157,0,0,3,158,0,0,0,7,0,0,0,6,0,0,3,140,0,0,3,176,0,0,3,178,0,0,3,177,0,0,3,156,0,0,2,149,0,0,4,45,0,0,3,160,0,0,2,150,0,0,4,46,0,0,3,152,0,0,2,151,0,0,4,47,0,0,3,20,0,0,3,55,0,0,3,54,0,0,0,14,0,0,0,59,0,0,0,58,0,0,1,121,0,0,0,98,0,0,0,97,0,0,3,65,0,0,2,157,0,0,2,156,0,0,3,24,0,0,3,63,0,0,3,62,0,0,0,135,0,0,0,71,0,0,0,70,0,0,0,141,0,0,0,65,0,0,0,64,0,0,3,22,0,0,3,59,0,0,3,58,0,0,3,170,0,0,3,169,0,0,3,172,0,0,1,185,0,0,2,56,0,0,0,48,0,0,3,175,0,0,3,174,0,0,3,173,0,0,0,201,0,0,0,95,0,0,1,221,0,0,3,151,0,0,3,150,0,0,3,149,0,0,1,225,0,0,0,109,0,0,0,108,0,0,3,155,0,0,3,154,0,0,3,153,0,0,1,229,0,0,0,117,0,0,0,116,0,0,3,159,0,0,3,158,0,0,3,157,0,0,1,227,0,0,0,113,0,0,0,112,0,0,0,199,0,0,0,198,0,0,1,77,0,0,0,8,0,0,3,177,0,0,3,178,0,0,2,188,0,0,0,222,0,0,2,23,0,0,2,188,0,0,2,21,0,0,2,193,0,0,2,189,0,0,2,16,0,0,2,195,0,0,2,189,0,0,0,226,0,0,2,18,0,0,1,245,0,0,1,244,0,0,0,179,0,0,0,179,0,0,0,178,0,0,1,245,0,0,0,175,0,0,0,174,0,0,1,240,0,0,1,240,0,0,1,239,0,0,0,175,0,0,1,232,0,0,1,231,0,0,1,234,0,0,1,234,0,0,2,90,0,0,1,232,0,0,1,139,0,0,1,138,0,0,1,22,0,0,1,22,0,0,2,86,0,0,1,139,0,0,2,5,0,0,2,181,0,0,3,141,0,0,1,98,0,0,2,5,0,0,1,97,0,0,1,93,0,0,1,249,0,0,1,92,0,0,1,249,0,0,2,179,0,0,3,145,0,0,1,88,0,0,1,254,0,0,1,87,0,0,1,254,0,0,2,180,0,0,3,143,0,0,4,55,0,0,1,223,0,0,2,185,0,0,3,171,0,0,1,222,0,0,4,55,0,0,1,108,0,0,1,107,0,0,0,33,0,0,0,33,0,0,3,136,0,0,1,108,0,0,2,51,0,0,2,50,0,0,1,137,0,0,1,137,0,0,2,178,0,0,2,51,0,0,0,100,0,0,3,131,0,0,1,106,0,0,1,106,0,0,1,105,0,0,0,100,0,0,1,111,0,0,1,110,0,0,0,36,0,0,0,36,0,0,3,137,0,0,1,111,0,0,1,135,0,0,1,38,0,0,0,79,0,0,0,79,0,0,0,78,0,0,1,135,0,0,3,229,0,0,0,17,0,0,0,16,0,0,0,16,0,0,0,123,0,0,3,229,0,0,0,136,0,0,2,173,0,0,3,233,0,0,3,233,0,0,0,177,0,0,0,136,0,0,0,130,0,0,2,175,0,0,3,235,0,0,3,235,0,0,0,181,0,0,0,130,0,0,3,231,0,0,0,126,0,0,0,125,0,0,0,125,0,0,1,54,0,0,3,231,0,0,1,76,0,0,3,186,0,0,2,196,0,0,2,196,0,0,2,197,0,0,1,76,0,0,3,99,0,0,0,105,0,0,0,104,0,0,0,104,0,0,2,12,0,0,3,99,0,0,3,102,0,0,0,41,0,0,0,40,0,0,0,40,0,0,2,10,0,0,3,102,0,0,3,106,0,0,0,155,0,0,0,154,0,0,0,154,0,0,2,8,0,0,3,106,0,0,3,140,0,0,0,183,0,0,4,56,0,0,4,56,0,0,0,183,0,0,2,161,0,0,2,211,0,0,1,69,0,0,0,132,0,0,0,132,0,0,3,187,0,0,2,211,0,0,0,138,0,0,3,189,0,0,2,202,0,0,2,202,0,0,1,64,0,0,0,138,0,0,0,209,0,0,3,188,0,0,2,206,0,0,2,206,0,0,1,186,0,0,0,209,0,0,2,198,0,0,0,10,0,0,0,202,0,0,0,202,0,0,3,190,0,0,2,198,0,0,2,190,0,0,1,25,0,0,4,51,0,0,4,51,0,0,1,26,0,0,2,190,0,0,4,52,0,0,1,30,0,0,2,186,0,0,2,186,0,0,1,29,0,0,4,52,0,0,4,53,0,0,0,239,0,0,0,238,0,0,0,238,0,0,1,183,0,0,4,53,0,0,3,192,0,0,3,191,0,0,1,115,0,0,1,115,0,0,4,25,0,0,3,192,0,0,3,195,0,0,3,194,0,0,1,113,0,0,1,113,0,0,4,23,0,0,3,195,0,0,1,72,0,0,1,71,0,0,1,74,0,0,1,74,0,0,1,35,0,0,1,72,0,0,1,82,0,0,4,21,0,0,3,198,0,0,3,198,0,0,3,197,0,0,1,82,0,0,1,86,0,0,2,184,0,0,4,16,0,0,2,184,0,0,1,86,0,0,1,85,0,0,2,192,0,0,0,20,0,0,4,15,0,0,0,20,0,0,2,192,0,0,0,18,0,0,2,95,0,0,0,173,0,0,0,172,0,0,0,173,0,0,2,95,0,0,4,13,0,0,0,26,0,0,2,194,0,0,0,24,0,0,2,194,0,0,0,26,0,0,4,14,0,0,1,117,0,0,0,102,0,0,0,101,0,0,0,102,0,0,1,117,0,0,3,101,0,0,0,240,0,0,0,35,0,0,0,34,0,0,0,35,0,0,0,240,0,0,3,105,0,0,0,243,0,0,0,38,0,0,0,37,0,0,0,38,0,0,0,243,0,0,3,104,0,0,0,176,0,0,1,238,0,0,3,232,0,0,1,238,0,0,0,176,0,0,0,175,0,0,2,87,0,0,1,24,0,0,3,228,0,0,1,24,0,0,2,87,0,0,1,22,0,0,2,91,0,0,1,236,0,0,3,230,0,0,1,236,0,0,2,91,0,0,1,234,0,0,0,180,0,0,1,243,0,0,3,234,0,0,1,243,0,0,0,180,0,0,0,179,0,0,2,53,0,0,0,76,0,0,2,51,0,0,0,76,0,0,2,53,0,0,1,139,0,0,3,133,0,0,0,128,0,0,1,106,0,0,0,128,0,0,3,133,0,0,1,232,0,0,3,139,0,0,1,112,0,0,1,111,0,0,1,112,0,0,3,139,0,0,1,240,0,0,3,135,0,0,1,109,0,0,1,108,0,0,1,130,0,0,4,0,0,0,1,245,0,0,1,47,0,0,1,46,0,0,2,200,0,0,2,200,0,0,1,141,0,0,1,47,0,0,1,39,0,0,1,43,0,0,2,208,0,0,2,208,0,0,1,142,0,0,1,39,0,0,2,213,0,0,1,144,0,0,1,10,0,0,1,10,0,0,1,67,0,0,2,213,0,0,2,204,0,0,1,143,0,0,1,16,0,0,1,16,0,0,1,62,0,0,2,204,0,0,0,81,0,0,2,183,0,0,1,85,0,0,1,85,0,0,1,84,0,0,0,81,0,0,0,24,0,0,2,195,0,0,2,16,0,0,2,16,0,0,0,148,0,0,0,24,0,0,0,18,0,0,2,193,0,0,2,21,0,0,2,21,0,0,0,149,0,0,0,18,0,0,0,172,0,0,0,171,0,0,3,147,0,0,3,147,0,0,3,200,0,0,0,172,0,0,2,218,0,0,0,134,0,0,1,12,0,0,1,12,0,0,3,202,0,0,2,218,0,0,2,215,0,0,0,13,0,0,1,41,0,0,1,41,0,0,3,204,0,0,2,215,0,0,1,49,0,0,3,201,0,0,2,226,0,0,2,226,0,0,1,120,0,0,1,49,0,0,2,222,0,0,0,140,0,0,1,18,0,0,1,18,0,0,3,203,0,0,2,222,0,0,0,83,0,0,4,50,0,0,3,165,0,0,3,165,0,0,3,209,0,0,0,83,0,0,2,19,0,0,2,23,0,0,3,161,0,0,3,161,0,0,3,207,0,0,2,19,0,0,2,14,0,0,2,18,0,0,3,163,0,0,3,163,0,0,3,208,0,0,2,14,0,0,0,168,0,0,2,98,0,0,2,97,0,0,2,97,0,0,4,49,0,0,0,168,0,0,0,207,0,0,0,59,0,0,2,217,0,0,2,217,0,0,0,208,0,0,0,207,0,0,2,220,0,0,1,15,0,0,1,14,0,0,1,14,0,0,0,71,0,0,2,220,0,0,2,228,0,0,0,205,0,0,0,204,0,0,0,204,0,0,0,98,0,0,2,228,0,0,2,224,0,0,1,21,0,0,1,20,0,0,1,20,0,0,0,65,0,0,2,224,0,0,1,32,0,0,1,154,0,0,1,153,0,0,1,153,0,0,2,187,0,0,1,32,0,0,2,54,0,0,3,212,0,0,0,170,0,0,0,170,0,0,0,49,0,0,2,54,0,0,1,28,0,0,1,157,0,0,1,156,0,0,1,156,0,0,2,191,0,0,1,28,0,0,1,56,0,0,1,55,0,0,0,237,0,0,0,237,0,0,2,101,0,0,1,56,0,0,1,171,0,0,3,213,0,0,2,246,0,0,2,246,0,0,1,206,0,0,1,171,0,0,1,170,0,0,3,214,0,0,2,243,0,0,2,243,0,0,2,242,0,0,1,170,0,0,2,252,0,0,1,210,0,0,1,177,0,0,1,177,0,0,3,215,0,0,2,252,0,0,2,248,0,0,1,208,0,0,1,174,0,0,1,174,0,0,3,216,0,0,2,248,0,0,4,34,0,0,3,217,0,0,0,239,0,0,0,239,0,0,4,53,0,0,4,34,0,0,0,192,0,0,2,56,0,0,3,34,0,0,3,34,0,0,0,193,0,0,0,192,0,0,4,36,0,0,3,219,0,0,1,26,0,0,1,26,0,0,4,51,0,0,4,36,0,0,4,35,0,0,3,218,0,0,1,30,0,0,1,30,0,0,4,52,0,0,4,35,0,0,1,81,0,0,3,244,0,0,3,166,0,0,3,166,0,0,2,85,0,0,1,81,0,0,2,59,0,0,3,246,0,0,0,249,0,0,0,249,0,0,4,6,0,0,2,59,0,0,1,3,0,0,4,7,0,0,2,61,0,0,2,61,0,0,3,245,0,0,1,3,0,0,1,125,0,0,3,248,0,0,2,235,0,0,2,235,0,0,4,8,0,0,1,125,0,0,0,254,0,0,4,10,0,0,2,63,0,0,2,63,0,0,3,247,0,0,0,254,0,0,2,240,0,0,1,180,0,0,1,79,0,0,1,79,0,0,4,11,0,0,2,240,0,0,0,251,0,0,1,199,0,0,1,198,0,0,1,198,0,0,3,10,0,0,0,251,0,0,0,194,0,0,4,9,0,0,2,237,0,0,2,237,0,0,1,126,0,0,0,194,0,0,1,204,0,0,3,7,0,0,1,5,0,0,1,5,0,0,1,205,0,0,1,204,0,0,1,192,0,0,3,4,0,0,1,0,0,0,1,0,0,0,1,193,0,0,1,192,0,0,2,238,0,0,4,12,0,0,0,196,0,0,0,196,0,0,3,249,0,0,2,238,0,0,2,7,0,0,0,79,0,0,1,38,0,0,1,38,0,0,1,37,0,0,2,7,0,0,1,36,0,0,1,137,0,0,2,50,0,0,2,50,0,0,0,75,0,0,1,36,0,0,0,34,0,0,0,33,0,0,1,107,0,0,1,107,0,0,2,73,0,0,0,34,0,0,0,37,0,0,0,36,0,0,1,110,0,0,1,110,0,0,1,132,0,0,0,37,0,0,0,101,0,0,0,100,0,0,1,105,0,0,1,105,0,0,0,127,0,0,0,101,0,0,0,123,0,0,2,89,0,0,3,228,0,0,3,228,0,0,3,229,0,0,0,123,0,0,3,234,0,0,3,235,0,0,2,175,0,0,2,175,0,0,2,177,0,0,3,234,0,0,2,173,0,0,2,171,0,0,3,232,0,0,3,232,0,0,3,233,0,0,2,173,0,0,1,54,0,0,2,93,0,0,3,230,0,0,3,230,0,0,3,231,0,0,1,54,0,0,0,155,0,0,3,106,0,0,0,242,0,0,0,242,0,0,3,253,0,0,0,155,0,0,0,41,0,0,3,102,0,0,0,245,0,0,0,245,0,0,3,254,0,0,0,41,0,0,0,105,0,0,3,99,0,0,1,119,0,0,1,119,0,0,3,255,0,0,0,105,0,0,2,197,0,0,2,6,0,0,1,33,0,0,1,33,0,0,1,76,0,0,2,197,0,0,0,153,0,0,4,22,0,0,4,21,0,0,4,21,0,0,1,82,0,0,0,153,0,0,0,39,0,0,4,24,0,0,4,23,0,0,4,23,0,0,1,113,0,0,0,39,0,0,0,103,0,0,4,26,0,0,4,25,0,0,4,25,0,0,1,115,0,0,0,103,0,0,2,174,0,0,0,132,0,0,1,69,0,0,1,69,0,0,1,68,0,0,2,174,0,0,2,172,0,0,0,138,0,0,1,64,0,0,1,64,0,0,1,63,0,0,2,172,0,0,0,121,0,0,0,209,0,0,1,186,0,0,1,186,0,0,0,122,0,0,0,121,0,0,1,53,0,0,0,202,0,0,0,10,0,0,0,10,0,0,0,9,0,0,1,53,0,0,1,35,0,0,1,34,0,0,4,13,0,0,4,13,0,0,1,72,0,0,1,35,0,0,2,5,0,0,1,98,0,0,2,3,0,0,2,3,0,0,1,98,0,0,1,100,0,0,1,254,0,0,1,88,0,0,1,252,0,0,1,252,0,0,1,88,0,0,1,90,0,0,1,249,0,0,1,93,0,0,1,247,0,0,1,247,0,0,1,93,0,0,1,95,0,0,2,201,0,0,2,200,0,0,1,46,0,0,1,46,0,0,0,11,0,0,2,201,0,0,2,209,0,0,2,208,0,0,1,43,0,0,1,43,0,0,1,187,0,0,2,209,0,0,2,210,0,0,2,213,0,0,1,67,0,0,1,67,0,0,1,70,0,0,2,210,0,0,2,205,0,0,2,204,0,0,1,62,0,0,1,62,0,0,1,65,0,0,2,205,0,0,1,100,0,0,0,161,0,0,1,196,0,0,1,196,0,0,0,161,0,0,1,194,0,0,1,90,0,0,0,165,0,0,1,202,0,0,1,202,0,0,0,165,0,0,1,200,0,0,1,190,0,0,0,157,0,0,1,188,0,0,1,95,0,0,0,157,0,0,1,190,0,0,1,194,0,0,0,163,0,0,3,8,0,0,3,8,0,0,0,163,0,0,1,198,0,0,1,188,0,0,0,159,0,0,3,2,0,0,3,2,0,0,0,159,0,0,1,192,0,0,1,200,0,0,0,167,0,0,3,5,0,0,3,5,0,0,0,167,0,0,1,204,0,0,1,120,0,0,1,45,0,0,1,44,0,0,1,44,0,0,1,49,0,0,1,120,0,0,0,134,0,0,0,133,0,0,1,66,0,0,1,66,0,0,1,12,0,0,0,134,0,0,0,140,0,0,0,139,0,0,1,61,0,0,1,61,0,0,1,18,0,0,0,140,0,0,0,13,0,0,0,12,0,0,1,42,0,0,1,42,0,0,1,41,0,0,0,13,0,0,2,55,0,0,2,54,0,0,0,49,0,0,0,49,0,0,0,48,0,0,2,55,0,0,4,49,0,0,2,97,0,0,3,148,0,0,3,148,0,0,1,224,0,0,4,49,0,0,4,50,0,0,0,83,0,0,0,82,0,0,0,82,0,0,1,181,0,0,4,50,0,0,3,162,0,0,3,161,0,0,2,23,0,0,2,23,0,0,2,22,0,0,3,162,0,0,3,164,0,0,3,163,0,0,2,18,0,0,2,18,0,0,2,17,0,0,3,164,0,0,0,59,0,0,0,14,0,0,2,214,0,0,2,214,0,0,2,217,0,0,0,59,0,0,0,71,0,0,0,135,0,0,2,221,0,0,2,221,0,0,2,220,0,0,0,71,0,0,0,98,0,0,1,121,0,0,2,229,0,0,2,229,0,0,2,228,0,0,0,98,0,0,0,65,0,0,0,141,0,0,2,225,0,0,2,225,0,0,2,224,0,0,0,65,0,0,1,206,0,0,0,58,0,0,0,57,0,0,0,57,0,0,1,171,0,0,1,206,0,0,2,242,0,0,0,97,0,0,0,96,0,0,0,96,0,0,1,170,0,0,2,242,0,0,0,69,0,0,1,177,0,0,1,210,0,0,1,210,0,0,0,70,0,0,0,69,0,0,1,208,0,0,0,64,0,0,0,63,0,0,0,63,0,0,1,174,0,0,1,208,0,0,3,66,0,0,0,99,0,0,4,57,0,0,0,99,0,0,3,66,0,0,2,242,0,0,1,102,0,0,1,209,0,0,1,208,0,0,1,209,0,0,1,102,0,0,4,58,0,0,1,207,0,0,1,104,0,0,4,59,0,0,1,104,0,0,1,207,0,0,1,206,0,0,1,211,0,0,1,103,0,0,4,60,0,0,1,103,0,0,1,211,0,0,1,210,0,0,2,56,0,0,1,185,0,0,1,184,0,0,1,184,0,0,3,34,0,0,2,56,0,0,0,211,0,0,0,23,0,0,3,28,0,0,0,23,0,0,0,211,0,0,0,21,0,0,0,29,0,0,0,218,0,0,0,27,0,0,0,218,0,0,0,29,0,0,3,25,0,0,4,61,0,0,0,186,0,0,1,185,0,0,0,186,0,0,4,61,0,0,2,37,0,0,4,58,0,0,0,232,0,0,4,62,0,0,0,232,0,0,4,58,0,0,1,102,0,0,4,57,0,0,0,91,0,0,4,63,0,0,0,91,0,0,4,57,0,0,0,99,0,0,4,59,0,0,0,229,0,0,4,64,0,0,0,229,0,0,4,59,0,0,1,104,0,0,4,60,0,0,0,235,0,0,4,65,0,0,0,235,0,0,4,60,0,0,1,103,0,0,3,38,0,0,3,39,0,0,1,148,0,0,3,39,0,0,3,38,0,0,0,44,0,0,4,66,0,0,3,28,0,0,0,23,0,0,3,28,0,0,4,66,0,0,0,53,0,0,4,67,0,0,3,25,0,0,0,29,0,0,3,25,0,0,4,67,0,0,0,56,0,0,4,68,0,0,2,37,0,0,4,61,0,0,2,37,0,0,4,68,0,0,2,35,0,0,4,63,0,0,1,122,0,0,4,69,0,0,1,122,0,0,4,63,0,0,0,91,0,0,4,65,0,0,0,72,0,0,4,70,0,0,0,72,0,0,4,65,0,0,0,235,0,0,4,62,0,0,0,66,0,0,4,71,0,0,0,66,0,0,4,62,0,0,0,232,0,0,4,64,0,0,0,60,0,0,4,72,0,0,0,60,0,0,4,64,0,0,0,229,0,0,4,73,0,0,0,56,0,0,4,67,0,0,0,56,0,0,4,73,0,0,0,54,0,0,4,74,0,0,0,44,0,0,3,38,0,0,0,44,0,0,4,74,0,0,0,42,0,0,4,75,0,0,0,53,0,0,4,66,0,0,0,53,0,0,4,75,0,0,0,51,0,0,4,71,0,0,0,68,0,0,4,76,0,0,0,68,0,0,4,71,0,0,0,66,0,0,0,74,0,0,4,70,0,0,0,72,0,0,4,70,0,0,0,74,0,0,4,77,0,0,4,69,0,0,0,247,0,0,4,78,0,0,0,247,0,0,4,69,0,0,1,122,0,0,0,62,0,0,4,72,0,0,0,60,0,0,4,72,0,0,0,62,0,0,4,79,0,0,1,226,0,0,4,79,0,0,0,62,0,0,4,79,0,0,1,226,0,0,1,225,0,0,0,93,0,0,4,78,0,0,0,247,0,0,4,78,0,0,0,93,0,0,0,201,0,0,1,228,0,0,4,77,0,0,0,74,0,0,4,77,0,0,1,228,0,0,1,227,0,0,1,230,0,0,4,76,0,0,0,68,0,0,4,76,0,0,1,230,0,0,1,229,0,0,1,23,0,0,1,22,0,0,1,138,0,0,1,237,0,0,0,175,0,0,1,239,0,0,1,242,0,0,0,179,0,0,1,244,0,0,1,235,0,0,1,234,0,0,1,231,0,0,3,132,0,0,1,106,0,0,3,131,0,0,2,52,0,0,2,51,0,0,2,178,0,0,3,134,0,0,1,108,0,0,3,136,0,0,3,138,0,0,1,111,0,0,3,137,0,0,4,27,0,0,2,85,0,0,2,84,0,0,2,85,0,0,4,27,0,0,4,11,0,0,4,6,0,0,0,109,0,0,2,58,0,0,0,109,0,0,4,6,0,0,0,107,0,0,4,7,0,0,0,113,0,0,2,60,0,0,0,113,0,0,4,7,0,0,0,111,0,0,4,8,0,0,0,95,0,0,0,94,0,0,0,95,0,0,4,8,0,0,0,200,0,0,4,10,0,0,0,117,0,0,2,62,0,0,0,117,0,0,4,10,0,0,0,115,0,0,1,78,0,0,4,11,0,0,4,27,0,0,4,11,0,0,1,78,0,0,4,12,0,0,3,10,0,0,0,107,0,0,4,6,0,0,0,107,0,0,3,10,0,0,3,9,0,0,4,9,0,0,0,200,0,0,4,8,0,0,0,200,0,0,4,9,0,0,0,198,0,0,3,4,0,0,0,115,0,0,4,10,0,0,0,115,0,0,3,4,0,0,3,3,0,0,3,7,0,0,0,111,0,0,4,7,0,0,0,111,0,0,3,7,0,0,3,6,0,0,0,198,0,0,4,12,0,0,1,78,0,0,4,12,0,0,0,198,0,0,4,9,0,0,0,17,0,0,3,229,0,0,3,182,0,0,0,126,0,0,3,231,0,0,3,180,0,0,0,177,0,0,3,233,0,0,3,179,0,0,0,181,0,0,3,235,0,0,3,181,0,0,2,9,0,0,0,35,0,0,3,183,0,0,2,11,0,0,0,38,0,0,3,184,0,0,1,136,0,0,1,135,0,0,0,78,0,0,2,13,0,0,0,102,0,0,3,185,0,0,3,188,0,0,0,209,0,0,0,15,0,0,3,189,0,0,0,138,0,0,0,137,0,0,3,187,0,0,0,132,0,0,0,131,0,0,3,190,0,0,0,202,0,0,0,124,0,0,3,107,0,0,3,106,0,0,2,8,0,0,3,103,0,0,3,102,0,0,2,10,0,0,3,100,0,0,3,99,0,0,2,12,0,0,0,80,0,0,2,196,0,0,3,186,0,0,1,143,0,0,2,204,0,0,2,203,0,0,1,144,0,0,2,213,0,0,2,212,0,0,1,141,0,0,2,200,0,0,2,199,0,0,1,142,0,0,2,208,0,0,2,207,0,0,1,83,0,0,1,82,0,0,3,197,0,0,1,75,0,0,1,74,0,0,1,71,0,0,1,114,0,0,1,113,0,0,3,194,0,0,1,116,0,0,1,115,0,0,3,191,0,0,3,201,0,0,1,49,0,0,1,48,0,0,3,203,0,0,1,18,0,0,1,17,0,0,3,204,0,0,1,41,0,0,1,40,0,0,3,202,0,0,1,12,0,0,1,11,0,0,3,199,0,0,2,184,0,0,2,182,0,0,3,193,0,0,0,26,0,0,0,25,0,0,3,196,0,0,0,20,0,0,0,19,0,0,1,73,0,0,2,95,0,0,2,94,0,0,1,15,0,0,2,220,0,0,2,219,0,0,0,208,0,0,2,217,0,0,2,216,0,0,1,21,0,0,2,224,0,0,2,223,0,0,0,205,0,0,2,228,0,0,2,227,0,0,2,183,0,0,0,81,0,0,2,99,0,0,3,200,0,0,3,147,0,0,2,96,0,0,0,148,0,0,2,16,0,0,2,15,0,0,0,149,0,0,2,21,0,0,2,20,0,0,3,213,0,0,1,171,0,0,0,206,0,0,3,215,0,0,1,177,0,0,1,13,0,0,3,216,0,0,1,174,0,0,1,19,0,0,3,214,0,0,1,170,0,0,0,203,0,0,3,208,0,0,3,163,0,0,1,155,0,0,2,98,0,0,0,168,0,0,1,134,0,0,3,207,0,0,3,161,0,0,1,152,0,0,3,209,0,0,3,165,0,0,2,100,0,0,1,173,0,0,2,245,0,0,2,247,0,0,1,169,0,0,2,241,0,0,2,244,0,0,1,179,0,0,2,251,0,0,2,253,0,0,1,176,0,0,2,250,0,0,2,249,0,0,2,101,0,0,0,237,0,0,2,108,0,0,3,212,0,0,2,54,0,0,0,191,0,0,1,154,0,0,1,32,0,0,1,31,0,0,1,157,0,0,1,28,0,0,1,27,0,0,3,224,0,0,0,90,0,0,1,168,0,0,3,221,0,0,0,231,0,0,1,175,0,0,3,223,0,0,1,218,0,0,1,172,0,0,3,222,0,0,1,214,0,0,1,178,0,0,3,217,0,0,4,34,0,0,2,109,0,0,3,218,0,0,4,35,0,0,0,150,0,0,0,193,0,0,3,34,0,0,3,33,0,0,3,219,0,0,4,36,0,0,0,145,0,0,1,212,0,0,3,84,0,0,3,83,0,0,1,217,0,0,3,71,0,0,3,70,0,0,1,219,0,0,3,74,0,0,3,73,0,0,1,213,0,0,3,79,0,0,3,78,0,0,2,30,0,0,2,29,0,0,3,227,0,0,0,152,0,0,2,25,0,0,3,226,0,0,0,147,0,0,2,27,0,0,3,225,0,0,3,220,0,0,0,190,0,0,0,189,0,0,3,239,0,0,0,246,0,0,1,215,0,0,3,237,0,0,0,114,0,0,1,2,0,0,3,238,0,0,0,110,0,0,1,7,0,0,3,240,0,0,0,106,0,0,0,253,0,0,3,97,0,0,3,96,0,0,2,28,0,0,3,88,0,0,3,87,0,0,2,24,0,0,3,92,0,0,3,91,0,0,2,26,0,0,1,158,0,0,3,109,0,0,3,108,0,0,1,167,0,0,3,130,0,0,3,129,0,0,1,164,0,0,3,120,0,0,3,119,0,0,1,220,0,0,3,123,0,0,3,122,0,0,1,161,0,0,3,115,0,0,3,114,0,0,1,251,0,0,1,250,0,0,3,242,0,0,2,0,0,0,1,255,0,0,3,241,0,0,2,2,0,0,2,1,0,0,3,243,0,0,3,236,0,0,0,47,0,0,0,46,0,0,3,246,0,0,2,59,0,0,1,159,0,0,3,245,0,0,2,61,0,0,1,162,0,0,3,248,0,0,1,125,0,0,1,124,0,0,3,247,0,0,2,63,0,0,1,165,0,0,3,142,0,0,3,141,0,0,2,181,0,0,3,144,0,0,3,143,0,0,2,180,0,0,3,146,0,0,3,145,0,0,2,179,0,0,0,197,0,0,3,168,0,0,3,167,0,0,1,199,0,0,0,251,0,0,0,250,0,0,1,205,0,0,1,5,0,0,1,4,0,0,1,126,0,0,2,237,0,0,2,236,0,0,1,193,0,0,1,0,0,0,0,255,0,0,1,253,0,0,1,252,0,0,1,89,0,0,2,4,0,0,2,3,0,0,1,99,0,0,1,248,0,0,1,247,0,0,1,94,0,0,3,244,0,0,1,81,0,0,1,80,0,0,3,250,0,0,3,8,0,0,1,197,0,0,3,249,0,0,0,196,0,0,0,195,0,0,3,252,0,0,3,2,0,0,1,191,0,0,3,251,0,0,3,5,0,0,1,203,0,0,1,180,0,0,2,240,0,0,2,239,0,0,1,101,0,0,1,196,0,0,1,195,0,0,1,96,0,0,1,190,0,0,1,189,0,0,1,91,0,0,1,202,0,0,1,201,0,0,2,86,0,0,2,88,0,0,0,77,0,0,0,77,0,0,1,139,0,0,2,86,0,0,0,174,0,0,2,170,0,0,1,133,0,0,1,133,0,0,1,240,0,0,0,174,0,0,2,90,0,0,2,92,0,0,0,129,0,0,0,129,0,0,1,232,0,0,2,90,0,0,0,178,0,0,2,176,0,0,1,131,0,0,1,131,0,0,1,245,0,0,0,178,0,0,4,50,0,0,1,182,0,0,1,57,0,0,1,57,0,0,1,182,0,0,1,55,0,0,4,49,0,0,0,50,0,0,0,169,0,0,0,169,0,0,0,50,0,0,0,49,0,0,0,84,0,0,1,148,0,0,3,39,0,0,1,148,0,0,0,84,0,0,1,59,0,0,4,15,0,0,0,220,0,0,2,192,0,0,0,220,0,0,4,15,0,0,4,24,0,0,0,4,0,0,4,16,0,0,4,22,0,0,4,16,0,0,0,4,0,0,1,86,0,0,0,224,0,0,4,14,0,0,4,26,0,0,4,14,0,0,0,224,0,0,2,194,0,0,1,224,0,0,0,171,0,0,2,230,0,0,0,171,0,0,1,224,0,0,3,148,0,0,0,226,0,0,2,195,0,0,0,224,0,0,2,195,0,0,0,226,0,0,2,189,0,0,0,222,0,0,2,193,0,0,0,220,0,0,2,193,0,0,0,222,0,0,2,188,0,0,1,181,0,0,1,84,0,0,0,4,0,0,1,84,0,0,1,181,0,0,0,82,0,0,1,8,0,0,2,35,0,0,4,68,0,0,2,35,0,0,1,8,0,0,2,84,0,0,2,140,0,0,0,51,0,0,4,75,0,0,0,51,0,0,2,140,0,0,1,151,0,0,0,54,0,0,2,143,0,0,1,150,0,0,2,143,0,0,0,54,0,0,4,73,0,0,0,182,0,0,2,84,0,0,1,8,0,0,2,84,0,0,0,182,0,0,4,27,0,0,2,146,0,0,0,42,0,0,4,74,0,0,0,42,0,0,2,146,0,0,1,149,0,0,1,29,0,0,2,187,0,0,2,22,0,0,2,187,0,0,1,29,0,0,2,186,0,0,1,25,0,0,2,191,0,0,2,17,0,0,2,191,0,0,1,25,0,0,2,190,0,0,1,183,0,0,1,55,0,0,1,182,0,0,1,55,0,0,1,183,0,0,0,238,0,0,1,151,0,0,2,141,0,0,0,166,0,0,2,141,0,0,1,151,0,0,2,140,0,0,1,150,0,0,2,144,0,0,0,158,0,0,2,144,0,0,1,150,0,0,2,143,0,0,1,149,0,0,2,147,0,0,0,162,0,0,2,147,0,0,1,149,0,0,2,146,0,0,4,51,0,0,0,27,0,0,2,231,0,0,0,27,0,0,4,51,0,0,1,25,0,0,4,52,0,0,0,21,0,0,2,232,0,0,0,21,0,0,4,52,0,0,1,29,0,0,4,53,0,0,1,59,0,0,0,86,0,0,1,59,0,0,4,53,0,0,1,183,0,0,2,145,0,0,0,158,0,0,2,144,0,0,0,158,0,0,2,145,0,0,3,3,0,0,0,162,0,0,2,148,0,0,3,9,0,0,2,148,0,0,0,162,0,0,2,147,0,0,0,166,0,0,2,142,0,0,3,6,0,0,2,142,0,0,0,166,0,0,2,141,0,0,0,160,0,0,3,9,0,0,2,148,0,0,3,9,0,0,0,160,0,0,0,107,0,0,0,156,0,0,3,3,0,0,2,145,0,0,3,3,0,0,0,156,0,0,0,115,0,0,0,164,0,0,3,6,0,0,2,142,0,0,3,6,0,0,0,164,0,0,0,111,0,0,0,119,0,0,2,88,0,0,3,36,0,0,2,88,0,0,0,119,0,0,0,77,0,0,2,170,0,0,2,102,0,0,1,133,0,0,2,102,0,0,2,170,0,0,0,1,0,0,2,92,0,0,1,50,0,0,0,129,0,0,1,50,0,0,2,92,0,0,2,32,0,0,2,105,0,0,2,176,0,0,0,31,0,0,2,176,0,0,2,105,0,0,1,131,0,0,2,103,0,0,2,102,0,0,3,205,0,0,2,106,0,0,2,105,0,0,3,206,0,0,2,104,0,0,1,132,0,0,2,102,0,0,1,132,0,0,2,104,0,0,0,244,0,0,0,75,0,0,2,254,0,0,1,37,0,0,2,254,0,0,0,75,0,0,0,119,0,0,0,127,0,0,1,52,0,0,1,118,0,0,1,52,0,0,0,127,0,0,1,50,0,0,2,73,0,0,4,4,0,0,0,241,0,0,2,107,0,0,1,129,0,0,2,105,0,0,2,74,0,0,1,118,0,0,1,52,0,0,1,118,0,0,2,74,0,0,3,255,0,0,3,0,0,0,1,37,0,0,2,254,0,0,1,37,0,0,3,0,0,0,2,6,0,0,2,70,0,0,0,241,0,0,4,4,0,0,0,241,0,0,2,70,0,0,3,253,0,0,2,67,0,0,0,244,0,0,2,104,0,0,0,244,0,0,2,67,0,0,3,254,0,0,2,72,0,0,3,253,0,0,2,70,0,0,3,253,0,0,2,72,0,0,4,22,0,0,2,69,0,0,3,254,0,0,2,67,0,0,3,254,0,0,2,69,0,0,4,24,0,0,3,11,0,0,2,6,0,0,3,0,0,0,2,6,0,0,3,11,0,0,1,34,0,0,2,76,0,0,3,255,0,0,2,74,0,0,3,255,0,0,2,76,0,0,4,26,0,0,3,36,0,0,2,89,0,0,3,51,0,0,2,89,0,0,3,36,0,0,2,88,0,0,2,32,0,0,2,93,0,0,3,15,0,0,2,93,0,0,2,32,0,0,2,92,0,0,0,31,0,0,2,177,0,0,3,47,0,0,2,177,0,0,0,31,0,0,2,176,0,0,0,1,0,0,2,171,0,0,3,43,0,0,2,171,0,0,0,1,0,0,2,170,0,0,0,5,0,0,4,22,0,0,2,72,0,0,4,22,0,0,0,5,0,0,0,4,0,0,0,223,0,0,4,24,0,0,2,69,0,0,4,24,0,0,0,223,0,0,0,220,0,0,0,227,0,0,4,26,0,0,2,76,0,0,4,26,0,0,0,227,0,0,0,224,0,0,0,87,0,0,1,34,0,0,3,11,0,0,1,34,0,0,0,87,0,0,2,230,0,0,3,47,0,0,1,68,0,0,3,45,0,0,1,68,0,0,3,47,0,0,2,177,0,0,3,43,0,0,1,63,0,0,3,41,0,0,1,63,0,0,3,43,0,0,2,171,0,0,3,51,0,0,0,122,0,0,3,49,0,0,0,122,0,0,3,51,0,0,2,89,0,0,3,15,0,0,0,9,0,0,3,13,0,0,0,9,0,0,3,15,0,0,2,93,0,0,2,230,0,0,0,89,0,0,1,224,0,0,0,89,0,0,2,230,0,0,0,87,0,0,3,13,0,0,0,11,0,0,3,17,0,0,0,11,0,0,3,13,0,0,0,9,0,0,3,49,0,0,1,187,0,0,3,56,0,0,1,187,0,0,3,49,0,0,0,122,0,0,3,45,0,0,1,70,0,0,3,64,0,0,1,70,0,0,3,45,0,0,1,68,0,0,3,41,0,0,1,65,0,0,3,60,0,0,1,65,0,0,3,41,0,0,1,63,0,0,0,139,0,0,3,60,0,0,1,65,0,0,3,60,0,0,0,139,0,0,3,58,0,0,0,133,0,0,3,64,0,0,1,70,0,0,3,64,0,0,0,133,0,0,3,62,0,0,0,12,0,0,3,56,0,0,1,187,0,0,3,56,0,0,0,12,0,0,3,54,0,0,1,45,0,0,3,17,0,0,0,11,0,0,3,17,0,0,1,45,0,0,2,156,0,0,1,127,0,0,2,22,0,0,2,233,0,0,2,22,0,0,1,127,0,0,1,29,0,0,1,128,0,0,2,17,0,0,2,234,0,0,2,17,0,0,1,128,0,0,1,25,0,0,0,14,0,0,3,54,0,0,0,12,0,0,3,54,0,0,0,14,0,0,3,20,0,0,3,62,0,0,0,135,0,0,3,24,0,0,0,135,0,0,3,62,0,0,0,133,0,0,0,141,0,0,3,58,0,0,0,139,0,0,3,58,0,0,0,141,0,0,3,22,0,0,1,121,0,0,2,156,0,0,1,45,0,0,2,156,0,0,1,121,0,0,3,65,0,0,3,170,0,0,0,48,0,0,1,222,0,0,0,48,0,0,3,170,0,0,1,185,0,0,3,20,0,0,0,58,0,0,2,112,0,0,0,58,0,0,3,20,0,0,0,14,0,0,3,65,0,0,0,97,0,0,2,153,0,0,0,97,0,0,3,65,0,0,1,121,0,0,3,24,0,0,0,70,0,0,2,124,0,0,0,70,0,0,3,24,0,0,0,135,0,0,3,22,0,0,0,64,0,0,2,118,0,0,0,64,0,0,3,22,0,0,0,141,0,0,3,172,0,0,1,185,0,0,3,170,0,0,1,185,0,0,3,172,0,0,4,61,0,0,2,118,0,0,1,209,0,0,2,116,0,0,1,209,0,0,2,118,0,0,0,64,0,0,2,153,0,0,3,66,0,0,2,162,0,0,3,66,0,0,2,153,0,0,0,97,0,0,2,112,0,0,1,207,0,0,2,110,0,0,1,207,0,0,2,112,0,0,0,58,0,0,2,124,0,0,1,211,0,0,2,122,0,0,1,211,0,0,2,124,0,0,0,70,0,0,2,42,0,0,0,23,0,0,0,22,0,0,0,23,0,0,2,42,0,0,4,66,0,0,4,61,0,0,2,159,0,0,4,68,0,0,2,159,0,0,4,61,0,0,3,172,0,0,0,29,0,0,2,48,0,0,4,67,0,0,2,48,0,0,0,29,0,0,0,28,0,0,2,116,0,0,4,58,0,0,2,120,0,0,4,58,0,0,2,116,0,0,1,209,0,0,2,162,0,0,4,57,0,0,2,164,0,0,4,57,0,0,2,162,0,0,3,66,0,0,2,110,0,0,4,59,0,0,2,114,0,0,4,59,0,0,2,110,0,0,1,207,0,0,2,122,0,0,4,60,0,0,2,126,0,0,4,60,0,0,2,122,0,0,1,211,0,0,3,38,0,0,2,65,0,0,4,74,0,0,2,65,0,0,3,38,0,0,1,58,0,0,4,67,0,0,3,27,0,0,4,73,0,0,3,27,0,0,4,67,0,0,2,48,0,0,4,66,0,0,3,30,0,0,4,75,0,0,3,30,0,0,4,66,0,0,2,42,0,0,4,68,0,0,1,9,0,0,1,8,0,0,1,9,0,0,4,68,0,0,2,159,0,0,4,63,0,0,2,164,0,0,4,57,0,0,2,164,0,0,4,63,0,0,2,169,0,0,4,62,0,0,2,120,0,0,4,58,0,0,2,120,0,0,4,62,0,0,2,139,0,0,4,65,0,0,2,126,0,0,4,60,0,0,2,126,0,0,4,65,0,0,2,135,0,0,4,64,0,0,2,114,0,0,4,59,0,0,2,114,0,0,4,64,0,0,2,131,0,0,1,145,0,0,4,74,0,0,2,65,0,0,4,74,0,0,1,145,0,0,2,146,0,0,2,44,0,0,4,73,0,0,3,27,0,0,4,73,0,0,2,44,0,0,2,143,0,0,2,38,0,0,4,75,0,0,3,30,0,0,4,75,0,0,2,38,0,0,2,140,0,0,4,71,0,0,2,139,0,0,4,62,0,0,2,139,0,0,4,71,0,0,2,137,0,0,2,135,0,0,4,70,0,0,2,133,0,0,4,70,0,0,2,135,0,0,4,65,0,0,4,69,0,0,2,169,0,0,4,63,0,0,2,169,0,0,4,69,0,0,2,167,0,0,4,72,0,0,2,131,0,0,4,64,0,0,2,131,0,0,4,72,0,0,2,129,0,0,2,129,0,0,4,79,0,0,3,149,0,0,4,79,0,0,2,129,0,0,4,72,0,0,2,133,0,0,4,77,0,0,3,157,0,0,4,77,0,0,2,133,0,0,4,70,0,0,2,167,0,0,4,78,0,0,3,173,0,0,4,78,0,0,2,167,0,0,4,69,0,0,2,137,0,0,4,76,0,0,3,153,0,0,4,76,0,0,2,137,0,0,4,71,0,0,0,6,0,0,0,184,0,0,0,183,0,0,0,184,0,0,0,6,0,0,1,77,0,0,3,149,0,0,1,225,0,0,3,151,0,0,1,225,0,0,3,149,0,0,4,79,0,0,3,157,0,0,1,227,0,0,3,159,0,0,1,227,0,0,3,157,0,0,4,77,0,0,3,173,0,0,0,201,0,0,3,175,0,0,0,201,0,0,3,173,0,0,4,78,0,0,3,153,0,0,1,229,0,0,3,155,0,0,1,229,0,0,3,153,0,0,4,76,0,0,1,77,0,0,0,8,0,0,0,199,0,0,0,8,0,0,1,77,0,0,0,6,0,0,3,151,0,0,0,108,0,0,2,151,0,0,0,108,0,0,3,151,0,0,1,225,0,0,3,175,0,0,1,221,0,0,3,178,0,0,1,221,0,0,3,175,0,0,0,201,0,0,3,159,0,0,0,112,0,0,2,150,0,0,0,112,0,0,3,159,0,0,1,227,0,0,3,155,0,0,0,116,0,0,2,149,0,0,0,116,0,0,3,155,0,0,1,229,0,0,0,199,0,0,3,178,0,0,1,221,0,0,3,178,0,0,0,199,0,0,0,8,0,0,0,221,0,0,4,32,0,0,2,233,0,0,2,233,0,0,0,222,0,0,0,221,0,0,0,225,0,0,4,33,0,0,2,234,0,0,2,234,0,0,0,226,0,0,0,225,0,0,0,3,0,0,4,31,0,0,2,57,0,0,2,57,0,0,1,181,0,0,0,3,0,0,1,222,0,0,0,50,0,0,1,223,0,0,1,223,0,0,4,55,0,0,1,222,0,0,0,142,0,0,2,29,0,0,0,85,0,0,2,29,0,0,0,142,0,0,3,98,0,0,0,190,0,0,0,185,0,0,0,188,0,0,0,185,0,0,0,190,0,0,3,31,0,0,3,68,0,0,3,69,0,0,3,67,0,0,3,69,0,0,3,68,0,0,0,90,0,0,3,77,0,0,3,81,0,0,1,214,0,0,3,81,0,0,3,77,0,0,3,80,0,0,3,86,0,0,3,82,0,0,3,85,0,0,3,82,0,0,3,86,0,0,0,231,0,0,3,76,0,0,3,72,0,0,3,75,0,0,3,72,0,0,3,76,0,0,1,218,0,0,0,212,0,0,2,25,0,0,0,210,0,0,2,25,0,0,0,212,0,0,3,89,0,0,2,27,0,0,0,219,0,0,3,93,0,0,0,219,0,0,2,27,0,0,0,217,0,0,3,127,0,0,3,128,0,0,3,126,0,0,3,128,0,0,3,127,0,0,0,114,0,0,3,117,0,0,3,118,0,0,3,116,0,0,3,118,0,0,3,117,0,0,0,110,0,0,0,216,0,0,1,250,0,0,0,215,0,0,1,250,0,0,0,216,0,0,0,55,0,0,0,214,0,0,1,255,0,0,0,213,0,0,1,255,0,0,0,214,0,0,0,52,0,0,2,34,0,0,0,47,0,0,2,36,0,0,0,47,0,0,2,34,0,0,0,45,0,0,0,144,0,0,2,1,0,0,0,143,0,0,2,1,0,0,0,144,0,0,0,43,0,0,3,84,0,0,3,85,0,0,3,82,0,0,3,85,0,0,3,84,0,0,0,67,0,0,3,74,0,0,3,75,0,0,3,72,0,0,3,75,0,0,3,74,0,0,0,61,0,0,3,71,0,0,3,67,0,0,3,69,0,0,3,67,0,0,3,71,0,0,0,248,0,0,3,79,0,0,3,80,0,0,3,77,0,0,3,80,0,0,3,79,0,0,0,73,0,0,0,188,0,0,0,187,0,0,3,109,0,0,0,187,0,0,0,188,0,0,0,185,0,0,3,98,0,0,3,40,0,0,3,96,0,0,3,40,0,0,3,98,0,0,0,142,0,0,3,112,0,0,3,113,0,0,3,111,0,0,3,113,0,0,3,112,0,0,0,106,0,0,3,125,0,0,3,121,0,0,3,124,0,0,3,121,0,0,3,125,0,0,0,246,0,0,3,89,0,0,3,29,0,0,3,87,0,0,3,29,0,0,3,89,0,0,0,212,0,0,3,93,0,0,3,26,0,0,3,91,0,0,3,26,0,0,3,93,0,0,0,219,0,0,1,1,0,0,0,67,0,0,3,84,0,0,0,67,0,0,1,1,0,0,0,114,0,0,1,6,0,0,0,73,0,0,3,79,0,0,0,73,0,0,1,6,0,0,0,110,0,0,1,216,0,0,0,248,0,0,3,71,0,0,0,248,0,0,1,216,0,0,0,246,0,0,0,252,0,0,0,61,0,0,3,74,0,0,0,61,0,0,0,252,0,0,0,106,0,0,3,109,0,0,3,110,0,0,2,36,0,0,3,110,0,0,3,109,0,0,0,187,0,0,3,96,0,0,3,95,0,0,0,143,0,0,3,95,0,0,3,96,0,0,3,40,0,0,3,87,0,0,3,90,0,0,0,213,0,0,3,90,0,0,3,87,0,0,3,29,0,0,3,94,0,0,3,91,0,0,3,26,0,0,3,91,0,0,3,94,0,0,0,215,0,0,2,60,0,0,1,163,0,0,4,7,0,0,1,163,0,0,2,60,0,0,3,120,0,0,2,62,0,0,1,166,0,0,4,10,0,0,1,166,0,0,2,62,0,0,3,130,0,0,2,58,0,0,1,160,0,0,4,6,0,0,1,160,0,0,2,58,0,0,3,115,0,0,0,94,0,0,1,123,0,0,4,8,0,0,1,123,0,0,0,94,0,0,3,123,0,0,1,87,0,0,3,143,0,0,0,52,0,0,3,143,0,0,1,87,0,0,1,254,0,0,1,92,0,0,3,145,0,0,0,55,0,0,3,145,0,0,1,92,0,0,1,249,0,0,1,97,0,0,3,141,0,0,0,43,0,0,3,141,0,0,1,97,0,0,2,5,0,0,2,83,0,0,3,168,0,0,0,45,0,0,3,168,0,0,2,83,0,0,3,166,0,0,3,126,0,0,3,130,0,0,2,62,0,0,3,130,0,0,3,126,0,0,3,128,0,0,3,111,0,0,3,115,0,0,2,58,0,0,3,115,0,0,3,111,0,0,3,113,0,0,3,116,0,0,3,120,0,0,2,60,0,0,3,120,0,0,3,116,0,0,3,118,0,0,3,124,0,0,3,123,0,0,0,94,0,0,3,123,0,0,3,124,0,0,3,121,0,0,0,210,0,0,0,151,0,0,2,232,0,0,0,151,0,0,0,210,0,0,2,25,0,0,0,85,0,0,2,31,0,0,0,86,0,0,2,31,0,0,0,85,0,0,2,29,0,0,0,217,0,0,0,146,0,0,2,231,0,0,0,146,0,0,0,217,0,0,2,27,0,0,3,31,0,0,3,32,0,0,1,184,0,0,3,32,0,0,3,31,0,0,0,190,0,0,0,228,0,0,1,218,0,0,3,76,0,0,1,218,0,0,0,228,0,0,0,230,0,0,0,234,0,0,1,214,0,0,3,81,0,0,1,214,0,0,0,234,0,0,0,236,69,78,68,0,0,0,50,0,0,0,13,194,245,0,0,0,0,0,0,66,249,255,106,188,35,215,10,66,249,216,142,191,28,40,246,66,249,170,149,191,64,0,0,66,249,20,21,191,110,20,123,66,248,182,195,191,122,225,72,66,245,0,0,191,128,0,0,194,248,140,176,191,125,112,164,194,249,20,21,191,110,20,123,194,249,170,149,191,64,0,0,194,249,222,148,191,17,235,133,194,250,0,0,0,0,0,0,194,245,0,0,128,0,0,0";
//viewers

R2D.EnvironmentBase = function(px, nx, py, ny, pz, nz) {
    EventDispatcher.call(this);

    var scope = this;
    var cubeTextureLoader = new THREE.CubeTextureLoader();
    var cubeTexture = cubeTextureLoader.load(
        [
            R2D.STYLE.PATH_TO_ENVIRONMENT + px,
            R2D.STYLE.PATH_TO_ENVIRONMENT + nx,
            R2D.STYLE.PATH_TO_ENVIRONMENT + py,
            R2D.STYLE.PATH_TO_ENVIRONMENT + ny,
            R2D.STYLE.PATH_TO_ENVIRONMENT + pz,
            R2D.STYLE.PATH_TO_ENVIRONMENT + nz
        ],
        complete
    );
    var isReady = false;
    var loaded = 0;

    function complete() {
        console.log('EnvironmentBase: complete');
        scope.dispatchComplete();
    }

    Object.defineProperty(scope, 'isReady', {
        get() {
            return isReady;
        }
    });
    Object.defineProperty(scope, 'texture', {
        get() {
            return cubeTexture;
        }
    });

    scope.getTexture = function() {
        return cubeTexture;
    };
};

R2D.extend(R2D.EnvironmentBase, EventDispatcher);

R2D.EnvironmentBase.NONE = 0;
R2D.EnvironmentBase.GLOSS = 1;
R2D.EnvironmentBase.METAL = 2;
//viewers

R2D.EnvironmentGloss = function() {
    R2D.EnvironmentBase.call(
        this,
        '/gloss/px.jpg',
        '/gloss/nx.jpg',
        '/gloss/py.jpg',
        '/gloss/ny.jpg',
        '/gloss/pz.jpg',
        '/gloss/nz.jpg'
    );
};

R2D.extend(R2D.EnvironmentGloss, R2D.EnvironmentBase);

R2D.EnvironmentGloss.REFLECTION_MIN = 0.01;
R2D.EnvironmentGloss.REFLECTION_MAX = 0.30;

R2D.EnvironmentGloss._texture = null;

R2D.EnvironmentGloss.getTexture = function() {
    if ( R2D.EnvironmentGloss._texture == null ) {
        R2D.EnvironmentGloss._texture = new R2D.EnvironmentGloss().getTexture();
    }

    return R2D.EnvironmentGloss._texture;
};

R2D.EnvironmentGloss.getReflectivity = function(value) {
    return R2D.EnvironmentGloss.REFLECTION_MIN + value * (R2D.EnvironmentGloss.REFLECTION_MAX - R2D.EnvironmentGloss.REFLECTION_MIN);
};

//viewers

R2D.EnvironmentMetal = function() {
    R2D.EnvironmentBase.call(
        this,
        '/metal/px.jpg',
        '/metal/nx.jpg',
        '/metal/py.jpg',
        '/metal/ny.jpg',
        '/metal/pz.jpg',
        '/metal/nz.jpg'
    );
};

R2D.extend(R2D.EnvironmentMetal, R2D.EnvironmentBase);

R2D.EnvironmentMetal.REFLECTION_MIN = 0.05;
R2D.EnvironmentMetal.REFLECTION_MAX = 0.50;

R2D.EnvironmentMetal._texture = null;

R2D.EnvironmentMetal.getTexture = function() {
    if ( R2D.EnvironmentMetal._texture == null ) {
        R2D.EnvironmentMetal._texture = new R2D.EnvironmentMetal().getTexture();
    }

    return R2D.EnvironmentMetal._texture;
};

R2D.EnvironmentMetal.getReflectivity = function(value) {
    return R2D.EnvironmentMetal.REFLECTION_MIN + value * (R2D.EnvironmentMetal.REFLECTION_MAX - R2D.EnvironmentMetal.REFLECTION_MIN);
};
//viewers

/*
events:
 Event.START - Start loading an item, data - product id
 Event.FINISH - Finish loading an item, data - product id
 Event.COMPLETE - Complete loading items in queue, data - null
 Event.ERROR - Error loading an item, data - product id
 */

R2D.Pool3D = function () {
    //-
};

R2D.Pool3D.__currentProductId = null;
R2D.Pool3D.__currentProductData = null;
R2D.Pool3D.__queue = [];
R2D.Pool3D.__exist = {};
R2D.Pool3D.__loaded = {};
R2D.Pool3D.__data = {};

R2D.Pool3D.__eventDispatcher = new EventDispatcher();

R2D.Pool3D.__loaderEventHandler = function (event) {
    var productId = R2D.Pool3D.__currentProductId;
    var productData = R2D.Pool3D.__currentProductData;
    var loader = event.currentTarget;

    loader.removeEventListener(Event.COMPLETE, R2D.Pool3D.__loaderEventHandler);
    loader.removeEventListener(Event.ERROR, R2D.Pool3D.__loaderEventHandler);

    R2D.Pool3D.__currentProductId = null;
    R2D.Pool3D.__currentProductData = null;
    R2D.Pool3D.__queue.shift();

    delete R2D.Pool3D.__exist[productId];

    if (event.type == Event.COMPLETE) {
        R2D.Pool3D.__data[productId] = loader.data;
        R2D.Pool3D.__loaded[productId] = true;

        R2D.Pool3D.dispatchEvent(new Event(Event.FINISH, productId));
    } else {
        console.warn(
            "R2D.Pool3D.__loaderEventHandler: Error load product data %s".format(
                productId
            )
        );

        R2D.Pool3D.dispatchEvent(new Event(Event.ERROR, productId));
    }

    R2D.Pool3D.__checkLoad();
};
R2D.Pool3D.__GLTFLoadListener = function (gltf) {
    var productId = R2D.Pool3D.__currentProductId;
    var productData = R2D.Pool3D.__currentProductData;

    R2D.Pool3D.__currentProductId = null;
    R2D.Pool3D.__currentProductData = null;
    R2D.Pool3D.__queue.shift();

    delete R2D.Pool3D.__exist[productId];

    gltf.scene.traverse(function (obj) {
        obj.position.y = 0;
        if (obj.type == "Mesh") {
            obj.castShadow = true;
            if (obj.material.map) obj.material.map.encoding = THREE.LinearEncoding;
            if (obj.material.normalMap)
                obj.material.normalMap.encoding = THREE.LinearEncoding;
            if (
                obj.material.metalness &&
                Number(productData.type) === R2D.ProductType.POSTER
            ) {
                obj.material.metalness = 0;
            }
        }
    });

    R2D.Pool3D.__data[productId] = gltf;
    R2D.Pool3D.__loaded[productId] = true;

    R2D.Pool3D.dispatchEvent(new Event(Event.FINISH, productId));

    R2D.Pool3D.__checkLoad();
};
R2D.Pool3D.__checkLoad = function () {
    var productId = null;
    var productData = null;

    if (R2D.Pool3D.__currentProductId != null) {
        return;
    }
    if (R2D.Pool3D.__queue.length == 0) {
        R2D.Pool3D.dispatchEvent(new Event(Event.COMPLETE, null));
        return;
    }

    productId = R2D.Pool3D.__queue[0];
    productData = R2D.Pool.getProductData(productId);

    if (!productData) {
        R2D.Pool3D.__currentProductId = null;
        R2D.Pool3D.__currentProductData = null;
        R2D.Pool3D.__queue.shift();

        delete R2D.Pool3D.__exist[productId];

        console.warn(
            "Pool3d: Error! Product data %s is missing! Ignored to load!".format(
                productId
            )
        );

        R2D.Pool3D.dispatchEvent(new Event(Event.ERROR, productId));

        R2D.Pool3D.__checkLoad();
    } else {
        var url = R2D.makeURL(R2D.URL.DOMAIN, productData.source.body.package);

        R2D.Pool3D.__currentProductId = productId;
        R2D.Pool3D.__currentProductData = productData;

        if (productData.isGLTF) {
            var gLoader = new THREE.GLTFLoader();
            //gLoader.setPath('r2d/');
            //gLoader.load('http://designer2:90/sofa_export.gltf', R2D.Pool3D.__GLTFLoadListener);
            gLoader.load(url, R2D.Pool3D.__GLTFLoadListener);
        } else {
            var loader = new R2D.XHRLoader();
            loader.addEventListener(Event.COMPLETE, R2D.Pool3D.__loaderEventHandler);
            loader.addEventListener(Event.ERROR, R2D.Pool3D.__loaderEventHandler);
            loader.load(url, null, "GET", null, "arraybuffer", false);
        }

        R2D.Pool3D.dispatchEvent(new Event(Event.START, productId));
    }
};

Object.assign(R2D.Pool3D, EventDispatcherConstantInterface);

R2D.Pool3D.isLoaded = function (productId) {
    return (
        R2D.Pool3D.__loaded.hasOwnProperty(productId) &&
        R2D.Pool3D.__loaded[productId] == true
    );
};
R2D.Pool3D.load = function (productId) {
    if (
        R2D.Pool3D.__loaded.hasOwnProperty(productId) &&
        R2D.Pool3D.__loaded[productId] == true
    )
        return;
    if (
        R2D.Pool3D.__exist.hasOwnProperty(productId) &&
        R2D.Pool3D.__exist[productId] == true
    )
        return;

    R2D.Pool3D.__exist[productId] = true;
    R2D.Pool3D.__queue.push(productId);

    R2D.Pool3D.__checkLoad();
};
R2D.Pool3D.getData = function (productId) {
    return R2D.Pool3D.__data[productId];
};
R2D.Pool3D.clearData = function (productId) {
    delete R2D.Pool3D.__data[productId];
    delete R2D.Pool3D.__loaded[productId];
};

// viewers

R2D.PoolMaterials = function() {
    //-
};

R2D.PoolMaterials.__materials = {};

R2D.PoolMaterials.isMaterial = function (productId) {
    if (R2D.PoolMaterials.__materials.hasOwnProperty(productId))
        return R2D.PoolMaterials.__materials[productId];
};
R2D.PoolMaterials.create = function (productId, initMaterialId) {
    if (productId == null || productId == undefined) {
        throw "Error! Product id is " + productId;
    }
    
    var material;
    if (initMaterialId) {
        material = new R2D.ObjectViewer3DMaterial(initMaterialId, productId);
        // R2D.PoolMaterials.__materials[initMaterialId + "_" + productId] = material;
        R2D.PoolMaterials.__materials[initMaterialId] = material;
    } else if (productId.length > 0 && productId[0] == "#") {
        material = new R2D.ObjectViewerColorMaterial(productId);
        R2D.PoolMaterials.__materials[productId] = material;
    } else {
        material = new R2D.ObjectViewer3DMaterial(productId);
        R2D.PoolMaterials.__materials[productId] = material;
    }
    return material;
};
R2D.PoolMaterials.remove = function (productId) {
    if (R2D.PoolMaterials.isMaterial(productId)) {
        const material = R2D.PoolMaterials.__materials[productId].getMaterial();

        if (material.map) material.map.dispose();
        if (material.lightMap) material.lightMap.dispose();
        if (material.bumpMap) material.bumpMap.dispose();
        if (material.normalMap) material.normalMap.dispose();
        if (material.specularMap) material.specularMap.dispose();
        if (material.envMap) material.envMap.dispose();
        if (material.alphaMap) material.alphaMap.dispose();
        if (material.aoMap) material.aoMap.dispose();
        if (material.displacementMap) material.displacementMap.dispose();
        if (material.emissiveMap) material.emissiveMap.dispose();
        if (material.gradientMap) material.gradientMap.dispose();
        if (material.metalnessMap) material.metalnessMap.dispose();
        if (material.roughnessMap) material.roughnessMap.dispose();
        material.dispose();

        delete R2D.PoolMaterials.__materials[productId];
    }
};
R2D.PoolMaterials.getMaterial = function (productId, addMaterial) {
    if (productId == 0 || productId == "0") return null;

    if (addMaterial) {
        if (R2D.PoolMaterials.isMaterial(addMaterial)) {
            R2D.PoolMaterials.__materials[addMaterial].setColor(productId);
            return R2D.PoolMaterials.__materials[addMaterial];
        } else {
            return R2D.PoolMaterials.create(productId, addMaterial);
        }
    }

    if (R2D.PoolMaterials.isMaterial(productId))
        return R2D.PoolMaterials.__materials[productId];
    return R2D.PoolMaterials.create(productId);
};
// viewers

R2D.Light3D = function(noFlares=false) {

    var me = this;

    var backLight = new THREE.AmbientLight(0xffffff);
    var middleLight = new THREE.Object3D();

    var ambientLight = new THREE.AmbientLight(0x555555);

    var shadowLight = new THREE.DirectionalLight(0xffffff, 0.2);
    var topLight = new THREE.DirectionalLight(0xffffff, 0.4);
    var frontLight = new THREE.DirectionalLight(0xffffff, 0.7);
    var leftLight = new THREE.DirectionalLight(0xffffff, 0.55);
    var rightLight = new THREE.DirectionalLight(0xffffff, 0.55);

    shadowLight.position.set(0, 400, 0);
    topLight.position.set(0, 400, 0);
    frontLight.position.set(0, 0, 2);
    leftLight.position.set(2, 0, -1);
    rightLight.position.set(-2, 0, -1);

    shadowLight.target.position.set(0, 0.8, 0);
    topLight.target.position.set(0, 0.8, 0);
    frontLight.target.position.set(0, 0.8, 0);
    leftLight.target.position.set(0, 0.8, 0);
    rightLight.target.position.set(0, 0.8, 0);

    middleLight.add(ambientLight);

    middleLight.add(shadowLight);
    middleLight.add(shadowLight.target);
    middleLight.add(topLight);
    middleLight.add(topLight.target);
    middleLight.add(frontLight);
    middleLight.add(frontLight.target);
    middleLight.add(leftLight);
    middleLight.add(leftLight.target);
    middleLight.add(rightLight);
    middleLight.add(rightLight.target);


    shadowLight.castShadow = true;
    shadowLight.shadow.camera.near = 50;
    shadowLight.shadow.camera.far = 450;
    shadowLight.shadow.mapSize.width = 2048;
    shadowLight.shadow.mapSize.height = 2048;
    shadowLight.shadow.bias = -0.005;
    shadowLight.shadow.radius = 4;

    me.modeMain = function()
    {
        ambientLight.color.setHex(0x555555);
        shadowLight.intensity = 0.2;
        topLight.intensity = 0.4;
        frontLight.intensity = 0.7;
        leftLight.intensity = 0.55;
        rightLight.intensity = 0.55;
    };

    me.modeNoFlares = function()
    {
        ambientLight.color.setHex(0xaaaaaa);
        shadowLight.intensity = 0.2;
        topLight.intensity = 0.2;
        frontLight.intensity = 0.35;
        leftLight.intensity = 0.2;
        rightLight.intensity = 0.2;
    };

    if (noFlares)
    {
        me.modeNoFlares();
    }

    me.modeUniform = function()
    {
        ambientLight.color.setHex(0xffffff);
        shadowLight.intensity = 0;
        topLight.intensity = 0;
        frontLight.intensity = 0.;
        leftLight.intensity = 0;
        rightLight.intensity = 0;
    };

    me.shadowOn = function()
    {
        shadowLight.castShadow = true;
    };

    me.shadowOff = function()
    {
        shadowLight.castShadow = false;
    };

    me.getBottom = function()
    {
        return backLight;
    };

    me.getMiddle = function()
    {
        return middleLight;
    };

    me.cameraChanged = function(position, target, rotation, fov)
    {
        var shadowSize = position.y * 2;

        if (shadowSize < 1200) shadowSize = 1200;

        var tg = Math.tan(-rotation.x + GEOM.toRad(fov) / 2);

        var shadowX = 0;
        var shadowZ = 0;
        if (tg != 0)
        {
            var dist = (position.y - 100) / tg;
        //    if (position.y < 300 && dist > 300) dist = 300;
            shadowX = position.x - dist * Math.sin(rotation.y) - shadowSize * 0.4 * Math.sin(rotation.y);
            shadowZ = -position.z + dist * Math.cos(rotation.y) + shadowSize * 0.4 * Math.cos(rotation.y);
        }

        updateShadow(shadowX, shadowZ, shadowSize);

        middleLight.rotation.set(0, rotation.y, 0);
    };

    function updateShadow(x, z, size)
    {
        shadowLight.shadow.camera.left = x - size / 2;
        shadowLight.shadow.camera.right = x + size / 2;
        shadowLight.shadow.camera.top = z - size / 2;
        shadowLight.shadow.camera.bottom = z + size / 2;
        shadowLight.shadow.camera.updateProjectionMatrix();
    }

    updateShadow(0, 0, 800);

};
// viewers

R2D.Scene3D = function(api) {
    let scope = this;
    let sceneBottom = new THREE.Scene();
    let sceneMiddle = new THREE.Scene();
    let sceneTop = new THREE.Scene();

    let lights = new R2D.Light3D();

    scope.ruler3d = new R2D.Ruler3D(scope);
    //scope.customRulers = new R2D.CustomRulers(scope, R2D.scene.constructor, api);
    scope.customRulers = R2D.CustomRulers.init(scope, R2D.scene.constructor, api);
    scope.titlesTool = new R2D.TitlesTool(scope, R2D.scene.constructor, api);

    let raycaster = new THREE.Raycaster();

    function getScene(target) {
        switch ( target ) {
            case R2D.Scene3D.BOTTOM:
                return sceneBottom;

            case R2D.Scene3D.TOP:
                return sceneTop;

            case undefined:
            case null:
            case R2D.Scene3D.MIDDLE:
                return sceneMiddle;

            default:
                console.error("Unknown scene type %s!".format(target));
                return sceneMiddle;
        }
    }

    Object.defineProperties(scope, {
        "bottom":{
            get() { return sceneBottom; }
        },
        "middle":{
            get() { return sceneMiddle; }
        },
        "top":{
            get() { return sceneTop; }
        }
    });

    scope.add = function(object, target)
    {
        getScene(target).add(object);
    };
    scope.remove = function(object, target)
    {
        getScene(target).remove(object);
    };
    scope.createDebugElements = function() {
        scope.add((function() {
            let geometry = new THREE.BoxGeometry(250, 100, 100);
            let material = new THREE.MeshPhongMaterial({color:0xff00ff});
            let mesh = new THREE.Mesh(geometry, material);

            mesh.receiveShadow = true;
            mesh.castShadowShadow = true;

            return mesh;
        })(), R2D.Scene3D.BOTTOM);
        scope.add((function() {
            let geometry = new THREE.BoxGeometry(100, 100, 250);
            let material = new THREE.MeshPhongMaterial({color:0xff0000});
            let mesh = new THREE.Mesh(geometry, material);

            mesh.receiveShadow = true;
            mesh.castShadowShadow = true;

            return mesh;
        })(), R2D.Scene3D.MIDDLE);
        scope.add((function() {
            let geometry = new THREE.BoxGeometry(50, 50, 50);
            let material = new THREE.MeshPhongMaterial({color:0xffff00});
            let mesh = new THREE.Mesh(geometry, material);

            mesh.receiveShadow = true;
            mesh.castShadowShadow = true;

            return mesh;
        })(), R2D.Scene3D.TOP);

        scope.createDebugElements = () => console.warn("Debug elements have been added!");
    };
    scope.objectUnderCursor = function(container, camera, u, v, exclude) {
        if (!camera) return null;
        
        let data = null;

        raycaster.setFromCamera(new THREE.Vector2(u, v), camera);

        data = raycaster.intersectObjects(container.children, true);

        for (let i = 0; i < data.length; i++)
        {
            let obj = data[i].object;

            if (typeof(obj.visible) !== "undefined" && ! obj.visible) continue;
            if (exclude && (exclude == obj || exclude.children.includes(obj))) continue;

            if (R2D.Viewers.getCurrentViewerType() == "2d") {
                const view2DObjects = R2D.mouseInteractionHelper._commonSceneObject.view2DObjects;
                if (view2DObjects.children.find((child) => child.getObjectByName("plane") == obj)) continue;
            }
            
            if (R2D.Viewers.getCurrentViewerType() == "3d") {
                const coversTitleObjects =
                    R2D.mouseInteractionHelper._commonSceneObject.coversTitleObjects;
                if (coversTitleObjects.children.find((child) => child == obj)) continue;
            }

            return data[i];
        }

        return null;
    };
    scope.circlesUnderCursor = function(container, camera, u, v) {
        let data = null;

        raycaster.setFromCamera(new THREE.Vector2(u, v), camera);

        data = raycaster.intersectObjects(container.children, true);

        for (let i = 0; i < data.length; i++)
        {
            let obj = data[i].object;
            if (obj.name == "ringXHelper" ||
                obj.name == "ringYHelper" ||
                obj.name == "ringZHelper")
            return data[i];
        }

        return null;
    };
    scope.intersectWithObject = function(camera, u, v, object3d) {
        raycaster.setFromCamera(new THREE.Vector2(u, v), camera);

        let objects = raycaster.intersectObject(object3d, false);

        return objects.length > 0 ? objects[0] : null;
    };
    scope.cameraChanged = function(position, target, rotation, fov)
    {
        lights.cameraChanged(position, target, rotation, fov)
    };

    sceneBottom.add(lights.getBottom());
    sceneMiddle.add(lights.getMiddle());

    scope.getLights = function()
    {
        return lights;
    };
};

R2D.Scene3D.BOTTOM = "bottom";
R2D.Scene3D.MIDDLE = "middle";
R2D.Scene3D.TOP = "top";
// viewers

R2D.Renderer3D = function(scene3d) {
    EventDispatcher.call(this);

    var scope = this;
    var width = 800;
    var height = 600;
    var camera3d = null;
    var canvas = HGen.element(null, 'canvas', 'canvas', {
        "style":"position: absolute; display: inline-block;",
        "width":"500",
        "height":"500"
    });
    var renderer = new THREE.WebGLRenderer({
        antialias:true,
        alpha:true,
        canvas:canvas.domElement
    });

    renderer.shadowMap.enabled = true;

    var filterBackground = new BGFilter(renderer);
    var filterContours = new ContoursFilter();
    var filterSelect = new OutlineFilter();
    var useSSAOFilter = true;
    var useContourFilter = false;
    var updater = new R2D.RenderUpdater();

    if (! R2D.config.isDesktop) updater.setFrames(2);
    if (! R2D.config.isDesktop) useSSAOFilter = false;

    filterContours.setInsideColor(1.0, 1.0, 1.0, 0.6);
    filterContours.setOutsideColor(1.0, 1.0, 1.0, 0.6);
    filterContours.setStrokeColor(0.0, 0.0, 0.0, 1.0);

    filterSelect.setInsideColor(1.0, 1.0, 1.0, 0.0);
    filterSelect.setOutsideColor(1.0, 1.0, 1.0, 0.0);
    filterSelect.setStrokeColor(1.0, 0.7, 0.0, 1.0);

    var mainTarget = new THREE.WebGLRenderTarget(1000, 800, {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter});

    var sceneSelect = new THREE.Scene();

    function render(useFilter, useBackground, updateFilter = true)
    {
        if (stats) stats.update();

        renderer.clear();

        if (!camera3d /*|| !composer*/) return;
        if (useBackground) filterBackground.render();

        renderer.render(scene3d.bottom, camera3d);

        renderer.render(scene3d.middle, camera3d);

        renderer.clearDepth();

        if (useContourFilter) {
            const planeViewers = R2D.view2d.getObjectsViewers3dPlanes();

            if (planeViewers.size > 0) {
                for (const iterator of planeViewers.values()) {
                    iterator.object3d.visible = false;
                }
            }

            filterContours.render();

            if (planeViewers.size > 0) {
                for (const iterator of planeViewers.values()) {
                    iterator.object3d.visible = true;
                }
            }
        }

        renderer.clearDepth();

        renderer.render(R2D.commonSceneHelper.commonSceneObject.view2DObjects, camera3d)
        renderer.clearDepth();

        if (R2D.scene.currentGroup) {
            var selectedObjects = R2D.scene.currentGroup.getContainer().children;

            for (var i = 0; i < selectedObjects.length; i++)
            {
                filterSelect.setComponents(selectedObjects[i], camera3d, renderer);
                filterSelect.render();
            }

            renderer.clearDepth();
        } else if (R2D.scene.currentView3DObject && R2D.scene.currentView3DObject.getObject3d) {
            let oldParent = null;
            let obj = null;

            if (
                R2D.Viewers.getCurrentViewerType &&
                R2D.Viewers.getCurrentViewerType() === "2d" &&
                R2D.scene.currentView3DObject.viewerPlane
            ) {
                obj = R2D.scene.currentView3DObject.getObject3d(R2D.scene.currentPartNum);
                oldParent = obj?.parent;

                if (oldParent) {
                    obj.visible = true;
                    sceneSelect.add(obj);

                    filterSelect.setComponents(sceneSelect, camera3d, renderer);
                    filterSelect.render();

                    obj.visible = false;
                    if (obj.getObjectByName("plane")) obj.getObjectByName("plane").visible = true;
                    oldParent.add(obj);

                    renderer.clearDepth();
                }
            } else {
                obj = R2D.scene.currentView3DObject.getObject3d(R2D.scene.currentPartNum);
                oldParent = obj?.parent;

                if (oldParent) {
                    sceneSelect.add(obj);

                    filterSelect.setComponents(sceneSelect, camera3d, renderer);
                    filterSelect.render();

                    oldParent.add(obj);

                    renderer.clearDepth();
                }
            }
        }

        renderer.render(scene3d.top, camera3d);
        renderer.clearDepth();
    }

    Object.defineProperties(scope, {
        "width":{
            get() { return width; },
            set(value) { throw "Use setSize() method instead!"; }
        },
        "height":{
            get() { return height; },
            set(value) { throw "Use setSize() method instead!"; }
        },
        "useSSAOFilter":{
            get() { return useSSAOFilter; },
            set(value) { useSSAOFilter = value; }
        },
        "useContourFilter":{
            get() { return useContourFilter; },
            set(value) { useContourFilter = value; }
        },
        "domElement":{
            get() { return canvas.domElement; }
        },
        "canvas":{
            get() { return canvas; }
        },
        "camera3d":{
            get() { return camera3d; }
        },
        "filterSSAO":{
            get() { return filterSSAO }
        }
    });

    scope.updateCamera3d = function(camera) {
        camera3d = camera;
        filterContours.setComponents(R2D.scene3d.middle, camera3d, renderer);
    };
    scope.render = function()
    {
        render(true, true);
    };
    scope.updateCursor = function()
    {
        requestAnimationFrame(updateCursorOnFrame);
    };
    var wasRunning = false;
    function updateCursorOnFrame()
    {
        if (updater.isRunning())
        {
            wasRunning = true;
            return;
        }
        else if (wasRunning)
        {
            wasRunning = false;
            render(true, true, true);
            return;
        }

        render(true, true, false);
    }
    scope.update = function() {
        updater.needsUpdate();
    };
    scope.getWidth = function () {
        return scope.width;
    };
    scope.getHeight = function () {
        return scope.height;
    };
    scope.setSize = function(w, h) {
        width = w;
        height = h;

        renderer.setSize(w, h);
        filterSelect.setSize(w, h);
        filterContours.setSize(w, h);
        mainTarget.setSize(w, h);

        updater.needsUpdate();
    };
    scope.getScreenshot = function(callback) {
        renderer.setClearAlpha(0);
        render(true, false);

        canvas.domElement.toBlob(function(blob) {
            renderer.setClearAlpha(1);
            render(true, true);
            callback(blob);
        });
    };

    R2D.Renderer3D.maxAnisotropy = renderer.getMaxAnisotropy();

    renderer.autoClear = false;
    renderer.setClearColor(0xffffff);
    renderer.setPixelRatio(window.devicePixelRatio);

    filterSelect.setSize(width, height);
    mainTarget.setSize(width, height);

    updater.onStart(() => {});
    updater.onProgress(() => render(false, true));
    updater.onFinish(() => render(true, true));
    updater.needsUpdate();


    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.altKey)
        {
            if (e.code == 'Digit1')
            {
                if (renderer.shadowMap.enabled)
                {
                    renderer.shadowMap.enabled = false;
                    scene3d.getLights().shadowOff();
                }
                else
                {
                    renderer.shadowMap.enabled = true;
                    scene3d.getLights().shadowOn();
                }

                scope.update();
            }
            else if (e.code == 'Digit2')
            {
                if (! stats) return;
                if (stats.domElement.parentNode)
                {
                    document.body.removeChild(stats.domElement);
                }
                else
                {
                    document.body.appendChild(stats.domElement);
                    stats.domElement.style.left = '0px';
                    stats.domElement.style.top = document.body.clientHeight - 50 + 'px';
                }
            }
        }
    });


    if (typeof(Stats) !== 'undefined')
    {
        var stats = new Stats();
        stats.setMode(0);
        stats.domElement.style.position = 'absolute';
    }

    scope.getWebGLRenderer = function () {
        return renderer;
    }
};

extend(R2D.Renderer3D, EventDispatcher);

R2D.Renderer3D.maxAnisotropy = 1;

R2D.Renderer3D.getMousePointForPicker = function(canvas, mouseX, mouseY) {
    var rect = canvas.getBoundingClientRect();
    var rx = (mouseX - rect.left) / rect.width * 2 - 1;
    var ry = -(mouseY - rect.top) / rect.height * 2 + 1;

    return new THREE.Vector2(rx, ry);
};
// viewers

R2D.Renderer3DPerspective = function (sharedRenderer, camera3d, scene3d) {
    EventDispatcher.call(this);

    let scope = this;
    let superSetSize = scope.setSize;
    let orbitController = new R2D.OrbitController();
    let sensitivePan = 0.01;
    let sensitiveTilt = 0.01;
    let sensitiveZoom = 0.05;

    let lookUp = false;
    let cameraMinHeight = 0;

    scope.setSensitiveZoom = function (value) {
        sensitiveZoom = value;
    };

    scope.setCameraMinHeight = function (val) {
        cameraMinHeight = val;
    };

    scope.setCameraLookUp = function (val) {
        lookUp = val;
    };

    function updateCameraPosition() {
        let position = orbitController.getPosition();
        let rotation = orbitController.getRotation();
        let anchor = orbitController.getAnchor();

        camera3d.position.set(position.x, position.y, position.z);
        camera3d.rotation.set(rotation.x, rotation.y, 0, "YXZ");

        if (scene3d) scene3d.cameraChanged(position, anchor, rotation, camera3d.fov);

        sharedRenderer.update();
    }
    function orbitControllerUpdateEventHandler(event) {
        updateCameraPosition();

        scope.dispatchEvent(
            new Event(R2D.Renderer3DPerspective.CAMERA_POSITION_UDPATE, scope)
        );
    }
    function getSensitiveMove() {
        return Math.max((orbitController.getDistance() / 2000) * 2.2, 0.1);
    }

    Object.defineProperties(scope, {});

    scope.update = function () {
        sharedRenderer.update();
    };
    scope.updateCursor = function () {
        sharedRenderer.updateCursor();
    };
    scope.enable = function () {
        orbitController.addEventListener(Event.UPDATE, orbitControllerUpdateEventHandler);
        orbitController.update();
    };
    scope.disable = function () {
        orbitController.removeEventListener(
            Event.UPDATE,
            orbitControllerUpdateEventHandler
        );
    };
    scope.getCameraPosition = function () {
        return orbitController.getPosition();
    };
    scope.updateCameraViewPosition = function (x, y, z, distance, pan, tilt) {
        orbitController.setAnchor(x, y, z);
        orbitController.setDistance(distance);
        orbitController.setPan(pan);
        orbitController.setTilt(tilt);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraPan = function () {
        return orbitController.getPan();
    };
    scope.setCameraPanBounds = function (min, max) {
        console.warn("R2D.Renderer3DPerspective.setPanBounds needs implement");
    };
    scope.updateCameraPan = function (pan) {
        orbitController.setPan(pan);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraTiltMin = function () {
        return orbitController.minTilt;
    };
    scope.getCameraTiltMax = function () {
        return orbitController.maxTilt;
    };
    scope.getCameraTilt = function () {
        return orbitController.getTilt();
    };
    scope.setCameraTiltBounds = function (min, max) {
        orbitController.minTilt = min;
        orbitController.maxTilt = max;
    };
    scope.updateCameraTilt = function (tilt) {
        orbitController.setTilt(tilt);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraDistanceMin = function () {
        return orbitController.minDistance;
    };
    scope.getCameraDistanceMax = function () {
        return orbitController.maxDistance;
    };
    scope.getCameraDistance = function () {
        return orbitController.getDistance();
    };
    scope.setCameraDistanceBounds = function (min, max) {
        orbitController.minDistance = min;
        orbitController.maxDistance = max;
    };
    scope.updateCameraDistance = function (distance) {
        orbitController.setDistance(distance);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraAnchor = function () {
        return orbitController.getAnchor();
    };
    scope.updateCameraAnchor = function (x, y, z) {
        orbitController.setAnchor(x, y, z);
        orbitController.update();

        updateCameraPosition();
    };
    scope.cameraZoom = function (delta) {
        let zd = orbitController.maxDistance - orbitController.minDistance;
        let zs = zd * sensitiveZoom;
        let zr = orbitController.getDistance() + (delta > 0 ? zs : -zs);
        orbitController.setDistance(zr);

        if (orbitController.getTilt() < 0 && lookUp) {
            let anch = orbitController.getAnchor();
            let anchHeight =
                cameraMinHeight +
                orbitController.getDistance() * Math.sin(-orbitController.getTilt());
            orbitController.setAnchor(anch.x, anchHeight, anch.z);
        }

        orbitController.update();
    };
    scope.cameraRotate = function (dx, dy) {
        orbitController.setPan(orbitController.getPan() - dx * sensitivePan);
        orbitController.setTilt(orbitController.getTilt() + dy * sensitiveTilt);

        let anch = orbitController.getAnchor();
        if (orbitController.getTilt() < 0 && lookUp) {
            let anchHeight =
                cameraMinHeight +
                orbitController.getDistance() * Math.sin(-orbitController.getTilt());
            orbitController.setAnchor(anch.x, anchHeight, anch.z);
        } else {
            orbitController.setAnchor(anch.x, cameraMinHeight, anch.z);
        }

        orbitController.update();
    };
    scope.cameraMove = function (dx, dy) {
        let sensitive = 1; // getSensitiveMove();
        let angle = orbitController.getPan();
        let sx = (Math.cos(angle) * dx + Math.sin(angle) * dy) * sensitive;
        let sz = (-Math.cos(angle) * dy + Math.sin(angle) * dx) * sensitive;

        let anchor = orbitController.getAnchor();
        let x = anchor.x - sx;
        let y = anchor.y;
        let z = anchor.z + sz;

        orbitController.setAnchor(x, y, z);
        orbitController.update();
    };
    scope.cameraMoveY = function (dy) {
        let sensitive = 1; // getSensitiveMove();
        let angle = orbitController.getPan();

        let anchor = orbitController.getAnchor();
        let y = dy;
        let x = anchor.x;
        let z = anchor.z;

        orbitController.setAnchor(x, y, z);
        orbitController.update();
    };

    /*scope.cameraJump = function(x, y)
    {
        let anchor = orbitController.getAnchor();
        orbitController.setAnchor(x, anchor.y, y);
        orbitController.update();
    };*/
    scope.setSize = function (width, height) {
        camera3d.aspect = width / height;

        camera3d.updateProjectionMatrix();
        sharedRenderer.setSize(width, height);
    };
    scope.setupRendererData = function () {
        sharedRenderer.updateCamera3d(camera3d);

        // sharedRenderer.filterSSAO.setBlur(false);

        //sharedRenderer.filterSSAO.setOpacitySSAO(0.35);
        //sharedRenderer.filterSSAO.setSSAORadius(150);
        //sharedRenderer.filterSSAO.setSSAORadiusFar(3);
        //sharedRenderer.filterSSAO.setSSAOMaxRangeNear(0.05);
        //sharedRenderer.filterSSAO.setSSAOMaxRangeFar(0.00005);
        //sharedRenderer.filterSSAO.setBlurRadiusNear(50);
        //sharedRenderer.filterSSAO.setBlurRadiusFar(4);
    };

    scope.getWebGLRenderer = function () {
        return sharedRenderer.getWebGLRenderer();
    }
};

R2D.extend(R2D.Renderer3DPerspective, EventDispatcher);

R2D.Renderer3DPerspective.CAMERA_POSITION_UDPATE = "cameraPositionUpdate";

// viewers

R2D.Renderer3DOrthographic = function(sharedRenderer, camera3d) {
    EventDispatcher.call(this);

    let scaleVaues = [-0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
    //let scaleVaues = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8];
    let scalePointer = 8;
    let sensArr = [4.8]

    var scope = this;
    var orbitController = new R2D.OrbitController();
    var cameraZoomMin = scaleVaues[0];
    var cameraZoomMax = scaleVaues[scaleVaues.length - 1];
    var cameraZoomCurrent = scaleVaues[scalePointer];
    var sensitivePan = 0.01;
    var sensitiveTilt = 0.01;
    var sensitiveZoom = 0.05;

    let cameraSteps = 0.1;

    function updateCameraPosition() {
        var position = orbitController.getPosition();
        var rotation = orbitController.getRotation();

        camera3d.position.set(position.x, position.y, position.z);
        camera3d.rotation.set(rotation.x, rotation.y, 0, 'YXZ');

        sharedRenderer.update();
    }
    function updateCamera() {
        var z = 1 - cameraZoomCurrent;
        var w = sharedRenderer.width * z;
        var h = sharedRenderer.height * z;
        var w2 = w / 2;
        var h2 = h / 2;

        camera3d.left = -w2;
        camera3d.right = w2;
        camera3d.top = h2;
        camera3d.bottom = -h2;

        camera3d.updateProjectionMatrix();

        sharedRenderer.update();
    }
    function orbitControllerUpdateEventHandler(event) {
        updateCameraPosition();

        scope.dispatchEvent(new Event(R2D.Renderer3DOrthographic.CAMERA_POSITION_UDPATE, scope));
    }
    function getSensitiveMove() {
        var r = (cameraZoomCurrent - cameraZoomMin) / (cameraZoomMax - cameraZoomMin);
        return (1 - r) * 1.6 + 0.2;
    }

    Object.defineProperties(scope, {
        "sharedRenderer":{
            get() {
                return sharedRenderer;
            }
        },
        "orbitController":{
            get() {
                return orbitController;
            }
        }
    });

    scope.update = function() {
        sharedRenderer.update();
    };
    scope.enable = function() {
        orbitController.addEventListener(Event.UPDATE, orbitControllerUpdateEventHandler);
        orbitController.update();
    };
    scope.disable = function() {
        orbitController.removeEventListener(Event.UPDATE, orbitControllerUpdateEventHandler);
    };
    scope.getCameraPosition = function() {
        return orbitController.getPosition();
    };
    scope.updateCameraViewPosition = function(x, y, z, distance, pan, tilt) {
        orbitController.setAnchor(x, y, z);
        orbitController.setDistance(distance);
        orbitController.setPan(pan);
        orbitController.setTilt(tilt);
        orbitController.update();

        updateCameraPosition();
    };
    scope.setCameraPanBounds = function(min, max) {
        console.warn("R2D.Renderer3DPerspective.setPanBounds needs implement");
    };
    scope.updateCameraPan = function(pan) {
        orbitController.setPan(pan);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraPan = function() {
        return orbitController.getPan();
    };
    scope.setCameraTiltBounds = function(min, max) {
        orbitController.minTilt = min;
        orbitController.maxTilt = max;
    };
    scope.updateCameraTilt = function(tilt) {
        orbitController.setTilt(tilt);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraTilt = function () {
        return orbitController.getTilt();
    };
    scope.setCameraDistanceBounds = function(min, max) {
        orbitController.minDistance = min;
        orbitController.maxDistance = max;
    };
    scope.updateCameraDistance = function(distance) {
        orbitController.setDistance(distance);

        updateCameraPosition();
    };
    scope.getCameraDistance = function () {
        return orbitController.getDistance();
    };
    scope.setCameraZoomBounds = function(min, max) {
        cameraZoomMin = min;
        cameraZoomMax = max;
    };
    scope.updateCameraZoom = function(zoom) {
        
        if ( zoom < cameraZoomMin ) cameraZoomCurrent = cameraZoomMin;
        else if ( zoom > cameraZoomMax ) cameraZoomCurrent = cameraZoomMax;
        else cameraZoomCurrent = zoom;

        updateCamera();
    };
    scope.getCameraZoom = function() {
        return cameraZoomCurrent;
    };
    scope.updateCameraAnchor = function(x, y, z) {
        orbitController.setAnchor(x, y, z);
        orbitController.update();

        updateCameraPosition();
    };
    scope.getCameraAnchor = function() {
        return orbitController.getAnchor();
    };
    scope.cameraRotate = function(dx, dy) {
        orbitController.setPan(orbitController.getPan() - dx * sensitivePan);
        orbitController.setTilt(orbitController.getTilt() + dy * sensitiveTilt);
        orbitController.update();
    };
    scope.cameraSet = function(sx, sy) {

        var anchor = orbitController.getAnchor();
        var x = anchor.x - sx;
        var y = anchor.y;
        var z = anchor.z + sy;
        orbitController.setAnchor(sx, y, sy);
        orbitController.update();
    }
    scope.cameraMove = function(dx, dy) {
        var sensitive = getSensitiveMove();
        var angle = orbitController.getPan();
        var sx = ( Math.cos(angle) * dx + Math.sin(angle) * dy) * sensitive;
        var sz = (-Math.cos(angle) * dy + Math.sin(angle) * dx) * sensitive;

        var anchor = orbitController.getAnchor();
        var x = anchor.x - sx;
        var y = anchor.y;
        var z = anchor.z + sz;
        orbitController.setAnchor(x, y, z);
        orbitController.update();
    };
    scope.cameraZoom = function(delta) {
        
        // if ( delta == 0 ) return;
        // let direction = delta < 0 ? 1 : -1;
        

        // var deltaZoom = cameraSteps * direction;
        
        // var newZoom = cameraZoomCurrent + deltaZoom;

        // if ( newZoom < cameraZoomMin ) cameraZoomCurrent = cameraZoomMin;
        // else if ( newZoom > cameraZoomMax ) cameraZoomCurrent = cameraZoomMax;
        // else cameraZoomCurrent = newZoom;

        // cameraZoomCurrent = +cameraZoomCurrent.toFixed(2)

        if (delta > 0)
        {
            scalePointer -= 1;
            if (scalePointer < 0) scalePointer = 0;
            cameraZoomCurrent = scaleVaues[scalePointer];
        }
        else
        {
            scalePointer += 1;
            
            if (scalePointer >= scaleVaues.length) scalePointer = scaleVaues.length - 1;
            cameraZoomCurrent = scaleVaues[scalePointer];
        }

        updateCamera();

        scope.dispatchEvent(new Event(R2D.Renderer3DOrthographic.CAMERA_POSITION_UDPATE, scope));
    };
    scope.setSize = function (width, height) {
        sharedRenderer.setSize(width, height);
        updateCamera();
    };
    scope.setupRendererData = function() {
        sharedRenderer.updateCamera3d(camera3d);

        //sharedRenderer.filterSSAO.setOpacitySSAO(1);
        //sharedRenderer.filterSSAO.setSSAORadiusNear(7);
        //sharedRenderer.filterSSAO.setSSAORadiusFar(7);
        //sharedRenderer.filterSSAO.setSSAOMinRangeNear(0.05);
        //sharedRenderer.filterSSAO.setSSAOMinRangeFar(0.05);
        //sharedRenderer.filterSSAO.setSSAOMaxRangeNear(1);
        //sharedRenderer.filterSSAO.setSSAOMaxRangeFar(1);
        //sharedRenderer.filterSSAO.setBlurRadiusNear(5);
        //sharedRenderer.filterSSAO.setBlurRadiusFar(5);
    };
};

R2D.extend(R2D.Renderer3DOrthographic, EventDispatcher);

R2D.Renderer3DOrthographic.CAMERA_POSITION_UDPATE = "cameraPositionUpdate";
//viewers

R2D.Renderer3DMouseController = function(domElement, renderer3d) {
    var scope = this;
    var mouseController = new R2D.MouseController();

    function mouseControllerUpdateEventHandler(event) {
        switch ( event.data.type ) {
            case "rotate":
                //event.data.dx;
                //event.data.dy;
                renderer3d.cameraRotate(event.data.dx, event.data.dy);
                break;

            case "move":
                //event.data.dx;
                //event.data.dy;
                renderer3d.cameraMove(event.data.dx, event.data.dy);
                break;

            case "zoom":
                //event.data.delta
                renderer3d.cameraZoom(event.data.delta);
                break;

            default:
                throw "Error! Unknown type of action!";
        }
    }

    mouseController.updateComponents(domElement);
    mouseController.addEventListener(Event.UPDATE, mouseControllerUpdateEventHandler);
};
// viewers

R2D.CommonSceneObject = function(scene, scene3d) {
    var scope = this;
    var terrain = (() => {
        var geometry = new THREE.PlaneBufferGeometry(50000, 50000);
        var material = new THREE.MeshPhongMaterial({color:0xffffff});
        var mesh = new THREE.Mesh(geometry, material);

        geometry.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI / 2));

        mesh.position.y = -2;
        mesh.castShadow = false;
        mesh.receiveShadow = true;

        return mesh;
    })();
    var moving = (() => {
        var geometry = new THREE.PlaneBufferGeometry(5000, 5000);
        var material = new THREE.MeshPhongMaterial({color:0xff0000, transparent:true, opacity:0.0, side:THREE.DoubleSide});
        var mesh = new THREE.Mesh(geometry, material);

        geometry.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
        mesh.position.set(0, -100, 0);

        return mesh;
    })();
    var interactiveObjects = new THREE.Object3D();
    var productObjects = new THREE.Object3D();
    var constructorObjects = new THREE.Object3D();
    var constructorWalls = new THREE.Object3D();
    var view2DObjects = new THREE.Object3D();
    view2DObjects.name = "view2DObjects";
    var coversTitleObjects = new THREE.Object3D();
    coversTitleObjects.name = "coversTitleObjects";

    var objectDashedBounds = new THREE.LineSegments(new THREE.BufferGeometry(), R2D.ObjectViewer3D.__lineDashedMaterial);
    var objectContour = null;

    Object.defineProperties(scope, {
        "scene":{
            get() { return scene; }
        },
        "constructor":{
            get() { return scene.constructor; }
        },
        "scene3d":{
            get() { return scene3d; }
        },
        "terrain":{
            get() { return terrain; }
        },
        "moving":{
            get() { return moving; }
        },
        "interactiveObjects":{
            get() { return interactiveObjects; }
        },
        "productObjects":{
            get() { return productObjects; }
        },
        "constructorObjects":{
            get() { return constructorObjects; }
        },
        "constructorWalls":{
            get() { return constructorWalls; }
        },
        "view2DObjects":{
            get() { return view2DObjects; }
        },
        "coversTitleObjects":{
            get() { return coversTitleObjects; }
        },
    });

    scope.boxSelectedDisplay = function(display) {
        //if ( display && !objectDashedBounds.parent ) scene3d.add(objectDashedBounds, "top");
        //if ( !display && objectDashedBounds.parent ) scene3d.remove(objectDashedBounds, "top");
    };
    scope.boxSelectedPosition = function(x, y, z) {
        objectDashedBounds.position.set(x, y, z);
    };
    scope.boxSelectedSize = function(w, h, d) {
        if ( w != objectDashedBounds.width || h != objectDashedBounds.height || d != objectDashedBounds.depth ) {
            objectDashedBounds.geometry = R2D.ObjectViewer3D.getBoundGeometry(w, h, d);
            objectDashedBounds.width = w;
            objectDashedBounds.height = h;
            objectDashedBounds.depth = d;
        }
    };
    scope.boxSelectedRotation = function(x, y, z) {
        // if ( rx != undefined && rx != objectDashedBounds.rotation.x ) objectDashedBounds.rotation.x = rx;
        if ( y != undefined && y != objectDashedBounds.rotation.y ) objectDashedBounds.rotation.y = y;
        // if ( rz != undefined && rz != objectDashedBounds.rotation.z ) objectDashedBounds.rotation.z = rz;
    };
    scope.hideContour = function() {
        if ( !objectContour ) return;

        scene3d.remove(objectContour, "top");

        objectContour = null;
    };
    scope.showContour = function(contours) {
        scope.hideContour();

        objectContour = R2D.ObjectConstructor3D.makeContour(contours);

        scene3d.add(objectContour, "top");
    };

    interactiveObjects.add(terrain);
    interactiveObjects.add(productObjects);
    interactiveObjects.add(constructorObjects);
    interactiveObjects.add(constructorWalls);
    interactiveObjects.add(view2DObjects);
    interactiveObjects.add(coversTitleObjects);

    scene3d.add(interactiveObjects);
    // scene3d.add(moving, "top"); ???

    scope.showTerrain = function()
    {
        if (terrain.parent) return;
        interactiveObjects.add(terrain);
    };

    scope.hideTerrain = function()
    {
        if (! terrain.parent) return;
        interactiveObjects.remove(terrain);
    };

    scope.getTerrain = () => terrain;

    /////////////////////

    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.altKey)
        {
            if (e.code == 'Digit3')
            {
            //    var loader = new THREE.GLTFLoader();
            //    loader.setPath('');
            //    loader.load('scene.gltf', function (gltf) {
            //        productObjects.add(gltf.scene);
            //        gltf.scene.scale.set(1, 1, 1);
            //    } );

                if (productObjects.children.length >= 1) exportGLTF(productObjects.children[0]);

                console.log(productObjects.children);
            }
        }
    });

    function exportGLTF( input ) {

        const gltfExporter = new THREE.GLTFExporter();

        const options = {
            trs: false,
            onlyVisible: true,
            truncateDrawRange: true,
            binary: false,
            maxTextureSize: Infinity
        };
        gltfExporter.parse( input, function ( result ) {

            if ( result instanceof ArrayBuffer ) {

                //saveArrayBuffer( result, 'scene.glb' );

            } else {

                const output = JSON.stringify( result, null, 2 );
                console.log( output );
                saveString( output, 'scene.gltf' );

            }

        }, options );

        function saveString( text, filename )
        {
            save( new Blob( [ text ], { type: 'text/plain' } ), filename );
        }

        function saveArrayBuffer( buffer, filename )
        {
            save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );
        }

        function save( blob, filename )
        {
            var link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);

            link.href = URL.createObjectURL( blob );
            link.download = filename;
            link.click();
        }
    }
};
// viewers

R2D.Ruler3D = function(scene3d) {
    var scope = this;
    var ruler = new R2D.Ruler();
    var currentRulers = [];
    var currentNears = [];
    var allLines = [];
    var currentElementValues = new Map();
    var minDistance = 5;

    var width = 800;
    var height = 600;
    var currentCamera3d = null;
    var currentToolContainer = null;

    function dimensionSystemChangeEvent(event) {
        currentElementValues.forEach((value, element) => {
            element.text(R2D.DimensionSystem.toString(value.value));
        });

        scope.cameraPositionUpdate();
    }

    Object.defineProperties(scope, {
         "width":{
             get() { return width; },
             set(value) { width = value; }
         },
        "height":{
            get() { return height; },
            set(value) { height = value; }
        }
    });

    scope.cameraPositionUpdate = function() {

        var valuesArray = [];

        currentElementValues.forEach((value, element) => {
            let position = value.position.clone().project(currentCamera3d);
            let bound = element.domElement.getBoundingClientRect();

            element.style.left = Math.round(((width / 2 *  position.x) + width / 2) - bound.width / 2) + "px";
            element.style.top = Math.round(((height / 2 * -position.y) + height / 2) - bound.height - 10) + "px";

            

            valuesArray.push({
                element:element,
                position:position
            });
        });

        valuesArray.sort((a, b) => {
            if ( a.position.z < b.position.z ) return  1;
            if ( a.position.z > b.position.z ) return -1;

            return 0;
        });
        valuesArray.forEach(object => currentToolContainer.appendChild(object.element.domElement));
    };
    scope.setSize = function(w, h) {
        width = w;
        height = h;
    };
    scope.updateComponents = function(camera3d, toolContainer) {
        currentCamera3d = camera3d;
        currentToolContainer = toolContainer;
    };

    scope.update = function()
    {
        
        ruler.clear();

        var view3DObjects = R2D.commonSceneHelper.productHelper.getView3DObjects();
        var activeView3DObject = R2D.scene.currentView3DObject;
        if (R2D.mouseInteractionHelper.stateDraggingProdFromCatalog.view3DObject)
        {
            activeView3DObject = R2D.mouseInteractionHelper.stateDraggingProdFromCatalog.view3DObject;
        }

        for (var i = 0; i < view3DObjects.length; i++)
        {
            var view3DObject = view3DObjects[i];
            if (view3DObject.type != R2D.ProductType.MODEL || view3DObject.forWall || view3DObject.group ||
                view3DObject == activeView3DObject || !view3DObject.sceneObject || !activeView3DObject) continue;
            if (activeView3DObject && activeView3DObject.sceneObject && view3DObject.sceneObject)
            {
                if (activeView3DObject.sceneObject.y + activeView3DObject.sceneObject.height - 10 < view3DObject.sceneObject.y ||
                    activeView3DObject.sceneObject.y + 10 > view3DObject.sceneObject.y + view3DObject.sceneObject.height) continue;
            }

            ruler.appendBox(view3DObject.getGeomBox());
        }

        for (i = 0; i < R2D.scene.groups.length; i++)
        {
            if (R2D.scene.groups[i] == R2D.scene.currentGroup) continue;
            ruler.appendBox(R2D.scene.groups[i].getGeomBox());
        }
    };

    scope.appendFromConstructor = function(constructorLines) {
        constructorLines.forEach(o => ruler.appendLine(GEOM.Line.make(o.x1, o.y1, o.x2, o.y2)));
    };
    scope.distances = [0, 0, 0, 0];
    scope.findRules = function(view3DObject)
    {
        
        scope.clear();

        if ( !view3DObject ) return;

        /*ruler.lines.forEach(line => {
            let pa = new THREE.Vector3(line.x1, 200, line.y1);
            let pb = new THREE.Vector3(line.x2, 200, line.y2);
            let line3d = R2D.ObjectViewer3D.getDashedLine(pa, pb, R2D.ObjectViewer3D.__lineDashedMaterialWrong);

            allLines.push(line3d);
            scene3d.add(line3d, "top");
        });*/

        if (view3DObject.type != R2D.ProductType.MODEL && view3DObject.objectType != 'group') return;

        if ( view3DObject.forWall ) {
            let box = view3DObject.getGeomBox();
            let lines = box.realLines();
            let lineA = lines[0];
            let lineB = lines[2];

            let rulersA = ruler.findRulersToPerpendicular(lineA);
            let rulersB = ruler.findRulersToPerpendicular(lineB);

            if ( rulersA.pointFront && rulersA.distanceFront > minDistance ) {
                let rulerLine = GEOM.line(lineA.b, rulersA.pointFront);
                let ruler3d = R2D.Ruler3D.makeRulerForWall(rulerLine, view3DObject.sceneObject.y, 20);
                let rulerLength = rulerLine.length();
                let valueElement = R2D.Ruler3D.makeValueElement(R2D.DimensionSystem.toString(rulerLength));

                currentRulers.push(ruler3d.ruler);
                currentNears.push(ruler3d.hit);
                currentElementValues.set(valueElement, {
                    position:ruler3d.rulerB,
                    value:rulerLength
                });

                scene3d.add(ruler3d.ruler, "top");
                scene3d.add(ruler3d.hit, "top");
                currentToolContainer?.appendChild(valueElement.domElement);
            }
            if ( rulersA.pointBack && rulersA.distanceBack > minDistance ) {
                let rulerLine = GEOM.line(lineA.a, rulersA.pointBack);
                let ruler3d = R2D.Ruler3D.makeRulerForWall(rulerLine, view3DObject.sceneObject.y, 20);
                let rulerLength = rulerLine.length();
                let valueElement = R2D.Ruler3D.makeValueElement(R2D.DimensionSystem.toString(rulerLength));

                currentRulers.push(ruler3d.ruler);
                currentNears.push(ruler3d.hit);
                currentElementValues.set(valueElement, {
                    position:ruler3d.rulerB,
                    value:rulerLength
                });

                scene3d.add(ruler3d.ruler, "top");
                scene3d.add(ruler3d.hit, "top");
                currentToolContainer?.appendChild(valueElement.domElement);
            }
            if ( rulersB.pointFront && rulersB.distanceFront > minDistance ) {
                let rulerLine = GEOM.line(lineB.b, rulersB.pointFront);
                let ruler3d = R2D.Ruler3D.makeRulerForWall(rulerLine, view3DObject.sceneObject.y, 20);
                let rulerLength = rulerLine.length();
                let valueElement = R2D.Ruler3D.makeValueElement(R2D.DimensionSystem.toString(rulerLength));

                currentRulers.push(ruler3d.ruler);
                currentNears.push(ruler3d.hit);
                currentElementValues.set(valueElement, {
                    position:ruler3d.rulerB,
                    value:rulerLength
                });

                scene3d.add(ruler3d.ruler, "top");
                scene3d.add(ruler3d.hit, "top");
                currentToolContainer?.appendChild(valueElement.domElement);
            }
            if ( rulersB.pointBack && rulersB.distanceBack > minDistance ) {
                let rulerLine = GEOM.line(lineB.a, rulersB.pointBack);
                let ruler3d = R2D.Ruler3D.makeRulerForWall(rulerLine, view3DObject.sceneObject.y, 20);
                let rulerLength = rulerLine.length();
                let valueElement = R2D.Ruler3D.makeValueElement(R2D.DimensionSystem.toString(rulerLength));

                currentRulers.push(ruler3d.ruler);
                currentNears.push(ruler3d.hit);
                currentElementValues.set(valueElement, {
                    position:ruler3d.rulerB,
                    value:rulerLength
                });

                scene3d.add(ruler3d.ruler, "top");
                scene3d.add(ruler3d.hit, "top");
                currentToolContainer?.appendChild(valueElement.domElement);
            }

            scope.distances = [NaN, Math.min(rulersA.distanceFront, rulersB.distanceBack),
                               NaN, Math.min(rulersA.distanceBack, rulersB.distanceFront)];
        } else {
            let box = view3DObject.getGeomBox();
            if (! box) return;
            let rulersData = ruler.findRulersFromBox(box);
            scope.distances = [];

            for ( let i = 0, l = rulersData.rulers.length; i < l; i++ ) {
                let rulerLine = rulersData.rulers[i];
                let nearLine = rulersData.nears[i];
                let distance = rulersData.distances[i];
                scope.distances.push(distance);
                /*
                if (! rulerLine)
                {
                    scope.distances.push(NaN);
                    continue;
                }
                scope.distances.push(rulerLine.length());
                */
                if (! rulerLine || rulerLine.length() < minDistance) continue;

                let ruler3d = R2D.Ruler3D.makeRuler(rulerLine, nearLine, view3DObject.y, 20);
                let rulerLength = rulerLine.length();
                let valueElement = R2D.Ruler3D.makeValueElement(R2D.DimensionSystem.toString(rulerLength));

                currentRulers.push(ruler3d.ruler);
                currentNears.push(ruler3d.hit);
                currentElementValues.set(valueElement, {
                    position:ruler3d.rulerB,
                    value:rulerLength
                });

                scene3d.add(ruler3d.ruler, "top");
                scene3d.add(ruler3d.hit, "top");
                currentToolContainer?.appendChild(valueElement.domElement);
            }

        }

        scope.cameraPositionUpdate();
    };
    scope.clear = function() {
        currentRulers.forEach(object3d => scene3d.remove(object3d, "top"));
        currentNears.forEach(object3d => scene3d.remove(object3d, "top"));
        allLines.forEach(object3d => scene3d.remove(object3d, "top"));
        currentElementValues.forEach((value, element) => currentToolContainer && currentToolContainer.contains(element.domElement) && currentToolContainer.removeChild(element.domElement));

        currentRulers = [];
        currentNears = [];
        allLines = [];
        currentElementValues = new Map();
    };

    R2D.DimensionSystem.addEventListener(Event.CHANGE, dimensionSystemChangeEvent);
};

R2D.Ruler3D.makeRuler = function(rulerLine, hitLine, positionY, hitLineLength) {
    let pa = new THREE.Vector3(rulerLine.x1, positionY, rulerLine.y1);
    let pb = new THREE.Vector3(rulerLine.x2, positionY, rulerLine.y2);
    let ruler = R2D.ObjectViewer3D.getDashedLine(pa, pb, R2D.ObjectViewer3D.__lineDashedMaterialRuler);

    let hiLineAngle = hitLine.angle();
    let hitLinePointA = GEOM.point(-hitLineLength / 2, 0).rotate(hiLineAngle).add(rulerLine.b);
    let hitLinePointB = GEOM.point( hitLineLength / 2, 0).rotate(hiLineAngle).add(rulerLine.b);
    let hitLineVec3A = new THREE.Vector3(hitLinePointA.x, positionY, hitLinePointA.y);
    let hitLineVec3B = new THREE.Vector3(hitLinePointB.x, positionY, hitLinePointB.y);
    let hitLineShort = R2D.ObjectViewer3D.getDashedLine(hitLineVec3A, hitLineVec3B, R2D.ObjectViewer3D.__lineDashedMaterialRuler);

    return {
        ruler:ruler,
        rulerA:pa,
        rulerB:pb,
        rulerCenter:new THREE.Vector3((pa.x + pb.x) / 2, (pa.y + pb.y) / 2, (pa.z + pb.z) / 2),
        hit:hitLineShort
    };
};
R2D.Ruler3D.makeRulerForWall = function(rulerLine, positionY, hitLineLength) {
    let pa = new THREE.Vector3(rulerLine.x1, positionY, rulerLine.y1);
    let pb = new THREE.Vector3(rulerLine.x2, positionY, rulerLine.y2);
    let ruler = R2D.ObjectViewer3D.getDashedLine(pa, pb, R2D.ObjectViewer3D.__lineDashedMaterialRuler);

    let hitLineVec3A = new THREE.Vector3(rulerLine.x2, positionY - hitLineLength / 2, rulerLine.y2);
    let hitLineVec3B = new THREE.Vector3(rulerLine.x2, positionY + hitLineLength / 2, rulerLine.y2);
    let hitLineShort = R2D.ObjectViewer3D.getDashedLine(hitLineVec3A, hitLineVec3B, R2D.ObjectViewer3D.__lineDashedMaterialRuler);

    return {
        ruler:ruler,
        rulerA:pa,
        rulerB:pb,
        rulerCenter:new THREE.Vector3((pa.x + pb.x) / 2, (pa.y + pb.y) / 2, (pa.z + pb.z) / 2),
        hit:hitLineShort
    };
};
R2D.Ruler3D.makeValueElement = function(value) {
    var element = HGen.fromModel({
        "type":"element",
        "tagName":"div",
        "attributes":{
            "class":"viewer-ruler-value"
        },
        "text":value
    });

    return element;
};
// viewers

R2D.CustomRulers = function(scene3d, wallsData, api)
{
    var me = this;
    var currentCamera3d = null;
    var currentToolContainer = null;
    var currentCanvas = null;
    var currentViewer = null;

    var creating = false;
    var newVectors = [];
    var rulers = [];

    var width = 800;
    var height = 600;

    var movingElem = null;
    var movingShiftX = 0;
    var movingShiftY = 0;

    var selectedRuler = null;

    // todo: public functions
    //var quickPanel = new R2D.QuickPanel();
    //var btnDelete = R2D.QuickPanel.getButtonDelete();
    //quickPanel.add(btnDelete);
    //btnDelete.addLeftMouseClickListener(btnDeleteListener);

    var tmpPointer;
    var tmpImg;
    var tmpRuler;

    wallsData.addEventListener(WC.REMOVE_ALL, removeAllListener);

    function removeAllListener(e)
    {
        var l = rulers.length;
        for (var i = 0; i < l; i++) me.delRuler(rulers[0]);
        for (i = 0; i < rulers.length; i++) rulers[i].removed = true;
    }

    function createTmpPointer()
    {
        tmpPointer = document.createElement('div');
        tmpImg = document.createElement('img');
        tmpImg.src = WC.imgAlignerIconUp?.src;
        tmpPointer.appendChild(tmpImg);
        tmpPointer.className = 'viewer-custom-ruler-flag';

        tmpImg.style['pointer-events'] = 'none';
    }

    me.setSize = function(w, h) {
        width = w;
        height = h;
        me.viewUpdate();
    };

    me.updateComponents = function(camera3d, toolContainer, canvas, viewer)
    {
        currentCamera3d = camera3d;
        currentToolContainer = toolContainer;
        currentCanvas = canvas;
        currentViewer = viewer;

        if (viewer == R2D.view2d)
        {
            setTimeout(function() {

                me.show();
            }, 100);
        }
        else
        {
            me.hide();
        }
    };

    var active = false;

    me.hide = function()
    {
        if (! active) return;
        active = false;

        for (var i = 0; i < rulers.length; i++)
        {
            if (rulers[i].line.parent) scene3d.remove(rulers[i].line, 'top');
        }

        R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, windowUpListener);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_WHEEL, windowWheelListener);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, windowMoveListener);
        R2D.DimensionSystem.removeEventListener(Event.CHANGE, dimensionSystemChangeEvent);

        me.exportData();
    };

    me.show = function()
    {
        if (! tmpPointer) createTmpPointer();

        if (active) return;
        active = true;

        importData();

        for (var i = 0; i < rulers.length; i++)
        {
            if (! rulers[i].line.parent) scene3d.add(rulers[i].line, 'top');
        }

        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_UP, windowUpListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_WHEEL, windowWheelListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, windowMoveListener);
        R2D.DimensionSystem.addEventListener(Event.CHANGE, dimensionSystemChangeEvent);

        //me.updateOnZoom();
        me.viewUpdate();
        enableElements();
    };

    me.addRuler = function()
    {
        delTmpRuler();

        if (creating)
        {
            creating = false;
            currentCanvas.style.cursor = '';
            if (tmpPointer.parentNode) currentToolContainer.removeChild(tmpPointer);
            R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.MOUSE_MOVE, tmpPointerMove);
            enableElements();
            return;
        }

        creating = true;
        newVectors = [];
        disableElements();

        currentToolContainer.appendChild(tmpPointer);
        currentCanvas.style.cursor = 'none';
        tmpPointerMove({clientX: mouseX, clientY: mouseY});
        R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.MOUSE_MOVE, tmpPointerMove);
    };

    me.addPoint = function(x, y)
    {
        var mousePoint = R2D.Renderer3D.getMousePointForPicker(currentCanvas, x, y);
        var intersection = scene3d.objectUnderCursor(scene3d.middle, currentCamera3d, mousePoint.x, mousePoint.y);
        if (! intersection) return;
        var v = new THREE.Vector3(intersection.point.x, 0, intersection.point.z);
        newVectors.push(v);

        if (newVectors.length == 1)
        {
            currentToolContainer.removeChild(tmpPointer);
            R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.MOUSE_MOVE, tmpPointerMove);

            addTmpRuler();
        }

        if (newVectors.length < 2) return;

        currentCanvas.style.cursor = '';

        delTmpRuler();

        creating = false;

        var r = new R2D.RulerAB(newVectors[0], newVectors[1]);
        r.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
        rulers.push(r);
        scene3d.add(r.line, 'top');
        currentToolContainer.appendChild(r.elemA);
        currentToolContainer.appendChild(r.elemB);
        currentToolContainer.appendChild(r.elemVal.domElement);

        R2D.MEC.add(r.elemA, r.elemA, R2D.MEC.LEFT_MOUSE_DOWN, elemDownListener);
        R2D.MEC.add(r.elemB, r.elemB, R2D.MEC.LEFT_MOUSE_DOWN, elemDownListener);

        enableElements();
        me.viewUpdate();
    };

    function importData()
    {
        while (rulers.length > 0) me.delRuler(rulers[0]);

        rulers = [];
        var rulersData = wallsData.customRulers;

        for (var i = 0; i < rulersData.length; i++)
        {
            var va = rulersData[i][0];
            var vb = rulersData[i][1];

            var r = new R2D.RulerAB(va, vb);
            r.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
            rulers.push(r);
            scene3d.add(r.line, 'top');
            currentToolContainer.appendChild(r.elemA);
            currentToolContainer.appendChild(r.elemB);
            currentToolContainer.appendChild(r.elemVal.domElement);

            R2D.MEC.add(r.elemA, r.elemA, R2D.MEC.LEFT_MOUSE_DOWN, elemDownListener);
            R2D.MEC.add(r.elemB, r.elemB, R2D.MEC.LEFT_MOUSE_DOWN, elemDownListener);
        }

        //console.log('Imported:');
        //console.log(wallsData.customRulers);
    }

    me.exportData = function()
    {
        wallsData.customRulers = [];
        for (var i = 0; i < rulers.length; i++)
        {
            if (rulers[i].removed) continue;
            wallsData.customRulers.push([rulers[i].A, rulers[i].B]);
        }
        //console.log('Exported:');
        //console.log(wallsData.customRulers);
    };

    function addTmpRuler()
    {
        tmpRuler = new R2D.RulerAB(newVectors[0], new THREE.Vector3(newVectors[0].x, newVectors[0].y, newVectors[0].z));
        tmpRuler.elemB.style['pointer-events'] = 'none';
        tmpRuler.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
        rulers.push(tmpRuler);
        scene3d.add(tmpRuler.line, 'top');
        currentToolContainer.appendChild(tmpRuler.elemA);
        currentToolContainer.appendChild(tmpRuler.elemB);
        currentToolContainer.appendChild(tmpRuler.elemVal.domElement);

        R2D.MEC.add(currentCanvas, currentCanvas, R2D.MEC.MOUSE_MOVE, tmpRulerMove);
    }

    function delTmpRuler()
    {
        if (! tmpRuler) return;

        R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.MOUSE_MOVE, tmpRulerMove);
        scene3d.remove(tmpRuler.line, 'top');
        currentToolContainer.removeChild(tmpRuler.elemVal.domElement);
        currentToolContainer.removeChild(tmpRuler.elemA);
        currentToolContainer.removeChild(tmpRuler.elemB);
        rulers.splice(rulers.indexOf(tmpRuler), 1);
        tmpRuler = null;
    }

    function tmpPointerMove(e)
    {
        tmpPointer.style.left = parseInt(e.clientX) - 12 + "px";
        tmpPointer.style.top = parseInt(e.clientY) - 34 + "px";
    }

    function tmpRulerMove(e)
    {
        var mousePoint = R2D.Renderer3D.getMousePointForPicker(currentCanvas, e.clientX, e.clientY);
        var intersection = scene3d.objectUnderCursor(scene3d.middle, currentCamera3d, mousePoint.x, mousePoint.y);

        if (! intersection) return;

        tmpRuler.B.x = intersection.point.x;
        tmpRuler.B.z = intersection.point.z;
        scene3d.remove(tmpRuler.line, 'top');
        tmpRuler.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
        scene3d.add(tmpRuler.line, 'top');
        me.viewUpdate();
    }

    var downTime = null;

    function elemDownListener(e)
    {
        if (creating) return;

        movingElem = e.target;

        var elPos = movingElem.vector.clone().project(currentCamera3d);

        movingShiftX = e.clientX - ((width / 2 * elPos.x) + width / 2);
        movingShiftY = e.clientY - ((height / 2 * -elPos.y) + height / 2);

        R2D.MEC.remove(e.target, e.target, R2D.MEC.LEFT_MOUSE_DOWN, elemDownListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, elemDragListener);
        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_UP, elemUpListener);

        downTime = new Date();
    }

    function elemDragListener(e)
    {
        var mousePoint = R2D.Renderer3D.getMousePointForPicker(currentCanvas, e.clientX - movingShiftX, e.clientY - movingShiftY);

        var intersection = scene3d.objectUnderCursor(scene3d.middle, currentCamera3d, mousePoint.x, mousePoint.y);

        if (! intersection) return;

        movingElem.vector.x = intersection.point.x;
        movingElem.vector.z = intersection.point.z;
        scene3d.remove(movingElem.ruler.line, 'top');
        movingElem.ruler.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
        scene3d.add(movingElem.ruler.line, 'top');
        me.viewUpdate();
    }

    function elemUpListener(e)
    {
        if (new Date() - downTime < 200)
        {
            selectedRuler = movingElem.ruler;
            api.dispatchEvent(new Event(api.RULER_3D_SELECTED, {x: parseInt(movingElem.style.left) + 42, y: parseInt(movingElem.style.top) - 20, ruler: selectedRuler}));
        }

        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, elemDragListener);
        R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, elemUpListener);
        R2D.MEC.add(movingElem, movingElem, R2D.MEC.LEFT_MOUSE_DOWN, elemDownListener);
        movingElem = null;
    }

    // var autoUpdate = null;

    me.viewUpdate = function()
    {
        if (! active) return;

        var elemHeight = 34;

        for (var i = 0; i < rulers.length; i++)
        {
            var r = rulers[i];

            r.elemVal.innerText = R2D.DimensionSystem.toString(r.length);

            var elPos = r.center.clone().project(currentCamera3d);
            var bound = r.elemVal.domElement.getBoundingClientRect();
            r.elemVal.domElement.style.left = Math.round(((width / 2 *  elPos.x) + width / 2) - bound.width / 2) + "px";
            r.elemVal.domElement.style.top = Math.round(((height / 2 * -elPos.y) + height / 2) - bound.height / 2) + "px";

            elPos = r.A.clone().project(currentCamera3d);
            bound = r.elemA.getBoundingClientRect();
            r.elemA.style.left = Math.round(((width / 2 *  elPos.x) + width / 2) - bound.width / 2) + "px";
            r.elemA.style.top = Math.round(((height / 2 * -elPos.y) + height / 2) - elemHeight) + "px";

            elPos = r.B.clone().project(currentCamera3d);
            bound = r.elemB.getBoundingClientRect();
            r.elemB.style.left = Math.round(((width / 2 *  elPos.x) + width / 2) - bound.width / 2) + "px";
            r.elemB.style.top = Math.round(((height / 2 * -elPos.y) + height / 2) - elemHeight) + "px";
        }

        if (currentViewer) currentViewer.rendererUpdate();

        // if (autoUpdate)
        // {
        //     clearTimeout(autoUpdate);
        //     autoUpdate = null;
        // }
        // autoUpdate = setTimeout(me.viewUpdate, 10);
    };

    me.updateOnZoom = function()
    {
        for (var i = 0; i < rulers.length; i++)
        {
            var r = rulers[i];
            scene3d.remove(r.line, 'top');
            r.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
            scene3d.add(r.line, 'top');
        }
    };

    me.isCreating = function()
    {
        return creating;
    };

    function dimensionSystemChangeEvent()
    {
        me.viewUpdate();
    }
    /*
    function showDelButton(x, y)
    {
        quickPanel.setPosition(x, y);
        if (! quickPanel.getDomElement().parentNode)
        {
            currentToolContainer.appendChild(quickPanel.getDomElement());
        }
    }

    function hideDelButton()
    {
        if (quickPanel.getDomElement().parentNode)
        {
            currentToolContainer.removeChild(quickPanel.getDomElement());
        }
    }
    */
    function disableElements()
    {
        for (var i = 0; i < rulers.length; i++)
        {
            var r = rulers[i];
            r.elemA.style['pointer-events'] = 'none';
            r.elemB.style['pointer-events'] = 'none';
        }
    }

    function enableElements()
    {
        for (var i = 0; i < rulers.length; i++)
        {
            var r = rulers[i];
            r.elemA.style['pointer-events'] = 'auto';
            r.elemB.style['pointer-events'] = 'auto';
        }
    }
    /*
    function btnDeleteListener()
    {
        hideDelButton();
        if (! selectedRuler) return;
        delRuler(selectedRuler);
        currentViewer.rendererUpdate();
    }
    */
    me.delRuler = ruler =>
    {
        if (ruler.line.parent) scene3d.remove(ruler.line, 'top');

        try {
            currentToolContainer.removeChild(ruler.elemVal.domElement);
            currentToolContainer.removeChild(ruler.elemA);
            currentToolContainer.removeChild(ruler.elemB);

            rulers.splice(rulers.indexOf(ruler), 1);
            selectedRuler = null;

            R2D.mouseInteractionHelper._currentViewer.rendererUpdate();
        }
        catch (e){}
    }

    function windowWheelListener()
    {
        //hideDelButton();
        me.updateOnZoom();
    }

    function windowUpListener(e)
    {
       // if (e.target.className != 'quick-panel-element-overlayer') hideDelButton()
    }

    var mouseX = 0;
    var mouseY = 0;
    function windowMoveListener(e)
    {
        mouseX = e.clientX;
        mouseY = e.clientY;
    }

    me.cancel = function()
    {
        console.log('Deprecated function');
    };

    me._cancel = function()
    {
        if (tmpPointer.parentNode) currentToolContainer.removeChild(tmpPointer);
        R2D.MEC.remove(currentCanvas, currentCanvas, R2D.MEC.MOUSE_MOVE, tmpPointerMove);

        currentCanvas.style.cursor = '';
        delTmpRuler();
        creating = false;
        enableElements();
        me.viewUpdate();
    };

    me.getSelectedRuler = () => selectedRuler;
    me.clearSelectedRuler = () => selectedRuler = null;

    document.addEventListener('keydown', function(e){

        switch (e.keyCode) {
            case 90: // z
                if (e.altKey) me.exportData();
                break;
        }
    });

};

R2D.CustomRulers._instance = null;
R2D.CustomRulers.init = (scene3d, wallsData, api) => {
    
    R2D.CustomRulers._instance = new R2D.CustomRulers(scene3d, wallsData, api);
    return R2D.CustomRulers._instance;
}

R2D.CustomRulers.delRuler = ruler => R2D.CustomRulers._instance.delRuler(ruler);

R2D.CustomRulers.getSelectedRuler = () => R2D.CustomRulers._instance.getSelectedRuler();


R2D.RulerAB = function(vA, vB)
{
    var me = this;
    me.A = vA;
    me.B = vB;

    me.update = function(canvas, scene, camera, size)
    {
        me.center = new THREE.Vector3((vA.x + vB.x) / 2, (vA.y + vB.y) / 2, (vA.z + vB.z) / 2);
        me.length =  vA.distanceTo(vB);
        me.line = new THREE.Object3D();

        var lineMeshes = R2D.RulerAB.getLine3D(vA, vB, canvas, scene, camera, size);

        for (var i = 0; i < lineMeshes.length; i++) me.line.add(lineMeshes[i]);
    };

    me.elemA = document.createElement('div');
    var imgA = document.createElement('img');
    imgA.src = WC.imgAlignerIconUp.src;
    me.elemA.appendChild(imgA);

    me.elemB = document.createElement('div');
    var imgB = document.createElement('img');
    imgB.src = WC.imgAlignerIconUp.src;
    me.elemB.appendChild(imgB);

    me.elemVal = R2D.Ruler3D.makeValueElement(R2D.DimensionSystem.toString(me.length));

    me.elemA.className = 'viewer-custom-ruler-flag';
    me.elemB.className = 'viewer-custom-ruler-flag';

    imgA.style['pointer-events'] = 'none';
    imgB.style['pointer-events'] = 'none';

    me.elemA.vector = me.A;
    me.elemB.vector = me.B;
    me.elemA.ruler = me;
    me.elemB.ruler = me;

    R2D.MEC.add(me.elemA, me.elemA, R2D.MEC.MOUSE_OVER, elemOverListener);
    R2D.MEC.add(me.elemA, me.elemA, R2D.MEC.MOUSE_OUT, elemOutListener);
    R2D.MEC.add(me.elemB, me.elemB, R2D.MEC.MOUSE_OVER, elemOverListener);
    R2D.MEC.add(me.elemB, me.elemB, R2D.MEC.MOUSE_OUT, elemOutListener);

    function elemOverListener(e)
    {
        e.target.children[0].src = WC.imgAlignerIconOver.src;
    }

    function elemOutListener(e)
    {
        e.target.children[0].src = WC.imgAlignerIconUp.src;
    }
};

R2D.RulerAB.pointToVect = function(p, canvas, scene, camera)
{
    var mousePoint = R2D.Renderer3D.getMousePointForPicker(canvas, p.x, p.y);
    var intersection = scene.objectUnderCursor(scene.middle, camera, mousePoint.x, mousePoint.y);
    //console.log(p.x, p.y, ' -> ', intersection.point.x, intersection.point.z);
    //console.log(new THREE.Vector3(p.x, p.y, -1 ).unproject(camera));
    if(intersection) return new THREE.Vector3(intersection.point.x, 0, intersection.point.z);
};

R2D.RulerAB.getLine3D = function(A, B, canvas, scene, camera, size)
{
    var meshes = [];

    meshes.push(R2D.ObjectViewer3D.getDashedLine(A, B, R2D.ObjectViewer3D.__lineDashedMaterialRed));

    var prA = A.clone().project(camera);
    var prB = B.clone().project(camera);

    var scrA = {x: ((size.w / 2 * prA.x) + size.w / 2), y: ((size.h / 2 * -prA.y) + size.h / 2)};
    var scrB = {x: ((size.w / 2 * prB.x) + size.w / 2), y: ((size.h / 2 * -prB.y) + size.h / 2)};

    var scrA1 = TR.perpendicularPoint(scrA, scrB, 1);
    var scrB1 = TR.perpendicularPoint(scrB, scrA, -1);
    var scrA2 = TR.perpendicularPoint(scrA, scrB, -1);
    var scrB2 = TR.perpendicularPoint(scrB, scrA, 1);

    var vA1 = R2D.RulerAB.pointToVect(scrA1, canvas, scene, camera);
    var vB1 = R2D.RulerAB.pointToVect(scrB1, canvas, scene, camera);
    var vA2 = R2D.RulerAB.pointToVect(scrA2, canvas, scene, camera);
    var vB2 = R2D.RulerAB.pointToVect(scrB2, canvas, scene, camera);

    meshes.push(R2D.ObjectViewer3D.getDashedLine(vA1, vB1, R2D.ObjectViewer3D.__lineDashedMaterialWhite));
    meshes.push(R2D.ObjectViewer3D.getDashedLine(vA2, vB2, R2D.ObjectViewer3D.__lineDashedMaterialWhite));

    return meshes;
};

// viewers

R2D.TitlesTool = function(scene3d, wallsData, api)
{
    let me = this;
    let currentCamera3d = null;
    let currentToolContainer = null;
    let currentCanvas = null;
    let currentViewer = null;

    let width = 800;
    let height = 600;

    let movingElem = null;
    let movingShiftX = 0;
    let movingShiftY = 0;

    let elements = [];

    wallsData.addEventListener(WC.REMOVE_ALL, removeAllListener);

    function removeAllListener(e)
    {
        me.hide();
    }

    me.setSize = function(w, h) {
        width = w;
        height = h;
        me.viewUpdate();
    };

    me.updateComponents = function(camera3d = currentCamera3d, toolContainer = currentToolContainer, canvas = currentCanvas, viewer = currentViewer, updateConstructor = true)
    {
        me.hide();

        currentCamera3d = camera3d;
        currentToolContainer = toolContainer;
        currentCanvas = canvas;
        currentViewer = viewer;

        if (viewer == R2D.view2d || viewer == R2D.viewConstructor) setTimeout(() => me.show(updateConstructor), 0);
    };

    me.rightPanelToggle = status => {
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;
        me.setSize(status ? width - 270 : width + 270, height);
    }

    let active = true;

    me.hide = () => {
        if (!active) return;

        active = false;

        R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, windowUpListener);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_WHEEL, windowWheelListener);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, windowMoveListener);
        R2D.DimensionSystem.removeEventListener(Event.CHANGE, dimensionSystemChangeEvent);

        removeTitles();
    };

    me.show = function(updateConstructor = true) {
        if(currentViewer == R2D.viewConstructor) {
            WC.wallsEditor.setStructureToWallsData();
            updateConstructor && WC.wallsEditor.setStructure(R2D.scene.constructor);
            R2D.scene.constructor.dispatchModelsReset();
            WC.wallsEditor.state.name === "stateEditing" && WC.wallsEditor.state.afterRebuild();
            WC.wallsEditor.state.draw();
        }

        if (active) return;

        active = true;

        createTitles();

        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_UP, windowUpListener);
        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_DOWN, windowDownListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_WHEEL, windowWheelListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, windowMoveListener);
        R2D.DimensionSystem.addEventListener(Event.CHANGE, dimensionSystemChangeEvent);

        //me.updateOnZoom();
        me.viewUpdate();
    };

    function createTitles()
    {
        if(!currentToolContainer) return;
        for (let cover of wallsData.covers)
        {
            if (!cover.title) continue;
            let elem = new R2D.TitleElement(cover, currentViewer);

            elements.push(elem);
            currentToolContainer.appendChild(elem.getDomElement());
            elem.getDomElement().addEventListener('mousedown', elemDownListener);
            elem.getDomElement().addEventListener('mouseup', elemUpListener);

            let inputName = elem.getInputElement();
            let spanText = elem.getSpanElement();

            elem.updateValue(spanText.offsetWidth);

            inputName.addEventListener("focus", e => document.addEventListener("keydown", onKeyDown))

            let onKeyDown = e => e.code == "Enter" ? e.target.blur() : null;

            inputName.addEventListener("blur", e => {
                if(!R2D.mouseInteractionHelper.getObjectSelection()) return;
                cover.title.text = e.target.value;
                inputName.style.pointerEvents = "none";
                document.removeEventListener("keydown", onKeyDown)
                api.dispatchEvent(new Event(api.CHANGED_TITLE_TEXT, cover.title?.text))
            });
            inputName.addEventListener("input", e => {
                spanText.innerHTML = e.target.value;
                inputName.style.width = spanText.offsetWidth + "px";
            });

            elem.updatePosition(currentCamera3d, width, height);

            
        }
    }

    function removeTitles()
    {
        if(!currentToolContainer) return;
        for (let elem of elements)
        {
            elem.getDomElement().removeEventListener('mousedown', elemDownListener);
            elem.getDomElement().removeEventListener('mouseup', elemUpListener);
            if(currentToolContainer.contains(elem.getDomElement())) currentToolContainer.removeChild(elem.getDomElement());
        }
        elements = [];
    }

    me.updateValues = function(id)
    {
        elements[id - 1]?.updatePosition(currentCamera3d, width, height);
        elements[id - 1]?.updateValue();
    };

    let autoUpdate = null;

    me.viewUpdate = function()
    {
        if (! active) return;

        for (let elem of elements) elem.updatePosition(currentCamera3d, width, height);
    };

    me.updateOnZoom = function()
    {
        /*
        for (let i = 0; i < rulers.length; i++)
        {
            let r = rulers[i];
            scene3d.remove(r.line, 'top');
            r.update(currentCanvas, scene3d, currentCamera3d, {w: width, h: height});
            scene3d.add(r.line, 'top');
        }
        */
    };

    me.isCreating = function()
    {
        return creating;
    };

    function dimensionSystemChangeEvent()
    {
        me.viewUpdate();
    }

    function windowWheelListener()
    {
        me.updateOnZoom();
    }

    let downTime = null;
    let upTime = null;

    function elemDownListener(e)
    {
        if(!R2D.mouseInteractionHelper.getObjectSelection()) return;
        downTime = Date.now();
        for (let elem of elements)
        {
            if (elem.getDomElement() == e.currentTarget)
            {
                movingElem = elem;
                movingShiftX = e.clientX - elem.scrX;
                movingShiftY = e.clientY - elem.scrY;
                movingElem.getDomElement().style.cursor = 'grabbing';
                break;
            }
        }
    }

    function elemUpListener(e)
    {
        if(!R2D.mouseInteractionHelper.getObjectSelection()) return;
        upTime = Date.now();
        if(upTime - downTime < 200) {
            for (let elem of elements)
            {
                if (elem.getDomElement() == e.target)
                {
                    //elem.select();
                    break;
                }
            }
        }
        
    }

    let downX = 0;
    let downY = 0;
    let downT = 0;
    function windowDownListener(e)
    {
        downX = e.clientX;
        downY = e.clientY;
        downT = new Date();
    }

    function windowUpListener(e)
    {
        if (! movingElem) return;

        movingElem.scrX = e.clientX - movingShiftX;
        movingElem.scrY = e.clientY - movingShiftY;
        movingElem.repositionByScreen(currentCamera3d, width, height);
        movingElem.getDomElement().style.cursor = 'grab';

        if (TR.manhDist(downX, downY, e.clientX, e.clientY) < 5 && new Date() - downT < 200)
        {
            if(R2D.mouseInteractionHelper.getObjectSelection()) movingElem.select();
            
        }

        movingElem = null;
    }

    function windowMoveListener(e)
    {
        if (! movingElem) return;

        movingElem.scrX = e.clientX - movingShiftX;
        movingElem.scrY = e.clientY - movingShiftY;
        movingElem.moveDiv();
    }

};

R2D.TitleElement = function(constrObj, currentViewer)
{
    let me = this;

    me.id = constrObj.id;

    let titleObj = constrObj.title;
    let div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.fontFamily = '"Roboto", sans-serif';
    div.style.color = '#202122';
    div.style.textAlign = 'center';
    div.style.userSelect = 'none';
    div.style.cursor = 'grab';
    div.style.whiteSpace = 'nowrap';
    div.style.display = titleObj.visible[R2D.Viewers.getCurrentViewerName()] || titleObj.areaVisible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';

    let inputName = document.createElement('input');
    inputName.type = "text";
    inputName.classList.add("titleTool_input");    

    let spanText = document.createElement('span');
    spanText.style.visibility = "hidden";
    spanText.style.position = "absolute";

    if(!titleObj.visible[R2D.Viewers.getCurrentViewerName()]) inputName.style.display = spanText.style.display = 'none';

    let areaText = document.createElement('span');
    areaText.style.position = "absolute";
    areaText.style.top = "100%";
    areaText.style.left = "50%";
    areaText.style.transform = "translateX(-50%)";

    if(!titleObj.areaVisible[R2D.Viewers.getCurrentViewerName()]) areaText.style.display = 'none';

    spanText.style.fontSize = inputName.style.fontSize = '13px';
    areaText.style.fontSize = '11px';

    inputName.value = spanText.innerHTML = titleObj.text;

    areaText.innerHTML = R2D.DimensionSystem.squareToString(constrObj.area);

    inputName.style.textShadow = areaText.style.textShadow = '-1px 0px 0px rgba(255, 255, 255, .8), 1px 0px 0px rgba(255, 255, 255, .8), 0px -1px 0px rgba(255, 255, 255, .8), 0px 1px 0px rgba(255, 255, 255, .8)';

    div.append(inputName);
    div.append(spanText);
    div.append(areaText);

    inputName.style.background = "transparent";
    inputName.style.border = "none";
    inputName.style.pointerEvents = "none";

    let pr = new THREE.Vector3();
    me.scrX = 0;
    me.scrY = 0;

    me.getInputElement = () => inputName;

    me.getSpanElement = () => spanText;

    me.getDomElement = function()
    {
        return div;
    };

    me.select = function() {   
        inputName.style.pointerEvents = "auto";
        inputName.focus();
    };

    me.updatePosition = function(camera, width, height) {
        if(currentViewer == R2D.view2d) {
            //let v = new THREE.Vector3(constrObj.rotatingCenter.x, 0, constrObj.rotatingCenter.y);
            let v = new THREE.Vector3(titleObj.x, 0, titleObj.y);
            pr = v.project(camera);
            
            me.scrX = width / 2 * pr.x + width / 2;
            me.scrY = height / 2 * -pr.y + height / 2;

            div.style.display = titleObj.visible[R2D.Viewers.getCurrentViewerName()] || titleObj.areaVisible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';
            inputName.style.display = spanText.style.display = titleObj.visible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';
            areaText.style.display = titleObj.areaVisible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';

            let bound = div.getBoundingClientRect();
            div.style.left = Math.round(me.scrX - bound.width / 2) + "px";
            div.style.top = Math.round(me.scrY - bound.height / 2) + "px";
        }
        else {
            let {x, y} = WC.wallsEditor.realToView({x: titleObj.x, y: titleObj.y});
        
            me.scrX = x;
            me.scrY = y;

            div.style.display = titleObj.visible[R2D.Viewers.getCurrentViewerName()] || titleObj.areaVisible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';
            inputName.style.display = spanText.style.display = titleObj.visible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';
            areaText.style.display = titleObj.areaVisible[R2D.Viewers.getCurrentViewerName()] ? 'block' : 'none';

            let bound = div.getBoundingClientRect();
            div.style.left = Math.round(me.scrX - bound.width / 2) + "px";
            div.style.top = Math.round(me.scrY - bound.height / 2) + "px";
        }
        
    };

    me.repositionByScreen = function(camera, width, height) {
        if(currentViewer == R2D.view2d) {
            pr.x = (me.scrX - width / 2) / (width / 2);
            pr.y = -(me.scrY - height / 2) / (height / 2);
            let v = pr.clone().unproject(camera);

            titleObj.x = v.x;
            titleObj.y = v.z;

            me.updatePosition(camera, width, height);
        } else {
            let {x, y} = WC.wallsEditor.viewToReal({x: me.scrX, y: me.scrY});

            titleObj.x = x;
            titleObj.y = y;

            me.updatePosition();
        }
    };

    me.moveDiv = function()
    {
        let bound = div.getBoundingClientRect();

        div.style.left = Math.round(me.scrX - bound.width / 2) + "px";
        div.style.top = Math.round(me.scrY - bound.height / 2) + "px";
    };

    me.updateValue = function(newWidth)
    {
        spanText.innerHTML = inputName.value = titleObj.text;
        newWidth = spanText.offsetWidth != 0 ? spanText.offsetWidth : newWidth;
        inputName.style.width = newWidth + "px";
    }
};

// viewers

R2D.ProductSceneHelper = function(commonSceneObject) {
    EventDispatcher.call(this);

    var scope = this;
    var scene = commonSceneObject.scene;
    var constructor = scene.constructor;
    var scene3d = commonSceneObject.scene3d;
    var sceneObjectMap = new Map();
    var view3DObjects = [];
    var alias = new Map();

    function findObjectView3DBySceneObject(sceneObject) {
        var i, l;

        for ( i = 0, l = view3DObjects.length; i < l; i++ ) {
            if ( view3DObjects[i].getSceneObject() == sceneObject ) {
                return view3DObjects[i];
            }
        }

        return null;
    }
    function objectView3DUpdateEvent(event) {
        scope.dispatchUpdate();
    }
    function sceneObjectAdded(event) {
        var sceneObject = event.data;
        var objectView3D = R2D.ObjectViewer3D.make(sceneObject);
        if(!objectView3D) return;
        var object3D = objectView3D.getObject3d();

        sceneObjectMap.set(sceneObject, objectView3D);
        view3DObjects.push(objectView3D);
        commonSceneObject.productObjects.add(object3D);
        objectView3D.addEventListener(Event.UPDATE, objectView3DUpdateEvent);
        scope.dispatchUpdate();
    }
    function sceneObjectRemoved(event) {
        var sceneObject = event.data;
        var objectView3D = findObjectView3DBySceneObject(sceneObject);
        var object3D;
        var index;

        if ( objectView3D == null ) {
            throw "Error removing object from scene! ObjectView3D is not found!";
        }

        index = view3DObjects.indexOf(objectView3D);
        object3D = objectView3D.getObject3d();

        sceneObjectMap.delete(sceneObject);
        view3DObjects.splice(index, 1);
        commonSceneObject.productObjects.remove(object3D);
        objectView3D.removeEventListener(Event.UPDATE, objectView3DUpdateEvent);
        scope.dispatchUpdate();
    }

    function visibleProducts(event) {
        var i, l;
        var objectView3d;

        for ( i = 0, l = event.data['visible'].length; i < l; i++ ) {
            objectView3d = scope.findObjectView3dByObjectID(event.data['visible'][i]);

            if(objectView3d) objectView3d.object3d.visible = true;
            
        }
        for ( i = 0, l = event.data['invisible'].length; i < l; i++ ) {
            objectView3d = scope.findObjectView3dByObjectID(event.data['invisible'][i]);

            if(objectView3d) objectView3d.object3d.visible = false;
        }

        scope.dispatchUpdate(scope);
    }

    Object.defineProperties(scope, {
        "view3DObjects":{
            get() { return view3DObjects; }
        }
    });

    scope.getView3DObjects = function() {
        return view3DObjects;
    };
    scope.findObjectView3dByObjectID = function(objectId) {
        for ( var i = 0, l = view3DObjects.length; i < l; i++ ) {
            if ( view3DObjects[i].sceneObject.objectId == objectId ) {
                return view3DObjects[i];
            }
        }

        return null;
    };
    scope.findObjectView3dBySceneObject = function(sceneObject) {
        return sceneObjectMap.get(sceneObject);
    };
    scope.findObjectView3DByObject3D = function(object3d) {
        for ( var index = 0, length = view3DObjects.length; index < length; index++ ) {
            var objView3d = view3DObjects[index];
            var obj3d =  objView3d.getObject3d();
            var found = false;
            obj3d.traverse(function(child){
                if (child == object3d) found = true;
            });
            if (found) return objView3d;

            /*
            var children = obj3d.children;

            for ( var i = 0, l = children.length; i < l; i++ ) {
                if ( children[i] == object3d ) {
                    return objView3d;
                }
            }
            */
        }
        if ( alias.has(object3d) ) {
            if ( sceneObjectMap.has(alias.get(object3d)) ) {
                return sceneObjectMap.get(alias.get(object3d));
            } else {
                console.error("Object3D has alias but hasn't View3DObject!");
            }
        }

        return null;
    };
    scope.addAlias = function(object3d, sceneObject) {
        alias.set(object3d, sceneObject);
    };
    scope.removeAlias = function(object3d) {
        alias.delete(object3d);
    };

    scene.addEventListener(R2D.Scene.OBJECT_ADDED, sceneObjectAdded);
    scene.addEventListener(R2D.Scene.OBJECT_REMOVED, sceneObjectRemoved);

    constructor.addEventListener(WC.MODELS_VISIBLE, visibleProducts);

    scope.addGroup = function(merged = true)
    {
        var gr = new R2D.ObjectViewer3DGroup();
        gr.merged = merged;
        scene.groups.push(gr);
        commonSceneObject.productObjects.add(gr.getContainer());
        return gr;
    };

    scope.removeGroup = function(group)
    {
        var objs = group.getObjViews();
        for (i = 0; i < objs.length; i++)
        {
            scope.removeObjFromGroup(objs[i], group);
        }

        commonSceneObject.productObjects.remove(group.getContainer());
        var i = scene.groups.indexOf(group);
        scene.groups.splice(i, 1);
        if (scene.currentGroup == group) scene.currentGroup = null;
    };

    scope.addObjToGroup = function(obj, group)
    {
        if (! group) group = scene.currentGroup;
        if (! group) return;
        group.add(obj);
    };

    scope.removeObjFromGroup = function(obj, group)
    {
        if (! group) group = scene.currentGroup;
        if (! group) return;
        group.remove(obj);
        commonSceneObject.productObjects.add(obj.object3d);
    };

    scope.removeGroupsWithOne = function()
    {
        var i = 0;
        var L = scene.groups.length;
        for (i = 0; i < L; i++)
        {
            if (scene.groups[i].getObjViews().length <= 1)
            {
                scope.removeGroup(scene.groups[i]);
                i--;
                L--;
            }
        }
    };
};

extend(R2D.ProductSceneHelper, EventDispatcher);
// viewers

R2D.ConstructorSceneHelper = function(commonSceneObject) {
    EventDispatcher.call(this);

    var scope = this;
    var scene = commonSceneObject.scene;
    var constructor = scene.constructor;
    var scene3d = commonSceneObject.scene3d;
    var view3DObjects = [];

    scope.findObjectView3DByConstructionData = function(constructorData)
    {
        return findConstructorObject(constructorData);
    };

    function findConstructorObject(constructorData) {
        for ( var i = 0, l = view3DObjects.length; i < l; i++ ) {
            if ( view3DObjects[i].getConstructorElementData() == constructorData ) {
                return view3DObjects[i];
            }
        }

        return null;
    }
    function constructorElementUpdate(event)
    {
        var objectConstructor3d = event.currentTarget;
        var constructorElementData;
        var modelsIds;
        var sceneObjects;
        var materialShift;
        var i, l;

        var meshes = objectConstructor3d.getMeshes();
        for (i = 0; i < meshes.length; i++)
        {
            if (objectConstructor3d.getType() == R2D.ObjectConstructor3DType.WALL)
            {
                if (! meshes[i].parent) commonSceneObject.constructorWalls.add(meshes[i])
            }
            else
            {
                if (! meshes[i].parent) commonSceneObject.constructorObjects.add(meshes[i])
            }
        }

        switch ( objectConstructor3d.getType() ) {
            case R2D.ObjectConstructor3DType.FRAME_TOP:
                constructorElementData = objectConstructor3d.getConstructorElementData();
                modelsIds = constructorElementData.modelIDs;
                materialShift = constructorElementData.getMaterialShift();
                sceneObjects = scene.getSceneObjectsByIds(modelsIds);

                for ( i = 0, l = sceneObjects.length; i < l; i++ ) {
                    sceneObjects[i].setMaterialFrameData(
                        constructorElementData.getMaterial(),
                        constructorElementData.getAddMaterial(),
                        constructorElementData.getMaterialRotation(),
                        materialShift[0],
                        materialShift[1]
                    );
                }
                break;

            case R2D.ObjectConstructor3DType.FRAME_BOTTOM:
                constructorElementData = objectConstructor3d.getConstructorElementData();
                modelsIds = constructorElementData.modelIDs;
                materialShift = constructorElementData.getMaterialShift();
                sceneObjects = scene.getSceneObjectsByIds(modelsIds);

                for ( i = 0, l = sceneObjects.length; i < l; i++ ) {
                    sceneObjects[i].setMaterialBottomData(
                        constructorElementData.getMaterial(),
                        constructorElementData.getAddMaterial(),
                        constructorElementData.getMaterialRotation(),
                        materialShift[0],
                        materialShift[1]
                    );
                }
                break;
            case R2D.ObjectConstructor3DType.WALL:
                constructorElementData = objectConstructor3d.getConstructorElementData();
                meshes = objectConstructor3d.getMeshes();
                for (i = 0; i < meshes.length; i++)
                {
                    meshes[i].visible = constructorElementData.exists && constructorElementData.visible;

                    if (objectConstructor3d.getType() == R2D.ObjectConstructor3DType.WALL)
                    {
                        if (! meshes[i].parent) commonSceneObject.constructorWalls.add(meshes[i]);
                    }
                    else
                    {
                        if (! meshes[i].parent) commonSceneObject.constructorObjects.add(meshes[i]);
                    }
                }
                if (scene.currentPartNum >= constructorElementData.parts.length) scene.currentPartNum = -1;
        }

        scope.dispatchUpdate(scope);
    }
    function addConstructorElement(event) {
        var constructorData = event.data;
        var constructorObject = findConstructorObject(constructorData);

        if ( constructorObject != null ) {
            throw "Creating constructor element error! This one is exist!"
        }

        constructorObject = R2D.ObjectConstructor3D.make(constructorData);
        var meshes = constructorObject.getMeshes();
        for (var i = 0; i < meshes.length; i++)
        {
            meshes[i].visible = constructorData.exists && constructorData.visible;
            if (constructorObject.getType() == R2D.ObjectConstructor3DType.WALL)
            {
                if (! meshes[i].parent) commonSceneObject.constructorWalls.add(meshes[i])
            }
            else
            {
                if (! meshes[i].parent) commonSceneObject.constructorObjects.add(meshes[i]);
            }
        }

        view3DObjects.push(constructorObject);

        constructorObject.addEventListener(Event.UPDATE, constructorElementUpdate);
        scope.dispatchUpdate();
    }
    function removeConstructorElement(event) {
        var constructorData = event.data;
        var constructorObject = findConstructorObject(constructorData);
        var index = -1;

        if ( constructorObject == null ) {
            throw "Error removing constructor element!"
        }

        index = view3DObjects.indexOf(constructorObject);
        var meshes = constructorObject.getMeshes();
        for (var i = 0; i < meshes.length; i++)
        {
            if (constructorObject.getType() == R2D.ObjectConstructor3DType.WALL)
            {
                commonSceneObject.constructorWalls.remove(meshes[i]);
            }
            else
            {
                commonSceneObject.constructorObjects.remove(meshes[i]);
            }
        }

        view3DObjects.splice(index, 1);
        constructorObject.removeEventListener(Event.UPDATE, constructorElementUpdate);
        scope.dispatchUpdate();
    }
    function visibleConstructionElement(event) {
        var constructorData = event.data;
        var constructorObject = findConstructorObject(constructorData);

        if ( constructorObject == null ) {
            throw "Unknown construction data!";
        }

        var meshes = constructorObject.getMeshes();
        for (var i = 0; i < meshes.length; i++)
        {
            if (typeof constructorData.exists !== 'undefined')
            {
                meshes[i].visible = constructorData.visible && constructorData.exists;
            }
            else
            {
                meshes[i].visible = constructorData.visible
            }
        }
    }

    Object.defineProperties(scope, {
        "constructor":{
            get() { return constructor; }
        }
    });

    scope.findObjectView3DByObject3D = function(object3d) {
        var foundObject = null;

        for (var index = 0, length = view3DObjects.length; index < length; index++ ) {
            var meshes = view3DObjects[index].getMeshes();
            for (var j = 0; j < meshes.length; j++)
            {
                if (meshes[j] == object3d)
                {
                    foundObject = view3DObjects[index];
                    break;
                }
            }

            if ( foundObject ) {
                break;
            }
        }

        if ( !foundObject ) {
            return null;
        }

        switch ( foundObject.type ) {
            case R2D.ObjectConstructor3DType.WALL:
            case R2D.ObjectConstructor3DType.COVER:
            case R2D.ObjectConstructor3DType.CAP:
            case R2D.ObjectConstructor3DType.AREA:
            case R2D.ObjectConstructor3DType.CEILING:
            case R2D.ObjectConstructor3DType.FRAME_TOP:
            case R2D.ObjectConstructor3DType.FRAME_BOTTOM:
            case R2D.ObjectConstructor3DType.CUT:
            case R2D.ObjectConstructor3DType.PLINTH_TOP:
            case R2D.ObjectConstructor3DType.PLINTH_BOTTOM:
                return foundObject;
        }

        return null;
    };

    constructor.addEventListener(WC.ELEMENT_CREATE, addConstructorElement);
    constructor.addEventListener(WC.ELEMENT_DELETE, removeConstructorElement);
    constructor.addEventListener(WC.ELEMENT_VISIBLE, visibleConstructionElement);
};

extend(R2D.ConstructorSceneHelper, EventDispatcher);
// viewers

R2D.DrawingHelper = function(constructor, scene3d) {
    EventDispatcher.call(this);

    let scope = this;
    let enabled = false;
    let currentDrawing = null;
    let currentDrawingObject3D = null;
    let currentState = null;
    
    /*
    let buttonDrawingAbove = R2D.TopLeftPanel.Button.makeButtonIconText(R2D.STYLE.TLP_ICON_DRAWING_ABOVE, R2D.TRANSLATION.FLOORPLAN_ABOVE, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    let buttonDrawingBelow = R2D.TopLeftPanel.Button.makeButtonIconText(R2D.STYLE.TLP_ICON_DRAWING_BELOW, R2D.TRANSLATION.FLOORPLAN_BELOW, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    let buttonDrawingOff = R2D.TopLeftPanel.Button.makeButtonIconText(R2D.STYLE.TLP_ICON_DRAWING_OFF, R2D.TRANSLATION.FLOORPLAN_OFF, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    let elementDrawing = new R2D.TopLeftPanel.Element(10, true, [buttonDrawingAbove, buttonDrawingBelow, buttonDrawingOff]);

    function translationUpdateEvent(event) {
        buttonDrawingAbove.getFace().setText(R2D.TRANSLATION.FLOORPLAN_ABOVE);
        buttonDrawingBelow.getFace().setText(R2D.TRANSLATION.FLOORPLAN_BELOW);
        buttonDrawingOff.getFace().setText(R2D.TRANSLATION.FLOORPLAN_OFF);
    }

    function updateDisplayButtons() {
        if ( currentDrawing && !elementDrawing.isAdded() ) R2D.TopLeftPanel.add(elementDrawing, 1);
        if ( !currentDrawing && elementDrawing.isAdded() ) R2D.TopLeftPanel.remove(elementDrawing, 1);
    }
    */
    scope.drawingAddToDisplay = () => {
        if ( currentDrawingObject3D == null ) {
            return;
        }

        switch ( currentState ) {
            case R2D.DrawingHelper.STATE_ABOVE:
                scene3d.add(currentDrawingObject3D, "top");
                break;

            case R2D.DrawingHelper.STATE_BELOW:
                scene3d.add(currentDrawingObject3D);
                break;

            case R2D.DrawingHelper.STATE_OFF:
                break;
        }

        scope.dispatchUpdate(scope);
    }
    scope.drawingRemoveFromDisplay = () => {
        if ( currentDrawingObject3D == null ) {
            return;
        }

        switch ( currentState ) {
            case R2D.DrawingHelper.STATE_ABOVE:
                scene3d.remove(currentDrawingObject3D, "top");
                break;

            case R2D.DrawingHelper.STATE_BELOW:
                scene3d.remove(currentDrawingObject3D);
                break;

            case R2D.DrawingHelper.STATE_OFF:
                break;
        }

        scope.dispatchUpdate(scope);
    }
    /*
    function buttonsUpdateDisplayState() {
        switch ( currentState ) {
            case R2D.DrawingHelper.STATE_ABOVE:
                elementDrawing.updateButtons([buttonDrawingAbove, buttonDrawingBelow, buttonDrawingOff]);
                break;

            case R2D.DrawingHelper.STATE_BELOW:
                elementDrawing.updateButtons([buttonDrawingBelow, buttonDrawingAbove, buttonDrawingOff]);
                break;

            case R2D.DrawingHelper.STATE_OFF:
            default:
                elementDrawing.updateButtons([buttonDrawingOff, buttonDrawingBelow, buttonDrawingAbove]);
                break;
        }
    }
    */
    scope.setState = state => {
        scope.drawingRemoveFromDisplay();
        switch ( state ) {
            case R2D.DrawingHelper.STATE_ABOVE:
                currentState = R2D.DrawingHelper.STATE_ABOVE;
                break;

            case R2D.DrawingHelper.STATE_BELOW:
                currentState = R2D.DrawingHelper.STATE_BELOW;
                break;

            case R2D.DrawingHelper.STATE_OFF:
                currentState = R2D.DrawingHelper.STATE_OFF;
                break;

            default:
                currentState = null;
        }
        scope.drawingAddToDisplay();
    }
    // function selectDrawingDisplayState(event) {
        
    //     // let button = event.currentTarget;
    //     // let buttons = elementDrawing.getButtons();

    //     // if ( button == buttons[0] ) return;

    //     drawingRemoveFromDisplay();

    //     switch ( button ) {
    //         case buttonDrawingAbove:
    //             setState(R2D.DrawingHelper.STATE_ABOVE);
    //             break;

    //         case buttonDrawingBelow:
    //             setState(R2D.DrawingHelper.STATE_BELOW);
    //             break;

    //         case buttonDrawingOff:
    //         default:
    //             setState(R2D.DrawingHelper.STATE_OFF);
    //     }
        
    //     //buttonsUpdateDisplayState();
    //     scope.drawingAddToDisplay();
    // }
    function drawingEvent(event) {
        currentDrawingObject3D = currentDrawing.getObject3D();
        if(!currentDrawingObject3D) return;
        currentDrawingObject3D.position.y = 1;
        currentDrawingObject3D.castShadow = false;
        currentDrawingObject3D.receiveShadow = false;

        scope.drawingAddToDisplay();
    }
    function updateDrawing(drawingData) {
        scope.drawingRemoveFromDisplay();

        

        if ( currentDrawing ) {
            currentDrawing.removeEventListener(Event.COMPLETE, drawingEvent);
            currentDrawing.removeEventListener(Event.ERROR, drawingEvent);
            currentDrawing.dispose();

            currentDrawing = null;
        }

        if ( !drawingData ) return;

        currentDrawing = new R2D.DrawingHelper.Drawing();

        

        currentDrawing.addEventListener(Event.COMPLETE, drawingEvent);
        currentDrawing.addEventListener(Event.ERROR, drawingEvent);
        currentDrawing.make(drawingData['drawing']['source'], drawingData['drawing']['rotation'], drawingData['drawing']['scale']);
        
    }
    function constructorEvent(event) {
        updateDrawing(constructor.getDrawingData());
        //updateDisplayButtons();
    }

    scope.getCurrentDrawingObject3D = () => currentDrawingObject3D;

    Object.defineProperties(scope, {
        "enabled":{
            get() { return enabled; }
        },
        "state":{
            get() { return currentState; },
            set(value) {
                if ( parseInt(value) == currentState ) return;

                scope.setState(parseInt(value));

                if ( enabled ) {
                    scope.drawingRemoveFromDisplay();
                    //buttonsUpdateDisplayState();
                    scope.drawingAddToDisplay();
                }
            }
        }
    });

    scope.enable = function() {
        if ( enabled ) return;
        

        updateDrawing(constructor.getDrawingData());
        //updateDisplayButtons();

        constructor.addEventListener(WC.DRAWING_CHANGED, constructorEvent);

        enabled = true;

    };
    scope.disable = function() {
        
        if ( !enabled ) return;

        updateDrawing(null);
        //updateDisplayButtons();

        constructor.removeEventListener(WC.DRAWING_CHANGED, constructorEvent);

        enabled = false;

    };

    //buttonDrawingAbove.addLeftMouseClickListener(selectDrawingDisplayState);
    //buttonDrawingBelow.addLeftMouseClickListener(selectDrawingDisplayState);
    //buttonDrawingOff.addLeftMouseClickListener(selectDrawingDisplayState);

    //R2D.Translation.addEventListener(Event.UPDATE, translationUpdateEvent);
};

// R2D.DrawingHelper._instance = null;

// R2D.DrawingHelper.init = (constructor, scene3d) => {
//     R2D.DrawingHelper._instance = new R2D.DrawingHelper(constructor, scene3d);
//     return R2D.DrawingHelper._instance;
// }

extend(R2D.DrawingHelper, EventDispatcher);

R2D.DrawingHelper.STATE_ABOVE = 2;
R2D.DrawingHelper.STATE_BELOW = 1;
R2D.DrawingHelper.STATE_OFF = 0;

R2D.DrawingHelper.Drawing = function() {
    EventDispatcher.call(this);

    let scope = this;
    let originalWidth = 1;
    let originalHeight = 1;
    let nearWidth = 1;
    let nearHeight = 1;
    let scaleX = 1;
    let scaleY = 1;
    let imageRotation = 0;
    let imageScale = 1;
    let imageSource = null;
    let imageSourceTexture = null;
    let image = null;
    let imageTexture = null;
    let mesh = null;

    function makeObject() {
        let material = new THREE.MeshBasicMaterial({color:0xffffff});
        let texture = new THREE.Texture();
        let geometry = R2D.DrawingHelper.Drawing.makePlaneGeometry(nearWidth / scaleX, nearHeight / scaleY);

        geometry.applyMatrix4(new THREE.Matrix4().makeScale(imageScale, 1, imageScale));
        geometry.applyMatrix4(new THREE.Matrix4().makeRotationY(imageRotation));

        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.flipY = false;
        texture.image = imageTexture;
        texture.needsUpdate = true;

        // material.side = THREE.DoubleSide;
        material.transparent = true;
        material.opacity = 0.3;
        material.map = texture;
        material.needsUpdate = true;

        mesh = new THREE.Mesh(geometry, material);
    }
    function imageTextureEventHandler(event) {
        if ( event.type == 'load' ) {
            makeObject();

            if(imageTexture) {
                imageTexture.removeEventListener('load', imageTextureEventHandler);
                imageTexture.removeEventListener('error', imageTextureEventHandler);
                
                scope.dispatchEvent(new Event(Event.COMPLETE, scope));
                imageTexture = null;
            }
            
        } else {
            closeTexture();
        }

    }
    function loadTexture() {
        if ( imageTexture ) return;

        imageTexture = document.createElement('img');

        imageTexture.addEventListener('load', imageTextureEventHandler);
        imageTexture.addEventListener('error', imageTextureEventHandler);
        imageTexture.setAttribute('src', imageSourceTexture);
    }
    function closeTexture() {
        if ( !imageTexture ) return;

        imageTexture.removeEventListener('load', imageTextureEventHandler);
        imageTexture.removeEventListener('error', imageTextureEventHandler);
        imageTexture.removeAttribute('src');
        imageTexture = null;
    }
    function makeImageSourceTexture() {
        let canvas = document.createElement('canvas');
        let context = canvas.getContext('2d');
        if(!image) return;

        originalWidth = image.width;
        originalHeight = image.height;
        nearWidth = Math.pow(2, Math.round(Math.log2(originalWidth)));
        nearHeight = Math.pow(2, Math.round(Math.log2(originalHeight)));

        if ( nearWidth > 2048 ) nearWidth = 2048;
        if ( nearHeight > 2048 ) nearHeight = 2048;

        scaleX = nearWidth / originalWidth;
        scaleY = nearHeight / originalHeight;

        canvas.width = nearWidth;
        canvas.height = nearHeight;

        context.drawImage(image, 0, 0, nearWidth, nearHeight);

        imageSourceTexture = canvas.toDataURL('image/jpeg');

        loadTexture();
    }
    function imageEventHandler(event) {
        if ( event.type == 'load' ) {
            makeImageSourceTexture();
        } else {
            console.error('Error load an image!');
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        closeImage();
    }
    function loadImage() {
        if ( image ) return;

        image = document.createElement('img');

        image.addEventListener('load', imageEventHandler);
        image.addEventListener('error', imageEventHandler);
        image.setAttribute('src', imageSource);
    }
    function closeImage() {
        if ( !image ) return;

        image.removeEventListener('load', imageEventHandler);
        image.removeEventListener('error', imageEventHandler);
        image.removeAttribute('src');
        image = null;
    }

    scope.getObject3D = function() { return mesh; };
    scope.make = function(source, rotation, scale) {
        scope.dispose();

        imageRotation = rotation;
        imageScale = scale;
        imageSource = source;

        loadImage();
    };
    scope.dispose = function() {
        imageRotation = 0;
        imageScale = 1;
        originalWidth = 1;
        originalHeight = 1;
        nearWidth = 1;
        nearHeight = 1;
        scaleX = 1;
        scaleY = 1;
        imageSource = null;
        imageSourceTexture = null;
        image = null;
        imageTexture = null;
        mesh = null;

        closeTexture();
        closeImage();
    }
};

extend(R2D.DrawingHelper.Drawing, EventDispatcher);

R2D.DrawingHelper.Drawing.makePlaneGeometry = function(width, height) {
    let w2 = width / 2;
    let h2 = height / 2;
    let geometry = new THREE.BufferGeometry();

    let bufferIndices = new Uint32Array([
        0, 1, 2,
        0, 2, 3
    ]);
    let bufferVertices = new Float32Array([
        w2, 0,  h2,
        w2, 0, -h2,
        -w2, 0, -h2,
        -w2, 0,  h2
    ]);
    let bufferUVs = new Float32Array([
        1, 1,
        1, 0,
        0, 0,
        0, 1
    ]);

    geometry.setIndex(new THREE.BufferAttribute(bufferIndices, 1));
    geometry.setAttribute("position", new THREE.BufferAttribute(bufferVertices, 3));
    geometry.setAttribute("uv", new THREE.BufferAttribute(bufferUVs, 2));

    geometry.computeVertexNormals();
    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();

    return geometry;
};
// viewers

R2D.ProductTransform2DHelper = function(toolsHTML, scene, apiDispatcher) {
    EventDispatcher.call(this);

    let scope = this;
    let constructor = scene.constructor;
    let history = scene.history;
    let productTransform2d = new R2D.ProductTransform2D();
    scope.api = apiDispatcher;
    let scale = 1;
    let pivotX = 0;
    let pivotY = 0;
    let anchorX = 0;
    let anchorY = 0;
    let currentProduct = null;
    let currentSceneObject = null;

    scope.updateButtons = () => {
        updateTransform2d();
        productTransform2d.updateButtons();
    }

    function updateTransform2d() {
        
        if ( !currentSceneObject ) return;
        if (
            R2D.mouseInteractionHelper.state.name === "stateSelectedProduct" && R2D.mouseInteractionHelper.state.getOnRotationDownStatus()
        ) {
            productTransform2d.useButtons(false, false, false, false);
        } 
        else if (
            currentSceneObject.type == R2D.ProductType.MODEL &&
            currentSceneObject.getForWall()
        ) {
            productTransform2d.useButtons(true, false, true, false);
        } else {
            productTransform2d.useButtons(true, true, true, true);
        }

        let px = pivotX - (anchorX - currentSceneObject.x) * scale;
        let py = pivotY - (anchorY - currentSceneObject.z) * scale;
        let sw = currentSceneObject.width * scale;
        let sh = currentSceneObject.depth * scale;
        let or = -G.toRad(currentSceneObject.rotationY);

        productTransform2d.setObjectData(px, py, sw, sh, or);
    }
    function productTransformEvent(event) {
        if(!currentSceneObject) return;
        
        switch ( event.type ) {
            case R2D.ProductTransform2D.ACTION_START:
                break;

            case R2D.ProductTransform2D.ACTION_PROGRESS:
                let newWidth = productTransform2d.getObjectWidth() / scale;
                let newDepth = productTransform2d.getObjectHeight() / scale;
                let newX = anchorX + (productTransform2d.getObjectX() - pivotX) / scale;
                let newZ = anchorY + (productTransform2d.getObjectY() - pivotY) / scale;

                currentSceneObject.x = newX;
                currentSceneObject.z = newZ;
                currentSceneObject.width = newWidth;
                currentSceneObject.depth = newDepth;

                currentSceneObject.update();

                scope.api.dispatchEvent(new Event(scope.api.MODEL_CHANGE_SIZE, {size: {width: newWidth, depth: newDepth}}));

                R2D.MouseInteractionHelper._instance._ruler3d.findRules(R2D.MouseInteractionHelper._instance._scene.currentView3DObject);
                break;

            case R2D.ProductTransform2D.ACTION_FINISH:
                if( !currentSceneObject ) return;
                if ( currentSceneObject.forWall ) {
                    constructor.pickElement(currentSceneObject.objectId);
                    constructor.dropElement(R2D.Scene.getObjectDataForWallElement(currentSceneObject), 10);
                }
                
                history.saveState();
                scope.api.dispatchEvent(new Event(scope.api.ESTIMATION_SEND, {}));
                break;
        }
    }
    function productUpdateEvent(event) {
        updateTransform2d();
    }

    scope.update = function(px, py, ax, ay, s) {
        pivotX = px;
        pivotY = py;
        anchorX = ax;
        anchorY = ay;
        scale = s;
        productTransform2d.updateScale(s);

        updateTransform2d();
    };
    scope.updateProduct = function(product) {
        if (currentProduct) {
            if(!currentProduct.sceneObject?.getIsFixedSizeEnabled()) {
                toolsHTML.removeChild(productTransform2d.getDomElement());
                currentSceneObject?.removeEventListener(Event.UPDATE, productUpdateEvent);
            };

            currentSceneObject = null;
        }

        currentProduct = product;

        if ( currentProduct ) {
            currentSceneObject = currentProduct.sceneObject;
            if(!currentProduct.sceneObject?.getIsFixedSizeEnabled()) {
                updateTransform2d();
                toolsHTML.appendChild(productTransform2d.getDomElement());
                currentSceneObject?.addEventListener(Event.UPDATE, productUpdateEvent);
            };
        }
    };

    productTransform2d.addEventListener(R2D.ProductTransform2D.ACTION_START, productTransformEvent);
    productTransform2d.addEventListener(R2D.ProductTransform2D.ACTION_PROGRESS, productTransformEvent);
    productTransform2d.addEventListener(R2D.ProductTransform2D.ACTION_FINISH, productTransformEvent);
};

extend(R2D.ProductTransform2DHelper, EventDispatcher);

R2D.MouseInteractionHelper = function(commonSceneObject, commonSceneHelper, apiDispatcher) {
    EventDispatcher.call(this);

    let scope = this;
    scope.api = apiDispatcher;
    scope._scene = commonSceneObject.scene;
    scope._constructor = scope._scene.constructor;
    scope._history = scope._scene.history;
    scope._scene3d = commonSceneObject.scene3d;
    scope._productHelper = commonSceneHelper.productHelper;
    scope._constructorHelper = commonSceneHelper.constructorHelper;
    scope._commonSceneObject = commonSceneObject;
    scope._object3DMoving = commonSceneObject.moving;
    scope._mouseController = new R2D.MouseController();
    scope._touchController = new R2D.TouchController();

    scope.prevState = null;
    let windowMouseDownPoint = {x:0, y:0};
    //scope._quickPanelHelper = new R2D.QuickPanelHelper(scope);

    scope._snap2d = new SNAP.Snap2D();
    scope._ruler3d = scope._scene3d.ruler3d;
    scope._customRulers = scope._scene3d.customRulers;
    scope._titlesTool = scope._scene3d.titlesTool;
    scope._materialPreviewDrag = new R2D.MaterialDragPreview();
    scope._currentCamera = null;
    scope._currentCanvas = null;
    scope._currentViewer = null;
    scope._currentTools = null;

    let objectSelection = true;
    let constructorSelection = true;

    scope._scene.addEventListener(R2D.Scene.SCENE_CLEARED, sceneClearedListener);
    scope._scene.addEventListener(R2D.Scene.CURRENT_OBJECT_REMOVED, currentObjRemovedListener);
    scope._scene.addEventListener(R2D.Scene.CURRENT_OBJECT_REPLACED, currentObjReplacedListener);

    function sceneClearedListener()
    {
        //scope._quickPanelHelper.hideQuickPanel();
        scope._ruler3d.clear();

        scope.changeState(scope.stateMain);

        if ( page )
        {
            page.disable();
            page.removeEventListener(Event.UPDATE, productPageUpdateEvent);
            page.removeEventListener(Event.CHANGE, productPageChangeEvent);
            page.removeEventListener(Event.CHANGE_FINISH, productPageChangeFinishEvent);

            if ( page.inHistory() ) {
                R2D.rightPanel.removePage(page);
            }
        }
    }

    function productPageUpdateEvent(event) {
        if (scope._scene.currentView3DObject)
        {
            switch ( scope._scene.currentView3DObject.objectType )
            {
                case "product":
                    //updateBoxSelected(scene.currentView3DObject);
                    break;

                case "constructor":
                    //-
                    break;
            }
        }
        else if (scope._scene.currentGroup)
        {

        }

        scope._currentViewer.rendererUpdate();
        scope._scene.history.saveState();
    }
    function productPageChangeEvent(event) {
        switch (scope._scene.currentView3DObject.objectType ) {
            case "product":
                scope._ruler3d.findRules(scope._scene.currentView3DObject);
                break;

            case "constructor":
                scope._titlesTool.updateValues();
                //-
                break;
        }
    }
    function productPageChangeFinishEvent(event) {
        switch (scope._scene.currentView3DObject.objectType ) {
            case "product":
                if (scope._scene.currentView3DObject.type == R2D.ProductType.MODEL && scope._scene.currentView3DObject.getForWall() ) {
                    scope._constructor.pickElement(scope._scene.currentView3DObject.sceneObject.objectId);
                    scope._constructor.dropElement(R2D.Scene.getObjectDataForWallElement(scope._scene.currentView3DObject.sceneObject), 10);
                }

                //updateBoxSelected(scene.currentView3DObject);
                scope._ruler3d.update();
                scope._ruler3d.appendFromConstructor(scope._constructor.getLines());
                scope._ruler3d.findRules(scope._scene.currentView3DObject);
                break;

            case "constructor":
                //-
                break;
        }

        scope._currentViewer.rendererUpdate();
        scope._scene.history.saveState('productSizes');
    }

    function currentSceneObjectUpdateEvent(event) {
        //updateBoxSelected(scene.currentView3DObject);
        scope._currentViewer.rendererUpdate();
    }
    function productHelperUpdateEvent(event) {
        if(scope._currentViewer) scope._currentViewer.rendererUpdate();
    }
    function constructorHelperUpdateEvent(event) {
        scope._currentViewer.rendererUpdate();
    }
    let page = null;
    function hidePage(view3DObject) {
        return;
        if (! view3DObject) return;
        let page = null;

        switch ( view3DObject.objectType ) {

            case "group":
                page = R2D.RightPanel.PageGroupSetting.getPage(view3DObject);
                break;

            case "product":
                page = R2D.RightPanel.PageProductSetting.getPage(view3DObject.sceneObject);
                break;

            case "constructor":

                switch ( view3DObject.type ) {
                    case 'wall':
                        page = R2D.RightPanel.PageConstructionElementWall.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                    case 'cover':
                        page = R2D.RightPanel.PageConstructionElementCover.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                    case 'topPlinth':
                    case 'bottomPlinth':
                        page = R2D.RightPanel.PageConstructionElementPlinth.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                    default:
                        page = R2D.RightPanel.PageConstructionElement.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                }
        }

        if ( page ) {
            page.disable();
            page.removeEventListener(Event.UPDATE, productPageUpdateEvent);
            page.removeEventListener(Event.CHANGE, productPageChangeEvent);
            page.removeEventListener(Event.CHANGE_FINISH, productPageChangeFinishEvent);

            if ( page.inHistory() ) {
                R2D.rightPanel.removePage(page);
            }
        }
    }

    scope.updateFreeSpace = function()
    {
        if (! page) return;
        if ((scope._scene.currentView3DObject && scope._scene.currentView3DObject.type == R2D.ProductType.MODEL)
            || scope._scene.currentGroup)
        {
            page.setFreeSpace(scope._ruler3d.distances);
        }
    };

    function showPage(view3DObject)
    {
        return;
        page = null;

        switch ( view3DObject.objectType ) {

            case "group":
                page = R2D.RightPanel.PageGroupSetting.getPage(view3DObject);
                scope.updateFreeSpace();
                //page.setFreeSpace(scope._ruler3d.distances);
                break;

            case "product":
                page = R2D.RightPanel.PageProductSetting.getPage(view3DObject.sceneObject);
                scope.updateFreeSpace();
                //page.setFreeSpace(scope._ruler3d.distances);
                break;

            case "constructor":

                switch ( view3DObject.type ) {
                    case 'wall':
                        
                        //page = R2D.RightPanel.PageConstructionElementWall.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                    case 'cover':

                        //page = R2D.RightPanel.PageConstructionElementCover.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                    case 'topPlinth':
                    case 'bottomPlinth':
                        page = R2D.RightPanel.PageConstructionElementPlinth.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                    default:
                        page = R2D.RightPanel.PageConstructionElement.getPage(view3DObject.type, view3DObject.constructorElementData, scope._constructor);
                        break;
                }
        }

        if ( page ) {
            page.enable();
            page.addEventListener(Event.UPDATE, productPageUpdateEvent);
            page.addEventListener(Event.CHANGE, productPageChangeEvent);
            page.addEventListener(Event.CHANGE_FINISH, productPageChangeFinishEvent);

            if ( !page.inFocus() ) {
                R2D.rightPanel.addPage(page);
                if (page.update) page.update();
            }
        }
    }

    scope.updateSnap2d = function() {
        let i, l;
        let constructorLines = scope._constructor.getLines();
        let geomLines = new Array(constructorLines.length);
        let geomPoints = [];
        let geomBoxes = [];

        for ( i = 0, l = constructorLines.length; i < l; i++ ) {
            let cln = constructorLines[i];

            geomLines[i] = new GEOM.Line.make(cln.x1, cln.y1, cln.x2, cln.y2);

            geomPoints.push(new GEOM.Point(cln.x1, cln.y1));
            geomPoints.push(new GEOM.Point(cln.x2, cln.y2));
        }

        for ( i = 0, l = scope._productHelper.view3DObjects.length; i < l; i++ )
        {
            let viewObj = scope._productHelper.view3DObjects[i];
            if (viewObj == scope._scene.currentView3DObject || viewObj.group ||
                viewObj == scope.stateDraggingProdFromCatalog.view3DObject) continue;
    //            (scope._scene.currentGroup && scope._scene.currentGroup == scope._productHelper.view3DObjects[i].group)) continue;

            let sceneObject = scope._productHelper.view3DObjects[i].sceneObject;
            let rectPoints = GEOM.Point.rotatePoints(sceneObject.get2DRectPoints(), -GEOM.toRad(sceneObject.rotationY));
            let objectPoints = GEOM.Point.shiftPoints(new GEOM.Point(sceneObject.x, sceneObject.z), rectPoints);

            geomBoxes.push(new SNAP.Box(objectPoints, sceneObject.getHeight()));
            //geomPoints = geomPoints.concat(objectPoints);
        }

        for (i = 0; i < scope._scene.groups.length; i++)
        {
            let group = scope._scene.groups[i];
            if (group == scope._scene.currentGroup) continue;
            let pts = group.get2DRectPoints();
            pts = GEOM.Point.shiftPoints(new GEOM.Point(group.x, group.z), pts);
            geomBoxes.push(new SNAP.Box(pts, group.getHeight()));
        }

        geomPoints = GEOM.Point.getUniquePoints(geomPoints);

        scope._snap2d.updateDistance(15);
        scope._snap2d.updateLines(geomLines);
        scope._snap2d.updatePoints(geomPoints);
        scope._snap2d.updateBoxes(geomBoxes);
    };

    function currentObjRemovedListener()
    {
        if (scope._scene.currentGroup)
        {
            scope.removeCurrentGroup();
        }
        else
        {
            let tempSceneObject = scope._scene.currentView3DObject.sceneObject;
            scope.unsetActiveObjectProduct();
            scope._scene.remove(tempSceneObject);
            scope._scene.history.saveState();
            scope.changeState(scope.stateMain);
        }
    }

    function currentObjReplacedListener()
    {
        scope.unsetActiveObjectProduct();
        scope.changeState(scope.stateMain);
    }

    scope.ungroupCurrentGroup = function()
    {
        let gr = scope._scene.currentGroup;
        if (! gr) return;
        scope.unsetActiveGroup();
        gr.clear();

        scope._productHelper.removeGroup(gr);
        //scope._quickPanelHelper.hideQuickPanel();

        scope._scene.history.saveState();
        scope.changeState(scope.stateMain);
    };

    scope.mergeCurrentGroup = function()
    {
        let gr = scope._scene.currentGroup;
        if (! gr) return;

        gr.merged = true;
        scope._scene.history.saveState();
    };

    scope.removeCurrentGroup = function()
    {
        let gr = scope._scene.currentGroup;
        if (! gr) return;
        scope.unsetActiveGroup();
        let objViews = gr.getObjViews();
        gr.clear();
        for (let i = 0; i < objViews.length; i++) scope._scene.remove(objViews[i].sceneObject);
        scope._productHelper.removeGroup(gr);
        //scope._quickPanelHelper.hideQuickPanel();

        scope._scene.history.saveState();
        scope.changeState(scope.stateMain);
    };

    scope.viewerCameraPositionUpdateEvent = (event) => {

        scope._ruler3d.cameraPositionUpdate();
        scope._customRulers.viewUpdate();
        scope._titlesTool.viewUpdate();
    }

    function addRulerListener(event)
    {
        scope.unsetActiveObject();
        scope.unsetActiveGroup();
        scope.changeState(scope.stateCreatingRuler);
    }

    let downX = 0;
    let downY = 0;
    function mouseControllerEvent(event) {
        switch ( event.data.type ) {
            case R2D.MouseController.ROTATE:
                if(scope.state.getOnRotationDownStatus && scope.state.getOnRotationDownStatus()) return;
                scope._currentViewer.cameraRotate(event.data.dx, event.data.dy);
                break;

            case R2D.MouseController.MOVE:
                //scope._currentViewer.cameraMove(event.data.dx, event.data.dy);
                apiDispatcher.dispatchEvent(new Event(apiDispatcher.CAMERA_MOVE, {x: event.data.dx, y: event.data.dy}));
                break;

            case R2D.MouseController.ZOOM:
                //scope._currentViewer.cameraZoom(event.data.delta);
                apiDispatcher.dispatchEvent(new Event(apiDispatcher.WHEEL_ZOOM, {x: event.data.x, y: event.data.y, delta: event.data.delta}));
                break;

            case R2D.MouseController.START_MOVE:
                //scope._currentViewer.setCursorGrabbing();
                break;

            case R2D.MouseController.END_MOVE:
                //scope._currentViewer.setCursorDefault();
                break;

            case R2D.MouseController.START_ROTATE:
                if(scope.state.getOnRotationDownStatus && scope.state.getOnRotationDownStatus()) return;
                scope._currentViewer.hideCursor();
                downX = event.data.x;
                downY = event.data.y;
                break;

            case R2D.MouseController.END_ROTATE:
                if(scope.state.getOnRotationDownStatus && scope.state.getOnRotationDownStatus()) return;
                scope._currentViewer.showCursor();
                break;
        }
    }

    function historyEvent(event) {
        switch ( event.type ) {
            case R2D.SceneHistory.STATE_UPDATE:
                scope.unsetActiveObject();
                scope.unsetActiveGroup();
                break;

            case R2D.SceneHistory.STATE_UPDATED:
                break;
        }
    }

    scope.rightMouseMoveEventHandler = event => {
        let dx = event.screenX - windowMouseDownPoint.x;
        let dy = event.screenY - windowMouseDownPoint.y;
        windowMouseDownPoint.x = event.screenX;
        windowMouseDownPoint.y = event.screenY;

        if(scope._currentViewer.getType && scope._currentViewer.getType() == "2d") WC.WallsEditor._instance.onCanvasMouseMove(event);
            
        scope._mouseController.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.MOVE,
            dx,
            dy
        }));

    }
    scope.rightMouseUpEventHandler = event => {
        // R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, rightMouseMoveEventHandler);
        // R2D.MEC.remove(window, window, R2D.MEC.RIGHT_MOUSE_UP, rightMouseUpEventHandler);

        // R2D.MEC.add(scope._currentCanvas, scope._currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);
        if(scope._currentViewer.getType && scope._currentViewer.getType() == "2d") WC.WallsEditor._instance.onCanvasMouseUp(event);

        scope._mouseController.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.END_MOVE
        }));

    }

    scope.rightMouseDownEventHandler = event => {
        
        //R2D.MEC.remove(scope._currentCanvas, scope._currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);

        windowMouseDownPoint.x = event.screenX;
        windowMouseDownPoint.y = event.screenY;

        // R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, rightMouseMoveEventHandler);
        // R2D.MEC.add(window, window, R2D.MEC.RIGHT_MOUSE_UP, rightMouseUpEventHandler);
        if(scope._currentViewer.getType && scope._currentViewer.getType() == "2d") WC.WallsEditor._instance.onCanvasMouseDown(event);

        scope._mouseController.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.START_MOVE
        }));

    }

    scope.setSize = function(w, h) {
        scope._ruler3d.setSize(w, h);
        scope._customRulers.setSize(w, h);
        scope._titlesTool.setSize(w, h);
    };
    scope.updateComponents = function(camera, canvas, viewer, tools)
    {
        scope.unsetActiveObject();
        scope.unsetActiveGroup();
        if (scope.state != scope.stateMain) scope.changeState(scope.stateMain);

        if ( scope._currentCanvas ) {
            //R2D.MEC.remove(scope._currentCanvas, scope._currentCanvas, R2D.MEC.LEFT_MOUSE_DOWN, leftMouseDownListener);
            //R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, leftMouseMoveListener);
            //R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUpListener);

            R2D.MEC.remove(scope._currentCanvas, scope._currentCanvas, R2D.MEC.TOUCH_DOWN, touchDownListener);
            R2D.MEC.remove(window, window, R2D.MEC.TOUCH_MOVE, touchMoveListener);
            R2D.MEC.remove(window, window, R2D.MEC.TOUCH_UP, touchUpListener);
        }
        if ( scope._currentViewer ) {
            scope._currentViewer.removeEventListener(R2D.Viewer.CAMERA_POSITION_UPDATE, scope.viewerCameraPositionUpdateEvent);
            scope._currentViewer.removeEventListener(R2D.Viewer.ADD_RULER, addRulerListener);
        }

        scope._currentCamera = camera;
        scope._currentCanvas = canvas;
        scope._currentViewer = viewer;
        scope._currentTools = tools;

        scope._mouseController.updateComponents(scope._currentCanvas);
        scope._touchController.updateComponents(scope._currentCanvas);
        scope._ruler3d.updateComponents(camera, tools);
        scope._customRulers.updateComponents(camera, tools, scope._currentCanvas, scope._currentViewer);
        scope._titlesTool.updateComponents(camera, tools, scope._currentCanvas, scope._currentViewer);

        if ( scope._currentCanvas )
        {
            //R2D.MEC.add(scope._currentCanvas, scope._currentCanvas, R2D.MEC.LEFT_MOUSE_DOWN, leftMouseDownListener);
            //R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, leftMouseMoveListener);
            //R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUpListener);
            
            //R2D.MEC.add(scope._currentCanvas, scope._currentCanvas, R2D.MEC.RIGHT_MOUSE_DOWN, rightMouseDownEventHandler);
            R2D.MEC.add(scope._currentCanvas, scope._currentCanvas, R2D.MEC.TOUCH_DOWN, touchDownListener);
            R2D.MEC.add(window, window, R2D.MEC.TOUCH_MOVE, touchMoveListener);
            R2D.MEC.add(window, window, R2D.MEC.TOUCH_UP, touchUpListener);
        }
        if ( scope._currentViewer )
        {
            scope._currentViewer.addEventListener(R2D.Viewer.CAMERA_POSITION_UPDATE, scope.viewerCameraPositionUpdateEvent);
            scope._currentViewer.addEventListener(R2D.Viewer.ADD_RULER, addRulerListener);
        } else {
            scope._currentViewer = {
                rendererUpdate() { /*console.warn("Handle update event!")*/},
                removeEventListener() { }
            };
        }
    };
    scope.titlesToolUpdate = () => scope._titlesTool.updateComponents(scope._currentCamera, scope._currentTools, scope._currentCanvas, scope._currentViewer);

    scope.objectSelection = value => objectSelection = value;

    scope.getObjectSelection = () => objectSelection;

    scope.constructorSelection = function (value) {
        constructorSelection = value;
    };

    scope._scene.addEventListener(R2D.Scene.DRAG_OBJECT, sceneObjectDragListener);
    scope._history.addEventListener(R2D.SceneHistory.STATE_UPDATE, historyEvent);

    scope._productHelper.addEventListener(Event.UPDATE, productHelperUpdateEvent);
    scope._constructorHelper.addEventListener(Event.UPDATE, constructorHelperUpdateEvent);
    scope._mouseController.addEventListener(Event.UPDATE, mouseControllerEvent);
    scope._touchController.addEventListener(Event.UPDATE, mouseControllerEvent);


    scope._constructor.addEventListener(WC.ASK_ELEMENT_NAME, askNameListener);
    function askNameListener()
    {
        //windowAskName.setValue();
    }

    // ----------------------------------------------------

    scope.mouseX = 0;
    scope.mouseY = 0;
    scope.vectorsForMatMove = null;
    //scope.clickX = 0;
    //scope.clickY = 0;

    scope.stateMain = new R2D.MIH.StateMain(scope);
    scope.stateSelectedProduct = new R2D.MIH.StateSelectedProduct(scope);
    scope.stateSelectedConstr = new R2D.MIH.StateSelectedConstr(scope);
    scope.stateDraggingProduct = new R2D.MIH.StateDraggingProduct(scope);
    scope.stateDraggingMaterial = new R2D.MIH.StateDraggingMaterial(scope);
    scope.stateDraggingProdFromCatalog = new R2D.MIH.StateDraggingProdFromCatalog(scope);
    scope.stateCreatingRuler = new R2D.MIH.StateCreatingRuler(scope);
    scope.stateSelectedGroup = new R2D.MIH.StateSelectedGroup(scope);
    scope.stateDraggingGroup = new R2D.MIH.StateDraggingGroup(scope);

    scope.state = scope.stateMain;
    scope.prevSavedState = null;

    scope.leftMouseDownListener = e => {
        if(!scope.state) return;
        if(e.button == 0) return scope.state.mouseDown(e);
        else if(e.button == 2) scope.rightMouseDownEventHandler(e);
    }

    scope.leftMouseMoveListener = e => {
        if(!scope.state) return;
        scope.mouseX = e.clientX;
        scope.mouseY = e.clientY;
        if(e.buttons == 2) return scope.rightMouseMoveEventHandler(e);
        return scope.state.mouseMove(e);
    }

    scope.leftMouseUpListener = e => {
        if(!scope.state) return;
        if(e.button == 0) return scope.state.mouseUp(e);
        else if(e.button == 2) scope.rightMouseUpEventHandler(e);
    }

    function touchDownListener(e)
    {
        if(!scope.state) return;
        scope.state.mouseDown(e);
    }

    function touchMoveListener(e)
    {
        if(!scope.state) return;
        scope.mouseX = e.clientX;
        scope.mouseY = e.clientY;
        scope.state.mouseMove(e);
    }

    function touchUpListener(e)
    {
        if(!scope.state) return;
        scope.state.mouseUp(e);
    }


    scope.draggingMaterialId = '';
    scope.draggingAddMaterialId = '';
    async function sceneObjectDragListener(event) {
        if(!event.data) return;
        //if (R2D.scene3d.customRulers.isCreating()) R2D.scene3d.customRulers.cancel();

        if ( event.data.type == R2D.ProductType.MATERIAL ) {
            if(!scope._currentTools) return;
            scope._materialPreviewDrag.setPosition(-1000, -1000);
            await scope._materialPreviewDrag.updatePreview(event.data.productId, event.data.productMaterialColor);
            scope._currentTools.appendChild(scope._materialPreviewDrag.domElement);
            if(event.data.productMaterialColor) {
                scope.draggingMaterialId = event.data.productMaterialColor;
                scope.draggingAddMaterialId = event.data.productId;
            } else {
                scope.draggingMaterialId = event.data.productId;
            }
            
            scope.stateDraggingMaterial.prevState = scope.state;
            scope.changeState(scope.stateDraggingMaterial);
        }
        else
        {
            //let boxView3DObject = new R2D.ObjectViewer3DBox(event.data);
            let sceneObj = event.data;
            scope._scene.add(sceneObj);
            let view3DObj = scope._productHelper.findObjectView3dBySceneObject(sceneObj);

            let sceneCenter = scope._scene.getBounds();

            scope._object3DMoving.position.set(
                sceneCenter.centerX,
                view3DObj.sceneObject.y + view3DObj.sceneObject.height / 2,
                sceneCenter.centerY
            );
            scope._object3DMoving.scale.set(1.5, 1, 1.5);

            scope.stateDraggingProdFromCatalog.view3DObject = view3DObj;
            scope.changeState(scope.stateDraggingProdFromCatalog);

            scope._ruler3d.update();
            scope._ruler3d.appendFromConstructor(scope._constructor.getLines());
            scope._ruler3d.findRules(view3DObj);
            scope._currentViewer.rendererUpdate();
        }
    }

    scope.changeState = function(state)
    {
        if(!scope.state || !state) return;
        let oldState = scope.state;
        scope.prevState = scope.state == state ? scope.prevState : oldState;
        scope.state.stop();
        scope.state = state;
        scope.state.start();

        scope._currentViewer.rendererUpdate();

        let evt = new Event(R2D.MouseInteractionHelper.STATE_CHANGED);
        evt.oldState = oldState;
        evt.newState = state;
        scope.dispatchEvent(evt);
        
        if( state.name == "stateMain" && oldState.name == "stateDraggingProdFromCatalog" ) this.api.dispatchEvent(new Event(this.api.ESTIMATION_SEND, {}));
    };

    scope.findCircles = function(mx, my) {
        let point = R2D.Renderer3D.getMousePointForPicker(scope._currentCanvas, mx, my);
        let objectData = scope._scene3d.circlesUnderCursor(R2D.scene3d.top, scope._currentCamera, point.x, point.y);

        return objectData;
    }

    scope.find3DObject = function(mx, my)
    {
        let point = R2D.Renderer3D.getMousePointForPicker(scope._currentCanvas, mx, my);
        let objectData = null;
        if (constructorSelection)
        {
            objectData = scope._scene3d.objectUnderCursor(commonSceneObject.interactiveObjects, scope._currentCamera, point.x, point.y);
        }
        else
        {
            objectData = scope._scene3d.objectUnderCursor(commonSceneObject.productObjects, scope._currentCamera, point.x, point.y);
        }

        let view3DObject = objectData ? scope._productHelper.findObjectView3DByObject3D(objectData.object) || scope._constructorHelper.findObjectView3DByObject3D(objectData.object) : null;

        if(scope.state.getRotationModeActive && !view3DObject) return objectData;

        if ( view3DObject ) {
            let partNum = null;
            if (typeof objectData.object.num !== 'undefined') partNum = objectData.object.num;
            return {
                point: objectData.point,
                distance: objectData.distance,
                view3DObject: view3DObject,
                partNum: partNum
            }
        }

        return null;
    };

    scope.setActiveGroup = function(group, mx, my, showQPanel = true)
    {
        scope._scene.currentGroup = group;
        //if (showQPanel) scope._quickPanelHelper.showQuickPanel(group, mx, my);

        if(scope._scene.currentGroup.isLockedOnScene) return;

        scope._ruler3d.update();
        scope._ruler3d.appendFromConstructor(scope._constructor.getLines());
        scope._ruler3d.findRules(scope._scene.currentGroup);

        showPage(scope._scene.currentGroup);

        //scope.clickX = mx;
        //scope.clickY = my;
    };

    scope.unsetActiveGroup = function()
    {
        if (! scope._scene.currentGroup) return;

        //hidePage(scope._scene.currentGroup);
        scope._scene.currentGroup = null;
        scope._ruler3d.clear();
        //scope._quickPanelHelper.hideQuickPanel();

        if (scope.state == scope.stateSelectedGroup || scope.state == scope.stateDraggingGroup)
        {
            scope.changeState(scope.stateMain);
        }
    };

    scope.setActiveObjectProduct = function(view3DObject, mx, my, showQPanel = true)
    {
        scope._scene.currentView3DObject = view3DObject;
        scope._scene.currentSceneObject = scope._scene.currentView3DObject.sceneObject;

        scope._scene.currentSceneObject && scope._scene.currentSceneObject.addEventListener(Event.UPDATE, currentSceneObjectUpdateEvent);
        scope._currentViewer.selectedObject(scope._scene.currentView3DObject);
        if(scope._scene.currentSceneObject?.isLockedOnScene) return;
        scope._ruler3d.update();
        scope._ruler3d.appendFromConstructor(scope._constructor.getLines());
        scope._ruler3d.findRules(scope._scene.currentView3DObject);

        //setView3DObject(scene.currentView3DObject);
        //showPage(scope._scene.currentView3DObject);
        //if (showQPanel) scope._quickPanelHelper.showQuickPanel(scope._scene.currentView3DObject, mx, my);
        //scope.clickX = mx;
        //scope.clickY = my;
    };

    scope.setPrevSelectedObjectElement = function () {
        let prevActiveView3dObjectOrGroup = scope._scene.prevSelectedView3DObject;
        let prevActiveView3dObjectOrGroupData = scope._scene.prevView3DObjectData;

        if(scope.prevSavedState) {
            scope.prevSavedState.name == "stateSelectedGroup" ? 
            scope.setActiveGroup(prevActiveView3dObjectOrGroup) :
            scope.prevSavedState.name == "stateSelectedProduct" ? 
            scope.setActiveObjectProduct(prevActiveView3dObjectOrGroup) : 
            scope.setActiveObjectConstructor(prevActiveView3dObjectOrGroup, scope.vectorsForMatMove?.x, scope.vectorsForMatMove?.y, prevActiveView3dObjectOrGroupData);
        }
        
        scope._ruler3d.update();
        scope._ruler3d.appendFromConstructor(scope._constructor.getLines());
        scope._ruler3d.findRules(prevActiveView3dObjectOrGroup);

        scope._currentViewer.rendererUpdate();
    };

    scope.unsetActiveObjectProduct = function()
    {
        if(!scope._currentViewer || !scope._currentViewer.unselectedObject) return;
        if (scope._scene.currentSceneObject)
        {
            scope._scene.currentSceneObject.removeEventListener(Event.UPDATE, currentSceneObjectUpdateEvent);
            hidePage(scope._scene.currentView3DObject);
        }

        scope._currentViewer.unselectedObject(scope._scene.currentView3DObject);
        scope._ruler3d.clear();
        //scope._quickPanelHelper.hideQuickPanel();

        scope._scene.currentView3DObject = null;
        scope._scene.currentView3DObjectData = null
        scope._scene.currentSceneObject = null;
        //scope._scene.currentGroup = null;

        scope._scene.history.setCurrentLabel('');
    };

    scope.setActiveObjectConstructor = function(view3DObject, mx, my, objectData, showQuickPanel=true)
    {
        scope._scene.currentView3DObject = view3DObject;
        scope._scene.currentPartNum = objectData ? objectData.partNum : null;
        scope._scene.currentConstructorElementData = view3DObject?.constructorElementData;

        let objectDataX = scope.find3DObject(mx + 1, my);
        let objectDataY = scope.find3DObject(mx, my + 1);
        if (objectDataX && objectDataY)
        {
            scope.vectorsForMatMove = [objectData.point, objectDataX.point, objectDataY.point];
        }

        if(objectData) {
            scope._scene.currentView3DObjectData = objectData;
        }

        let type = scope._scene.currentView3DObject?.getType();
        if(type == 'wall') return { state: "stateSelectedWall", quickPanel: {x: mx, y: my - 30} };
        else if(type == 'topPlinth' || type == 'bottomPlinth') return { state: "stateSelectedPlinth", quickPanel: {x: mx, y: my - 30} };
        else return { state: "stateSelectedConstr", quickPanel: {x: mx, y: my - 30}, type };
    };

    scope.unsetActiveObjectConstructor = function()
    {
        //scope._quickPanelHelper.hideQuickPanel();

        scope._scene.currentView3DObject = null;
        scope._scene.currentConstructorElementData = null;
    };

    scope.unsetActiveObject = function()
    {
        if (! scope._scene.currentView3DObject) return;

        if (scope.state == scope.stateSelectedProduct || scope.state == scope.stateDraggingProduct)
        {
            scope.unsetActiveObjectProduct();
            scope.changeState(scope.stateMain);
        }

        if (scope.state == scope.stateSelectedConstr)
        {
            scope.unsetActiveObjectConstructor();
            scope.changeState(scope.stateMain);
        }
    };
    scope.cancelCreatingRuler = function()
    {
        if (scope.state == scope.stateCreatingRuler) scope.changeState(scope.stateMain);
    };
    /*
    scope.tryAddToGroup = function(view3DObj)
    {
        if (view3DObj.group) return; // merge groups?
        if (scope._scene.currentGroup)
        {
            scope._productHelper.addObjToGroup(view3DObj);
        }
        else if (scope._scene.currentView3DObject && view3DObj != scope._scene.currentView3DObject)
        {
            scope._scene.currentGroup = scope._productHelper.addGroup();
            scope._productHelper.addObjToGroup(scope._scene.currentView3DObject);
            scope._productHelper.addObjToGroup(view3DObj);
        }
    }
    */

    // actions from quick panel

    scope.clearFill = function()
    {
        if(!scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.clearMaterial && scope._scene.currentView3DObject.clearMaterial();
        scope._scene.currentView3DObject.update();
        scope._scene.history.saveState();
    };

    scope.duplicateCurrentModel = function()
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject.clone();
        if(!sceneObject) return;

        if ( scope._scene.currentView3DObject.getForWall && scope._scene.currentView3DObject.getForWall() )
        {
            let pointA = GEOM.Point.rotatePoint(new GEOM.Point( sceneObject.getWidth(), 0), -GEOM.toRad(sceneObject.rotationY));
            let pointB = GEOM.Point.rotatePoint(new GEOM.Point(-sceneObject.getWidth(), 0), -GEOM.toRad(sceneObject.rotationY));

            pointA.x += sceneObject.x;
            pointA.y += sceneObject.z;
            pointB.x += sceneObject.x;
            pointB.y += sceneObject.z;

            if (scope._constructor.moveElement({ x:pointA.x, y:pointA.y }, 20) ) {
                sceneObject.x = pointA.x;
                sceneObject.z = pointA.y;

                scope._scene.add(sceneObject);
            } else if ( scope._constructor.moveElement({ x:pointB.x, y:pointB.y }, 20) ) {
                sceneObject.x = pointB.x;
                sceneObject.z = pointB.y;

                scope._scene.add(sceneObject);
            }
        }
        else
        {
            if (isNaN(scope._ruler3d.distances[1]) || scope._ruler3d.distances[1] >= sceneObject.getWidth())
            {
                pointA = GEOM.Point.rotatePoint(new GEOM.Point( sceneObject.getWidth(), 0), -GEOM.toRad(sceneObject.rotationY));
            }
            else if (isNaN(scope._ruler3d.distances[3]) || scope._ruler3d.distances[3] >= sceneObject.getWidth())
            {
                pointA = GEOM.Point.rotatePoint(new GEOM.Point(-sceneObject.getWidth(), 0), -GEOM.toRad(sceneObject.rotationY));
            }
            else if (isNaN(scope._ruler3d.distances[2]) || scope._ruler3d.distances[2] >= sceneObject.getWidth())
            {
                pointA = GEOM.Point.rotatePoint(new GEOM.Point(0, sceneObject.getDepth()), -GEOM.toRad(sceneObject.rotationY));
            }
            else if (isNaN(scope._ruler3d.distances[0]) || scope._ruler3d.distances[0] >= sceneObject.getWidth())
            {
                pointA = GEOM.Point.rotatePoint(new GEOM.Point(0, -sceneObject.getDepth()), -GEOM.toRad(sceneObject.rotationY));
            }
            else
            {
                pointA = GEOM.Point.rotatePoint(new GEOM.Point( sceneObject.getWidth(), 0), -GEOM.toRad(sceneObject.rotationY));
            }

            pointA.x += sceneObject.x;
            pointA.y += sceneObject.z;

            sceneObject.x = pointA.x;
            sceneObject.z = pointA.y;

            scope._scene.add(sceneObject);
        }

        scope._scene.history.saveState();

        scope._ruler3d.update(scope._productHelper.getView3DObjects(), scope._scene.currentView3DObject);
        scope._ruler3d.appendFromConstructor(scope._constructor.getLines());
        scope._ruler3d.findRules(scope._scene.currentView3DObject);
        this.api.dispatchEvent(new Event(this.api.ESTIMATION_SEND, {}));
    };

    scope.duplicateCurrentGroup = function()
    {
        let newGroup = scope._productHelper.addGroup();
        newGroup.copyFrom(scope._scene.currentGroup);
        scope._scene.history.saveState();
        this.api.dispatchEvent(new Event(this.api.ESTIMATION_SEND, {}));
    };

    scope.flipCurrentGroupX = function()
    {
        scope._scene.currentGroup.flipX();
        scope._scene.history.saveState();
        scope._currentViewer.rendererUpdate();
    };

    scope.flipCurrentGroupZ = function()
    {
        scope._scene.currentGroup.flipZ();
        scope._scene.history.saveState();
        scope._currentViewer.rendererUpdate();
    };

    scope.flipCurrentModelX = function()
    {
        if(!scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.sceneObject.flipX = !scope._scene.currentView3DObject.sceneObject.flipX;
        scope._scene.currentView3DObject.sceneObject.update();

        if (scope._scene.currentView3DObject.getForWall && scope._scene.currentView3DObject.getForWall())
        {
            scope._constructor.pickElement(scope._scene.currentView3DObject.sceneObject.objectId);
            scope._constructor.dropElement(R2D.Scene.getObjectDataForWallElement(scope._scene.currentView3DObject.sceneObject), 10);
        }
        scope._scene.history.saveState();
    };

    scope.flipCurrentModelZ = function()
    {
        if(!scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.sceneObject.flipZ = !scope._scene.currentView3DObject.sceneObject.flipZ;
        scope._scene.currentView3DObject.sceneObject.update();

        if (scope._scene.currentView3DObject.getForWall && scope._scene.currentView3DObject.getForWall())
        {
            scope._constructor.pickElement(scope._scene.currentView3DObject.sceneObject.objectId);
            scope._constructor.dropElement(R2D.Scene.getObjectDataForWallElement(scope._scene.currentView3DObject.sceneObject), 10);
        }
        scope._scene.history.saveState();
    };

    let startR;
    scope.startRotateCurrentModel = function()
    {
        startR = scope._scene.currentView3DObject.sceneObject.rotationY;
    };
    scope.rotateCurrentModel = function(degrees)
    {
        scope._scene.currentView3DObject.sceneObject.rotationY = G.pacifyAngleDeg(degrees);
        scope._scene.currentView3DObject.sceneObject.update();
        scope._ruler3d.findRules(scope._scene.currentView3DObject);
    };
    scope.stopRotateCurrentModel = function()
    {
        scope._scene.history.saveState();
    };

    scope.startRotateCurrentGroup = function()
    {
        startR = scope._scene.currentGroup.rotation;
    };
    scope.rotateCurrentGroup = function(degrees)
    {
        scope._scene.currentGroup.setRotation(GEOM.toRad(degrees));
        scope._ruler3d.findRules(scope._scene.currentGroup);
        scope._currentViewer.rendererUpdate();
    };
    scope.stopRotateCurrentGroup = function()
    {
        scope._scene.history.saveState();
    };

    //

    let startE;
    scope.startElevateCurrentModel = function()
    {
        startE = scope._scene.currentView3DObject.sceneObject.y;
    };
    scope.elevateCurrentModel = function(height)
    {
        scope._scene.currentView3DObject.sceneObject.y = height;
        scope._scene.currentView3DObject.sceneObject.update();
    };
    scope.stopElevateCurrentModel = function()
    {
        scope._scene.history.saveState();
    };

    scope.startElevateCurrentGroup = function()
    {
        startE = scope._scene.currentGroup.y;
    };
    scope.elevateCurrentGroup = function(height)
    {
        scope._scene.currentGroup.y = height;
        scope._scene.currentGroup.update();
    };
    scope.stopElevateCurrentGroup = function()
    {
        scope._scene.history.saveState();
    };

    //

    scope.startRotateCurrentMaterial = function()
    {
        scope._scene.currentView3DObject.startRotateMaterial();
    };
    scope.rotateCurrentMaterial = function(degrees)
    {
        scope._scene.currentView3DObject.rotateMaterial(GEOM.toRad(degrees), scope._scene.currentPartNum);
        scope._scene.currentView3DObject.update();
    };
    scope.stopRotateCurrentMaterial = function()
    {
        scope._scene.currentView3DObject.stopRotateMaterial();
        scope._scene.currentView3DObject.update();
        scope._scene.history.saveState();
    };

    let shiftVectH = null;
    let shiftVectV = null;
    let pointDown = null;
    let pointPrev = null;
    let startShift = null;
    scope.startMoveCurrentMaterial = function(x, y)
    {
        if (scope.vectorsForMatMove && scope._scene.currentView3DObject)
        {
            let vectors = scope.vectorsForMatMove;
            if (scope._scene.currentView3DObject.type == 'wall' || scope._scene.currentView3DObject.type == 'cut' ||
                scope._scene.currentView3DObject.type == 'topFrame')
            {
                let x1 = TR.euclDist(vectors[0].x, vectors[0].z, vectors[1].x, vectors[1].z);
                let y1 = vectors[1].y - vectors[0].y;
                let x2 = TR.euclDist(vectors[0].x, vectors[0].z, vectors[2].x, vectors[2].z);
                let y2 = vectors[2].y - vectors[0].y;
                shiftVectH = new TR.Point(x1, y1);
                shiftVectV = new TR.Point(x2, y2);
            }
            else if (scope._scene.currentView3DObject.type == 'cover' || scope._scene.currentView3DObject.type == 'ceiling' ||
                scope._scene.currentView3DObject.type == 'area' || scope._scene.currentView3DObject.type == 'cap')
            {
                x1 = vectors[1].x - vectors[0].x;
                y1 = vectors[1].z - vectors[0].z;
                x2 = vectors[2].x - vectors[0].x;
                y2 = vectors[2].z - vectors[0].z;
                shiftVectH = new TR.Point(x1, y1);
                shiftVectV = new TR.Point(x2, y2);
            }
            else if (scope._scene.currentView3DObject.type == 'bottomFrame')
            {
                x1 = vectors[1].x - vectors[0].x;
                y1 = vectors[1].z - vectors[0].z;
                x2 = vectors[2].x - vectors[0].x;
                y2 = vectors[2].z - vectors[0].z;
                let data = scope._scene.currentView3DObject.constructorElementData;
                shiftVectH = new TR.Point(x1 * data.dirY.x + y1 * data.dirY.y, x1 * data.dirX.x + y1 * data.dirX.y);
                shiftVectV = new TR.Point(x2 * data.dirY.x + y2 * data.dirY.y, x2 * data.dirX.x + y2 * data.dirX.y);
            }
        }

        pointDown = {
            x,
            y
        };

        pointPrev = {
            x,
            y
        };

        startShift = scope._scene.currentView3DObject?.getMaterialShift && scope._scene.currentView3DObject?.getMaterialShift(scope._scene.currentPartNum);

        scope._scene.currentView3DObject?.startMoveMaterial && scope._scene.currentView3DObject.startMoveMaterial();
    };
    scope.moveCurrentMaterial = function(x, y)
    {
        if(!pointDown || !shiftVectH || !shiftVectV) return;
        // let dx = scope.mouseX - pointPrev.x;
        // let dy = scope.mouseY - pointPrev.y;

        let scrShiftX = x - pointDown.x;
        let scrShiftY = y - pointDown.y;

        let shiftX = scrShiftX * shiftVectH.x + scrShiftY * shiftVectV.x;
        let shiftY = scrShiftX * shiftVectH.y + scrShiftY * shiftVectV.y;

        pointPrev = {
            x: scope.mouseX,
            y: scope.mouseY
        };

        //scope.setX(scope.getX() + dx);
        //scope.setY(scope.getY() + dy);

        scope._scene.currentView3DObject?.moveMaterial && scope._scene.currentView3DObject.moveMaterial([startShift[0] + shiftX, startShift[1] + shiftY], scope._scene.currentPartNum);
        scope._scene.currentView3DObject?.update();

        //scope._scene.currentView3DObject.moveMaterial([x, y], scope._scene.currentPartNum);
        //scope._scene.currentView3DObject.update();
    };
    scope.stopMoveCurrentMaterial = function()
    {
        pointDown = null;
        pointPrev = null;

        scope._scene.currentView3DObject?.stopMoveMaterial && scope._scene.currentView3DObject?.stopMoveMaterial();
        scope._scene.history.saveState();
    };

    scope.getAvailableTools = function()
    {
        let currentObj = scope._scene.currentView3DObject;
        let currentGroup = scope._scene.currentGroup;
        if (currentGroup)
        {
            return {
                flipX: true,
                flipZ: true,
                duplicate: true,
                remove: true,
                elevate: true,
                rotate: true,
                move: false
            };
        }
        else if (currentObj && currentObj.objectType == 'product')
        {
            switch (currentObj.type) {
                case R2D.ProductType.MODEL:
                    return {
                        flipX: true,
                        flipZ: true,
                        duplicate: true,
                        remove: true,
                        elevate: true,
                        rotate: ! currentObj.getForWall(),
                        move: false
                    };
                    break;

                case R2D.ProductType.CARPET:
                    return {
                        flipX: false,
                        flipZ: false,
                        duplicate: false,
                        remove: true,
                        elevate: true,
                        rotate: true,
                        move: false
                    };
                    break;

                case R2D.ProductType.POSTER:
                    return {
                        flipX: false,
                        flipZ: false,
                        duplicate: false,
                        remove: true,
                        elevate: true,
                        rotate: false,
                        move: false
                    };
                    break;
            }
        }
        else if (currentObj && currentObj.objectType == 'constructor')
        {
            let useMoving = !(currentObj.type == R2D.ObjectConstructor3DType.FRAME_TOP ||
            currentObj.type == R2D.ObjectConstructor3DType.PLINTH_TOP ||
            currentObj.type == R2D.ObjectConstructor3DType.PLINTH_BOTTOM);

            return {
                flipX: false,
                flipZ: false,
                duplicate: false,
                remove: true,
                elevate: false,
                rotate: true,
                move: useMoving
            };
        }
    };

    scope.getCurrentModelMaterials = function()
    {
        if (scope._scene.currentView3DObject)
        {
            if(!scope._scene.currentView3DObject?.sceneObject?.getMaterials) return [];
            let materials = scope._scene.currentView3DObject.sceneObject.getMaterials();
            let res = [];
            for (let mat of materials)
            {
                
                res.push({
                    matId: mat.current,
                    source: mat.source,
                    setId: mat.setId,
                    addMaterial: mat.addMaterial
                });
            }
            return res;
        }
    };

    scope.setMaterialOnCurrentModel = function(index, matId)
    {
        if (! scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.sceneObject.setMaterialAt(index, matId);
        scope._scene.currentView3DObject.sceneObject.update();
        scope._scene.history.saveState();
    };

    scope.setAddMaterialOnCurrentModel = function(index, matId)
    {
        if (! scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.sceneObject.setAddMaterialAt(index, matId);
        scope._scene.currentView3DObject.sceneObject.update();
        scope._scene.history.saveState();
    };

    scope.getCurrentConstrMaterial = function()
    {
        if (! scope._scene.currentView3DObject) return;
        return scope._scene.currentView3DObject.getConstructorElementData && scope._scene.currentView3DObject.getConstructorElementData().getMaterial(scope._scene.currentPartNum);
    };
    scope.getCurrentConstrAddMaterial = function()
    {
        if (! scope._scene.currentView3DObject) return;
        return scope._scene.currentView3DObject.getConstructorElementData().getAddMaterial(scope._scene.currentPartNum);
    };

    scope.setMaterialOnCurrentConstr = function(matId)
    {
        if (! scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.update();
        scope._scene.currentView3DObject.getConstructorElementData().setMaterial(matId, scope._scene.currentPartNum);
        scope._scene.currentView3DObject.getConstructorElementData().dispatchUpdate();
    };
    scope.setAddMaterialOnCurrentConstr = function(addMatId)
    {
        if (! scope._scene.currentView3DObject) return;
        scope._scene.currentView3DObject.update();
        scope._scene.currentView3DObject.getConstructorElementData().setAddMaterial(addMatId, scope._scene.currentPartNum);
        scope._scene.currentView3DObject.getConstructorElementData().dispatchUpdate();
    };

    scope.dragProductFromCatalog = function(id, addMaterialId)
    {
        // let productId = event.data;
        // let productData = R2D.Pool.getProductData(productId);
        // let sceneObject = R2D.Creator.makeSceneObject(productData);

        // R2D.controller.dragSceneObject(sceneObject);
        let materialId = addMaterialId || id;
        let productsDataLoader;
        
        productData = R2D.Pool.getProductData(materialId);

        if (productData)
        {
            console.log('Already exists!');
            let sceneObject;
            if(addMaterialId) sceneObject = R2D.Creator.makeSceneObject(productData, id);
            else sceneObject = R2D.Creator.makeSceneObject(productData);
            R2D.controller.dragSceneObject(sceneObject);
            
        }
        else
        {
            console.log('Not exists!');
            productsDataLoader = new R2D.ProductsDataLoader();
            productsDataLoader.addEventListener(Event.COMPLETE, productsDataLoaderEventHandler);
            productsDataLoader.load([materialId]);
        }

        function productsDataLoaderEventHandler(event) {
            if ( event.type == Event.COMPLETE )
            {
                productsDataLoader.removeEventListener(Event.COMPLETE, productsDataLoaderEventHandler);
                productsDataLoader.dispose();
                productsDataLoader = null;

                productData = R2D.Pool.getProductData(materialId);

                console.log('Loaded data!');
                if(addMaterialId) sceneObject = R2D.Creator.makeSceneObject(productData, id);
                else sceneObject = R2D.Creator.makeSceneObject(productData);
                R2D.controller.dragSceneObject(sceneObject);
            }
        };
    };

    scope.setCurrentObjectRotation = function(value, axis, isMouseDown)
    {
        if (!scope._scene.currentView3DObject) return null;

        scope._scene.currentView3DObject.sceneObject[`rotation${axis.toUpperCase()}`] = Number(value);
        scope._scene.currentView3DObject.sceneObject.update();

        !isMouseDown ? scope._scene.history.saveState() : null;

        scope._ruler3d.findRules(scope._scene.currentView3DObject);

    };

    scope.getCurrentModelSizes = function()
    {
        if (!scope._scene.currentView3DObject) return {};

        let sceneObj = scope._scene.currentView3DObject.sceneObject;

        if (!sceneObj) return {};

        return {
            width: sceneObj.getWidth(),
            height: sceneObj.getHeight(),
            depth: sceneObj.getDepth(),
            elevation: sceneObj.y
        };
    };

    scope.setCurrentModelWidth = function(vWidth, keepRatio, isMouseDown)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let cWidth = sceneObject.getWidth();
        let ratio = vWidth / cWidth;

        if ( keepRatio ) {
            changeSizesByRatio(ratio);
        } else {
            sceneObject.setWidth(Math.round(cWidth * ratio * 10) / 10, false);
            sceneObject.update();
        }

        scope._ruler3d.findRules(scope._scene.currentView3DObject);

        !isMouseDown ? scope._scene.history.saveState() : null;
    };

    scope.setCurrentModelHeight = function(vHeight, keepRatio, isMouseDown)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let cHeight = sceneObject.getHeight();

        let ratio = vHeight / cHeight;

        if ( keepRatio ) {
            changeSizesByRatio(ratio);
        } else {
            sceneObject.setHeight(Math.round(cHeight * ratio * 10) / 10, false);
            sceneObject.update();
        }

        scope._ruler3d.findRules(scope._scene.currentView3DObject);
        !isMouseDown ? scope._scene.history.saveState() : null;
    };

    scope.setCurrentModelDepth = function(vDepth, keepRatio, isMouseDown)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let cDepth = sceneObject.getDepth();

        let ratio = vDepth / cDepth;

        if ( keepRatio ) {
            changeSizesByRatio(ratio);
        } else {
            sceneObject.setDepth(Math.round(cDepth * ratio * 10) / 10, false);
            sceneObject.update();
        }

        scope._ruler3d.findRules(scope._scene.currentView3DObject);
        !isMouseDown ? scope._scene.history.saveState() : null;
    };

    scope.setCurrentModelElevation = function(vElevation, isMouseDown)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        sceneObject.y = vElevation;
        scope._ruler3d.findRules(scope._scene.currentView3DObject);
        sceneObject.update();
        !isMouseDown ? scope._scene.history.saveState() : null;
    };

    function changeSizesByRatio(r)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let objType = sceneObject.getType();

        let width = sceneObject.getWidth();
        let height = sceneObject.getHeight();
        let depth = sceneObject.getDepth();

        if (objType == 2)
        {
            width *= r;
            height *= r;
            depth *= r;
        }
        else if (objType == 3)
        {
            width *= r;
            height *= r;
        }
        else if (objType == 4)
        {
            width *= r;
            depth *= r;
        }

        let min = Math.min(width, height, depth);
        let max = 0;
        let ratio = 1;

        if ( min == 0 ) {
            min = R2D.SceneObject.OBJECT_SIZE_MIN;
        }
        if ( min < R2D.SceneObject.OBJECT_SIZE_MIN ) {
            ratio = R2D.SceneObject.OBJECT_SIZE_MIN / min;

            width *= ratio;
            height *= ratio;
            depth *= ratio;
        }

        max = Math.max(width, height, depth);

        if ( max == 0 ) {
            max = R2D.SceneObject.OBJECT_SIZE_MAX;
        }

        sceneObject.setWidth(Math.round(width * 10) / 10, true);
        sceneObject.setDepth(Math.round(depth * 10) / 10, true);
        sceneObject.setHeight(Math.round(height * 10) / 10, true);
        sceneObject.update();
    }

    scope.changeCurrentModelWidth = function(val=1, keepRatio)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let cWidth = sceneObject.getWidth();
        let ratio = (cWidth + val) / cWidth;

        if ( keepRatio ) {
            changeSizesByRatio(ratio);
        } else {
            sceneObject.setWidth(Math.round(cWidth * ratio * 10) / 10);
            sceneObject.update();
        }

        scope._ruler3d.findRules(scope._scene.currentView3DObject);
    };

    scope.changeCurrentModelHeight = function(val=1, keepRatio)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let cHeight = sceneObject.getWidth();
        let ratio = (cHeight + val) / cHeight;

        if ( keepRatio ) {
            changeSizesByRatio(ratio);
        } else {
            sceneObject.setHeight(Math.round(cHeight * ratio * 10) / 10);
            sceneObject.update();
        }

        scope._ruler3d.findRules(scope._scene.currentView3DObject);
    };

    scope.changeCurrentModelDepth = function(val=1, keepRatio)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        let cDepth = sceneObject.getWidth();
        let ratio = (cDepth + val) / cDepth;

        if ( keepRatio ) {
            changeSizesByRatio(ratio);
        } else {
            sceneObject.setDepth(Math.round(cDepth * ratio * 10) / 10);
            sceneObject.update();
        }

        scope._ruler3d.findRules(scope._scene.currentView3DObject);
    };

    scope.changeCurrentModelElevation = function(val=1, keepRatio)
    {
        let sceneObject = scope._scene.currentView3DObject?.sceneObject;
        if(!sceneObject) return;
        sceneObject.y = sceneObject.y + val;
        sceneObject.update();
    };

    scope.stopChangingModelSizes = function()
    {
        scope._scene.history.saveState();
    }

    // ------------------- Rotation 3D -------------------

    const colors = {
        orange: "#efa802",
        grey: "#3f3f3f",
        white: "#ffffff",
        black: "#000000",
        red: "#dd3737",
        green: "#b5cb38",
        blue: "#66acf4",
    };
    const segments = 64; //    4

    scope.getColors = () => colors;

    scope.getRingsObject3D = function () {
        return scope._scene3d.top.children.find(i => i.name == 'rotationRings');
    };

    scope.updateRingSize = function (ring, point, rMax) {
        const parent = ring.parent;
        ring.geometry.dispose();
        const halfThickness =
            (ring.geometry.parameters.outerRadius -
                ring.geometry.parameters.innerRadius) /
            2;
        let r = Math.sqrt(
            Math.pow(point.x - parent.position.x, 2) +
                Math.pow(point.y - parent.position.y, 2) +
                Math.pow(point.z - parent.position.z, 2)
        );
        if (r > rMax) r = rMax;
        ring.geometry = new THREE.RingGeometry(
            r - halfThickness,
            r + halfThickness,
            segments,
            1,
            0,
            2 * Math.PI
        );
        if (ring.name === "ringX") {
            ring.rotation.y = -Math.PI / 2;
        } else if (ring.name === "ringY") {
            ring.rotation.x = Math.PI / 2;
        }
    };

    scope.updateRingsDirAndZoom = function (rings3d) {
        if(!rings3d) return;
        function getRingGeometry(start, length) {
            const gap = 0.01;
            return new THREE.RingGeometry(
                innerRadius,
                outerRadius,
                segments / 4,
                1,
                start + gap,
                length - 2 * gap
            );
        }

        function getTorusGeometry() {
            const radius = innerRadius + thickness / 2;
            const tube = sens;
            return new THREE.TorusGeometry(radius, tube, 4, 8, Math.PI / 2);
        }

        function getAxisGeometry() {
            return new THREE.CylinderGeometry(
                axisThickness,
                axisThickness,
                axisLen,
                8
            );
        }

        const cameraPos = scope._currentCamera.position;
        const objectPos = scope._scene.currentView3DObject.object3d.position;
        let distToCamera = 0;

        if (scope._currentViewer.getType() === "2d") {
            distToCamera = (1 - scope._currentViewer.getViewStateData().camera.zoom) * 1250;
        } else {
            distToCamera = Math.sqrt(
                Math.pow(cameraPos.x - objectPos.x, 2) +
                    Math.pow(cameraPos.y - objectPos.y, 2) +
                    Math.pow(cameraPos.z - objectPos.z, 2)
            );
        }
        
        const dir = new THREE.Vector3()
            .subVectors(cameraPos, objectPos)
            .setLength(distToCamera / 50);

        const thickness = distToCamera / 400;
        const innerRadius = distToCamera / 10;
        const outerRadius = innerRadius + thickness;
        const axisLen = innerRadius / 1.5;
        const axisThickness = distToCamera / 1800;
        const sens = distToCamera / 150;

        const axisX = rings3d.getObjectByName("axisX");
        const axisY = rings3d.getObjectByName("axisY");
        const axisZ = rings3d.getObjectByName("axisZ");

        const ringX = rings3d.getObjectByName("ringX");
        const ringY = rings3d.getObjectByName("ringY");
        const ringZ = rings3d.getObjectByName("ringZ");
        const ringXHelper = rings3d.getObjectByName("ringXHelper");
        const ringYHelper = rings3d.getObjectByName("ringYHelper");
        const ringZHelper = rings3d.getObjectByName("ringZHelper");

        const sphere = rings3d.getObjectByName("sphereRings");

        ringX.geometry.dispose();
        ringY.geometry.dispose();
        ringZ.geometry.dispose();
        ringXHelper.geometry.dispose();
        ringYHelper.geometry.dispose();
        ringZHelper.geometry.dispose();
        axisX.geometry.dispose();
        axisY.geometry.dispose();
        axisZ.geometry.dispose();
        sphere.geometry.dispose();

        axisY.geometry = getAxisGeometry();
        axisY.position.set(0, axisLen / 2, 0);

        sphere.geometry = new THREE.SphereGeometry(thickness * 2, 32, 32);

        if (cameraPos.x > objectPos.x && cameraPos.z > objectPos.z) {
            ringX.geometry = getRingGeometry(0, Math.PI / 2);
            ringY.geometry = getRingGeometry(0, Math.PI / 2);
            ringZ.geometry = getRingGeometry(0, Math.PI / 2);

            ringXHelper.geometry = getTorusGeometry();
            ringXHelper.rotation.y = -Math.PI / 2;
            ringYHelper.geometry = getTorusGeometry();
            ringYHelper.rotation.x = Math.PI / 2;
            ringYHelper.rotation.z = 0;
            ringZHelper.geometry = getTorusGeometry();
            ringZHelper.rotation.z = 0;

            axisX.geometry = getAxisGeometry();
            axisX.rotation.z = Math.PI / 2;
            axisX.position.set(axisLen / 2, 0, 0);

            axisZ.geometry = getAxisGeometry();
            axisZ.rotation.x = Math.PI / 2;
            axisZ.position.set(0, 0, axisLen / 2);
        } else if (cameraPos.x > objectPos.x && cameraPos.z < objectPos.z) {
            ringX.geometry = getRingGeometry(Math.PI / 2, Math.PI / 2);
            ringY.geometry = getRingGeometry((3 * Math.PI) / 2, Math.PI / 2);
            ringZ.geometry = getRingGeometry(0, Math.PI / 2);

            ringXHelper.geometry = getTorusGeometry();
            ringXHelper.rotation.y = Math.PI / 2;
            ringYHelper.geometry = getTorusGeometry();
            ringYHelper.rotation.x = -Math.PI / 2;
            ringYHelper.rotation.z = 0;
            ringZHelper.geometry = getTorusGeometry();
            ringZHelper.rotation.z = 0;

            axisX.geometry = getAxisGeometry();
            axisX.rotation.z = Math.PI / 2;
            axisX.position.set(axisLen / 2, 0, 0);

            axisZ.geometry = getAxisGeometry();
            axisZ.rotation.x = Math.PI / 2;
            axisZ.position.set(0, 0, -axisLen / 2);
        } else if (cameraPos.x < objectPos.x && cameraPos.z < objectPos.z) {
            ringX.geometry = getRingGeometry(Math.PI / 2, Math.PI / 2);
            ringY.geometry = getRingGeometry(Math.PI, Math.PI / 2);
            ringZ.geometry = getRingGeometry(Math.PI / 2, Math.PI / 2);

            ringXHelper.geometry = getTorusGeometry();
            ringXHelper.rotation.y = Math.PI / 2;
            ringYHelper.geometry = getTorusGeometry();
            ringYHelper.rotation.x = -Math.PI / 2;
            ringYHelper.rotation.z = Math.PI / 2;
            ringZHelper.geometry = getTorusGeometry();
            ringZHelper.rotation.z = Math.PI / 2;

            axisX.geometry = getAxisGeometry();
            axisX.rotation.z = Math.PI / 2;
            axisX.position.set(-axisLen / 2, 0, 0);

            axisZ.geometry = getAxisGeometry();
            axisZ.rotation.x = Math.PI / 2;
            axisZ.position.set(0, 0, -axisLen / 2);
        } else if (cameraPos.x < objectPos.x && cameraPos.z > objectPos.z) {
            ringX.geometry = getRingGeometry(0, Math.PI / 2);
            ringY.geometry = getRingGeometry(Math.PI / 2, Math.PI / 2);
            ringZ.geometry = getRingGeometry(Math.PI / 2, Math.PI / 2);

            ringXHelper.geometry = getTorusGeometry();
            ringXHelper.rotation.y = -Math.PI / 2;
            ringYHelper.geometry = getTorusGeometry();
            ringYHelper.rotation.x = Math.PI / 2;
            ringYHelper.rotation.z = Math.PI / 2;
            ringZHelper.geometry = getTorusGeometry();
            ringZHelper.rotation.z = Math.PI / 2;

            axisX.geometry = getAxisGeometry();
            axisX.rotation.z = Math.PI / 2;
            axisX.position.set(-axisLen / 2, 0, 0);

            axisZ.geometry = getAxisGeometry();
            axisZ.rotation.x = Math.PI / 2;
            axisZ.position.set(0, 0, axisLen / 2);
        }

        if (scope._currentViewer.getType() === "2d") {
            axisX.geometry = new THREE.BufferGeometry();
            axisY.geometry = new THREE.BufferGeometry();
            axisZ.geometry = new THREE.BufferGeometry();
            ringX.visible = false;
            ringZ.visible = false;
            ringXHelper.geometry = new THREE.BufferGeometry();
            ringZHelper.geometry = new THREE.BufferGeometry();
           
            const {
                innerRadius: iR,
                outerRadius: oR,
                thetaSegments: tS,
            } = ringY.geometry.parameters;
            ringY.geometry.dispose();
            const newGeometryY = new THREE.RingGeometry(iR, oR, tS * 4);
            ringY.geometry = newGeometryY;
            const {
                radius,
                tube,
                radialSegments,
                tubularSegments,
            } = ringYHelper.geometry.parameters;
            ringYHelper.geometry.dispose();
            const newGeometryYHelper = new THREE.TorusGeometry(
                radius,
                tube,
                radialSegments * 2,
                tubularSegments * 2,
                Math.PI * 2,
            );
            ringYHelper.geometry = newGeometryYHelper;
        }
    };

    scope.createRings3D = function () {
        if(!R2D.scene.currentSceneObject) return;
        const rings = new THREE.Object3D();
        rings.name = "rotationRings";
        rings.position.set(
            R2D.scene.currentSceneObject.x,
            R2D.scene.currentSceneObject.y,
            R2D.scene.currentSceneObject.z
        );
        // axis X
        const axisXMaterial = new THREE.MeshBasicMaterial({
            color: colors.red,
            depthWrite: false,
        });
        const axisXGeometry = new THREE.CylinderGeometry();
        const axisX = new THREE.Mesh(axisXGeometry, axisXMaterial);
        axisX.name = "axisX";
        // axis Y
        const axisYMaterial = new THREE.MeshBasicMaterial({
            color: colors.green,
            depthWrite: false,
        });
        const axisYGeometry = new THREE.CylinderGeometry();
        const axisY = new THREE.Mesh(axisYGeometry, axisYMaterial);
        axisY.name = "axisY";
        // axisZ
        const axisZMaterial = new THREE.MeshBasicMaterial({
            color: colors.blue,
            depthWrite: false,
        });
        const axisZGeometry = new THREE.CylinderGeometry();
        const axisZ = new THREE.Mesh(axisZGeometry, axisZMaterial);
        axisZ.name = "axisZ";
        // ring X
        const geometryX = new THREE.RingGeometry();
        const materialX = new THREE.MeshBasicMaterial({
            color: colors.orange,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
        });
        const ringX = new THREE.Mesh(geometryX, materialX);
        ringX.name = "ringX";
        ringX.rotation.y = -Math.PI / 2;
        // ring Y
        const geometryY = new THREE.RingGeometry();
        const materialY = new THREE.MeshBasicMaterial({
            color: colors.orange,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
        });
        const ringY = new THREE.Mesh(geometryY, materialY);
        ringY.name = "ringY";
        ringY.rotation.x = Math.PI / 2;
        // ring Z
        const geometryZ = new THREE.RingGeometry();
        const materialZ = new THREE.MeshBasicMaterial({
            color: colors.orange,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
        });
        const ringZ = new THREE.Mesh(geometryZ, materialZ);
        ringZ.name = "ringZ";
        // ring X helper
        const materialHelper = new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0,
            depthWrite: false,
        });
        const geometryXHelper = new THREE.TorusGeometry();
        const ringXHelper = new THREE.Mesh(
            geometryXHelper,
            materialHelper,
        );
        ringXHelper.name = "ringXHelper";
        // ring Y helper
        const geometryYHelper = new THREE.TorusGeometry();
        const ringYHelper = new THREE.Mesh(
            geometryYHelper,
            materialHelper,
        );
        ringYHelper.name = "ringYHelper";
        // ring Z helper
        const geometryZHelper = new THREE.TorusGeometry();
        const ringZHelper = new THREE.Mesh(
            geometryZHelper,
            materialHelper,
        );
        ringZHelper.name = "ringZHelper";
        // sphere
        const sphereGeom = new THREE.SphereGeometry(7, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({
            color: colors.orange,
        });
        const sphere = new THREE.Mesh(sphereGeom, sphereMat);
        sphere.name = "sphereRings";
        sphere.visible = false;
        sphere.position.set(800, 800, 0);

        rings.add(axisX);
        rings.add(axisY);
        rings.add(axisZ);
        rings.add(ringX);
        rings.add(ringY);
        rings.add(ringZ);
        rings.add(ringXHelper);
        rings.add(ringYHelper);
        rings.add(ringZHelper);
        rings.add(sphere);

        scope.updateRingsDirAndZoom(rings);
        return rings;
    };

    scope.createHelperPlanes = function () {
        const materialPlane = new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0,
            depthWrite: false,
        });
        // helper plane x
        const geometryXPlane = new THREE.PlaneGeometry(2000, 2000);
        const planeX = new THREE.Mesh(geometryXPlane, materialPlane);
        planeX.name = "planeX";
        planeX.rotation.y = -Math.PI / 2;
        // helper plane y
        const geometryYPlane = new THREE.PlaneGeometry(2000, 2000);
        const planeY = new THREE.Mesh(geometryYPlane, materialPlane);
        planeY.name = "planeY";
        planeY.rotation.x = Math.PI / 2;
        // helper plane z
        const geometryZPlane = new THREE.PlaneGeometry(2000, 2000);
        const planeZ = new THREE.Mesh(geometryZPlane, materialPlane);
        planeZ.name = "planeZ";

        return { planeX, planeY, planeZ };
    };

    scope.helperPlanes = scope.createHelperPlanes();

    scope.formatSprite = function (createNew, text, sprite, isHover) {
        const lineWidth = 16;
        const fontSize = 140;
        const canvas = document.createElement("canvas");
        canvas.width = 430;
        canvas.height = 290;
        const ctx = canvas.getContext("2d");
        ctx.font = `${fontSize}px arial`;
        ctx.lineWidth = lineWidth;

        if (createNew) {
            ctx.fillStyle = colors.white;
            ctx.strokeStyle = colors.grey;
        } else if (isHover) {
            ctx.fillStyle = colors.orange;
            ctx.strokeStyle = colors.orange;
        } else {
            ctx.fillStyle = colors.white;
            ctx.strokeStyle = colors.grey;
        }
        ctx.beginPath();
        ctx.roundRect(
            lineWidth / 2,
            lineWidth / 2,
            canvas.width - lineWidth,
            canvas.height - lineWidth,
            40
        );
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.fillStyle = colors.black;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 12);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        if (createNew) {
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                depthWrite: false,
            });
            const newSprite = new THREE.Sprite(spriteMaterial);
            newSprite.name = "button_ok";
            return newSprite;
        } else {
            sprite.material.map = texture;
        }
    };

};

R2D.MouseInteractionHelper._instance = null;

R2D.MouseInteractionHelper.init = (commonSceneObject, commonSceneHelper, apiDispatcher) => {
    
    R2D.MouseInteractionHelper._instance = new R2D.MouseInteractionHelper(commonSceneObject, commonSceneHelper, apiDispatcher)
    return R2D.MouseInteractionHelper._instance;
};

R2D.MouseInteractionHelper.mousedown = e => R2D.MouseInteractionHelper._instance.leftMouseDownListener(e);
R2D.MouseInteractionHelper.mouseup = e => R2D.MouseInteractionHelper._instance.leftMouseUpListener(e);
R2D.MouseInteractionHelper.mousemove = e => R2D.MouseInteractionHelper._instance.leftMouseMoveListener(e);

extend(R2D.MouseInteractionHelper, EventDispatcher);

R2D.MouseInteractionHelper.STATE_CHANGED = 'MIHStateChanged';

R2D.MIH = {};
R2D.MIH.BaseState = function(mih)
{
    var me = this;
    me.name = '';

    me.start = function()
    {

    };

    me.stop = function()
    {

    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {

    };

    me.mouseUp = function()
    {

    };

};

R2D.MIH.StateMain = function (mih) {
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = "stateMain";

    var maxMoveDist = 5;
    var downPos = null;

    var isSelectingModel = true;

    me.setIsSelectingModel = function (value) {
        isSelectingModel = value;
    };

    me.start = function () {};

    me.stop = function () {
        downPos = null;
    };

    me.mouseDown = function (e) {
        //downPos = R2D.Renderer3D.getMousePointForPicker(mih.getCanvas(), e.clientX, e.clientY);
        downPos = new TR.Point(e.clientX, e.clientY);
    };

    me.mouseMove = function (e) {
        //console.log('move, ', e.clientX, e.clientY);

        if (R2D.Viewers.getCurrentViewerType() == "walk" && e.buttons == 0) {
            var point = R2D.Renderer3D.getMousePointForPicker(
                mih._currentCanvas,
                e.clientX,
                e.clientY
            );
            mih._currentViewer.updateCursor(point.x, point.y);
        }
    };

    me.mouseUp = function (e) {
        if (!isSelectingModel) return;
        if (!downPos) return;
        var upPos = new TR.Point(e.clientX, e.clientY);
        if (TR.euclDistP(upPos, downPos) > maxMoveDist) return;

        var objectData = mih.find3DObject(e.clientX, e.clientY);
        //objectData.view3DObject - [R2D.ObjectViewer3DModel] or [R2D.ObjectConstructor3DWall, Floor...]

        if (R2D.Viewers.getCurrentViewerType() == "walk") {
            if (objectData)
                R2D.viewWalk.cameraJump(objectData.point.x, objectData.point.z);
        } else {
            if (objectData && objectData.view3DObject) {
                //R2D.ObjectViewer3DModel
                if (objectData.view3DObject.objectType == "product") {
                    if (objectData.view3DObject.group) {
                        mih.setActiveGroup(
                            objectData.view3DObject.group,
                            e.clientX,
                            e.clientY
                        );
                        mih.changeState(mih.stateSelectedGroup);
                        return {
                            state: "stateSelectedGroup",
                            quickPanel: { x: e.clientX, y: e.clientY },
                        };
                    } else {
                        mih.setActiveObjectProduct(
                            objectData.view3DObject,
                            e.clientX,
                            e.clientY,
                            objectData
                        );
                        mih.changeState(mih.stateSelectedProduct);
                        return {
                            state: "stateSelectedProduct",
                            quickPanel: { x: e.clientX, y: e.clientY },
                        };
                    }
                } else if (objectData.view3DObject.objectType == "constructor") {
                    let result = mih.setActiveObjectConstructor(
                        objectData.view3DObject,
                        e.clientX,
                        e.clientY,
                        objectData
                    );
                    mih.changeState(mih.stateSelectedConstr);
                    return result;
                }
            }
            else if(mih._scene3d.customRulers.getSelectedRuler()) {
                mih._scene3d.customRulers.clearSelectedRuler();
                mih.api.dispatchEvent(new Event(mih.api.QUICK_PANELS_HIDE, {}));
            }
            
        }
    };
};

R2D.MIH.StateMain.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateMain.prototype.constructor = R2D.MIH.StateMain;

R2D.MIH.StateCreatingRuler = function(mih)
{
    var me = this;
    me.name = 'stateCreatingRuler';

    me.start = function()
    {
        mih._customRulers.addRuler();
    };

    me.stop = function()
    {
        mih._customRulers._cancel();
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {

    };

    me.mouseUp = function(e)
    {
        mih._customRulers.addPoint(e.clientX, e.clientY);
        if (! mih._customRulers.isCreating()) mih.changeState(mih.stateMain);
    };

};


R2D.MIH.StateDraggingProduct = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateDraggingProduct';

    var oldPosition = null;
    var pointIntersect = null;

    me.start = function()
    {
        mih.updateSnap2d();
    };

    me.stop = function()
    {

    };

    me.mouseDown = function(e)
    {

    };

    me.mouseMove = function(e)
    {
        moveProduct(e);
    };

    me.mouseUp = function(e)
    {
        stopDraggingProduct();
    };

    function createRings () {
        if(!mih._scene.isRotation3dActive) return;
        const rings = mih.createRings3D();
        R2D.scene3d.add(rings, "top");
         
        mih._currentViewer.rendererUpdate();
    }

    me.startDraggingProduct = function(x, y, z)
    {
        if(!mih._scene.currentView3DObject || !mih._scene.currentView3DObject.sceneObject) return;
        mih._object3DMoving.position.set(x, y, z);

        mih._currentViewer.rendererUpdate();

        oldPosition = {
            x:mih._scene.currentView3DObject.sceneObject.x,
            y:mih._scene.currentView3DObject.sceneObject.y,
            z:mih._scene.currentView3DObject.sceneObject.z
        };

        if (mih._scene.currentView3DObject.type == R2D.ProductType.MODEL && mih._scene.currentView3DObject.forWall ) {
            mih._constructor.pickElement(mih._scene.currentView3DObject.sceneObject.objectId);
        }

        mih._mouseController.disable();
        mih._touchController.disable();

        mih._currentViewer.rendererUpdate();

        //mih._quickPanelHelper.hideQuickPanel();
        //updateSnap2d();
    };

    function stopDraggingProduct()
    {
        if(!mih._scene.currentView3DObject) return;
        mih._object3DMoving.scale.set(1, 1, 1);
        //mih._object3DMoving.position.set(0, -100, 0);

        //mih._scene3d.remove(mih._scene.currentView3DObject.object3d);
        //mih._ruler3d.clear();
        mih._currentViewer.rendererUpdate();

        pointIntersect = null;
        oldPosition = null;

        mih._mouseController.enable();
        mih._touchController.enable();

        // --

        if (mih._scene.currentView3DObject.type == R2D.ProductType.MODEL)
        {
            //page.setFreeSpace(ruler3d.distances);
        }

        if (mih._scene.currentView3DObject.forWall)
        {
            let dropData = R2D.Scene.getObjectDataForWallElement(mih._scene.currentView3DObject.sceneObject);
            let dropResult = mih._constructor.dropElement(dropData, 10);

            if ( dropResult )
            {
                R2D.Scene.setDropDataToWallElement(mih._scene.currentView3DObject.sceneObject, dropResult);
                //mih._scene.add(mih._scene.currentView3DObject.sceneObject);

                createRings();

                mih.changeState(mih.stateSelectedProduct);
            }
            else
            {
                let view3dObject = mih._scene.currentView3DObject;

                mih.unsetActiveObject();
                mih._scene.remove(view3dObject.sceneObject);
                mih.api.dispatchEvent(new Event(mih.api.OBJECT_DRAG_OUT_OF_WALL, {}));
            }
        }
        else
        {
            createRings();
            mih.changeState(mih.stateSelectedProduct);
        }

        mih._scene.history.saveState();
        mih.updateFreeSpace();
        mih.api.dispatchEvent(new Event(mih.api.HISTORY_UNDO_REDO, {}));
    }

    function moveProduct(event) {
        if(!mih._scene.currentView3DObject) return;
        var sceneObject = mih._scene.currentView3DObject.sceneObject;

        if (sceneObject.type == R2D.ProductType.POSTER || checkAsSmartMoving(sceneObject))
        {
            moveObjectSmart(mih._scene.currentView3DObject, event.clientX, event.clientY);
        }
        else
        {
            moveObjectHorizontal(mih._scene.currentView3DObject, event.clientX, event.clientY, !event.ctrlKey);
        }

        mih._ruler3d.findRules(mih._scene.currentView3DObject);

        function checkAsSmartMoving(sceneObject) {
            var max = Math.max(sceneObject.width, sceneObject.height, sceneObject.depth);
            var min = Math.min(sceneObject.width, sceneObject.height, sceneObject.depth);

            return max / min < 15 && sceneObject.volume < 30000;
        }
    }

    var oldSnapObj = null;

    function moveObjectHorizontal(view3DObject, mx, my, useSnap)
    {
        var scrPoint = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, mx, my);
        var intersection = mih._scene3d.intersectWithObject(mih._currentCamera, scrPoint.x, scrPoint.y, mih._object3DMoving);

        var intersectWalls = mih._scene3d.objectUnderCursor(mih._commonSceneObject.constructorWalls, mih._currentCamera, scrPoint.x, scrPoint.y, view3DObject.object3d);

        if (view3DObject.type == R2D.ProductType.MODEL && view3DObject.getForWall())
        {
            if (intersectWalls) intersection = intersectWalls;
        }

        if ( !pointIntersect )
        {
            if ( !intersection ) return;
            pointIntersect = intersection.point;  // intersection where moving start
        }
        else if ( !oldPosition )
        {
            oldPosition = {
                x:pointIntersect.x,
                y:pointIntersect.y,
                z:pointIntersect.z
            };
        }
        else
        {
            if ( !intersection ) return;
            var sceneObject = view3DObject.sceneObject;

            var position = {
                x:intersection.point.x + oldPosition.x - pointIntersect.x,
                y:intersection.point.z + oldPosition.z - pointIntersect.z
            };

            if ( view3DObject.type == R2D.ProductType.MODEL && view3DObject.getForWall())
            {
                var snapObject = mih._constructor.moveElement(position, 20);

                if (! snapObject || ! oldSnapObj || snapObject.rotation != oldSnapObj.rotation)
                {
                    position = {x:intersection.point.x, y:intersection.point.z};
                    snapObject = mih._constructor.moveElement(position, 20);
                }

                oldSnapObj = snapObject;

                if ( snapObject ) {
                    R2D.Scene.setDropDataToWallElement(sceneObject, snapObject);
                } else {
                    sceneObject.x = position.x;
                    sceneObject.z = position.y;
                    sceneObject.depth = sceneObject.defaultDepth;
                }
            }
            else if (useSnap && view3DObject.type == R2D.ProductType.MODEL)
            {
                var objectPoints = GEOM.Point.shiftPoints(new GEOM.Point(position.x, position.y), GEOM.Point.rotatePoints(sceneObject.get2DRectPoints(), -GEOM.toRad(sceneObject.rotationY)));

                var shiftPoint = new GEOM.Point(0,0);

                shiftPoint = useSnap ? mih._snap2d.snapPolygon(objectPoints, shiftPoint, sceneObject.getHeight()) : new GEOM.Point(0,0);

                sceneObject.x = position.x - (shiftPoint ? shiftPoint.x : 0);
                sceneObject.z = position.y - (shiftPoint ? shiftPoint.y : 0);
            } else {
                sceneObject.x = position.x;
                sceneObject.z = position.y;
            }

            //       
            // if (view3DObject.getObject3d().parent.type === "Group") {
            //     view3DObject.getObject3d().parent.children[0].position.x = sceneObject.x;
            //     view3DObject.getObject3d().parent.children[0].position.z = sceneObject.z;
            // }

            sceneObject.update();

            //updateBoxSelected(scene.currentView3DObject);

            mih._currentViewer.rendererUpdate();
        }
    }

    function moveObjectSmart(view3DObject, mx, my) {
        if(!mih._scene.currentView3DObject) return;
        var point = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, mx, my);
        var intersect = mih._scene3d.objectUnderCursor(mih._commonSceneObject.interactiveObjects, mih._currentCamera, point.x, point.y, view3DObject.object3d);

        if ( intersect == null ) return;

        var sceneObject = view3DObject.sceneObject;
        var intersectSceneObject = mih._productHelper.findObjectView3DByObject3D(intersect.object);
        var intersectSceneObjectRotationY = intersectSceneObject ? G.toRad(intersectSceneObject.sceneObject.rotationY) : 0;
        var iPoint = intersect.point;
        if (! pointIntersect) pointIntersect = iPoint;
        var iNormal = intersect.face.normal;
        var vectorPoint = new G.V(iPoint.x, iPoint.y, iPoint.z);
        var vectorNormal = new G.V(iNormal.x, iNormal.y, iNormal.z).rotateByY(intersectSceneObjectRotationY);
        var boundsPoints = view3DObject.getVectorsSides();
        var shiftPoint = G.shiftVectors(vectorPoint, vectorNormal, boundsPoints);
        var positionPoint = G.V.sum(vectorPoint, shiftPoint);

        sceneObject.x = positionPoint.x;
        sceneObject.y = positionPoint.y;
        sceneObject.z = positionPoint.z;

        if (mih._scene.currentView3DObject.sceneObject.type == R2D.ProductType.POSTER)
        {
            sceneObject.rotationY = TR.radToDeg(Math.atan2(vectorNormal.x, vectorNormal.z));
            if (oldPosition) sceneObject.y = sceneObject.y - pointIntersect.y + oldPosition.y;
        }
        else if (mih._scene.currentView3DObject.sceneObject.type == R2D.ProductType.MODEL)
        {
            // sceneObject.rotationY = TR.radToDeg(Math.atan2(vectorNormal.x, vectorNormal.z));
        }

        sceneObject.update();

        mih._currentViewer.rendererUpdate();

        mih.api.dispatchEvent(new Event(mih.api.OBJECT_SMART_MOVE, {elevation: sceneObject.y}));
    }
};

R2D.MIH.StateDraggingProduct.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateDraggingProduct.prototype.constructor = R2D.MIH.StateDraggingProduct;




R2D.MIH.StateDraggingMaterial = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateDraggingMaterial';

    me.prevState = null;

    me.start = function()
    {

    };

    me.stop = function()
    {

    };

    me.mouseDown = function(e)
    {

    };

    me.mouseMove = function(e)
    {
        mih._materialPreviewDrag.setPosition(e.clientX, e.clientY);
    };

    me.mouseUp = function(e)
    {
        var point = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, e.clientX, e.clientY);
        var objectUnderCursor = mih._scene3d.objectUnderCursor(mih._commonSceneObject.interactiveObjects, mih._currentCamera, point.x, point.y);
        var constructorObject3d = objectUnderCursor ? mih._constructorHelper.findObjectView3DByObject3D(objectUnderCursor.object) : null;
        var partNum = 0;
        if (objectUnderCursor && objectUnderCursor.object && objectUnderCursor.object.num) partNum = objectUnderCursor.object.num;

        if ( constructorObject3d ) {
            //constructorObject3d.setMaterial(mih._materialPreviewDrag.productId, partNum);
            constructorObject3d.setMaterial(mih.draggingMaterialId, partNum);
            constructorObject3d.setAddMaterial(mih.draggingAddMaterialId || "", partNum);

            mih.draggingAddMaterialId = "";

            constructorObject3d.update();
            mih._scene.history.saveState();
            mih._currentViewer.rendererUpdate();
            mih.api.dispatchEvent(new Event(mih.api.HISTORY_UNDO_REDO, {}));
        }
        
        if(mih._currentTools && mih._materialPreviewDrag && mih._currentTools.contains(mih._materialPreviewDrag.domElement)) mih._currentTools.removeChild(mih._materialPreviewDrag.domElement);

        mih.changeState(me.prevState);
        me.prevState = null;
    };
};

R2D.MIH.StateDraggingMaterial.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateDraggingMaterial.prototype.constructor = R2D.MIH.StateDraggingMaterial;

R2D.MIH.StateDraggingProdFromCatalog = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateDraggingProdFromCatalog';

    var oldPosition = null;
    var pointIntersect = null;

    me.view3DObject = null;

    me.start = function()
    {
        mih.updateSnap2d();
        mih.unsetActiveGroup();
        mih.unsetActiveObject();
    };

    me.stop = function()
    {
        me.view3DObject = null;
    };

    me.mouseDown = function(e)
    {

    };

    me.mouseMove = function(e)
    {
        moveProduct(e);
    };

    me.mouseUp = function(e)
    {
        stopDraggingProduct();
        mih.changeState(mih.stateMain);
    };

    function stopDraggingProduct()
    {
        if(!me.view3DObject) return;
        mih._object3DMoving.scale.set(1, 1, 1);
        //mih._object3DMoving.position.set(0, -100, 0);

        mih._ruler3d.clear();
        mih._currentViewer.rendererUpdate();

        pointIntersect = null;
        oldPosition = null;

        mih._mouseController.enable();
        mih._touchController.enable();

        if (me.view3DObject.forWall)
        {
            let dropData = R2D.Scene.getObjectDataForWallElement(me.view3DObject.sceneObject);
            let dropResult = mih._constructor.dropElement(dropData, 10);

            if ( dropResult )
            {
                R2D.Scene.setDropDataToWallElement(me.view3DObject.sceneObject, dropResult);
                //mih._scene.add(mih._scene.currentView3DObject.sceneObject);
            }
            else
            {
                let view3dObject = me.view3DObject;
                mih._scene.remove(view3dObject.sceneObject);
            }
        }

        mih._scene.history.saveState();
        mih.api.dispatchEvent(new Event(mih.api.HISTORY_UNDO_REDO, {}));
    }

    function moveProduct(event)
    {
        if(!me.view3DObject) return;
        var sceneObject = me.view3DObject.sceneObject;

        if (sceneObject.type == R2D.ProductType.POSTER || checkAsSmartMoving(sceneObject))
        {
            moveObjectSmart(me.view3DObject, event.clientX, event.clientY);
        }
        else if (sceneObject.type == R2D.ProductType.MODEL && ! sceneObject.forWall)
        {
            moveObjectSmartFromCatalog(me.view3DObject, event.clientX, event.clientY, !event.ctrlKey);
        }
        else
        {
            moveObjectHorizontal(me.view3DObject, event.clientX, event.clientY, !event.ctrlKey);
        }

        mih._ruler3d.findRules(me.view3DObject);

        function checkAsSmartMoving(sceneObject) {
            var max = Math.max(sceneObject.width, sceneObject.height, sceneObject.depth);
            var min = Math.min(sceneObject.width, sceneObject.height, sceneObject.depth);

            return max / min < 15 && sceneObject.volume < 30000;
        }
    }

    var oldSnapObj = null;

    function moveObjectHorizontal(view3DObject, mx, my, useSnap)
    {
        var scrPoint = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, mx, my);
        var intersection = mih._scene3d.intersectWithObject(mih._currentCamera, scrPoint.x, scrPoint.y, mih._object3DMoving);

        var intersectWalls = mih._scene3d.objectUnderCursor(mih._commonSceneObject.constructorWalls, mih._currentCamera, scrPoint.x, scrPoint.y, view3DObject.object3d);

        if (view3DObject.type == R2D.ProductType.MODEL && view3DObject.getForWall())
        {
            if (intersectWalls) intersection = intersectWalls;
        }

        if ( !pointIntersect )
        {
            if ( !intersection ) return;
            pointIntersect = intersection.point;  // intersection where moving start
        }
        else if ( !oldPosition )
        {
            oldPosition = {
                x:pointIntersect.x,
                y:pointIntersect.y,
                z:pointIntersect.z
            };
        }
        else
        {
            if ( !intersection ) return;
            var sceneObject = view3DObject.sceneObject;

            var position = {
                x:intersection.point.x + oldPosition.x - pointIntersect.x,
                y:intersection.point.z + oldPosition.z - pointIntersect.z
            };

            if ( view3DObject.type == R2D.ProductType.MODEL && view3DObject.getForWall())
            {
                var snapObject = mih._constructor.moveElement(position, 20);

                if (! snapObject || ! oldSnapObj || snapObject.rotation != oldSnapObj.rotation)
                {
                    position = {x:intersection.point.x, y:intersection.point.z};
                    snapObject = mih._constructor.moveElement(position, 20);
                }

                oldSnapObj = snapObject;

                if ( snapObject ) {
                    R2D.Scene.setDropDataToWallElement(sceneObject, snapObject);
                } else {
                    sceneObject.x = position.x;
                    sceneObject.z = position.y;
                    sceneObject.depth = sceneObject.defaultDepth;
                }
            }
            else if (useSnap && view3DObject.type == R2D.ProductType.MODEL)
            {
                var objectPoints = GEOM.Point.shiftPoints(new GEOM.Point(position.x, position.y), GEOM.Point.rotatePoints(sceneObject.get2DRectPoints(), -GEOM.toRad(sceneObject.rotationY)));
                var shiftPoint = new GEOM.Point(0,0);

                shiftPoint = useSnap ? mih._snap2d.snapPolygon(objectPoints, shiftPoint, sceneObject.getHeight()) : new GEOM.Point(0,0);

                sceneObject.x = position.x - (shiftPoint ? shiftPoint.x : 0);
                sceneObject.z = position.y - (shiftPoint ? shiftPoint.y : 0);
            } else {
                sceneObject.x = position.x;
                sceneObject.z = position.y;
            }

            sceneObject.update();

            mih._currentViewer.rendererUpdate();
        }
    }

    function moveObjectSmart(view3DObject, mx, my) {
        var point = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, mx, my);
        var intersect = mih._scene3d.objectUnderCursor(mih._commonSceneObject.interactiveObjects, mih._currentCamera, point.x, point.y, view3DObject.object3d);

        if ( intersect == null ) return;

        var sceneObject = view3DObject.sceneObject;
        var intersectSceneObject = mih._productHelper.findObjectView3DByObject3D(intersect.object);
        var intersectSceneObjectRotationY = intersectSceneObject ? G.toRad(intersectSceneObject.sceneObject.rotationY) : 0;
        var iPoint = intersect.point;
        if (! pointIntersect) pointIntersect = iPoint;
        var iNormal = intersect.face.normal;
        var vectorPoint = new G.V(iPoint.x, iPoint.y, iPoint.z);
        var vectorNormal = new G.V(iNormal.x, iNormal.y, iNormal.z).rotateByY(intersectSceneObjectRotationY);
        var boundsPoints = view3DObject.getVectorsSides();
        var shiftPoint = G.shiftVectors(vectorPoint, vectorNormal, boundsPoints);
        var positionPoint = G.V.sum(vectorPoint, shiftPoint);

        sceneObject.x = positionPoint.x;
        sceneObject.y = positionPoint.y;
        sceneObject.z = positionPoint.z;

        if (sceneObject.type == R2D.ProductType.POSTER)
        {
            sceneObject.rotationY = TR.radToDeg(Math.atan2(vectorNormal.x, vectorNormal.z));
            if (oldPosition) sceneObject.y = sceneObject.y - pointIntersect.y + oldPosition.y;
        }
        else if (sceneObject.type == R2D.ProductType.MODEL)
        {
            // sceneObject.rotationY = TR.radToDeg(Math.atan2(vectorNormal.x, vectorNormal.z));
        }

        sceneObject.update();

        mih._currentViewer.rendererUpdate();
    }

    function moveObjectSmartFromCatalog(view3DObject, mx, my, useSnap)
    {
        var point = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, mx, my);
        var intersect = mih._scene3d.objectUnderCursor(mih._commonSceneObject.constructorWalls, mih._currentCamera, point.x, point.y, view3DObject.object3d);

        if ( intersect == null )
        {
            setDefaultRotation(view3DObject.sceneObject);
            moveObjectHorizontal(view3DObject, mx, my, useSnap);
            return;
        }

        var sceneObject = view3DObject.sceneObject;
        var intersectSceneObject = mih._productHelper.findObjectView3DByObject3D(intersect.object);
        var intersectSceneObjectRotationY = intersectSceneObject ? G.toRad(intersectSceneObject.sceneObject.rotationY) : 0;
        var iPoint = intersect.point;
        if (! pointIntersect) pointIntersect = iPoint;
        var iNormal = intersect.face.normal;
        var vectorPoint = new G.V(iPoint.x, iPoint.y, iPoint.z);
        var vectorNormal = new G.V(iNormal.x, iNormal.y, iNormal.z).rotateByY(intersectSceneObjectRotationY);
        var boundsPoints = view3DObject.getVectorsSides();
        var shiftPoint = G.shiftVectors(vectorPoint, vectorNormal, boundsPoints);
        var positionPoint = G.V.sum(vectorPoint, shiftPoint);

        sceneObject.x = positionPoint.x;
        //    sceneObject.y = positionPoint.y;
        sceneObject.z = positionPoint.z;

        sceneObject.rotationY = TR.radToDeg(Math.atan2(vectorNormal.x, vectorNormal.z));

        if (useSnap)
        {
            var objectPoints = GEOM.Point.shiftPoints(new GEOM.Point(sceneObject.x, sceneObject.z), GEOM.Point.rotatePoints(sceneObject.get2DRectPoints(), -GEOM.toRad(sceneObject.rotationY)));
            shiftPoint = new GEOM.Point(0, 0);

            shiftPoint = useSnap ? mih._snap2d.snapPolygon(objectPoints, shiftPoint, sceneObject.getHeight()) : new GEOM.Point(0, 0);

            sceneObject.x = sceneObject.x - (shiftPoint ? shiftPoint.x : 0);
            sceneObject.z = sceneObject.z - (shiftPoint ? shiftPoint.y : 0);
        }


        sceneObject.update();

        mih._currentViewer.rendererUpdate();
    }

    function setDefaultRotation(obj)
    {
        var camData = R2D.Viewers.getCameraData();
        if (camData.type == 'perspective')
        {
            var p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            var pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4)
            {
                obj.rotationY = -270;
            }
            else if (p > 3 * pi4 && p < 5 * pi4)
            {
                obj.rotationY = -180;
            }
            else if (p > 5 * pi4 && p < 7 * pi4)
            {
                obj.rotationY = -90;
            }
            else
            {
                obj.rotationY = 0;
            }
        }
    }
};

R2D.MIH.StateDraggingProdFromCatalog.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateDraggingProdFromCatalog.prototype.constructor = R2D.MIH.StateDraggingProdFromCatalog;





R2D.MIH.StateSelectedProduct = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateSelectedProduct';

    var maxMoveDist = 5;
    var downPos = null;
    var downObjectData = null;

    let rotationModeActive = false;
    let onRotationDownStatus = false;

    let raycaster = new THREE.Raycaster();
    let sphere = null;
    let rings3d;
    let curPlane = null;
    let circle;
    let realCircle = null;
    let isSpriteHovered = false;
    let planeData = null;
    let isClicked = false;

    let curDir = "";
    let curAngle = 0;
    let angle = 0;
    let dRot = 0;
    let startAngle = 0;
    let resAngle = 0;
    let rMax = 300;


    //me.setRotationModeActive = state => rotationModeActive = state;
    //me.getRotationModeActive = () => rotationModeActive;

    me.setOnRotationDownStatus = state => onRotationDownStatus = state;
    me.getOnRotationDownStatus = () => onRotationDownStatus;

    function findAngles() {
        if (angle > 0) {
            angle = -2 * Math.PI + angle;
        }                    
        if (Math.abs(angle - startAngle) > Math.PI / 2) {
            if (angle > startAngle) {
                dRot = -(Math.abs(angle) + 2 * Math.PI + startAngle);
            } else {
                dRot = Math.abs(startAngle) + 2 * Math.PI + angle;
            }
        } else {
            dRot = angle - startAngle;
        }

        startAngle = angle;
        curAngle += dRot;
        resAngle = curAngle % (2 * Math.PI);
    }

    function removeRings() {
        if(!mih._scene.isRotation3dActive) return;
        mih._scene3d.top.children.forEach(i => {
            if(i.name == "rotationRings") {
                i.clear();
                i.removeFromParent();
            }
        })

        me.setOnRotationDownStatus(false);
        
        mih._currentViewer.rendererUpdate();
    };

    me.start = function()
    {
        isClicked = false;
    };

    me.stop = function()
    {
        downPos = null;
        downObjectData = null;
    };

    me.mouseDown = function (e) {
        downPos = new TR.Point(e.clientX, e.clientY);

        isClicked = true;

        const mouse = R2D.Renderer3D.getMousePointForPicker(
            mih._currentCanvas,
            e.clientX,
            e.clientY
        );
        raycaster.setFromCamera(mouse, mih._currentCamera);

        planeData = curPlane ? raycaster.intersectObject(curPlane, true)[0] : null;

        if (planeData && planeData.object && mih._scene.isRotation3dActive) {
            mih._ruler3d.clear();
            mih.api.dispatchEvent(new Event(mih.api.HIDE_OBJECT_QUICK_PANEL, {}));
            rings3d = mih.getRingsObject3D();

            if(!rings3d) return;

            sphere = rings3d.children.find((i) => i.name == "sphereRings");

            const point = planeData.point;
            const center = {
                x: rings3d.position.x,
                y: rings3d.position.y,
                z: rings3d.position.z,
            };

            switch (planeData.object.name) {
                case "planeX":
                    curDir = "x";
                    realCircle = rings3d.children.find((i) => i.name == "ringX");
                    startAngle = Math.atan2(point.y - center.y, -(point.z - center.z));
                    break;
                case "planeY":
                    curDir = "y";
                    realCircle = rings3d.children.find((i) => i.name == "ringY");
                    startAngle = Math.atan2(-(point.z - center.z), point.x - center.x);
                    break;
                case "planeZ":
                    curDir = "z";
                    realCircle = rings3d.children.find((i) => i.name == "ringZ");
                    startAngle = Math.atan2(point.y - center.y, point.x - center.x);
                    break;

                default:
                    return;
                    break;
            }

            if (startAngle > 0) {
                startAngle = -2 * Math.PI + startAngle;
            }
            curAngle = 0;

            rings3d.children.forEach((i) => (i.visible = false));
            realCircle.visible = true;
            sphere.visible = true;
            let { innerRadius, outerRadius, thetaSegments } = realCircle.geometry.parameters;
            realCircle.geometry.dispose();
            let newGeometry = new THREE.RingGeometry(innerRadius, outerRadius, thetaSegments * 4);
            realCircle.geometry = newGeometry;
            sphere.position.set(
                point.x - rings3d.position.x,
                point.y - rings3d.position.y,
                point.z - rings3d.position.z
            );

            me.setOnRotationDownStatus(true);

            mih.updateRingSize(realCircle, point, rMax);

            mih._currentViewer.rendererUpdate();

            if(R2D.view2d == mih._currentViewer) mih._currentViewer.objectButtonsUpdate();

            return mih.api.dispatchEvent(new Event(mih.api.START_ROTATING_OBJECT, {axis: realCircle.name, mouse: e}));
        }
        
        downObjectData = mih.find3DObject(e.clientX, e.clientY);
    };

    me.mouseMove = function (e) {
        rings3d = mih.getRingsObject3D();
        sphere = rings3d?.children.find((i) => i.name == "sphereRings");

        if (rings3d && mih._scene.isRotation3dActive) {
            let x = 0;
            let y = 0;
            let z = 0;
            let r = 0;

            const mouse = R2D.Renderer3D.getMousePointForPicker(
                mih._currentCanvas,
                e.clientX,
                e.clientY
            );

            if (onRotationDownStatus) {
                raycaster.setFromCamera(mouse, mih._currentCamera);
                const intersects = raycaster.intersectObject(curPlane, true);
    
                let currObj3d = mih._scene.currentView3DObject.object3d;
    
                if (intersects.length === 0) return;
    
                let x = 0;
                let y = 0;
                let z = 0;
                dRot = 0;

                let point = intersects[0].point;
                let center = {
                    x: rings3d.position.x,
                    y: rings3d.position.y,
                    z: rings3d.position.z,
                };
    
                if (curDir === "x") {
                    angle = Math.atan2(point.y - center.y, -(point.z - center.z));
                    findAngles();
    
                    r = Math.sqrt(
                        Math.pow(point.y - center.y, 2) + Math.pow(point.z - center.z, 2)
                    );
                    if (r > rMax) r = rMax;
                    z = -r * Math.cos(angle);
                    y = r * Math.sin(angle);
                    x = 0;
                    currObj3d.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), dRot);
                } else if (curDir === "y") {
                    angle = Math.atan2(-(point.z - center.z), point.x - center.x);
                    findAngles();
    
                    r = Math.sqrt(
                        Math.pow(point.x - center.x, 2) + Math.pow(point.z - center.z, 2)
                    );
                    if (r > rMax) r = rMax;
                    x = r * Math.cos(angle);
                    z = -r * Math.sin(angle);
                    y = 0;
                    currObj3d.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), dRot);
                } else if (curDir === "z") {
                    angle = Math.atan2(point.y - center.y, point.x - center.x);
                    findAngles();
    
                    r = Math.sqrt(
                        Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)
                    );
                    if (r > rMax) r = rMax;
                    x = r * Math.cos(angle);
                    y = r * Math.sin(angle);
                    z = 0;
                    currObj3d.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), dRot);
                }
    
                sphere.position.set(x, y, z);
                mih.updateRingSize(realCircle, point, rMax);
    
                mih._currentViewer.rendererUpdate();
                mih.api.dispatchEvent(
                    new Event(mih.api.ROTATING_OBJECT, {
                        angle: G.toDeg(resAngle).toFixed(0),
                        mouse: e,
                    })
                );
                mih.api.dispatchEvent(new Event(mih.api.OBJECT_ROTATION_AXIS, {}));

                mih._scene.currentSceneObject.rotationX = Math.round(
                    G.toDeg(mih._scene.currentView3DObject.object3d.rotation.x)
                );
                mih._scene.currentSceneObject.rotationY = Math.round(
                    G.toDeg(mih._scene.currentView3DObject.object3d.rotation.y)
                );
                mih._scene.currentSceneObject.rotationZ = Math.round(
                    G.toDeg(mih._scene.currentView3DObject.object3d.rotation.z)
                );

                R2D.scene.currentSceneObject.dispatchEvent(new Event(Event.UPDATE, {}));

                return;
            } else {
                const colors = mih.getColors();
                const circle = mih.findCircles(e.clientX, e.clientY);

                if (circle && circle.object && !isClicked) {
                    const center = {
                        x: rings3d.position.x,
                        y: rings3d.position.y,
                        z: rings3d.position.z,
                    };

                    const iR = rings3d.getObjectByName("ringX").geometry.parameters.innerRadius;
                    const oR = rings3d.getObjectByName("ringX").geometry.parameters.outerRadius;
                    r = (iR + oR) / 2;

                    if (circle.object.name === "ringXHelper") {
                        const ring = rings3d.getObjectByName("ringX");
                        ring.material.color = new THREE.Color(colors.red);
                        ring.material.opacity = 1;
                        sphere.material.color.set(colors.red);
                        sphere.visible = true;
                        rings3d.remove(mih.helperPlanes.planeY);
                        rings3d.remove(mih.helperPlanes.planeZ);
                        if (!mih.helperPlanes.planeX.parent) rings3d.add(mih.helperPlanes.planeX);
                        curPlane = mih.helperPlanes.planeX;

                        raycaster.setFromCamera(mouse, mih._currentCamera);
                        const intersects = raycaster.intersectObject(circle.object, true);
                        if (!intersects[0]) return;
                        const point = intersects[0].point;

                        angle = Math.atan2(point.y - center.y, -(point.z - center.z));
                        z = -r * Math.cos(angle);
                        y = r * Math.sin(angle);
                        x = 0;
                    } else if (circle.object.name === "ringYHelper") {
                        const ring = rings3d.getObjectByName("ringY");
                        ring.material.color = new THREE.Color(colors.green);
                        ring.material.opacity = 1;
                        sphere.material.color.set(colors.green);
                        sphere.visible = true;
                        rings3d.remove(mih.helperPlanes.planeX);
                        rings3d.remove(mih.helperPlanes.planeZ);
                        if (!mih.helperPlanes.planeY.parent) rings3d.add(mih.helperPlanes.planeY);
                        curPlane = mih.helperPlanes.planeY;

                        raycaster.setFromCamera(mouse, mih._currentCamera);
                        const intersects = raycaster.intersectObject(circle.object, true);
                        if (!intersects[0]) return;
                        const point = intersects[0].point;

                        angle = Math.atan2(-(point.z - center.z), point.x - center.x);
                        x = r * Math.cos(angle);
                        z = -r * Math.sin(angle);
                        y = 0;
                    } else if (circle.object.name === "ringZHelper") {
                        const ring = rings3d.getObjectByName("ringZ");
                        ring.material.color = new THREE.Color(colors.blue);
                        ring.material.opacity = 1;
                        sphere.material.color.set(colors.blue);
                        sphere.visible = true;
                        rings3d.remove(mih.helperPlanes.planeX);
                        rings3d.remove(mih.helperPlanes.planeY);
                        if (!mih.helperPlanes.planeZ.parent) rings3d.add(mih.helperPlanes.planeZ);
                        curPlane = mih.helperPlanes.planeZ;

                        raycaster.setFromCamera(mouse, mih._currentCamera);
                        const intersects = raycaster.intersectObject(circle.object, true);
                        if (!intersects[0]) return;
                        const point = intersects[0].point;

                        angle = Math.atan2(point.y - center.y, point.x - center.x);
                        x = r * Math.cos(angle);
                        y = r * Math.sin(angle);
                        z = 0;
                    } else if (circle.object.name === "button_ok" && !isSpriteHovered) {
                        mih.formatSprite(false, "OK", circle.object, true);
                        isSpriteHovered = true;
                    }

                    sphere.position.set(x, y, z);
                    mih._currentViewer.rendererUpdate();
                } else {
                    rings3d.children.forEach((i) => {
                        if (i.name === "ringX" || i.name === "ringY" || i.name === "ringZ") {
                            i.material.color = new THREE.Color(colors.orange);
                            i.material.opacity = 0.6;
                        } else if (isSpriteHovered && i.name === "button_ok") {
                            mih.formatSprite(false, "OK", i, false);
                            isSpriteHovered = false;
                        }
                        rings3d.remove(mih.helperPlanes.planeX);
                        rings3d.remove(mih.helperPlanes.planeY);
                        rings3d.remove(mih.helperPlanes.planeZ);
                        curPlane = null;
                        sphere.visible = false;
                    });
                }
    
                mih._currentViewer.rendererUpdate();
            }
        }
        if (!downPos) return;

        var pos = new TR.Point(e.clientX, e.clientY);

        if (TR.euclDistP(pos, downPos) >= 1 && downObjectData && downObjectData.view3DObject == mih._scene.currentView3DObject)
        {
            var objectData = mih.find3DObject(e.clientX, e.clientY);
            if(!objectData) return;
            removeRings();
            if(mih._scene.currentSceneObject.isLockedOnScene) return;
            mih.stateDraggingProduct.startDraggingProduct(objectData.point.x, objectData.point.y, objectData.point.z);
            mih.changeState(mih.stateDraggingProduct);
            return {state: "stateDraggingProduct", quickPanel: { x: e.clientX, y: e.clientY }};
        }
    };

    me.mouseUp = function (e) {
        let rotationFeatureWasActive = false;
        isClicked = false;
        
        if (! downPos) return;
        var upPos = new TR.Point(e.clientX, e.clientY);
        var objectData = mih.find3DObject(e.clientX, e.clientY);
        let result = null;
        if(onRotationDownStatus && mih._scene.isRotation3dActive) {
            mih._scene.currentSceneObject.rotationX = Math.round(
                G.toDeg(mih._scene.currentView3DObject.object3d.rotation.x)
            );
            mih._scene.currentSceneObject.rotationY = Math.round(
                G.toDeg(mih._scene.currentView3DObject.object3d.rotation.y)
            );
            mih._scene.currentSceneObject.rotationZ = Math.round(
                G.toDeg(mih._scene.currentView3DObject.object3d.rotation.z)
            );

            if (rings3d) {
                mih.updateRingsDirAndZoom(rings3d);
                rings3d.children.forEach(i => i.visible = true);
                sphere.visible = false;
                circle = null;
                planeData = null;
                rings3d.remove(curPlane);
            }

            me.setOnRotationDownStatus(false);

            mih._ruler3d.findRules(mih._scene.currentView3DObject);

            mih._currentViewer.rendererUpdate();

            mih.api.dispatchEvent(new Event(mih.api.STOP_ROTATING_OBJECT, {}));

            if(R2D.view2d == mih._currentViewer) mih._currentViewer.objectButtonsUpdate();

            return mih.api.dispatchEvent(
                new Event(mih.api.SHOW_OBJECT_QUICK_PANEL, {})
            ); 
        }

        circle = mih.findCircles(e.clientX, e.clientY);

        if (TR.euclDistP(upPos, downPos) > maxMoveDist)
        {

        }
        else if (e.ctrlKey || e.metaKey)
        {
            if(mih._scene.currentSceneObject.isLockedOnScene || (objectData && objectData?.view3DObject?.sceneObject?.isLockedOnScene)) return;
            if(mih._scene.isRotation3dActive) mih.api.dispatchEvent(new Event(mih.api.STOP_ROTATING_OBJECT, {}));
            removeRings();
            mih._ruler3d.update();
            mih._ruler3d.appendFromConstructor(mih._constructor.getLines());
            mih._ruler3d.findRules(mih._scene.currentView3DObject);
            
            if (! objectData || ! objectData.view3DObject) return;
            var viewObj = objectData.view3DObject;
            if (! R2D.ObjectViewer3DGroup.validSceneObject(viewObj.sceneObject) || ! R2D.ObjectViewer3DGroup.validSceneObject(mih._scene.currentSceneObject)) return;
            if (viewObj == mih._scene.currentView3DObject || viewObj.group) return;

            var group = mih._productHelper.addGroup(false);
            mih.setActiveGroup(group, 0, 0, false);
            mih._productHelper.addObjToGroup(mih._scene.currentView3DObject);
            mih._productHelper.addObjToGroup(viewObj);

            mih.unsetActiveObjectProduct();
            mih.changeState(mih.stateSelectedGroup);

            mih.api.dispatchEvent(new Event(mih.api.STATE_SELECTED_GROUP, {pos: {x: e.clientX, y: e.clientY}}));
            result = { state: "stateSelectedGroup", quickPanel: {x: e.clientX, y: e.clientY} }
        }
        else if (objectData && objectData.view3DObject == mih._scene.currentView3DObject)
        {
            
            result = !rotationFeatureWasActive ? { state: "stateSelectedProduct", quickPanel: {x: e.clientX, y: e.clientY} } : null;
        }
        else
        {
            if(mih._scene.isRotation3dActive) mih.api.dispatchEvent(new Event(mih.api.STOP_ROTATING_OBJECT, {}));
            removeRings();
            
            mih.unsetActiveObjectProduct();
            mih.changeState(mih.stateMain);
            result = { state: "stateEditing" }
        }

        downPos = null;
        downObjectData = null;
        return result;
    };
};

R2D.MIH.StateSelectedProduct.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateSelectedProduct.prototype.constructor = R2D.MIH.StateSelectedProduct;

R2D.MIH.StateSelectedConstr = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateSelectedConstr';

    var maxMoveDist = 5;
    var downPos = null;
    var downObjectData = null;

    me.start = function()
    {

    };

    me.stop = function()
    {
        downPos = null;
        downObjectData = null;
    };

    me.mouseDown = function(e)
    {
        downPos = new TR.Point(e.clientX, e.clientY);
    };

    me.mouseMove = function(e)
    {

    };

    me.mouseUp = function(e)
    {
        if (! downPos) return;
        var upPos = new TR.Point(e.clientX, e.clientY);
        if (TR.euclDistP(upPos, downPos) < maxMoveDist)
        {
            mih.unsetActiveObjectConstructor();
            mih.changeState(mih.stateMain);
            return {state: "stateEditing"};
        }

        downPos = null;
    };
};

R2D.MIH.StateSelectedConstr.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateSelectedConstr.prototype.constructor = R2D.MIH.StateSelectedConstr;




R2D.MIH.StateSelectedGroup = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateSelectedGroup';

    var maxMoveDist = 5;
    var downPos = null;
    var downObjectData = null;

    me.start = function()
    {

    };

    me.stop = function()
    {
        downPos = null;
        downObjectData = null;
    };

    me.mouseDown = function(e)
    {
        downPos = new TR.Point(e.clientX, e.clientY);
        downObjectData = mih.find3DObject(e.clientX, e.clientY);
    };

    me.mouseMove = function(e)
    {
        if (!downPos || e.metaKey || e.ctrlKey || mih._scene.currentGroup.isLockedOnScene) return;

        var pos = new TR.Point(e.clientX, e.clientY);

        if (TR.euclDistP(pos, downPos) < 1) return;

        if (! downObjectData || ! downObjectData.view3DObject) return;

        var viewObj = downObjectData.view3DObject;
        if (! viewObj.group || viewObj.group != mih._scene.currentGroup) return;
        
        mih.stateDraggingGroup.startDraggingProduct(downObjectData.point.x, downObjectData.point.y, downObjectData.point.z);
        mih.changeState(mih.stateDraggingGroup);
    };

    me.mouseUp = function(e)
    {
        let result = null;
        if (! downPos) return;
        var upPos = new TR.Point(e.clientX, e.clientY);
        var objectData = mih.find3DObject(e.clientX, e.clientY);

        if (TR.euclDistP(upPos, downPos) > maxMoveDist)
        {

        }
        else if ((e.ctrlKey || e.metaKey) && objectData && objectData.view3DObject &&
            R2D.ObjectViewer3DGroup.validSceneObject(objectData.view3DObject.sceneObject))
        {
            if(mih._scene.currentGroup.isLockedOnScene) return;
            var viewObj = objectData.view3DObject;
            if (! viewObj.forWall && ! viewObj.group)
            {
                mih._productHelper.addObjToGroup(viewObj);
                mih._currentViewer.rendererUpdate();
            }
            else if (viewObj.group == mih._scene.currentGroup)
            {
                mih._productHelper.removeObjFromGroup(viewObj);

                if (mih._scene.currentGroup.getObjViews().length == 1)
                {
                    var objFromGroup = mih._scene.currentGroup.getObjViews()[0];
                    mih.unsetActiveGroup();
                    mih._productHelper.removeGroupsWithOne();
                    mih.setActiveObjectProduct(objFromGroup, 0, 0, false);
                    mih.changeState(mih.stateSelectedProduct);
                }

                mih._currentViewer.rendererUpdate();
                mih._scene.history.saveState();
                mih.api.dispatchEvent(new Event(mih.api.HISTORY_UNDO_REDO, {}));
            }

            result = {state: "stateSelectedGroup", quickPanel: {x: e.clientX, y: e.clientY}}
        }
        else if (objectData && objectData.view3DObject.group == mih._scene.currentGroup)
        {
            /*
            if (mih._quickPanelHelper.isVisible())
            {
                mih._quickPanelHelper.hideQuickPanel();
            }
            else
            {
                mih._quickPanelHelper.showQuickPanel(mih._scene.currentGroup, e.clientX, e.clientY);
            }
            */
            result = {state: "stateSelectedGroup", quickPanel: {x: e.clientX, y: e.clientY}}
        }
        else
        {
            if (mih._scene.currentGroup?.merged)
            {
                mih.unsetActiveGroup();
            }
            else
            {
                mih.ungroupCurrentGroup();
            }

            result = {state: "stateEditing"};
            mih.changeState(mih.stateMain);
            
        }

        downPos = null;
        downObjectData = null;
        return result;
    };
};

R2D.MIH.StateSelectedGroup.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateSelectedGroup.prototype.constructor = R2D.MIH.StateSelectedGroup;



R2D.MIH.StateDraggingGroup = function(mih)
{
    var me = this;
    R2D.MIH.BaseState.call(this, mih);
    me.name = 'stateDraggingGroup';

    var oldPosition = null;
    var pointIntersect = null;

    me.start = function()
    {
        mih.updateSnap2d();
    };

    me.stop = function()
    {

    };

    me.mouseDown = function(e)
    {


    };

    me.mouseMove = function(e)
    {
        moveGroupHorizontal(mih._scene.currentGroup, e.clientX, e.clientY, !event.ctrlKey);

        mih._ruler3d.update();
        mih._ruler3d.appendFromConstructor(mih._constructor.getLines());
        mih._ruler3d.findRules(mih._scene.currentGroup);
    };

    me.mouseUp = function(e)
    {
        stopDraggingGroup();
    };

    me.startDraggingProduct = function(x, y, z)
    {
        mih._object3DMoving.position.set(x, y, z);
        mih._currentViewer.rendererUpdate();

        oldPosition = {
            x: mih._scene.currentGroup.x,
            y: mih._scene.currentGroup.y,
            z: mih._scene.currentGroup.z
        };

        mih._mouseController.disable();
        mih._touchController.disable();

        mih._currentViewer.rendererUpdate();
        //mih._quickPanelHelper.hideQuickPanel();
        //updateSnap2d();
    };

    function moveGroupHorizontal(view3DGroup, mx, my, useSnap)
    {
        var scrPoint = R2D.Renderer3D.getMousePointForPicker(mih._currentCanvas, mx, my);
        var intersection = mih._scene3d.intersectWithObject(mih._currentCamera, scrPoint.x, scrPoint.y, mih._object3DMoving);

        if ( !pointIntersect )
        {
            if ( !intersection ) return;
            pointIntersect = intersection.point;
        }
        else if ( !oldPosition )
        {
            oldPosition = {
                x:pointIntersect.x,
                y:pointIntersect.y,
                z:pointIntersect.z
            };
        }
        else
        {
            if ( !intersection ) return;
            var position = {
                x:intersection.point.x + oldPosition.x - pointIntersect.x,
                y:intersection.point.z + oldPosition.z - pointIntersect.z
            };

            if (useSnap)
            {
                var rpts = view3DGroup.get2DRectPoints();

                var objectPoints = GEOM.Point.shiftPoints(new GEOM.Point(position.x, position.y), rpts);

                var shiftPoint = new GEOM.Point(0,0);

                shiftPoint = useSnap ? mih._snap2d.snapPolygon(objectPoints, shiftPoint, view3DGroup.getHeight()) : new GEOM.Point(0,0);

                view3DGroup.setX(position.x - (shiftPoint ? shiftPoint.x : 0));
                view3DGroup.setZ(position.y - (shiftPoint ? shiftPoint.y : 0));
            } else {
                view3DGroup.setX(position.x);
                view3DGroup.setZ(position.y);
                //console.log('new position: ', position.x, position.y);
            }

            //sceneObject.update();

            //updateBoxSelected(scene.currentView3DObject);

            mih._currentViewer.rendererUpdate();
        }
    }

    function stopDraggingGroup()
    {
        mih._object3DMoving.scale.set(1, 1, 1);
        //mih._object3DMoving.position.set(0, -100, 0);

        //mih._ruler3d.clear();
        mih._currentViewer.rendererUpdate();

        pointIntersect = null;
        oldPosition = null;

        mih._mouseController.enable();
        mih._touchController.enable();

        //mih._quickPanelHelper.showQuickPanel(mih._scene.currentView3DObject, mih.mouseX, mih.mouseY);

        mih._scene.history.saveState();

        mih.changeState(mih.stateSelectedGroup);
        mih.updateFreeSpace();
        mih.api.dispatchEvent(new Event(mih.api.HISTORY_UNDO_REDO, {}));
    }
};

R2D.MIH.StateDraggingGroup.prototype = Object.create(R2D.MIH.BaseState.prototype);
R2D.MIH.StateDraggingGroup.prototype.constructor = R2D.MIH.StateDraggingGroup;




//

R2D.MouseInteractionHelperSimple = function(commonSceneObject, commonSceneHelper) {
    EventDispatcher.call(this);

    var scope = this;
    var scene = commonSceneObject.scene;
    var productHelper = commonSceneHelper.productHelper;
    var constructorHelper = commonSceneHelper.constructorHelper;
    var mouseController = new R2D.MouseController();
    var touchController = new R2D.TouchController();
    var currentCamera = null;
    var currentCanvas = null;
    var currentViewer = null;
    var currentTools = null;

    function productHelperUpdateEvent(event) {
        currentViewer.rendererUpdate();
    }
    function constructorHelperUpdateEvent(event) {
        currentViewer.rendererUpdate();
    }

    function mouseControllerEvent(event) {
        switch ( event.data.type ) {
            case "rotate":
                currentViewer.cameraRotate(event.data.dx, event.data.dy);
                break;

            case "move":
                currentViewer.cameraMove(event.data.dx, event.data.dy);
                break;

            case "zoom":
                currentViewer.cameraZoom(event.data.delta);
                break;
        }
    }

    scope.updateComponents = function(camera, canvas, viewer, tools) {
        currentCamera = camera;
        currentCanvas = canvas;
        currentViewer = viewer;
        currentTools = tools;

        mouseController.updateComponents(currentCanvas);
        touchController.updateComponents(currentCanvas);

        if ( !currentViewer ) {
            currentViewer = { rendererUpdate() { /*console.warn("Handle update event!")*/} };
        }
    };

    scope.constructorSelection = function () {

    };

    productHelper.addEventListener(Event.UPDATE, productHelperUpdateEvent);
    constructorHelper.addEventListener(Event.UPDATE, constructorHelperUpdateEvent);
    mouseController.addEventListener(Event.UPDATE, mouseControllerEvent);
    touchController.addEventListener(Event.UPDATE, mouseControllerEvent);
};

extend(R2D.MouseInteractionHelperSimple, EventDispatcher);
// viewers

R2D.KeyboardInteractionHelper = function(commonSceneObject, commonSceneHelper, api) {
    EventDispatcher.call(this);

    var scope = this;
    var currentDomElement = null;
    var currentViewer = null;
    var keyboardController = new R2D.KeyboardController(api);
    var deltaMove = 5;

    function keyboardControllerEvent(event)
    {
        
        var dist = 1;
        if (event.shiftKey) dist = 10;

        var selectedProduct = (commonSceneHelper.scene.currentView3DObject &&
            commonSceneHelper.scene.currentView3DObject.objectType == 'product' && !commonSceneHelper.scene.currentSceneObject?.isLockedOnScene);

        var selectedElement = (commonSceneHelper.scene.currentView3DObject &&
            commonSceneHelper.scene.currentView3DObject.objectType == 'constructor');

        var selectedGroup = commonSceneHelper.scene.currentGroup && !commonSceneHelper.scene.currentGroup?.isLockedOnScene;

        if (R2D.Viewers.getCurrentViewerType() == "constructor") {
            dist = R2D.DimensionSystem.isMetric() ? 1 : R2D.DimensionSystem.ImperialFT._INCH_TO_CM;

            if (event.shiftKey && event.ctrlKey) {
                dist = R2D.DimensionSystem.isMetric()
                    ? 10
                    : R2D.DimensionSystem.ImperialFT._FOOT_TO_CM;
            } else if (event.shiftKey) {
                dist = R2D.DimensionSystem.isMetric()
                    ? 0.1
                    : R2D.DimensionSystem.ImperialFT._INCH_TO_CM *
                      R2D.DimensionSystem.ImperialFT._approximate;
            }

            switch (event.type) {
                case R2D.KeyboardController.LEFT_DOWN:
                    if(WC.wallsEditor.state.name == "stateSelectedCover") WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
                    WC.SFK.state.moveElement(WC.SFK.LEFT, dist);
                    WC.wallsEditor.titlesTool.hide();
                    WC.wallsEditor.titlesTool.show(false);
                    break;
                case R2D.KeyboardController.RIGHT_DOWN:
                    if(WC.wallsEditor.state.name == "stateSelectedCover") WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
                    WC.SFK.state.moveElement(WC.SFK.RIGHT, dist);
                    WC.wallsEditor.titlesTool.hide();
                    WC.wallsEditor.titlesTool.show(false);
                    break;
                case R2D.KeyboardController.FORWARD_DOWN:
                    if(WC.wallsEditor.state.name == "stateSelectedCover") WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
                    WC.SFK.state.moveElement(WC.SFK.UP, dist);
                    WC.wallsEditor.titlesTool.hide();
                    WC.wallsEditor.titlesTool.show(false);
                    break;
                case R2D.KeyboardController.BACKWARD_DOWN:
                    if(WC.wallsEditor.state.name == "stateSelectedCover") WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
                    WC.SFK.state.moveElement(WC.SFK.DOWN, dist);
                    WC.wallsEditor.titlesTool.hide();
                    WC.wallsEditor.titlesTool.show(false);
                    break;

                default:
                    break;
            }
        }

        if(!currentViewer) return;
        let moveNum = R2D.Viewers.getIsRenderMakeActive() ? dist : deltaMove;

        let currObj = commonSceneHelper.scene.currentView3DObject;

        switch ( event.type ) {
            case R2D.KeyboardController.LEFT:
                if (! selectedProduct && ! selectedElement && ! selectedGroup) currentViewer.cameraMove(moveNum, 0);
                break;

            case R2D.KeyboardController.RIGHT:
                if (! selectedProduct && ! selectedElement && ! selectedGroup) currentViewer.cameraMove(-moveNum, 0);
                break;

            case R2D.KeyboardController.FORWARD:
                if (! selectedProduct && ! selectedElement && ! selectedGroup) currentViewer.cameraMove(0, moveNum);
                break;

            case R2D.KeyboardController.BACKWARD:
                if (! selectedProduct && ! selectedElement && ! selectedGroup) currentViewer.cameraMove(0, -moveNum);
                break;

            case R2D.KeyboardController.LEFT_DOWN:
                if (selectedProduct) currentViewer.moveSelectedObject(dist * Math.sign(deltaMove), 0);
                if (selectedElement) currentViewer.moveSelectedMaterial(dist * Math.sign(deltaMove), 0);
                if (selectedGroup) currentViewer.moveSelectedGroup(dist * Math.sign(deltaMove), 0);
                currentViewer.hideCursor();
                break;

            case R2D.KeyboardController.RIGHT_DOWN:
                if (selectedProduct) currentViewer.moveSelectedObject(- dist * Math.sign(deltaMove), 0);
                if (selectedElement) currentViewer.moveSelectedMaterial(- dist * Math.sign(deltaMove), 0);
                if (selectedGroup) currentViewer.moveSelectedGroup(- dist * Math.sign(deltaMove), 0);
                currentViewer.hideCursor();
                break;

            case R2D.KeyboardController.FORWARD_DOWN:
                
                if (selectedProduct) currentViewer.moveSelectedObject(0, dist * Math.sign(deltaMove), event.ctrlKey);
                if (selectedElement) {
                    currentViewer.moveSelectedMaterial(0, dist * Math.sign(deltaMove));
                }
                if (selectedGroup) currentViewer.moveSelectedGroup(0, dist * Math.sign(deltaMove), event.ctrlKey);
                if(currObj?.sceneObject?.type == R2D.ProductType.POSTER) api.dispatchEvent(new Event(api.OBJECT_SMART_MOVE, {elevation: currObj ? currObj.sceneObject.y : selectedGroup.y}));
                currentViewer.hideCursor();
                break;

            case R2D.KeyboardController.BACKWARD_DOWN:
                if (selectedProduct) currentViewer.moveSelectedObject(0, - dist * Math.sign(deltaMove), event.ctrlKey);
                if (selectedElement) currentViewer.moveSelectedMaterial(0, - dist * Math.sign(deltaMove));
                if (selectedGroup) currentViewer.moveSelectedGroup(0, - dist * Math.sign(deltaMove), event.ctrlKey);
                if(currObj?.sceneObject?.type == R2D.ProductType.POSTER) api.dispatchEvent(new Event(api.OBJECT_SMART_MOVE, {elevation: currObj ? currObj.sceneObject.y : selectedGroup.y}));
                currentViewer.hideCursor();
                break;

            case R2D.KeyboardController.LEFT_UP:
                if (selectedProduct) currentViewer.finishMoveSelectedObject();
                currentViewer.showCursor();
                break;

            case R2D.KeyboardController.RIGHT_UP:
                if (selectedProduct) currentViewer.finishMoveSelectedObject();
                currentViewer.showCursor();
                break;

            case R2D.KeyboardController.FORWARD_UP:
                if (selectedProduct) currentViewer.finishMoveSelectedObject();
                currentViewer.showCursor();
                break;

            case R2D.KeyboardController.BACKWARD_UP:
                if (selectedProduct) currentViewer.finishMoveSelectedObject();
                currentViewer.showCursor();
                break;
        }
    }

    scope.updateComponents = function(domeElement, viewer) {
        currentDomElement = domeElement;
        currentViewer = viewer;

        keyboardController.updateComponents(currentDomElement);
    };

    keyboardController.addEventListener(R2D.KeyboardController.LEFT_DOWN, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.RIGHT_DOWN, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.FORWARD_DOWN, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.BACKWARD_DOWN, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.LEFT_UP, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.RIGHT_UP, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.FORWARD_UP, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.BACKWARD_UP, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.LEFT, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.RIGHT, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.FORWARD, keyboardControllerEvent);
    keyboardController.addEventListener(R2D.KeyboardController.BACKWARD, keyboardControllerEvent);

    document.addEventListener('keydown', keydownListener);

    function keydownListener(e)
    {
        if (e.ctrlKey && e.code == 'KeyZ')
        {
            if (R2D.scene.history.getIsUndo()) {
                R2D.mouseInteractionHelper._titlesTool.updateComponents();
                R2D.scene.history.undo();
                api.dispatchEvent(new Event(api.HISTORY_UNDO_REDO, {removeQuickPanel: true, clearRightPanel: true}));
            }
        }
        else if (e.ctrlKey && e.code == 'KeyY')
        {
            if (R2D.scene.history.getIsRedo()) {
                R2D.mouseInteractionHelper._titlesTool.updateComponents();
                R2D.scene.history.redo();
                api.dispatchEvent(new Event(api.HISTORY_UNDO_REDO, {removeQuickPanel: true, clearRightPanel: true}));
            }
        }
        else if ((e.key == 'Delete' || e.key == "Backspace") && !e.target.matches("input"))
        {
            if (! R2D.KeyboardInteractionHelper.keysBlocked) {
                R2D.scene.removeCurrentObject();
                api.dispatchEvent(new Event(api.HISTORY_UNDO_REDO, {removeQuickPanel: true, clearRightPanel: true}));
            }
        }
        else if (e.ctrlKey && e.code == 'KeyC')
        {
            R2D.scene.copy();
        }
        else if (e.ctrlKey && e.code == 'KeyV')
        {
            R2D.scene.paste();
        }
        else if (e.code == 'Escape')
        {
            //if (R2D.scene3d.customRulers.isCreating()) R2D.scene3d.customRulers.cancel();
            R2D.mouseInteractionHelper.cancelCreatingRuler();
        }
        
    }
};

extend(R2D.KeyboardInteractionHelper, EventDispatcher);

R2D.KeyboardInteractionHelper.keysBlocked = false;
// viewers

R2D.KeyboardInteractionHelperSimple = function(commonSceneObject, commonSceneHelper) {
    EventDispatcher.call(this);

    var scope = this;

    scope.updateComponents = function(domeElement, viewer) {
        //-
    };
};

extend(R2D.KeyboardInteractionHelperSimple, EventDispatcher);
// viewers

R2D.CommonSceneHelper = function(commonSceneObject) {
    EventDispatcher.call(this);

    var scope = this;
    var scene = commonSceneObject.scene;
    var constructor = scene.constructor;
    var scene3d = commonSceneObject.scene3d;
    var productHelper = new R2D.ProductSceneHelper(commonSceneObject);
    var constructorHelper = new R2D.ConstructorSceneHelper(commonSceneObject);
    var drawingHelper = new R2D.DrawingHelper(constructor, scene3d);

    function helperUpdate(event) {
        scope.dispatchUpdate();
    }

    Object.defineProperties(scope, {
        "commonSceneObject":{
            get() { return commonSceneObject; }
        },
        "scene":{
            get() { return scene; }
        },
        "constructor":{
            get() { return constructor; }
        },
        "scene3d":{
            get() { return scene3d; }
        },
        "productHelper":{
            get() { return productHelper; }
        },
        "constructorHelper":{
            get() { return constructorHelper; }
        },
        "drawingHelper":{
            get() { return drawingHelper; }
        }
    });

    productHelper.addEventListener(Event.UPDATE, helperUpdate);
    constructorHelper.addEventListener(Event.UPDATE, helperUpdate);
    drawingHelper.addEventListener(Event.UPDATE, helperUpdate);
};

extend(R2D.CommonSceneHelper, EventDispatcher);
//viewers

R2D.ViewerScene3D = function (
    sharedRenderer,
    commonSceneHelper,
    mouseInteractionHelper,
    keyboardInteractionHelper
) {
    R2D.Viewer.call(
        this,
        "3d",
        new R2D.ViewerData(
            R2D.STYLE.LP_ICON_3D,
            document.createElement("div"),
            "HINT_BUTTON_3D"
        ),
        commonSceneHelper.scene,
        true,
        true
    );

    var scope = this;
    var width = 800;
    var height = 600;
    var enabled = false;
    var scene = commonSceneHelper.scene;
    var constructor = scene.constructor;
    var scene3d = commonSceneHelper.scene3d;
    var drawing = commonSceneHelper.drawingHelper;
    var camera3d = new THREE.PerspectiveCamera(40, 800 / 600, 5.0, 5000.0);
    var renderer = new R2D.Renderer3DPerspective(sharedRenderer, camera3d, scene3d);

    var body = HGen.fromModel(
        {
            label: "viewer-scene-3d",
            type: "container",
            attributes: {
                class: "viewer-body",
            },
            children: [
                {
                    label: "tools",
                    type: "container",
                    attributes: {
                        class: "viewer-tools",
                    },
                },
            ],
        },
        scope.getDomElement()
    );
    body.style.overflow = "hidden";
    var toolsHTML = body.lbl("tools").domElement;
    var canvasHTML = sharedRenderer.canvas.domElement;
    var canvas = HGen.fromModel(
        {
            label: "canvas",
            type: "element",
            tagName: "canvas",
            attributes: {
                class: "viewer-canvas",
            },
        },
        canvasHTML
    );
    canvas.id = "canvasViewer3d";

    scope.cameraState = {
        anchor: {
            x: 0,
            y: 110,
            z: 0,
        },
        distance: {
            min: 100,
            max: 2500,
            current: 1500,
        },
        tilt: {
            min: -0.8, //0,
            max: 1.57,
            current: 1.25,
        },
        pan: 0,
    };

    function updateConstructorCameraPosition() {
        var cPos = renderer.getCameraPosition();
        var cAnch = renderer.getCameraAnchor();

        constructor.setCameraPosition(
            new GEOM.Vector(cPos.x, cPos.z, cPos.y),
            new GEOM.Vector(cAnch.x, cAnch.z, cAnch.y)
        );
    }

    function viewerSceneUpdateEventHandler(event) {
        renderer.update();
    }

    function rendererCameraPositionUpdateEventHandler(event) {
        var cPan = renderer.getCameraPan();
        var cTilt = renderer.getCameraTilt();
        var cDist = renderer.getCameraDistance();
        var cPos = renderer.getCameraPosition();
        var cAnch = renderer.getCameraAnchor();

        scope.cameraState.anchor.x = cAnch.x;
        scope.cameraState.anchor.y = cAnch.y;
        scope.cameraState.anchor.z = cAnch.z;
        scope.cameraState.distance.current = cDist;
        scope.cameraState.tilt.current = cTilt;
        scope.cameraState.pan = cPan;

        updateConstructorCameraPosition();

        scope.dispatchEvent(new Event(R2D.Viewer.CAMERA_POSITION_UPDATE, scope));

        R2D.controller.savedLastChanges = false;
    }

    function updateCamera() {
        camera3d.aspect = width / height;
        camera3d.updateProjectionMatrix();
    }

    function historyStageEvent(event) {
        //R2D.User.updateElementHistory(scene.history.isUndo, scene.history.isRedo);
    }

    function historyUserEvent(event) {
        /*
        switch (event.type) {
            case R2D.User.HISTORY_UNDO:
                scene.history.undo();
                break;

            case R2D.User.HISTORY_REDO:
                scene.history.redo();
                break;
        }
        */
    }

    scope.setCameraSettings = function ({
        minHeight,
        anchor,
        isLookUp,
        sensitiveZoom,
        distance,
        pan,
        tilt,
    }) {
        renderer.setCameraMinHeight(minHeight);
        renderer.setCameraLookUp(isLookUp);
        renderer.setSensitiveZoom(sensitiveZoom);
        renderer.updateCameraViewPosition(
            anchor.x,
            anchor.y,
            anchor.z,
            distance,
            pan,
            tilt
        );
    };

    scope.updateCameraDistance = function (dist) {
        renderer.updateCameraDistance(dist);
    };

    scope.isEnabled = function () {
        return enabled;
    };
    scope.enable = function (previousViewer) {
        
        if (enabled) return;

        //if (R2D.tipArea) R2D.tipArea.show3dMain();

        mouseInteractionHelper.updateComponents(camera3d, canvasHTML, scope, toolsHTML);
        keyboardInteractionHelper.updateComponents(canvasHTML, scope);

        renderer.enable();
        renderer.setupRendererData();
        renderer.setCameraDistanceBounds(
            scope.cameraState.distance.min,
            scope.cameraState.distance.max
        );
        renderer.setCameraTiltBounds(
            scope.cameraState.tilt.min,
            scope.cameraState.tilt.max
        );
        renderer.setCameraMinHeight(scope.cameraState.anchor.y);
        renderer.setCameraLookUp(true);
        renderer.updateCameraViewPosition(
            scope.cameraState.anchor.x,
            scope.cameraState.anchor.y,
            scope.cameraState.anchor.z,
            scope.cameraState.distance.current,
            scope.cameraState.pan,
            scope.cameraState.tilt.current
        );

        updateConstructorCameraPosition();

        commonSceneHelper.addEventListener(Event.UPDATE, viewerSceneUpdateEventHandler);
        renderer.addEventListener(
            R2D.Renderer3DPerspective.CAMERA_POSITION_UDPATE,
            rendererCameraPositionUpdateEventHandler
        );

        if (previousViewer != "2d" && previousViewer != "walk") {
            scene.history.clear();
            scene.history.saveState();
        }

        scene.history.addEventListener(R2D.SceneHistory.UNDO_ACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.UNDO_INACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.REDO_ACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.REDO_INACTIVE, historyStageEvent);

        drawing.enable();

        //R2D.User.updateElementHistory(scene.history.isUndo, scene.history.isRedo);
        //R2D.User.addEventListener(R2D.User.HISTORY_UNDO, historyUserEvent);
        //R2D.User.addEventListener(R2D.User.HISTORY_REDO, historyUserEvent);
        //R2D.User.showElementHistory(true);

        body.addAt(0, canvas);

        enabled = true;

        mouseInteractionHelper.constructorSelection(true);

        R2D.scene3d.getLights().modeMain();

        scope.dispatchEvent(new Event(Event.ENABLED));

        scope.coversTitleViewer3D.enable();
    };
    scope.disable = function () {
        if (!enabled) return;

        //if (R2D.tipArea) R2D.tipArea.hide();
        renderer.disable();
        renderer.removeEventListener(
            R2D.Renderer3DPerspective.CAMERA_POSITION_UDPATE,
            rendererCameraPositionUpdateEventHandler
        );
        commonSceneHelper.removeEventListener(
            Event.UPDATE,
            viewerSceneUpdateEventHandler
        );
        mouseInteractionHelper.updateComponents(null, null, null);
        keyboardInteractionHelper.updateComponents(null, null);

        //R2D.User.showElementHistory(false);
        //R2D.User.removeEventListener(R2D.User.HISTORY_UNDO, historyUserEvent);
        //R2D.User.removeEventListener(R2D.User.HISTORY_REDO, historyUserEvent);

        scene.history.removeEventListener(
            R2D.SceneHistory.UNDO_ACTIVE,
            historyStageEvent
        );
        scene.history.removeEventListener(
            R2D.SceneHistory.UNDO_INACTIVE,
            historyStageEvent
        );
        scene.history.removeEventListener(
            R2D.SceneHistory.REDO_ACTIVE,
            historyStageEvent
        );
        scene.history.removeEventListener(
            R2D.SceneHistory.REDO_INACTIVE,
            historyStageEvent
        );

        drawing.disable();

        //R2D.User.showElementLogin(false);
        //R2D.User.showElementCurrentProject(false);
        //R2D.User.showElementShareProject(false);
        //R2D.User.showElementTakeSnapshot(false);
        //R2D.User.showElementSaveProject(false);
        //R2D.User.showElementUser(false);
        //R2D.User.showElementLanguages(false);
        //R2D.User.showButtonMyRenders(false);
        //R2D.User.showButtonRender(false);

        body.remove(canvas);

        enabled = false;

        scope.coversTitleViewer3D.disable();
    };

    scope.reset = previousViewer => {
        scope.disable();
        scope.enable(previousViewer);
    }

    scope.selectedObject = function (object) {
        //-
    };
    scope.unselectedObject = function (object) {
        scene3d.top.children.forEach((i) => {
            if (i.name == "rotationRings") {
                i.clear();
                i.removeFromParent();
            }
        });
        if (mouseInteractionHelper.state.name === "stateSelectedProduct") {
            mouseInteractionHelper.state.setOnRotationDownStatus(false);
            //mouseInteractionHelper.state.setRotationModeActive(false);
        }
    };
    scope.stateUserUnknown = function () {
        //R2D.User.showElementCurrentProject(true);
        //R2D.User.showElementShareProject(true);
        //R2D.User.showElementTakeSnapshot(true);
        //R2D.User.showElementUser(false);
        //R2D.User.showElementLogin(true);
        //R2D.User.showElementLanguages(true);
        //R2D.User.showElementSaveProject(true);
        //R2D.User.showButtonMyRenders(false);
        //R2D.User.showButtonRender(false);
    };
    scope.stateUserLogged = function () {
        //R2D.User.showElementLogin(false);
        //R2D.User.showElementCurrentProject(true);
        //R2D.User.showElementShareProject(true);
        //R2D.User.showElementTakeSnapshot(true);
        //R2D.User.showElementSaveProject(true);
        //R2D.User.showElementUser(true);
        //R2D.User.showElementLanguages(true);
        //R2D.User.showButtonMyRenders(true);
        //R2D.User.showButtonRender(true);
    };
    scope.rendererUpdate = function () {
        renderer.update();
    };
    scope.setSize = function (w, h) {
        width = w;
        height = h;

        body.style.width = width + "px";
        body.style.height = height + "px";

        updateCamera();

        renderer.setSize(width, height);
        renderer.update();
    };
    scope.cameraRotate = function (dx, dy) {
        renderer.cameraRotate(dx, dy);
        if (
            mouseInteractionHelper.state.name === "stateSelectedProduct" && mouseInteractionHelper._scene.isRotation3dActive
        ) {
            const rings = mouseInteractionHelper.getRingsObject3D();
            mouseInteractionHelper.updateRingsDirAndZoom(rings);
        }

        scope.coversTitleViewer3D.update();
    };
    scope.cameraMove = function (dx, dy) {
        renderer.cameraMove(dx, dy);
        if (
            mouseInteractionHelper.state.name === "stateSelectedProduct" && mouseInteractionHelper._scene.isRotation3dActive
        ) {
            const rings = mouseInteractionHelper.getRingsObject3D();
            mouseInteractionHelper.updateRingsDirAndZoom(rings);
            const sphere = rings?.children.find((i) => i.name == "sphereRings");
            if(sphere) sphere.visible = false;
        }
    };
    scope.cameraZoom = function (delta) {
        renderer.cameraZoom(delta);
        if (
            mouseInteractionHelper.state.name === "stateSelectedProduct" && mouseInteractionHelper._scene.isRotation3dActive
        ) {
            const rings = mouseInteractionHelper.getRingsObject3D();
            mouseInteractionHelper.updateRingsDirAndZoom(rings);
            const sphere = rings?.children.find((i) => i.name == "sphereRings");
            if(sphere) sphere.visible = false;
        }

        scope.coversTitleViewer3D.update();
    };
    scope.toCenter = function () {
        var sceneBounds = scene.getBounds();

        renderer.updateCameraAnchor(
            sceneBounds.centerX,
            scope.cameraState.anchor.y,
            sceneBounds.centerY
        );
    };
    scope.getViewStateData = function () {
        return {
            state: "3d",
            camera: {
                px: scope.cameraState.anchor.x,
                py: scope.cameraState.anchor.y,
                pz: scope.cameraState.anchor.z,
                tilt: GEOM.toDeg(scope.cameraState.tilt.current),
                pan: GEOM.toDeg(scope.cameraState.pan),
                zoom:
                    (scope.cameraState.distance.current -
                        scope.cameraState.distance.min) /
                    (scope.cameraState.distance.max - scope.cameraState.distance.min),
            },
        };
    };
    scope.setViewStateData = function (data) {
        if (data["state"] != "3d") return false;

        scope.cameraState.anchor.x = parseFloat(data.camera.px);
        // scope.cameraState.anchor.y = parseFloat(data.camera.py);
        scope.cameraState.anchor.z = parseFloat(data.camera.pz);
        scope.cameraState.pan = GEOM.toRad(parseFloat(data.camera.pan));
        scope.cameraState.tilt.current = GEOM.toRad(parseFloat(data.camera.tilt));
        scope.cameraState.distance.current =
            (scope.cameraState.distance.max - scope.cameraState.distance.min) *
                parseFloat(data.camera.zoom) +
            scope.cameraState.distance.min;

        if (enabled) {
            renderer.updateCameraViewPosition(
                scope.cameraState.anchor.x,
                scope.cameraState.anchor.y,
                scope.cameraState.anchor.z,
                scope.cameraState.distance.current,
                scope.cameraState.pan,
                scope.cameraState.tilt.current
            );
        }

        return true;
    };
    scope.makeRenderScreenShot = function() {
        
    };
    scope.makeScreenShot = function (prev) {
        var oldWidth = width;
        var oldHeight = height;
        var oldSSAO = sharedRenderer.useSSAOFilter;
        var image = null;

        scope.setSize(1280, 720);

        if (prev) {
            scope.setSize(265, 150);
            sharedRenderer.useSSAOFilter = false;
        }

        sharedRenderer.render();

        image = canvasHTML.toDataURL("image/jpeg");

        scope.setSize(oldWidth, oldHeight);
        sharedRenderer.useSSAOFilter = oldSSAO;

        return image;
    };
    scope.makePreviewScreenShot = function () {
        return scope.makeScreenShot(true);
    };
    scope.canRender = () => true;
    scope.objectSelection = function (value) {
        mouseInteractionHelper.objectSelection(value);
    };
    scope.getCameraData = function () {
        return {
            type: "perspective",
            fov: 40,
            pan: renderer.getCameraPan(),
            tilt: renderer.getCameraTilt(),
            distance: renderer.getCameraDistance(),
            position: renderer.getCameraPosition(),
            anchor: renderer.getCameraAnchor(),
        };
    };
    scope.moveSelectedObject = function (dx, dy, vertical) {
        var camData = scope.getCameraData();
        var sceneObject = scene.currentView3DObject.sceneObject;

        if (scene.currentView3DObject.type == R2D.ProductType.POSTER) {
            sceneObject.y += dy;
            sceneObject.x =
                sceneObject.x - dx * Math.cos(TR.degToRad(sceneObject.rotationY));
            sceneObject.z =
                sceneObject.z + dx * Math.sin(TR.degToRad(sceneObject.rotationY));
        } else if (scene.currentView3DObject.forWall) {
            var deltaAngle =
                (camData.pan + Math.PI * 100 - TR.degToRad(sceneObject.rotationY)) %
                (2 * Math.PI);

            var d = dx;
            if (deltaAngle > Math.PI * 0.5 && deltaAngle < Math.PI * 1.5) d = -dx;

            sceneObject.y += dy;
            sceneObject.x =
                sceneObject.x - d * Math.cos(TR.degToRad(sceneObject.rotationY));
            sceneObject.z =
                sceneObject.z + d * Math.sin(TR.degToRad(sceneObject.rotationY));
        } else {
            if (vertical) {
                sceneObject.y += dy;
            } else {
                var p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
                var pi4 = Math.PI / 4;
                if (p > pi4 && p < 3 * pi4) {
                    sceneObject.z += dx;
                    sceneObject.x -= dy;
                } else if (p > 3 * pi4 && p < 5 * pi4) {
                    sceneObject.x += dx;
                    sceneObject.z += dy;
                } else if (p > 5 * pi4 && p < 7 * pi4) {
                    sceneObject.z -= dx;
                    sceneObject.x += dy;
                } else {
                    sceneObject.x -= dx;
                    sceneObject.z -= dy;
                }
            }
        }

        sceneObject.update();
        scene3d.ruler3d.findRules(scene.currentView3DObject);
        scope.rendererUpdate();

        mouseInteractionHelper.updateFreeSpace();
    };

    scope.moveSelectedGroup = function (dx, dy, vertical) {
        var camData = scope.getCameraData();
        var group = scene.currentGroup;

        if (vertical) {
            group.y += dy;
        } else {
            var p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            var pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4) {
                group.z += dx;
                group.x -= dy;
            } else if (p > 3 * pi4 && p < 5 * pi4) {
                group.x += dx;
                group.z += dy;
            } else if (p > 5 * pi4 && p < 7 * pi4) {
                group.z -= dx;
                group.x += dy;
            } else {
                group.x -= dx;
                group.z -= dy;
            }
        }

        //group.update();
        scene3d.ruler3d.findRules(scene.currentView3DObject);
        scope.rendererUpdate();

        mouseInteractionHelper.updateFreeSpace();
    };

    scope.finishMoveSelectedObject = function () {
        if (
            scene.currentView3DObject.type == R2D.ProductType.MODEL &&
            scene.currentView3DObject.getForWall()
        ) {
            constructor.pickElement(scene.currentView3DObject.sceneObject.objectId);
            constructor.dropElement(
                R2D.Scene.getObjectDataForWallElement(
                    scene.currentView3DObject.sceneObject
                ),
                10
            );
        }
    };

    scope.moveSelectedMaterial = function (dx, dy) {
        var currentObj = commonSceneHelper.scene.currentView3DObject;
        var partNum = commonSceneHelper.scene.currentPartNum;

        var startShift = currentObj.getMaterialShift(partNum);

        if (
            currentObj.type == "wall" ||
            currentObj.type == "cut" ||
            currentObj.type == "topFrame"
        ) {
            scene.currentView3DObject.startMoveMaterial();
            scene.currentView3DObject.moveMaterial(
                [startShift[0] - dx, startShift[1] + dy],
                commonSceneHelper.scene.currentPartNum
            );
            scene.currentView3DObject.stopMoveMaterial();
            scene.currentView3DObject.update();
            scene.history.saveState();
        } else if (currentObj.type == "bottomFrame") {
            var dxn, dyn;
            var camData = scope.getCameraData();
            var p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            var pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4) {
                dxn = -dy;
                dyn = +dx;
            } else if (p > 3 * pi4 && p < 5 * pi4) {
                dxn = +dx;
                dyn = +dy;
            } else if (p > 5 * pi4 && p < 7 * pi4) {
                dxn = +dy;
                dyn = -dx;
            } else {
                dxn = -dx;
                dyn = -dy;
            }

            scene.currentView3DObject.startMoveMaterial();
            scene.currentView3DObject.moveMaterial(
                [startShift[0] - dxn, startShift[1] - dyn],
                commonSceneHelper.scene.currentPartNum
            );
            scene.currentView3DObject.stopMoveMaterial();
            scene.currentView3DObject.update();
            scene.history.saveState();
        } else if (
            currentObj.type == "cover" ||
            currentObj.type == "ceiling" ||
            currentObj.type == "area" ||
            currentObj.type == "cap"
        ) {
            var dxn, dyn;
            var camData = scope.getCameraData();
            var p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            var pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4) {
                dxn = -dy;
                dyn = +dx;
            } else if (p > 3 * pi4 && p < 5 * pi4) {
                dxn = +dx;
                dyn = +dy;
            } else if (p > 5 * pi4 && p < 7 * pi4) {
                dxn = +dy;
                dyn = -dx;
            } else {
                dxn = -dx;
                dyn = -dy;
            }

            scene.currentView3DObject.startMoveMaterial();
            scene.currentView3DObject.moveMaterial(
                [startShift[0] + dxn, startShift[1] + dyn],
                commonSceneHelper.scene.currentPartNum
            );
            scene.currentView3DObject.stopMoveMaterial();
            scene.currentView3DObject.update();
            scene.history.saveState();
        }
    };

    var cursorStyle = "";
    scope.setCursorGrabbing = function () {
        //cursorStyle = document.body.style.cursor;
        //canvasHTML.style.cursor = 'none';
    };

    scope.setCursorDefault = function () {
        //canvasHTML.style.cursor = cursorStyle;
    };

    scope.coversTitleViewer3D = new CoversTitleViewer3D(scope);
};

R2D.extend(R2D.ViewerScene3D, R2D.Viewer);
//viewers
R2D.ViewerScene2D = function(sharedRenderer, commonSceneHelper, mouseInteractionHelper, keyboardInteractionHelper, apiDispatcher) {
    R2D.Viewer.call(this, '2d', new R2D.ViewerData(R2D.STYLE.LP_ICON_2D, document.createElement("div"), 'HINT_BUTTON_2D'), commonSceneHelper.scene, true, true);

    let scope = this;
    let width = 800;
    let height = 600;
    let enabled = false;
    let scene = commonSceneHelper.scene;
    let constructor = scene.constructor;
    let history = scene.history;
    let scene3d = commonSceneHelper.scene3d;
    let drawing = commonSceneHelper.drawingHelper;
    let productObjects = commonSceneHelper.commonSceneObject.productObjects;
    let view2DObjects = commonSceneHelper.commonSceneObject.view2DObjects;
    let productHelper = commonSceneHelper.productHelper;
    let camera2d = new THREE.OrthographicCamera(-400, 400, -300, 300, 1, 1000);
    let renderer = new R2D.Renderer3DOrthographic(sharedRenderer, camera2d);

    let body = HGen.fromModel({
        "label":"viewer-scene-2d",
        "type":"container",
        "attributes":{
            "class":"viewer-body"
        },
        "children":[
            {
                "label":"tools",
                "type":"container",
                "attributes":{
                    "class":"viewer-tools"
                }
            }
        ]
    }, scope.getDomElement());
    body.style.overflow = 'hidden';
    let toolsHTML = body.lbl("tools").domElement;
    let canvasHTML = sharedRenderer.canvas.domElement;
    let canvas = HGen.fromModel({
        "label":"canvas",
        "type":"element",
        "tagName":"canvas",
        "attributes":{
            "class":"viewer-canvas"
        }
    }, canvasHTML);

    let cameraState = {
        anchor:{
            x:0,
            y:0,
            z:0
        },
        distance:900,
        tilt:Math.PI / 2,
        pan:0,
        zoom:{
            min: -0.8,
            max:0.8,
            current:1
        }
    };

    let productTransform2dHelper = new R2D.ProductTransform2DHelper(toolsHTML, scene, apiDispatcher);
    let objectsViewers3dPlanes = new Map();

    let topMeshes = [];

    scope.getObjectsViewers3dPlanes = () => objectsViewers3dPlanes;

    function updateConstructorCameraPosition() {
        let cPos = renderer.getCameraPosition();
        let cAnch = renderer.getCameraAnchor();

        constructor.setCameraPosition(new GEOM.Vector(cPos.x, cPos.z, cPos.y), new GEOM.Vector(cAnch.x, cAnch.z, cAnch.y));
    }
    scope.objectButtonsUpdate = () => {
        // let cAnch = renderer.getCameraAnchor();
        // let cZoom = renderer.getCameraZoom();
        // productTransform2dHelper.update(width / 2, height / 2, cAnch.x, cAnch.z, width / (width * (1 - cZoom)));
        productTransform2dHelper.updateButtons();
    }

    scope.viewerSceneUpdateEventHandler = event => {
        renderer.update();
    }
    scope.rendererCameraPositionUpdateEventHandler = event =>
    {
        let cAnch = renderer.getCameraAnchor();
        let cZoom = renderer.getCameraZoom();

        cameraState.anchor.x = cAnch.x;
        cameraState.anchor.y = cAnch.y;
        cameraState.anchor.z = cAnch.z;
        cameraState.zoom.current = cZoom;

        productTransform2dHelper.update(width / 2, height / 2, cAnch.x, cAnch.z, width / (width * (1 - cZoom)));

        updateConstructorCameraPosition();

        scope.dispatchEvent(new Event(R2D.Viewer.CAMERA_POSITION_UPDATE, scope));

        R2D.controller.savedLastChanges = false;
    }

    function historyStageEvent(event) {
        //R2D.User.updateElementHistory(scene.history.isUndo, scene.history.isRedo);
    }
    function historyUserEvent(event) {
        /*
        switch ( event.type ) {
            case R2D.User.HISTORY_UNDO:
                scene.history.undo();
                break;

            case R2D.User.HISTORY_REDO:
                scene.history.redo();
                break;
        }*/
    }
    function sceneObjectEvent(event) {
        let sceneObject = event.data;
        let viewerPlane = null;

        switch (event.type) {
            case R2D.Scene.OBJECT_ADDED:
                break;

            case R2D.Scene.OBJECT_REMOVED:
                viewerPlane = objectsViewers3dPlanes.get(sceneObject);
                if (!viewerPlane) return;

                if (sceneObject.type == R2D.ProductType.MODEL) {
                    if (enabled) {
                        view2DObjects.remove(viewerPlane.object3d);
                    }

                    productHelper.removeAlias(
                        viewerPlane.object3d.getObjectByName("planeForClick")
                    );
                    objectsViewers3dPlanes.delete(sceneObject);
                    viewerPlane.destroy();
                }
                break;
        }
    }

    scene.addEventListener(R2D.Scene.SCENE_CLEARED, sceneClearedListener);

    function sceneClearedListener()
    {
        removeTopMeshes();
    }

    function createTopMeshes()
    {
        topMeshes = [];
        let dataCap = constructor.cap;
        if (dataCap.parts[0].indices.length > 0)
        {
            let capGeom = R2D.Tool.makeBufferGeometry(dataCap.parts[0].indices, dataCap.parts[0].vertices, dataCap.parts[0].uvs);
            let capMesh = new THREE.Mesh(capGeom, new THREE.MeshPhongMaterial({color: 0x444444, side: THREE.DoubleSide}));
            let bbox = new THREE.Box3().setFromObject(capMesh);
            capMesh.position.y = 690 - bbox.min.y;
            capMesh.scale.z = -1;
            topMeshes.push(capMesh);
        }

        for (let i = 0; i < constructor.areas.length; i++)
        {
            let areaPart = constructor.areas[i].parts[0];
            let arGeom = R2D.Tool.makeBufferGeometry(areaPart.indices, areaPart.vertices, areaPart.uvs);
            let arMesh = new THREE.Mesh(arGeom, new THREE.MeshPhongMaterial({color: 0x666644, side: THREE.DoubleSide}));
            bbox = new THREE.Box3().setFromObject(arMesh);
            arMesh.position.y = 690 - bbox.min.y;
            arMesh.scale.z = -1;
            topMeshes.push(arMesh);
        }

        for (i = 0; i < topMeshes.length; i++)
        {
            commonSceneHelper.commonSceneObject.constructorObjects.add(topMeshes[i]);
        }
    }

    function removeTopMeshes()
    {
        for (let i = 0; i < topMeshes.length; i++)
        {
            if (topMeshes[i].parent) commonSceneHelper.commonSceneObject.constructorObjects.remove(topMeshes[i]);
        }
        topMeshes = [];
    }

    scope.reset = function() {
        removeTopMeshes();
        createTopMeshes();
    };
    scope.isEnabled = function() {
        return enabled;
    };
    scope.enable = function (previousViewer) {
        if ( enabled ) return;
        let sceneBounds = scene.getBounds();

        //if (R2D.tipArea) R2D.tipArea.show2dMain();

        commonSceneHelper.constructorHelper.constructor.hidePlinths();

        sharedRenderer.useContourFilter = true;

        mouseInteractionHelper.updateComponents(camera2d, canvasHTML, scope, toolsHTML);
        keyboardInteractionHelper.updateComponents(canvasHTML, scope);

        renderer.enable();
        renderer.setupRendererData();
        
        renderer.setCameraDistanceBounds(cameraState.distance, cameraState.distance);
        renderer.setCameraZoomBounds(cameraState.zoom.min, cameraState.zoom.max);
        renderer.setCameraTiltBounds(cameraState.tilt, cameraState.tilt);
        renderer.updateCameraViewPosition(cameraState.anchor.x, cameraState.anchor.y, cameraState.anchor.z, cameraState.distance, cameraState.pan, cameraState.tilt);
        renderer.updateCameraZoom(renderer.getCameraZoom());

        updateConstructorCameraPosition();

        commonSceneHelper.addEventListener(Event.UPDATE, scope.viewerSceneUpdateEventHandler);
        renderer.addEventListener(R2D.Renderer3DOrthographic.CAMERA_POSITION_UDPATE, scope.rendererCameraPositionUpdateEventHandler);

        if ( previousViewer != '3d' && previousViewer != "walk" ) {
            scene.history.clear();
            scene.history.saveState();
        }

        scene.history.addEventListener(R2D.SceneHistory.UNDO_ACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.UNDO_INACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.REDO_ACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.REDO_INACTIVE, historyStageEvent);

        drawing.enable();

        //R2D.User.updateElementHistory(scene.history.isUndo, scene.history.isRedo);
        //R2D.User.addEventListener(R2D.User.HISTORY_UNDO, historyUserEvent);
        //R2D.User.addEventListener(R2D.User.HISTORY_REDO, historyUserEvent);
        //R2D.User.showElementHistory(true);

        // objectsViewers3dPlanes.forEach(objectPlane => productObjects.add(objectPlane.object3d));

        objectsViewers3dPlanes.forEach((planeViewer) => {
            planeViewer.updateObject();
            view2DObjects.add(planeViewer.object3d);
            planeViewer.object3d.getObjectByName("plane").visible = true;

            const objViewer3d = productHelper.findObjectView3DByObject3D(
                planeViewer.object3d.getObjectByName("planeForClick")
            );
            if (objViewer3d) {
                objViewer3d.object3d.visible = false;
            }
        });

        body.addAt(0, canvas);

        enabled = true;

        mouseInteractionHelper.constructorSelection(true);

        createTopMeshes();

        R2D.scene3d.getLights().modeUniform();

    };
    scope.disable = function () {
        if ( !enabled ) return;

        //if (R2D.tipArea) R2D.tipArea.hide();

        commonSceneHelper.constructorHelper.constructor.showPlinths();

        sharedRenderer.useContourFilter = false;

        renderer.disable();
        renderer.removeEventListener(R2D.Renderer3DOrthographic.CAMERA_POSITION_UDPATE, scope.rendererCameraPositionUpdateEventHandler);
        commonSceneHelper.removeEventListener(Event.UPDATE, scope.viewerSceneUpdateEventHandler);

        mouseInteractionHelper.updateComponents(null, null, null);
        keyboardInteractionHelper.updateComponents(null, null);

        //R2D.User.showElementHistory(false);
        //R2D.User.removeEventListener(R2D.User.HISTORY_UNDO, historyUserEvent);
        //R2D.User.removeEventListener(R2D.User.HISTORY_REDO, historyUserEvent);

        scene.history.removeEventListener(R2D.SceneHistory.UNDO_ACTIVE, historyStageEvent);
        scene.history.removeEventListener(R2D.SceneHistory.UNDO_INACTIVE, historyStageEvent);
        scene.history.removeEventListener(R2D.SceneHistory.REDO_ACTIVE, historyStageEvent);
        scene.history.removeEventListener(R2D.SceneHistory.REDO_INACTIVE, historyStageEvent);

        drawing.disable();
        /*
        R2D.User.showElementLogin(false);
        R2D.User.showElementCurrentProject(false);
        R2D.User.showElementShareProject(false);
        R2D.User.showElementTakeSnapshot(false);
        R2D.User.showElementSaveProject(false);
        R2D.User.showElementUser(false);
        R2D.User.showElementLanguages(false);
        */
        objectsViewers3dPlanes.forEach((planeViewer) =>
            view2DObjects.remove(planeViewer.object3d)
        );

        productObjects.children.forEach((obj) => {
            obj.visible = true;
        });

        // objectsViewers3dPlanes.forEach(objectPlane => R2D.scene3d.add(objectPlane.object3d, "top"));

        body.remove(canvas);

        enabled = false;

        removeTopMeshes();
    };
    scope.selectedObject = function(object) {
        productTransform2dHelper.updateProduct(object);
    };
    scope.unselectedObject = function(object) {
        productTransform2dHelper.updateProduct(null);
        scene3d.top.children.forEach((i) => {
            if (i.name == "rotationRings") {
                i.clear();
                i.removeFromParent();
            }
        });
        if (mouseInteractionHelper.state.name === "stateSelectedProduct") {
            mouseInteractionHelper.state.setOnRotationDownStatus(false);
            //mouseInteractionHelper.state.setRotationModeActive(false);
        }
    };
    scope.stateUserUnknown = function() {
        /*
        R2D.User.showElementCurrentProject(true);
        R2D.User.showElementShareProject(true);
        R2D.User.showElementTakeSnapshot(true);
        R2D.User.showElementUser(false);
        R2D.User.showButtonMyRenders(false);
        R2D.User.showButtonRender(false);
        R2D.User.showElementLogin(true);
        R2D.User.showElementLanguages(true);
        R2D.User.showElementSaveProject(true);
        */
    };
    scope.stateUserLogged = function() {
        /*
        R2D.User.showElementLogin(false);
        R2D.User.showElementCurrentProject(true);
        R2D.User.showElementShareProject(true);
        R2D.User.showElementTakeSnapshot(true);
        R2D.User.showElementSaveProject(true);
        R2D.User.showElementUser(true);
        R2D.User.showElementLanguages(true);
        R2D.User.showButtonMyRenders(true);
        R2D.User.showButtonRender(true);
        */
    };
    scope.rendererUpdate = function() {
        renderer.update();
    };
    scope.setSize = function(w, h)
    {
        width = w;
        height = h;

        body.style.width = width + 'px';
        body.style.height = height + 'px';

        renderer.setSize(width, height);
        renderer.update();

        scope.rendererCameraPositionUpdateEventHandler();
    };
    scope.cameraRotate = function(dx, dy) {
        //-
    };
    scope.cameraMove = function (dx, dy) {
        renderer.cameraMove(dx, dy);
        if (
            mouseInteractionHelper.state.name === "stateSelectedProduct" && mouseInteractionHelper._scene.isRotation3dActive
        ) {
            const rings = mouseInteractionHelper.getRingsObject3D();
            mouseInteractionHelper.updateRingsDirAndZoom(rings);
            const sphere = rings?.children.find((i) => i.name == "sphereRings");
            if(sphere) sphere.visible = false;
        }
    };
    scope.cameraSet = function (sx, sy) {
        renderer.cameraSet(sx, sy);
    };


    scope.zoom = function(x, y, dir)
    {
        renderer.cameraZoom(-dir);
        let newX, newZ;
        
        let sceneBounds = scene.getBounds();

        newX = (x - window.innerWidth / 2) * 0.1;
        newZ = (y - window.innerHeight / 2) * 0.1;

        newX *= -dir;
        newZ *= -dir;

        renderer.updateCameraAnchor(newX, cameraState.anchor.y, newZ);
        
    };


    scope.cameraZoom = function(delta) {
        renderer.cameraZoom(delta);
        if (
            mouseInteractionHelper.state.name === "stateSelectedProduct" && mouseInteractionHelper._scene.isRotation3dActive
        ) {
            const rings = mouseInteractionHelper.getRingsObject3D();
            mouseInteractionHelper.updateRingsDirAndZoom(rings);
            const sphere = rings?.children.find((i) => i.name == "sphereRings");
            if(sphere) sphere.visible = false;
        }
        // let sceneBounds = scene.getBounds();
        // scope.zoom(sceneBounds.centerX, cameraState.anchor.y, delta)
    };
    scope.toCenter = function() {
        let sceneBounds = scene.getBounds();

        renderer.updateCameraAnchor(sceneBounds.centerX, cameraState.anchor.y, sceneBounds.centerY);
    };
    scope.updateCameraAnchor = (x, y, z) => {
        renderer.updateCameraAnchor(x, y, z);
    }
    scope.getViewStateData = function() {
        return {
            state:'2d',
            camera:{
                px:cameraState.anchor.x,
                py:cameraState.anchor.y,
                pz:cameraState.anchor.z,
                tilt:GEOM.toDeg(cameraState.tilt),
                pan:GEOM.toDeg(cameraState.pan),
                zoom:cameraState.zoom.current
            }
        };
    };
    scope.setViewStateData = function(data) {
        if ( data['state'] != '2d' ) return false;

        cameraState.anchor.x = parseFloat(data.camera.px);
        cameraState.anchor.y = parseFloat(data.camera.py);
        cameraState.anchor.z = data.camera.pz ? parseFloat(data.camera.pz) : cameraState.anchor.z;
        cameraState.zoom.current = data.camera.zoom ? parseFloat(data.camera.zoom) : cameraState.anchor.zoom; 

        if ( enabled ) {
            renderer.updateCameraViewPosition(cameraState.anchor.x, cameraState.anchor.y, cameraState.anchor.z, cameraState.distance, cameraState.pan, cameraState.tilt);
            renderer.updateCameraZoom(cameraState.zoom.current);
        }

        return true;
    };
    scope.makeRenderScreenShot = function() {
        
    };
    scope.makeScreenShot = function(prev) {
        let oldWidth = width;
        let oldHeight = height;
        let image = null;

        scope.setSize(1280, 720);

        sharedRenderer.render();

        image = canvasHTML.toDataURL('image/jpeg');

        scope.setSize(oldWidth, oldHeight);

        return image;
    };
    scope.makePreviewScreenShot = function ()
    {
        return scope.makeScreenShot(true);
    };
    scope.canRender = () => true;
    scope.objectSelection = function (value) {
        mouseInteractionHelper.objectSelection(value);
    };
    scope.getCameraObj = () => cameraState;
    scope.getCameraData = function () {
        return {
            type:'orthographic',
            viewportLeft:camera2d.left,
            viewportRight:camera2d.right,
            viewportTop:camera2d.top,
            viewportBottom:camera2d.bottom,
            position:renderer.getCameraPosition(),
            anchor:renderer.getCameraAnchor()
        };
    };

    scene.addEventListener(R2D.Scene.OBJECT_ADDED, sceneObjectEvent);
    scene.addEventListener(R2D.Scene.OBJECT_REMOVED, sceneObjectEvent);

    scope.getUseRulers = function()
    {
        return true;
    };

    scope.addRuler = function()
    {
        scope.dispatchEvent(new Event(R2D.Viewer.ADD_RULER));
    };

    scope.moveSelectedObject = function(dx, dy)
    {
        let camData = scope.getCameraData();
        let sceneObject = scene.currentView3DObject.sceneObject;

        if (scene.currentView3DObject.forWall)
        {
            let angle = (TR.degToRad(sceneObject.rotationY) + Math.PI * 100) % (2 * Math.PI);

            let d = dx;
            if (angle > Math.PI * 0.5 && angle < Math.PI * 1.5) d = -dx;

            sceneObject.x = sceneObject.x - d * Math.cos(TR.degToRad(sceneObject.rotationY));
            sceneObject.z = sceneObject.z + d * Math.sin(TR.degToRad(sceneObject.rotationY));
        }
        else
        {
            sceneObject.x -= dx;
            sceneObject.z -= dy;
        }

        sceneObject.update();
        scene3d.ruler3d.findRules(scene.currentView3DObject);
        scope.rendererUpdate();

        mouseInteractionHelper.updateFreeSpace();
    };

    scope.moveSelectedGroup = function(dx, dy)
    {
        let group = scene.currentGroup;

        group.x -= dx;
        group.z -= dy;

    //    group.update();
        scene3d.ruler3d.findRules(scene.currentView3DObject);
        scope.rendererUpdate();

        mouseInteractionHelper.updateFreeSpace();
    };

    scope.moveSelectedMaterial = function(dx, dy)
    {

    };

    scope.finishMoveSelectedObject = function()
    {
        if (scene.currentView3DObject.type == R2D.ProductType.MODEL && scene.currentView3DObject.getForWall())
        {
            constructor.pickElement(scene.currentView3DObject.sceneObject.objectId);
            constructor.dropElement(R2D.Scene.getObjectDataForWallElement(scene.currentView3DObject.sceneObject), 10);
        }
    };
};

R2D.ViewerScene2D._instance = null;

R2D.ViewerScene2D.init = (sharedRenderer, commonSceneHelper, mouseInteractionHelper, keyboardInteractionHelper, apiDispatcher) => {
    R2D.ViewerScene2D._instance = new R2D.ViewerScene2D(sharedRenderer, commonSceneHelper, mouseInteractionHelper, keyboardInteractionHelper, apiDispatcher);
    return R2D.ViewerScene2D._instance;
}

R2D.extend(R2D.ViewerScene2D, R2D.Viewer);
//viewers

R2D.ViewerSceneWalk = function(sharedRenderer, commonSceneHelper, mouseInteractionHelper, keyboardInteractionHelper) {
    R2D.Viewer.call(this, 'walk', new R2D.ViewerData(R2D.STYLE.LP_ICON_WALK, document.createElement("div"), 'HINT_BUTTON_WALK'), commonSceneHelper.scene, false, false);

    let scope = this;
    let width = 800;
    let height = 600;
    let enabled = false;
    let scene = commonSceneHelper.scene;
    let constructor = scene.constructor;
    let scene3d = commonSceneHelper.scene3d;
    let drawing = commonSceneHelper.drawingHelper;
    let camera3d = new THREE.PerspectiveCamera(60, 800 / 600, 5.0, 5000.0);
    let renderer = new R2D.Renderer3DPerspective(sharedRenderer, camera3d, scene3d);
    let isRenderStateActive = false;


    let urlList = R2D.URL.URL_GET_CATEGORY_PRODUCTS;
    if (urlList.includes('?'))
    {
        urlList += '&';
    }
    else
    {
        urlList += '?';
    }
    urlList = urlList +  'category_tag=skybox';

     // todo: public functions
    //let skyboxesPage = new R2D.RightPanel.PageSkyboxes('Skyboxes', R2D.makeURL(R2D.URL.DOMAIN, urlList));
    //skyboxesPage.addEventListener(R2D.RightPanel.PageSkyboxes.SkyboxElement.SELECT, skyboxSelectListener);
    //skyboxesPage.addEventListener(R2D.RightPanel.PageSkyboxes.SkyboxElement.ROTATE, skyboxRotateListener);
    //skyboxesPage.addEventListener(R2D.RightPanel.PageSkyboxes.SkyboxElement.END_ROTATE, skyboxEndRotateListener);
    //skyboxesPage.addEventListener(Event.COMPLETE, skyboxCompleteListener);

    R2D.controller.addEventListener(Event.COMPLETE, sceneCompleteListener);
    scene.addEventListener(R2D.Scene.SCENE_CLEARED, sceneClearedListener);

    let mouseX = 0;
    let mouseY = 0;

    let body = HGen.fromModel({
        "label":"viewer-scene-walk",
        "type":"container",
        "attributes":{
            "class":"viewer-body"
        },
        "children":[
            {
                "label":"tools",
                "type":"container",
                "attributes":{
                    "class":"viewer-tools"
                }
            }
        ]
    }, scope.getDomElement());
    body.style.overflow = 'hidden';
    let toolsHTML = body.lbl("tools").domElement;
    let canvasHTML = sharedRenderer.canvas.domElement;
    let canvas = HGen.fromModel({
        "label":"canvas",
        "type":"element",
        "tagName":"canvas",
        "attributes":{
            "class":"viewer-canvas"
        }
    }, canvasHTML);

    let cameraState = {
        anchor:{
            x:0,
            y:150,
            z:0,
            default:150
        },
        distance:{
            min:1,
            max:1,
            current:1
        },
        tilt:{
            min:-1,//-0.3,
            max:1.45,
            current:0
        },
        pan:0
    };

    function updateConstructorCameraPosition() {
        let cPos = renderer.getCameraPosition();
        let cAnch = renderer.getCameraAnchor();

        constructor.setCameraPosition(new GEOM.Vector(cPos.x, cPos.z, cPos.y), new GEOM.Vector(cAnch.x, cAnch.z, cAnch.y), false);
    }
    function viewerSceneUpdateEventHandler(event) {
        renderer.update();
    }
    function rendererCameraPositionUpdateEventHandler(event) {
        let cPan = renderer.getCameraPan();
        let cTilt = renderer.getCameraTilt();
        let cDist = renderer.getCameraDistance();
        let cPos = renderer.getCameraPosition();
        let cAnch = renderer.getCameraAnchor();

        cameraState.anchor.x = cAnch.x;
        cameraState.anchor.y = cAnch.y;
        cameraState.anchor.z = cAnch.z;
        cameraState.distance.current = cDist;
        cameraState.tilt.current = cTilt;
        cameraState.pan = cPan;

        updateConstructorCameraPosition();

        scope.dispatchEvent(new Event(R2D.Viewer.CAMERA_POSITION_UPDATE, scope));

        R2D.controller.savedLastChanges = false;
    }
    function updateCamera() {
        camera3d.aspect = width / height;
        camera3d.updateProjectionMatrix();
    }

    function historyStageEvent(event) {
        //R2D.User.updateElementHistory(scene.history.isUndo, scene.history.isRedo);
    }
    function historyUserEvent(event) {
        /*
        switch ( event.type ) {
            case R2D.User.HISTORY_UNDO:
                scene.history.undo();
                break;

            case R2D.User.HISTORY_REDO:
                scene.history.redo();
                break;
        }
        */
    }

    scope.isEnabled = function() {
        return enabled;
    };
    scope.enable = function (previousViewer) {
        if ( enabled ) return;

        //R2D.tipArea.showWalkMain();

        mouseInteractionHelper.updateComponents(camera3d, canvasHTML, scope, toolsHTML);
        keyboardInteractionHelper.updateComponents(canvasHTML, scope);

        renderer.enable();
        renderer.setupRendererData();
        renderer.setCameraDistanceBounds(cameraState.distance.min, cameraState.distance.max);
        renderer.setCameraTiltBounds(cameraState.tilt.min, cameraState.tilt.max);
        renderer.updateCameraViewPosition(cameraState.anchor.x, cameraState.anchor.y, cameraState.anchor.z, cameraState.distance.current, cameraState.pan, cameraState.tilt.current);
        renderer.setCameraMinHeight(cameraState.anchor.y);

        updateConstructorCameraPosition();

        commonSceneHelper.addEventListener(Event.UPDATE, viewerSceneUpdateEventHandler);
        renderer.addEventListener(R2D.Renderer3DPerspective.CAMERA_POSITION_UDPATE, rendererCameraPositionUpdateEventHandler);

        if ( previousViewer != '2d' && previousViewer != "3d" ) {
            scene.history.clear();
            scene.history.saveState();
        }

        scene.history.addEventListener(R2D.SceneHistory.UNDO_ACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.UNDO_INACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.REDO_ACTIVE, historyStageEvent);
        scene.history.addEventListener(R2D.SceneHistory.REDO_INACTIVE, historyStageEvent);

        drawing.enable();

        //R2D.User.updateElementHistory(scene.history.isUndo, scene.history.isRedo);
        //R2D.User.addEventListener(R2D.User.HISTORY_UNDO, historyUserEvent);
        //R2D.User.addEventListener(R2D.User.HISTORY_REDO, historyUserEvent);
        //R2D.User.showElementHistory(true);

        body.addAt(0, canvas);

        enabled = true;

        R2D.scene.checkSkybox();
        R2D.scene.showCursor();
        //skyboxesPage.enable();
        //R2D.rightPanel.addPage(skyboxesPage);

        //R2D.catalogLoader.addEventListener(Event.COMPLETE, catalogLoaderListener);

        R2D.scene3d.getLights().modeMain();
    };
    scope.disable = function () {
        if ( !enabled ) return;

        //R2D.tipArea.hide();

        renderer.disable();
        renderer.removeEventListener(R2D.Renderer3DPerspective.CAMERA_POSITION_UDPATE, rendererCameraPositionUpdateEventHandler);
        commonSceneHelper.removeEventListener(Event.UPDATE, viewerSceneUpdateEventHandler);

        mouseInteractionHelper.updateComponents(null, null, null);
        keyboardInteractionHelper.updateComponents(null, null);

        //R2D.User.showElementHistory(false);
        //R2D.User.removeEventListener(R2D.User.HISTORY_UNDO, historyUserEvent);
        //R2D.User.removeEventListener(R2D.User.HISTORY_REDO, historyUserEvent);

        scene.history.removeEventListener(R2D.SceneHistory.UNDO_ACTIVE, historyStageEvent);
        scene.history.removeEventListener(R2D.SceneHistory.UNDO_INACTIVE, historyStageEvent);
        scene.history.removeEventListener(R2D.SceneHistory.REDO_ACTIVE, historyStageEvent);
        scene.history.removeEventListener(R2D.SceneHistory.REDO_INACTIVE, historyStageEvent);

        drawing.disable();
        /*
        R2D.User.showElementLogin(false);
        R2D.User.showElementCurrentProject(false);
        R2D.User.showElementShareProject(false);
        R2D.User.showElementTakeSnapshot(false);
        R2D.User.showElementSaveProject(false);
        R2D.User.showElementUser(false);
        R2D.User.showElementLanguages(false);
        */
        body.remove(canvas);

        enabled = false;

        R2D.scene.hideSkybox();

        //R2D.rightPanel.removePage(skyboxesPage);

        //R2D.catalogLoader.removeEventListener(Event.COMPLETE, catalogLoaderListener);
    };
    scope.changeIsRenderStateActive = state => isRenderStateActive = state;
    scope.selectedObject = function(object) {
        //-
    };
    scope.unselectedObject = function(object) {
        //-
    };
    scope.stateUserUnknown = function() {
        /*
        R2D.User.showElementCurrentProject(true);
        R2D.User.showElementShareProject(true);
        R2D.User.showElementTakeSnapshot(true);
        R2D.User.showElementUser(false);
        R2D.User.showButtonMyRenders(false);
        R2D.User.showButtonRender(false);
        R2D.User.showElementLogin(true);
        R2D.User.showElementLanguages(true);
        R2D.User.showElementSaveProject(true);
        */
    };
    scope.stateUserLogged = function() {
        /*
        R2D.User.showElementLogin(false);
        R2D.User.showElementCurrentProject(true);
        R2D.User.showElementShareProject(true);
        R2D.User.showElementTakeSnapshot(true);
        R2D.User.showElementSaveProject(true);
        R2D.User.showElementUser(true);
        R2D.User.showElementLanguages(true);
        R2D.User.showButtonMyRenders(true);
        R2D.User.showButtonRender(true);
        */
    };
    scope.rendererUpdate = function() {
        renderer.update();
    };
    scope.showCursor = function() {
        if (jumping || isRenderStateActive) return;
        R2D.scene.showCursor();
        scope.updateCursor(mouseX, mouseY);
    };
    scope.hideCursor = function() {
        R2D.scene.hideCursor();
    };
    scope.updateCursor = function(x, y) {

        mouseX = x;
        mouseY = y;

        let objectData = scene3d.objectUnderCursor(R2D.commonSceneObject.interactiveObjects,
            mouseInteractionHelper._currentCamera, x, y);


        if (objectData)
        {
            let n = new THREE.Vector3();
            n.copy(objectData.face.normal);
            n.transformDirection(objectData.object.matrixWorld);
            //objectData.object
            scene.repositionCursor3D(objectData.point, n);
        }
        else
        {
            scene.repositionCursor3D(null);
        }

        renderer.updateCursor(x, y);
    };
    scope.setSize = function(w, h, isRenderActive) {
        width = w;
        height = h;

        body.style.width = width + 'px';
        body.style.height = height + 'px';

        isRenderActive ? document.querySelector("#planner").classList.add("renderMake") : document.querySelector("#planner").classList.remove("renderMake");
        
        updateCamera();

        renderer.setSize(width, height);
        renderer.update();
    };
    scope.cameraRotate = function(dx, dy) {
        renderer.cameraRotate(dx, dy);
        mouseInteractionHelper.api.dispatchEvent(new Event(mouseInteractionHelper.api.CAMERA_ROTATE, {degrees: radiansToDegrees(renderer.getCameraTilt())} ));
        if(scope.webGLRenderer.clippingPlanes.length == 1) scope.updateClipPlane();
    };

    scope.getCameraVerAngle = () => radiansToDegrees(renderer.getCameraTilt());

    function radiansToDegrees(radians)
    {
        return radians * 180 / Math.PI;
    }

    scope.setCameraVerAngleRad = rad => renderer.updateCameraTilt(rad);

    scope.cameraMove = function (dx, dy) {
        renderer.cameraMove(dx, dy);
        R2D.scene.repositionSkybox();
        R2D.scene.checkSkybox();
        if(scope.webGLRenderer.clippingPlanes.length == 1) scope.updateClipPlane();
    };
    scope.cameraMoveY = function (dy) {
        renderer.cameraMoveY(dy);
        renderer.setCameraMinHeight(dy);
        R2D.scene.repositionSkybox();
        R2D.scene.checkSkybox();
    };
    scope.cameraMinHeightResetToDef = function() {
        renderer.setCameraMinHeight(cameraState.anchor.default);
    };
    scope.cameraZoom = function(delta) {
        renderer.cameraMove(0, delta > 0 ? -30 : 30);
        R2D.scene.repositionSkybox();
        R2D.scene.checkSkybox();
        if(scope.webGLRenderer.clippingPlanes.length == 1) scope.updateClipPlane();
    };

    let startX = null;
    let startZ = null;
    let startP = null;
    let addX = 0;
    let addZ = 0;
    let addP = 0;
    let t = 0;
    let dt = 0.1;
    let interval = null;
    let jumping = false;
    scope.cameraJump = function(x, y)
    {
        let stepsNum = 100;
        let animTime = 500;
        let minDist = 40;

        let startPos = renderer.getCameraAnchor();
        startX = startPos.x;
        startZ = startPos.z;
        addX = (x - startPos.x) * 0.8;
        addZ = (y - startPos.z) * 0.8;
        if (Math.sqrt(addX * addX + addZ * addZ) < minDist) return;

        jumping = true;
        scope.hideCursor();

        if (addX > 500) addX = 500;
        if (addZ > 500) addZ = 500;
        if (addX < -500) addX = -500;
        if (addZ < -500) addZ = -500;
        startP = renderer.getCameraPan();
        let startAngle = (startP + Math.PI * 200) % (Math.PI * 2);
        let newAngle = (Math.atan2(x - startPos.x, y - startPos.z) - Math.PI + Math.PI * 200) % (Math.PI * 2);
        addP = (newAngle - startAngle);
        if (addP > Math.PI) addP -= Math.PI * 2;
        if (addP < -Math.PI) addP += Math.PI * 2;

        if (interval) clearInterval(interval);
        t = 0;
        dt = 1 / stepsNum;
        interval = setInterval(function()
        {
            t += dt;
            let arg = Math.sin(t * Math.PI / 2);
            renderer.updateCameraAnchor(startX + addX * arg, startPos.y, startZ + addZ * arg);
            //renderer.updateCameraPan(startP + addP * t);

            //scope.updateCursor(mouseX, mouseY);
            if (t >= 1)
            {
                jumping = false;
                scope.showCursor();
                clearInterval(interval);
            }

        }, animTime / stepsNum);

    };
    scope.toCenter = function() {
        let sceneBounds = scene.getBounds();

        renderer.updateCameraAnchor(sceneBounds.centerX, cameraState.anchor.y, sceneBounds.centerY);
    };
    scope.getViewStateData = function() {
        return {
            state:'walk',
            camera:{
                px:cameraState.anchor.x,
                py:cameraState.anchor.y,
                pz:cameraState.anchor.z,
                tilt:GEOM.toDeg(cameraState.tilt.current),
                pan:GEOM.toDeg(cameraState.pan),
                zoom:1
            }
        };
    };
    scope.setViewStateData = function(data) {
        if ( data['state'] != 'walk' ) return false;

        cameraState.anchor.x = parseFloat(data.camera.px);
        // cameraState.anchor.y = parseFloat(data.camera.py);
        cameraState.anchor.z = parseFloat(data.camera.pz);
        cameraState.pan = GEOM.toRad(parseFloat(data.camera.pan));
        cameraState.tilt.current = GEOM.toRad(parseFloat(data.camera.tilt));

        if ( enabled ) {
            renderer.updateCameraViewPosition(cameraState.anchor.x, cameraState.anchor.y, cameraState.anchor.z, cameraState.distance.current, cameraState.pan, cameraState.tilt.current);
        }

        return true;
    };
    scope.makeRenderScreenShot = function() {
        
        let image = null;

        sharedRenderer.render();

        image = canvasHTML.toDataURL('image/jpeg');

        return image;
    };
    scope.makeScreenShot = function(prev) {
        let oldWidth = width;
        let oldHeight = height;
        let oldSSAO = sharedRenderer.useSSAOFilter;
        let image = null;
        //scope.setSize(1280, 720);
        scope.setSize(R2D.Viewers.getRenderFrameData().frameWidth, R2D.Viewers.getRenderFrameData().frameHeight);

        if (prev)
        {
            scope.setSize(265, 150);
            sharedRenderer.useSSAOFilter = false;
        }

        sharedRenderer.render();

        image = canvasHTML.toDataURL('image/jpeg');

        scope.setSize(oldWidth, oldHeight);
        sharedRenderer.useSSAOFilter = oldSSAO;

        return image;
    };
    scope.makePreviewScreenShot = function ()
    {
        return scope.makeScreenShot(true);
    };
    scope.canRender = () => true;
    scope.objectSelection = function (value) {
        mouseInteractionHelper.objectSelection(value);
    };
    scope.getCameraData = function () {
        return {
            type:'perspective',
            fov:scope.getCameraFOV(),
            pan:renderer.getCameraPan(),
            tilt:renderer.getCameraTilt(),
            distance:renderer.getCameraDistance(),
            position:renderer.getCameraPosition(),
            anchor:renderer.getCameraAnchor(),
            clipping:scope.getDistFromCameraToPlane()
        };
    };

    scope.moveSelectedGroup = function (dx, dy, vertical) {
        let camData = scope.getCameraData();
        let group = scene.currentGroup;

        if (vertical)
        {
            group.y += dy;
        }
        else
        {
            let p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            let pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4)
            {
                group.z += dx;
                group.x -= dy;
            }
            else if (p > 3 * pi4 && p < 5 * pi4)
            {
                group.x += dx;
                group.z += dy;
            }
            else if (p > 5 * pi4 && p < 7 * pi4)
            {
                group.z -= dx;
                group.x += dy;
            }
            else
            {
                group.x -= dx;
                group.z -= dy;
            }
        }

        //group.update();
        scene3d.ruler3d.findRules(scene.currentView3DObject);
        scope.rendererUpdate();

        mouseInteractionHelper.updateFreeSpace();
    };

    scope.moveSelectedObject = function (dx, dy) {
        let camData = scope.getCameraData();
        let sceneObject = scene.currentView3DObject.sceneObject;

        if (scene.currentView3DObject.type == R2D.ProductType.POSTER)
        {
            sceneObject.y += dy;
            sceneObject.x = sceneObject.x - dx * Math.cos(TR.degToRad(sceneObject.rotationY));
            sceneObject.z = sceneObject.z + dx * Math.sin(TR.degToRad(sceneObject.rotationY));
        }
        else if (scene.currentView3DObject.forWall)
        {
            let deltaAngle = (camData.pan + Math.PI * 100 - TR.degToRad(sceneObject.rotationY)) % (2 * Math.PI);

            let d = dx;
            if (deltaAngle > Math.PI * 0.5 && deltaAngle < Math.PI * 1.5) d = -dx;

            sceneObject.y += dy;
            sceneObject.x = sceneObject.x - d * Math.cos(TR.degToRad(sceneObject.rotationY));
            sceneObject.z = sceneObject.z + d * Math.sin(TR.degToRad(sceneObject.rotationY));
        }
        else
        {
            let p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            let pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4)
            {
                scene.currentView3DObject.sceneObject.z += dx;
                scene.currentView3DObject.sceneObject.x -= dy;
            }
            else if (p > 3 * pi4 && p < 5 * pi4)
            {
                scene.currentView3DObject.sceneObject.x += dx;
                scene.currentView3DObject.sceneObject.z += dy;
            }
            else if (p > 5 * pi4 && p < 7 * pi4)
            {
                scene.currentView3DObject.sceneObject.z -= dx;
                scene.currentView3DObject.sceneObject.x += dy;
            }
            else
            {
                scene.currentView3DObject.sceneObject.x -= dx;
                scene.currentView3DObject.sceneObject.z -= dy;
            }
        }

        scene.currentView3DObject.sceneObject.update();
        scene3d.ruler3d.findRules(scene.currentView3DObject);
        scope.rendererUpdate();

        mouseInteractionHelper.updateFreeSpace();
    };

    scope.finishMoveSelectedObject = function()
    {
        if (scene.currentView3DObject.type == R2D.ProductType.MODEL && scene.currentView3DObject.getForWall())
        {
            constructor.pickElement(scene.currentView3DObject.sceneObject.objectId);
            constructor.dropElement(R2D.Scene.getObjectDataForWallElement(scene.currentView3DObject.sceneObject), 10);
        }
    };

    scope.moveSelectedMaterial = function (dx, dy)
    {
        let currentObj = commonSceneHelper.scene.currentView3DObject;
        let partNum = commonSceneHelper.scene.currentPartNum;

        let startShift = currentObj.getMaterialShift(partNum);

        if (currentObj.type == 'wall' || currentObj.type == 'cut')
        {
            scene.currentView3DObject.startMoveMaterial();
            scene.currentView3DObject.moveMaterial([startShift[0] - dx, startShift[1] + dy], commonSceneHelper.scene.currentPartNum);
            scene.currentView3DObject.stopMoveMaterial();
            scene.currentView3DObject.update();
            scene.history.saveState();
        }
        else if (currentObj.type == 'cover' || currentObj.type == 'ceiling' || currentObj.type == 'area' || currentObj.type == 'cap')
        {
            let dxn, dyn;
            let camData = scope.getCameraData();
            let p = (camData.pan + 100 * Math.PI) % (2 * Math.PI);
            let pi4 = Math.PI / 4;
            if (p > pi4 && p < 3 * pi4)
            {
                dxn = -dy;
                dyn = +dx;
            }
            else if (p > 3 * pi4 && p < 5 * pi4)
            {
                dxn = +dx;
                dyn = +dy;
            }
            else if (p > 5 * pi4 && p < 7 * pi4)
            {
                dxn = +dy;
                dyn = -dx;
            }
            else
            {
                dxn = -dx;
                dyn = -dy;
            }

            scene.currentView3DObject.startMoveMaterial();
            scene.currentView3DObject.moveMaterial([startShift[0] + dxn, startShift[1] + dyn], commonSceneHelper.scene.currentPartNum);
            scene.currentView3DObject.stopMoveMaterial();
            scene.currentView3DObject.update();
            scene.history.saveState();
        }
    };

    scope.getCameraFOV = () => camera3d.fov;

    scope.setCameraFOV = fov => {
        camera3d.fov = fov;
        camera3d.updateProjectionMatrix();
        renderer.update();
    }

    function skyboxSelectListener(e)
    {
        R2D.scene.setSkyboxMat(e.data.id);
        R2D.scene.setSkyboxRotation(e.data.rotation);
        R2D.scene.history.saveState();
    }

    function skyboxRotateListener(e)
    {
        R2D.scene.setSkyboxRotation(e.data.rotation);
    }

    function skyboxEndRotateListener(e)
    {
        R2D.scene.history.saveState();
    }

    function skyboxCompleteListener(e)
    {
        let skyboxId = R2D.scene.skyboxId;
        let skyboxRotation = R2D.scene.skyboxRotation;
        if (! skyboxId) skyboxId = e.data;

        if (skyboxId)
        {
            R2D.scene.setSkyboxMat(skyboxId);
            R2D.scene.setSkyboxRotation(skyboxRotation);
            //skyboxesPage.selectNewElement(skyboxId, skyboxRotation);
        }
    }

    let fovs = [60, 70, 80, 90, 100];
    let f = 0;

    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.altKey && e.code == 'KeyF')
        {
            f = (f + 1) % fovs.length;
            camera3d.fov = fovs[f];
            camera3d.updateProjectionMatrix();
            renderer.update();

            console.log('New FOV is ', fovs[f]);
        }
    });

    function catalogLoaderListener(e)
    {
        //R2D.rightPanel.addPage(skyboxesPage);
    }

    function sceneCompleteListener()
    {
        //if (R2D.scene.skyboxId) skyboxesPage.selectNewElement(R2D.scene.skyboxId, R2D.scene.skyboxRotation);
    }

    function sceneClearedListener()
    {

    }

    // CLIPPING

    const defaultDist = 20;
    scope.webGLRenderer = renderer.getWebGLRenderer();
    scope.distFromCameraToPlane = defaultDist;

    scope.onClipping = function () {
        if (scope.webGLRenderer.clippingPlanes.length !== 0) {
            return;
        }

        const clipPlane = new THREE.Plane(new THREE.Vector3(), 0);
        scope.webGLRenderer.clippingPlanes = [clipPlane];
        scope.updateClipPlane();
    };

    scope.offClipping = function () {
        scope.webGLRenderer.clippingPlanes = [];
        sharedRenderer.render();
    };

    scope.setDistFromCameraToPlane = function (dist) {
        scope.distFromCameraToPlane = dist;
        scope.updateClipPlane();
    };

    scope.getDistFromCameraToPlane = function () {
        return scope.distFromCameraToPlane;
    };

    scope.updateClipPlane = function () {
        const cameraData = scope.getCameraData();
        const vAnchor = new THREE.Vector3(cameraData.anchor.x, 0, cameraData.anchor.z);
        const vPos = new THREE.Vector3(cameraData.position.x, 0, cameraData.position.z);
        const vCameraDir = new THREE.Vector3().subVectors(vAnchor, vPos);
        vCameraDir.normalize();
        const clipPlane = scope.webGLRenderer.clippingPlanes[0];
        if(clipPlane) {
            clipPlane.constant = 0;
            clipPlane.normal = vCameraDir;
            const startDist = -clipPlane.distanceToPoint(vPos);
            clipPlane.constant = -(scope.distFromCameraToPlane - startDist);
        };
        
        sharedRenderer.render();
    };
};

R2D.extend(R2D.ViewerSceneWalk, R2D.Viewer);
class CoversTitleViewer3D {
    constructor(view3d) {
        this.rendererUpdate = view3d.rendererUpdate;
        this.scene = R2D.commonSceneHelper.scene;
        this.cameraData = view3d.cameraState;

        this.titlesContainer = R2D.commonSceneObject.coversTitleObjects;

        this.titlesData = [];
        this.scale = 1;
        this.isEnabled = false;
        this.font = { family: "Arial" };

        this.initParams = {
            distToCover: 1,
            fontSize: 10,
            k: 5, // 
            padding: 5, //padding between text and edge of plane
            planeHeight: 100,
            ctxLineWidth: 2,
            url: "url(/src_designer/Roboto-Regular.ttf)",
        };

        this.colors = {
            white: "rgba(255, 255, 255, 0.8)",
            black: "#000000",
            transparent: "rgba(255, 255, 255, 0)",
        };

        this.loadFont();
    }

    loadFont = function () {
        const fontLoader = new FontFace("loadedFont", this.initParams.url);
        fontLoader
            .load()
            .then((font) => {
                document.fonts.add(font);
                this.font = font;
            })
            .catch((err) => {
                console.log(err);
            });
    };

    enable = function () {
        this.isEnabled = true;

        this.updateScale();
        this.updateTitlesData();
        this.create3D();
        this.rendererUpdate();
    };

    disable = function () {
        this.remove3D();
        this.rendererUpdate();
        this.isEnabled = false;
    };

    create3D = function () {
        this.titlesData.forEach((titleData) => {
            const mesh = this.createMesh(titleData);
            this.titlesContainer.add(mesh);
        });

        this.update3D();
    };

    createMesh = function (titleData) {
        const planeGeometry = new THREE.PlaneGeometry(
            this.initParams.planeHeight,
            this.initParams.planeHeight
        );
        planeGeometry.rotateX(-Math.PI / 2);
        const planeMaterial = new THREE.MeshBasicMaterial({
            transparent: true,
        });
        const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
        mesh.userData.titleId = titleData.id;
        const x = titleData.title?.x || 0;
        const z = titleData.title?.y || 0;
        mesh.position.set(x, this.initParams.distToCover, z);

        return mesh;
    };

    createPlaneTexture = function (titleData) {
        const k = this.initParams.k;
        const scale = k * this.scale;
        const pad = this.initParams.padding * scale;

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const textWidth2 = (titleData.maxTxtWidth * scale) / 2;
        const txtHeight2 = (this.initParams.fontSize * scale) / 2;

        canvas.width = textWidth2 * 2 + pad * 2;
        canvas.height = this.initParams.planeHeight * k;

        ctx.fillStyle = this?.colors?.transparent;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = "center";
        ctx.miterLimit = 2;
        ctx.lineJoin = "round";

        ctx.fillStyle = this.colors.black;
        ctx.strokeStyle = this.colors.white;
        ctx.lineWidth = this.initParams.ctxLineWidth * scale;

        if (titleData.title?.visible?.view3d) {
            ctx.font = `${txtHeight2 * 2}px ${this.font.family}`;
            ctx.strokeText(titleData.title.text, canvas.width / 2, canvas.height / 2 - 2 * k);
            ctx.fillText(titleData.title.text, canvas.width / 2, canvas.height / 2 - 2 * k);
        }

        if (titleData.title?.areaVisible?.view3d) {
            ctx.font = `${(txtHeight2 - 5) * 2}px ${this.font.family}`;
            ctx.strokeText(
                titleData.area,
                canvas.width / 2,
                canvas.height / 2 + txtHeight2 * 2 + 2 * k
            );
            ctx.fillText(
                titleData.area,
                canvas.width / 2,
                canvas.height / 2 + txtHeight2 * 2 + 2 * k
            );
        }

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        return texture;
    };

    remove3D = function () {
        this.titlesContainer.children.forEach((mesh) => {
            mesh.geometry.dispose();
            if (mesh.material.map) mesh.material.map.dispose();
            mesh.material.dispose();
        });
        this.titlesContainer.clear && this.titlesContainer.clear();
    };

    update() {
        if (!this.isEnabled) return;

        this.updateScale();
        this.updateTitlesData();
        this.update3D();
        this.rendererUpdate();
    }

    updateScale = function () {
        const zoom =
            (this.cameraData.distance.current - this.cameraData.distance.min) /
            (this.cameraData.distance.max - this.cameraData.distance.min);
        this.scale = 1 + zoom * 1.5;
    };

    updateTitlesData() {
        this.titlesData = this.scene
            .getConstructor()
            .covers.map((cover, index) => {
                const titleData = {
                    id: index,
                    title: cover.title,
                    area: R2D.DimensionSystem.squareToString(cover.area),
                    maxTxtWidth: Math.max(
                        cover.title?.text.length * 9,
                        R2D.DimensionSystem.squareToString(cover.area).length * 9
                    ),
                };

                return titleData;
            })
            .filter((titleData) => titleData.title);
    }

    update3D = function () {
        this.titlesData.forEach((titleData) => {
            const mesh = this.titlesContainer.children.find(
                (mesh) => mesh.userData.titleId === titleData.id
            );

            if (!mesh) return;

            if (!titleData.title?.visible?.view3d && !titleData.title?.areaVisible?.view3d) {
                mesh.visible = false;
                return;
            };

            mesh.visible = true;
            if (mesh.material.map) mesh.material.map.dispose();
            const texture = this.createPlaneTexture(titleData);
            mesh.material.map = texture;
            mesh.material.map.needsUpdate = true;
            const scaleX = texture.image.width / this.initParams.planeHeight / this.initParams.k;
            mesh.scale.set(scaleX, 1, 1);
            mesh.rotation.set(0, this.cameraData.pan, 0);
        });
    };
}

var WC = {};

function TR() { }

TR.MIN_CONTOUR_AREA = 50;
TR.MIN_SP_RATIO = 1;

TR.BELONG = 'belong';
TR.CONTAIN = 'contain';
TR.OUTSIDE = 'outside';
TR.CONTACT = 'contact';
TR.CONTACT_BELONG = 'contactBelong';
TR.CONTACT_CONTAIN = 'contactContain';
TR.INTERSECT = 'intersect';
TR.COINCIDE = 'coincide';

TR.L_EPS = 0.00000001;
TR.B_EPS = 0.0001;

TR.euclDist = function(ax, ay, bx, by)
{
    return Math.sqrt(Math.pow((ax - bx), 2) + Math.pow((ay - by), 2));
};

TR.manhDist = function(ax, ay, bx, by)
{
    return Math.abs(ax - bx) + Math.abs(ay - by);
};

TR.euclDistP = function(A, B)
{
	return TR.euclDist(A.x, A.y, B.x, B.y);
};

TR.manhDistP = function(A, B)
{
    return TR.manhDist(A.x, A.y, B.x, B.y);
};

TR.degToRad = function(deg)
{
    return deg / 180 * Math.PI;
};

TR.radToDeg = function(rad)
{
    return rad / Math.PI * 180;
};

TR.contourArea = function(points)
{
    var a = 0;
    for (var i = 0; i < points.length - 1; i++)
    {
        a += (points[i].y + points[i + 1].y) / 2 * (points[i + 1].x - points[i].x);
    }

    a += (points[points.length - 1].y + points[0].y) / 2 * (points[0].x - points[points.length - 1].x);

    return a;
};

TR.contourPerim = function(points)
{
    var p = 0;
    for (var i = 0; i < points.length - 1; i++)
    {
        p += TR.euclDistP(points[i], points[i + 1]);
    }

    p += TR.euclDistP(points[points.length - 1], points[0]);

    return p;
};

TR.Point = function(x, y)
{
    var me = this;
    me.x = x;
    me.y = y;

    me.clone = function()
    {
        return new TR.Point(me.x, me.y);
    };

    me.match = function(P = {}, accuracy)
    {
        accuracy = typeof accuracy !== 'undefined' ? accuracy : TR.L_EPS;

        return ((Math.abs(P?.x - me.x) < accuracy) && (Math.abs(P?.y - me.y) < accuracy));
    };
};

TR.pointsMatch = function(A, B, accuracy)
{
    accuracy = typeof accuracy !== 'undefined' ? accuracy : TR.L_EPS;

    return ((Math.abs(A.x - B.x) < accuracy) && (Math.abs(A.y - B.y) < accuracy));
};

TR.distanceBetweenPointAndLine = function(point, pointLineA, pointLineB)
{
    var a = pointLineB.y - pointLineA.y;
    var b = pointLineA.x - pointLineB.x;
    var c = pointLineB.x * pointLineA.y - pointLineA.x * pointLineB.y;

    return ((a * point.x) + (b * point.y) + c) / Math.pow((Math.pow(a, 2) + Math.pow(b, 2)), .5);
};

TR.pointOnLine = function(point, a, b, accuracy)
{
    if(!point || !a || !b) return;
    accuracy = typeof accuracy !== 'undefined' ? accuracy : TR.B_EPS;

    if (point.x < Math.min(a.x, b.x) - accuracy) return false;
    if (point.x > Math.max(a.x, b.x) + accuracy) return false;

    if (point.y < Math.min(a.y, b.y) - accuracy) return false;
    if (point.y > Math.max(a.y, b.y) + accuracy) return false;

    var distA = TR.euclDist(point.x, point.y, a.x, a.y);
    if (distA < accuracy) return true;

    var distB = TR.euclDist(point.x, point.y, b.x, b.y);
    if (distB < accuracy) return true;

    var AB = TR.euclDist(a.x, a.y, b.x, b.y);
    if ((distA >= AB) && (distB >= AB)) return false;

    var distL = Math.abs(TR.distanceBetweenPointAndLine(point, a, b));

    if (distL < accuracy) return true;

    return false;
};

TR.pointOnContour = function(P, contour, accuracy)       // contour - array of points
{
    accuracy = typeof accuracy !== 'undefined' ? accuracy : TR.B_EPS;

    for (var i = 0; i < contour.length - 1; i++)
    {
        if (TR.pointOnLine(P, contour[i], contour[i + 1], accuracy)) return true;
    }

    if (TR.pointOnLine(P, contour[contour.length - 1], contour[0], accuracy)) return true;
    return false;
};

TR.pointInContours = function(P, contours, one)
{
    var c = 0;

    for (var i = 0; i < contours.length; i++)
    {
        if (TR.pointInContour(P, contours[i])) c++;
        if (one && c > 0) return 1;
    }

    return c;
};

TR.pointInContour = function(P, contour)            // contour - array of points
{
    if (! contour || contour.length < 3) return false;

    var EPS = 0.000001;
    var cont = [].concat(contour);

    var ptsOnRay = [];
    for (var i = 0; i < cont.length; i++)
    {
        if (cont[i].x < P.x + EPS && (Math.abs(cont[i].y - P.y) < EPS)) ptsOnRay.push(i); // added '+ EPS'
    }

    var numIntersect = 0;

    if (ptsOnRay.length > 0)
    {
        var bounds = [];
        var start = -1;
        var end = -1;
        for (i = 0; i < ptsOnRay.length; i++)
        {
            if (start == -1)
            {
                start = ptsOnRay[i]
            }
            if (start != -1)
            {
                if (i == ptsOnRay.length - 1 || ptsOnRay[i + 1] - ptsOnRay[i] > 1)
                {
                    end = ptsOnRay[i];
                    bounds.push([start, end]);
                    start = -1;
                    end = -1;
                }
            }
        }

        if (bounds[0][0] == 0 && bounds[bounds.length - 1][1] == cont.length - 1)
        {
            var sp = [bounds[bounds.length - 1][0], bounds[0][1]];
            bounds.pop();
            bounds.shift();
            bounds.push(sp);
        }

        for (i = 0; i < bounds.length; i++)
        {
            var b = bounds[i];
            var y0;
            var y1;

            if (b[0] == 0)
            {
                y0 = contour[contour.length - 1].y;
            }
            else
            {
                y0 = contour[b[0] - 1].y;
            }

            if (b[1] == contour.length - 1)
            {
                y1 = contour[0].y;
            }
            else
            {
                y1 = contour[b[1] + 1].y;
            }

            if (y0 < P.y && P.y < y1) numIntersect++;
            if (y0 > P.y && P.y > y1) numIntersect++;
        }
    }

    cont.push(cont[0]);
    for (i = 0; i < cont.length - 1; i++)
    {
        if (ptsOnRay.indexOf(i) >= 0 || (ptsOnRay.indexOf(i + 1) >= 0) ||
            (i == cont.length - 2 && ptsOnRay.indexOf(0) >= 0)) continue;

        var ax = cont[i].x;
        var ay = cont[i].y;
        var bx = cont[i + 1].x;
        var by = cont[i + 1].y;

        if (ax > P.x && bx > P.x) continue;
        if (ay > P.y && by > P.y) continue;
        if (ay < P.y && by < P.y) continue;
        if (ax < P.x && bx < P.x)
        {
            numIntersect++;
            continue;
        }

        var k = (by - ay) / (bx - ax);
        var ly = k * P.x + ay - k * ax;

        if ((k > 0) && (ly > P.y)) numIntersect++;
        if ((k < 0) && (ly < P.y)) numIntersect++;
    }

    return numIntersect % 2 != 0;
};

TR.triangleCenter = function(Ax, Ay, Bx, By, Cx, Cy)
{
    return new TR.Point((Ax + Bx + Cx) / 3, (Ay + By + Cy) / 3);
};

TR.triangleArea = function(Ax, Ay, Bx, By, Cx, Cy)
{
	return ((Ax - Cx) * (By - Cy) - (Bx - Cx) * (Ay - Cy)) / 2;
};

TR.triangleIsNarrow = function(Ax, Ay, Bx, By, Cx, Cy)
{
	var minLen = 0.1;
	var AB = TR.manhDist(Ax, Ay, Bx, By);
	var BC = TR.manhDist(Bx, By, Cx, Cy);
	var CA = TR.manhDist(Cx, Cy, Ax, Ay);

	return AB < minLen || BC < minLen || CA < minLen;
};

TR.angleBetweenLines = function(Ax, Ay, Bx, By, Cx, Cy, Dx, Dy)
{
    var angAB = Math.atan2(Bx - Ax, By - Ay);
    var angCD = Math.atan2(Dx - Cx, Dy - Cy);

    var ang = angAB - angCD;

    if (ang < 0) ang += 2 * Math.PI;
    if (ang >= 2 * Math.PI) ang -= 2 * Math.PI;

    return ang;
};

TR.checkMinMaxOutside = function(contourA, contourB)
{
    var minAX = Number.MAX_VALUE;
    var maxAX = -Number.MAX_VALUE;
    var minAY = Number.MAX_VALUE;
    var maxAY = -Number.MAX_VALUE;

    for (var i = 0; i < contourA.length; i++)
    {
        var P = contourA[i];
        if(P) {
            if (P.x < minAX) minAX = P.x;
            if (P.x > maxAX) maxAX = P.x;
            if (P.y < minAY) minAY = P.y;
            if (P.y > maxAY) maxAY = P.y;
        }
    }

    var minBX = Number.MAX_VALUE;
    var maxBX = -Number.MAX_VALUE;
    var minBY = Number.MAX_VALUE;
    var maxBY = -Number.MAX_VALUE;

    for (i = 0; i < contourB.length; i++)
    {
        P = contourB[i];
        if(P) {
            if (P.x < minBX) minBX = P.x;
            if (P.x > maxBX) maxBX = P.x;
            if (P.y < minBY) minBY = P.y;
            if (P.y > maxBY) maxBY = P.y;
        }
        
    }

    if (maxAX < minBX - TR.L_EPS) return true;
    if (minAX > maxBX + TR.L_EPS) return true;
    if (maxAY < minBY - TR.L_EPS) return true;
    if (minAY > maxBY + TR.L_EPS) return true;

    return false;
};

TR.compareContoursOnePoint = function(contourA, contourB)      // checks one point, returns BELONG, CONTAIN or OUTSIDE
{
    for (var i = 0; i < contourA.length; i++)
    {
        var pA = contourA[i];
        if (! TR.pointOnContour(pA, contourB))
        {
            if (TR.pointInContour(pA, contourB))
            {
                return TR.BELONG;
            }
            else
            {
                break;
            }
        }
    }

    for (i = 0; i < contourB.length; i++)
    {
        var pB = contourB[i];
        if (! TR.pointOnContour(pB, contourA))
        {
            if (TR.pointInContour(pB, contourA))
            {
                return TR.CONTAIN;
            }
            else
            {
                return TR.OUTSIDE;
            }
        }
    }
};

TR.contourSelfIntersected = function(contour) //      
{
    var pts = contour.concat([contour[0]]);
    for (var i = 0; i < pts.length - 2; i++)
    {
        for (var j = i + 1; j < pts.length - 1; j++)
        {
            var A = pts[i];
            var B = pts[i + 1];
            var C = pts[j];
            var D = pts[j + 1];

            if (TR.segmentsIntersected(A, B, C, D)) return true;
        }
    }

    return false;
};

TR.segmentsIntersected = function(A1, A2, B1, B2)
{
    var v1 = (B2.x - B1.x) * (A1.y - B1.y) - (B2.y - B1.y) * (A1.x - B1.x); // ...
    var v2 = (B2.x - B1.x) * (A2.y - B1.y) - (B2.y - B1.y) * (A2.x - B1.x);
    var v3 = (A2.x - A1.x) * (B1.y - A1.y) - (A2.y - A1.y) * (B1.x - A1.x);
    var v4 = (A2.x - A1.x) * (B2.y - A1.y) - (A2.y - A1.y) * (B2.x - A1.x);

    return (v1 * v2 < 0) && (v3 * v4 < 0);
};

TR.lineIntersectLine = function(A, B, E, F, as_seg, vertices, accuracy)
{
    as_seg = typeof as_seg !== 'undefined' ? as_seg : true;
    vertices = typeof vertices !== 'undefined' ? vertices : true;
    accuracy = typeof accuracy !== 'undefined' ? accuracy : 0;

    if (as_seg)
    {
        if ((A.x < E.x - accuracy && A.x < F.x - accuracy) && (B.x < E.x - accuracy && B.x < F.x - accuracy)) return null;
        if ((A.x > E.x + accuracy && A.x > F.x + accuracy) && (B.x > E.x + accuracy && B.x > F.x + accuracy)) return null;

        if ((A.y < E.y - accuracy && A.y < F.y - accuracy) && (B.y < E.y - accuracy && B.y < F.y - accuracy)) return null;
        if ((A.y > E.y + accuracy && A.y > F.y + accuracy) && (B.y > E.y + accuracy && B.y > F.y + accuracy)) return null;

    }

    var a1 = B.y - A.y;
    var b1 = A.x - B.x;
    var c1 = B.x * A.y - A.x * B.y;
    var a2 = F.y - E.y;
    var b2 = E.x - F.x;
    var c2 = F.x * E.y - E.x * F.y;

    var denom = a1 * b2 - a2 * b1;
    if (Math.abs(denom) < TR.L_EPS) return null;

    var ip = new TR.Point((b1 * c2 - b2 * c1) / denom, (a2 * c1 - a1 * c2) / denom);

    if (TR.pointsMatch(A, E) || TR.pointsMatch(A, F)) ip = A;
    if (TR.pointsMatch(B, E) || TR.pointsMatch(B, F)) ip = B;

    if (as_seg)
    {
        if (TR.manhDist(ip.x, ip.y, B.x, B.y) > TR.manhDist(A.x, A.y, B.x, B.y) + accuracy) return null;
        if (TR.manhDist(ip.x, ip.y, A.x, A.y) > TR.manhDist(A.x, A.y, B.x, B.y) + accuracy) return null;
        if (TR.manhDist(ip.x, ip.y, F.x, F.y) > TR.manhDist(E.x, E.y, F.x, F.y) + accuracy) return null;
        if (TR.manhDist(ip.x, ip.y, E.x, E.y) > TR.manhDist(E.x, E.y, F.x, F.y) + accuracy) return null;
    }
    if (! vertices) if (TR.pointsMatch(ip, A) || TR.pointsMatch(ip, B) || TR.pointsMatch(ip, E) || TR.pointsMatch(ip, F)) ip = null;

    return ip;
};

TR.segmentsOverlay = function(A, B, E, F, dist) // AB, EF must be > eps
{
    dist = typeof dist !== 'undefined' ? dist : TR.L_EPS;

    var d1 = Math.abs(TR.distanceBetweenPointAndLine(A, E, F, false));
    var d2 = Math.abs(TR.distanceBetweenPointAndLine(B, E, F, false));

    if (d1 > dist || d2 > dist) return false;

    var eps = -TR.L_EPS;

    if (Math.abs(A.y - B.y) < TR.B_EPS || Math.abs(E.y - F.y) < TR.B_EPS)
    {
        if (A.x < E.x - eps && A.x < F.x - eps && B.x < E.x - eps && B.x < F.x - eps) return false;
        if (A.x > E.x + eps && A.x > F.x + eps && B.x > E.x + eps && B.x > F.x + eps) return false;
    }
    else
    {
        if (A.y < E.y - eps && A.y < F.y - eps && B.y < E.y - eps && B.y < F.y - eps) return false;
        if (A.y > E.y + eps && A.y > F.y + eps && B.y > E.y + eps && B.y > F.y + eps) return false;
    }

    return true;
};

TR.checkContact = function(contourA, contourB)
{
    for (var i = 0; i < contourA.length - 1; i++)
    {
        var P1 = contourA[i];
        var P2 = contourA[i + 1];
        if (TR.manhDist(P1.x, P1.y, P2.x, P2.y) < TR.B_EPS) continue;

        for (var j = 0; j < contourB.length - 1; j++)
        {
            var P3 = contourB[j];
            var P4 = contourB[j + 1];
            if (TR.manhDist(P3.x, P3.y, P4.x, P4.y) < TR.B_EPS) continue;

            if (TR.segmentsOverlay(P1, P2, P3, P4)) return true;
        }
    }

    return false;
};

TR.compareContoursByArea = function(inputContourA, inputContourB)
{
    var setSize = 10;
    var mmA = TR.findMinMax(inputContourA);
    var mmB = TR.findMinMax(inputContourB);
    var adx = mmA.maxX - mmA.minX;
    var ady = mmA.maxY - mmA.minY;

    var ptsInA = 0;
    var ptsInB = 0;
    var ptsInAB = 0;
    for (var i = 0; i < setSize; i++)
    {
        for (var j = 0; j < setSize; j++)
        {
            var P = {x: mmA.minX + adx * i / setSize, y: mmA.minY + ady * j / setSize};

            var inA = TR.pointInContour(P, inputContourA);
            var inB = TR.pointInContour(P, inputContourB);

            if (inA && inB)
            {
                ptsInAB++;
            }
            else if (inA)
            {
                ptsInA++;
            }
            else if (inB)
            {
                ptsInB ++;
            }
        }
    }

    if (ptsInAB > 0) return TR.INTERSECT; else return TR.OUTSIDE
};

TR.compareContours = function(inputContourA, inputContourB)
{
    var contourA = [].concat(inputContourA);
    var contourB = [].concat(inputContourB);

    contourA.push(inputContourA && inputContourA[0].clone());
    contourB.push(inputContourB && inputContourB[0].clone());

    if (TR.checkMinMaxOutside(contourA, contourB)) return TR.OUTSIDE;

    for (var i = 0; i < contourA.length - 1; i++)
    {
        var pair1 = [contourA[i], contourA[i + 1]];

        for (var j = 0; j < contourB.length - 1; j++)
        {
            var pair2 = [contourB[j], contourB[j + 1]];

            if (TR.lineIntersectLine(pair1[0], pair1[1], pair2[0], pair2[1], true, false))
            {
                return TR.INTERSECT;
            }
        }
    }

    var ptsAInB = false;
    var ptsAOutB = false;

    for (i = 0; i < contourA.length - 1; i++)
    {
        if (! TR.pointOnContour(contourA[i], contourB))
        {
            if (TR.pointInContour(contourA[i], contourB))
            {
                ptsAInB = true;
            }
            else
            {
                ptsAOutB = true;
            }
        }

        if (ptsAInB && ptsAOutB) return TR.INTERSECT;

        var midPt = new TR.Point((contourA[i].x + contourA[i + 1].x) / 2, (contourA[i].y + contourA[i + 1].y) / 2);

        if (! TR.pointOnContour(midPt, contourB))
        {
            if (TR.pointInContour(midPt, contourB))
            {
                ptsAInB = true;
            }
            else
            {
                ptsAOutB = true;
            }
        }

        if (ptsAInB && ptsAOutB) return TR.INTERSECT;
    }

    var contact = TR.checkContact(contourA, contourB);

    if (ptsAInB)
    {
        if (contact) return TR.CONTACT_BELONG;

        return TR.BELONG
    }

    var ptsBInA = false;
    var ptsBOutA = false;

    for (i = 0; i < contourB.length - 1; i++)
    {
        if (! TR.pointOnContour(contourB[i], contourA))
        {
            if (TR.pointInContour(contourB[i], contourA))
            {
                ptsBInA = true;
            }
            else
            {
                ptsBOutA = true;
            }
        }

        if (ptsBInA && ptsBOutA) return TR.INTERSECT;

        midPt = new TR.Point((contourB[i].x + contourB[i + 1].x) / 2, (contourB[i].y + contourB[i + 1].y) / 2);

        if (! TR.pointOnContour(midPt, contourA))
        {
            if (TR.pointInContour(midPt, contourA))
            {
                ptsBInA = true;
            }
            else
            {
                ptsBOutA = true;
            }
        }

        if (ptsBInA && ptsBOutA) return TR.INTERSECT;
    }

    if (ptsBInA)
    {
        if (contact) return TR.CONTACT_CONTAIN;

        return TR.CONTAIN
    }

    // ---

    if (ptsAOutB && ptsBOutA)
    {
        if (contact) return TR.CONTACT;

        return TR.OUTSIDE;
    }

    if (! ptsAInB && ! ptsAOutB && ! ptsBInA && ! ptsBOutA) return TR.COINCIDE;

    return TR.INTERSECT;
};

TR.projectionPointOnLine = function(point, la, lb, as_seg, vertices)
{
    if(!lb || !la) return;
    as_seg = typeof as_seg !== 'undefined' ? as_seg : true;
    vertices = typeof vertices !== 'undefined' ? vertices : true;

    var acc = TR.L_EPS;

    var dx = lb.x - la.x;
    var dy = lb.y - la.y;
    var py = (point.y * dy * dy + la.y * dx * dx + (point.x - la.x) * dx * dy) / (dx * dx + dy * dy);
    var px;

    if (Math.abs(dy) < TR.B_EPS)
    {
        px = point.x;
    }
    else
    {
        px = (py - la.y) * dx / dy + la.x;
    }

    var result = new TR.Point(px, py);

    if (as_seg)
    {
        if (!(((result.x >= (la.x - acc) && result.x <= (lb.x + acc)) || (result.x >= (lb.x - acc) && result.x <= (la.x + acc))) &&
            ((result.y >= (la.y - acc) && result.y <= (lb.y + acc)) || (result.y >= (lb.y - acc) && result.y <= (la.y + acc))))) result = null;
    }

    if (! vertices && result) if (TR.manhDist(result.x, result.y, la.x, la.y) < TR.L_EPS ||
                                  TR.manhDist(result.x, result.y, lb.x, lb.y) < TR.L_EPS)
    {
        result = null;
    }

    return result;
};

TR.pointInBounds = function(P, A, B, acc)
{
    acc = typeof acc !== 'undefined' ? acc : TR.L_EPS;
    
    return (((P.x >= (A.x - acc) && P.x <= (B.x + acc)) || (P.x >= (B.x - acc) && P.x <= (A.x + acc))) &&
            ((P.y >= (A.y - acc) && P.y <= (B.y + acc)) || (P.y >= (B.y - acc) && P.y <= (A.y + acc))))
};

TR.bisectorPoint = function(O, A, B)
{
    if (!A || !B || !O)
    {
        console.log('error');
        return;
    }

    var OA = TR.euclDist(O.x, O.y, A.x, A.y);
    var OB = TR.euclDist(O.x, O.y, B.x, B.y);

    var a = new TR.Point(O.x + (A.x - O.x) / OA, O.y + (A.y - O.y) / OA);
    var b = new TR.Point(O.x + (B.x - O.x) / OB, O.y + (B.y - O.y) / OB);

    var C = new TR.Point((a.x + b.x) / 2, (a.y + b.y) / 2);

    if (TR.euclDist(O.x, O.y, C.x, C.y) < TR.L_EPS) return null;

    return C;
};

TR.perpendicularPoint = function(A, B, d)
{
	var k, cos, sin;

	if (B.y == A.y)
	{
		k = Number.MAX_VALUE;
		cos = 0;
		sin = 1;
	}
	else
	{
		k = - (B.x - A.x) / (B.y - A.y);
		cos = Math.sqrt(1 / (1 + k * k));
		sin = k * cos;
	}

	if (A.y > B.y)
	{
		sin = -sin;
		cos = -cos;
	}
	else if (A.y == B.y && A.x < B.x)
	{
		sin = -sin;
		cos = -cos;
	}

	var px = A.x + d * cos;
	var py = A.y + d * sin;

	return new TR.Point(px, py);
};

TR.pointAtAngle = function(A, B, phi, r)
{
    var k;
    var ang;

    if (B.y == A.y)
    {
        ang = 0 + phi;
    }
    else
    {
        k = (B.y - A.y) / (B.x - A.x);
        ang = Math.atan(k) + phi;
    }
    if (B.x < A.x)
    {
        ang = ang + Math.PI;
    }

    return new TR.Point(A.x + r * Math.cos(ang), A.y + r * Math.sin(ang));
};

TR.parallelLines = function(A, B, C, D, maxAngle)
{
    maxAngle = typeof maxAngle !== 'undefined' ? maxAngle : 0.05;
    var ang = TR.angleBetweenLines(A.x, A.y, B.x, B.y, C.x, C.y, D.x, D.y);

    return ! (((ang > maxAngle) && (ang < Math.PI - maxAngle)) || ((ang > Math.PI + maxAngle) && (ang < 2 * Math.PI - maxAngle)));
};

TR.rotateXY = function(x, y, angle)
{
    //console.log('rotate on ' + angle);

    var sin = Math.sin(angle);
    var cos = Math.cos(angle);
    var nx = x * cos - y * sin;
    var ny = x * sin + y * cos;

    return [nx, ny];
};

TR.resplitSegments = function(points, edges) // point - array [x, y], edge - array [A, B]
{
    var pts = new Array(points.length);
    var eds = new Array(edges.length);
    for (var i = 0; i < points.length; i++)
    {
        pts[i] = {x: points[i][0], y: points[i][1]};
    }
    for (i = 0; i < edges.length; i++)
    {
        eds[i] = {A: pts[edges[i][0]], B: pts[edges[i][1]]}
    }

    var edgeGroupsOnX = [];
    var edgeGroupsOnY = [];
    var otherEdges = [];
    for (i = 0; i < eds.length; i++)
    {
        var ed = eds[i];
        if (Math.abs(ed.A.x - ed.B.x) < TR.L_EPS)
        {
            var added = false;
            for (var j = 0; j < edgeGroupsOnX.length; j++)
            {
                if (Math.abs(ed.A.x - edgeGroupsOnX[j][0].A.x) < TR.L_EPS)
                {
                    edgeGroupsOnX[j].push(ed);
                    added = true;
                    break;
                }
            }
            if (! added) edgeGroupsOnX.push([ed]);
        }
        else if (Math.abs(ed.A.y - ed.B.y) < TR.L_EPS)
        {
            added = false;
            for (j = 0; j < edgeGroupsOnY.length; j++)
            {
                if (Math.abs(ed.A.y - edgeGroupsOnY[j][0].A.y) < TR.L_EPS)
                {
                    edgeGroupsOnY[j].push(ed);
                    added = true;
                    break;
                }
            }
            if (! added) edgeGroupsOnY.push([ed]);
        }
        else
        {
            otherEdges.push(ed);
        }
    }

    var axis = 'y';
    var resEdgesOnX = [];
    for (i = 0; i < edgeGroupsOnX.length; i++)
    {
        resEdgesOnX = resEdgesOnX.concat(rebuildGroup(edgeGroupsOnX[i]));
    }

    axis = 'x';
    var resEdgesOnY = [];
    for (i = 0; i < edgeGroupsOnY.length; i++)
    {
        resEdgesOnY = resEdgesOnY.concat(rebuildGroup(edgeGroupsOnY[i]));
    }

    var allEdges = otherEdges.concat(resEdgesOnX).concat(resEdgesOnY);
    var resEds = new Array(allEdges.length);
    for (i = 0; i < allEdges.length; i++)
    {
        resEds[i] = [pts.indexOf(allEdges[i].A), pts.indexOf(allEdges[i].B)];
    }

    return resEds;

    function rebuildGroup(group)
    {
        var grPts = [];
        for (j = 0; j < group.length; j++)
        {
            ed = group[j];
            if (grPts.indexOf(ed.A) == -1) grPts.push(ed.A);
            if (grPts.indexOf(ed.B) == -1) grPts.push(ed.B);
        }

        grPts.sort(compare);
        var links = new Array(grPts.length - 1);

        for (j = 0; j < group.length; j++)
        {
            ed = group[j];
            var iA = grPts.indexOf(ed.A);
            var iB = grPts.indexOf(ed.B);
            var iMin = Math.min(iA, iB);
            var iMax = Math.max(iA, iB);

            for (var k = iMin; k < iMax; k++) links[k] = 1;
        }

        var newGroup = [];
        for (j = 0; j < links.length; j++)
        {
            if (links[j]) newGroup.push({A: grPts[j], B: grPts[j + 1]})
        }

        return newGroup;
    }

    function compare(A, B)
    {
        if (A[axis] < B[axis])
        {
            return -1;
        }
        else if (A[axis] > B[axis])
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
};

TR.clearContour = function(inpCont)
{
    if (! inpCont || inpCont.length < 3 || ! TR.contourValid(inpCont)) return null;

    var minLen = 5;

    var contour = null;
    for (var i = 0; i < inpCont.length - 1; i++)
    {
        if (TR.euclDistP(inpCont[i], inpCont[i + 1]) >= minLen)
        {
            contour = inpCont.slice(i).concat(inpCont.slice(0, i));
            break;
        }
    }

    if (! contour) return null;

    var indGroupsToMerge = [[]];

    for (i = 0; i < contour.length; i++)
    {
        var inext = i < contour.length - 1 ? i + 1 : 0;

        if (TR.euclDistP(contour[i], contour[inext]) < minLen)
        {
            indGroupsToMerge[indGroupsToMerge.length - 1].push(i)
        }
        else
        {
            if (indGroupsToMerge[indGroupsToMerge.length - 1].length > 0)
            {
                indGroupsToMerge[indGroupsToMerge.length - 1].push(i);
                indGroupsToMerge.push([]);
            }
        }
    }
    if (indGroupsToMerge[indGroupsToMerge.length - 1].length == 0)
    {
        indGroupsToMerge.pop();
    }
    else
    {
        indGroupsToMerge[indGroupsToMerge.length - 1].push(i % contour.length);
    }

    var newPtsGroups = new Array(indGroupsToMerge.length);
    for (i = 0; i < indGroupsToMerge.length; i++)
    {
        var indGroup = indGroupsToMerge[i];
        var ptsGroup = new Array(indGroup.length);
        for (var j = 0; j < indGroup.length; j++)
        {
            ptsGroup[j] = contour[indGroup[j]];
        }

        var L = contour.length;
        var indPrev = (indGroup[0] - 1 + L) % L;
        var indNext = (indGroup[indGroup.length - 1] + 1) % L;
        var ptPrev = contour[indPrev];
        var ptNext = contour[indNext];

        var A = ptsGroup[0];
        var B = ptsGroup[ptsGroup.length - 1];

        if (TR.pointOnLine(A, ptPrev, B))
        {
            newPtsGroups[i] = [B];
        }
        else if (TR.pointOnLine(B, A, ptNext))
        {
            newPtsGroups[i] = [A];
        }
        else
        {
            newPtsGroups[i] = [A, B];
        }
    }

    if (indGroupsToMerge.length == 0) return contour;

    indGroupsToMerge.reverse();
    newPtsGroups.reverse();

    i = 0;
    indGroup = indGroupsToMerge[0];
    ptsGroup = newPtsGroups[0];
    if (indGroup[indGroup.length - 1] == 0)
    {
        i = 1;
        contour.splice(indGroup[0]);
        contour[0] = ptsGroup[ptsGroup.length - 1];
        contour = contour.concat(ptsGroup.slice(0, ptsGroup.length - 1));
    }

    for (; i < indGroupsToMerge.length; i++)
    {
        indGroup = indGroupsToMerge[i];
        ptsGroup = newPtsGroups[i];

        contour = contour.slice(0, indGroup[0]).concat(ptsGroup).concat(contour.slice(indGroup[indGroup.length - 1] + 1));
    }

    if (contour.length < 3) return null;

    var ind_to_del = [];
    for (i = 0; i < contour.length; i++)
    {
        inext = i < contour.length - 1 ? i + 1 : 0;
        var iprev = i > 0 ? i - 1 : contour.length - 1;
        if (TR.euclDistP(inpCont[iprev], inpCont[inext]) < minLen)
        {
            ind_to_del.push(i)
        }
    }
    var new_cont = [];
    for (i = 0; i < contour.length; i++)
    {
        if (ind_to_del.indexOf(i) == -1) new_cont.push(contour[i])
    }
    contour = new_cont;

    if (contour.length < 3) return null;

    return contour;
};

TR.contourValid = function(cont)
{
    var ar = Math.abs(TR.contourArea(cont));
    var per = TR.contourPerim(cont);

    return ar >= TR.MIN_CONTOUR_AREA && ar / per >= TR.MIN_SP_RATIO;
};

TR.findMinMax = function(cont)
{
    var res = {
        minX: Number.MAX_VALUE,
        maxX: -Number.MAX_VALUE,
        minY: Number.MAX_VALUE,
        maxY: -Number.MAX_VALUE
    };

    for (var i = 0; i < cont.length; i++)
    {
        var P = cont[i];
        if (P.x < res.minX) res.minX = P.x;
        if (P.x > res.maxX) res.maxX = P.x;
        if (P.y < res.minY) res.minY = P.y;
        if (P.y > res.maxY) res.maxY = P.y;
    }

    return res;
};

TR.roundCoord = function(P)
{
    //return new TR.Point(Math.round(P.x), Math.round(P.y));
    //console.log(P.x, Math.round(P.x * 10) / 10, P.y, Math.round(P.y * 10) / 10);
    return new TR.Point(Math.round(P.x * 1000) / 1000, Math.round(P.y * 1000) / 1000);
};

TR.parseNanFloat = function(x)
{
    var res = parseFloat(x);
    if (isNaN(res)) res = 0;
    return res;
};

TR.flipPoints = function(pts, hor, ver, w, h)
{
    var res = new Array(pts.length);
    for (var i = 0; i < pts.length; i++)
    {
        var x = pts[i].x;
        var y = pts[i].y;
        if (hor) x = w - x;
        if (ver) y = h - y;
        res[i] = new TR.Point(x, y);
    }
    return res;
};

/*
console.log('-------------------------');
var cont = [
    new TR.Point(0, 30),
    new TR.Point(0, 20),
    new TR.Point(0, 10),
    new TR.Point(0, 0),
    new TR.Point(10, 0),
    new TR.Point(20, 0),
    new TR.Point(30, 0)
];

TR.clearContour(cont);
*/
TR.points = [];
TR.edgeObjects = [];
TR.triObjects = [];
TR.groupedTriObjects = [[]];
TR.fillGroups = [];

TR.clear = function()
{
    TR.points = [];
    TR.edgeObjects = [];
    TR.triObjects = [];
    TR.groupedTriObjects = [[]];
};

TR.triangulate = function(points, edges)
{
    TR.points = points;
    var trs = imported_triangulate(points, edges, {exterior: true});
    TR.createStructure(trs, edges);
    TR.groupedTriObjects = TR.groupTriangles(TR.triObjects, true);
};

TR.createStructure = function(triangleIndices, fixedEdgeIndices)
{
    var num = 0;
    var dictEdge = {};

    for (var i = 0; i < triangleIndices.length; i++)
    {
        var tr = {};
        tr.num = num++;
        tr.pointIndices = [triangleIndices[i][0], triangleIndices[i][1], triangleIndices[i][2]];
        var eds = [{}, {}, {}];
        eds[0].pointIndices = [triangleIndices[i][0], triangleIndices[i][1]].sort(TR.numSort);
        eds[1].pointIndices = [triangleIndices[i][1], triangleIndices[i][2]].sort(TR.numSort);
        eds[2].pointIndices = [triangleIndices[i][2], triangleIndices[i][0]].sort(TR.numSort);

        for (var j = 0; j < 3; j++)
        {
            if (dictEdge[eds[j].pointIndices.toString()])
            {
                eds[j] = dictEdge[eds[j].pointIndices.toString()]
            }
            else
            {
                TR.edgeObjects.push(eds[j]);
                dictEdge[eds[j].pointIndices.toString()] = eds[j];
                eds[j].triangles = [];
            }

            eds[j].triangles.push(tr)
        }

        tr.edges = eds;
        TR.triObjects.push(tr);
    }

    for (i = 0; i < TR.edgeObjects.length; i++)
    {
        TR.edgeObjects[i].fixed = false;
        for (j = 0; j < fixedEdgeIndices.length; j++)
        {
            if ((TR.edgeObjects[i].pointIndices[0] == fixedEdgeIndices[j][0] &&
                 TR.edgeObjects[i].pointIndices[1] == fixedEdgeIndices[j][1]) ||
                (TR.edgeObjects[i].pointIndices[1] == fixedEdgeIndices[j][0] &&
                 TR.edgeObjects[i].pointIndices[0] == fixedEdgeIndices[j][1]))
            {
                TR.edgeObjects[i].fixed = true;
                break;
            }
        }
    }
};

TR.groupTriangles = function(triObjects, separateByFixedEdges)
{
    for (var i = 0; i < triObjects.length; i++) triObjects[i].added = false;
    var groupedTriObjects = [[]];

    for (i = 0; i < TR.triObjects.length; i++)
    {
        if (checkTriangle(TR.triObjects[i]))
        {
            groupedTriObjects.push([]);
        }
    }

    groupedTriObjects.pop();

    return groupedTriObjects;

    function checkTriangle(tri)
    {
        if (tri.added) return false;
        tri.added = true;
        groupedTriObjects[groupedTriObjects.length - 1].push(tri);

        for (var i = 0; i < 3; i++)
        {
            var ed = tri.edges[i];

            if (ed.fixed && separateByFixedEdges) continue;
            if (ed.triangles.length <= 1) continue;

            if (tri == ed.triangles[0])
            {
                checkTriangle(ed.triangles[1])
            }
            else
            {
                checkTriangle(ed.triangles[0])
            }
        }

        return true;
    }
};

TR.numSort = function(a, b) {return a - b};

TR.contoursFromGroup = function(triGroup, onlyFixedEdges, findInner)
{
    onlyFixedEdges = typeof onlyFixedEdges !== 'undefined' ? onlyFixedEdges : true;
    findInner = typeof findInner !== 'undefined' ? findInner : false;

    var dictPointIndex = {};

    for (var i = 0; i < triGroup.length; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            var ed = triGroup[i].edges[j];

            if (onlyFixedEdges && ! ed.fixed) continue;

            var inds = ed.pointIndices;

            if (! dictPointIndex[inds[0]]) dictPointIndex[inds[0]] = [];
            if (dictPointIndex[inds[0]].indexOf(inds[1]) == -1) dictPointIndex[inds[0]].push(inds[1]);

            if (! dictPointIndex[inds[1]]) dictPointIndex[inds[1]] = [];
            if (dictPointIndex[inds[1]].indexOf(inds[0]) == -1) dictPointIndex[inds[1]].push(inds[0]);
        }
    }

    var cont = getOneContour();

    var res = [cont];

    if (! cont || ! onlyFixedEdges)
    {
        return res;
    }

    while (true)
    {
		clearDict();

        if (Object.keys(dictPointIndex).length == 0) break;

        cont = getOneContour(true);

        if (cont)
        {
            res.push(cont);
        }
        else
        {
            break;
        }
    }

    return res;

	function clearDict() // remove dead ends, etc
	{
		for (i = 0; i < cont.length; i++) delete dictPointIndex[cont[i]];

		do
		{
			var removed = false;

			var keys = Object.keys(dictPointIndex);
			for (var key in dictPointIndex)
			{
				var arr = dictPointIndex[key];
				var L = arr.length;
				for (j = 0; j < L; j++)
				{
					if (keys.indexOf(String(arr[j])) == -1)
					{
						arr = arr.splice(j, 1);
						j--;
						L--;

						removed = true;
					}
				}
			}

			var keysToDel = [];

			for (key in dictPointIndex)
			{
				if (dictPointIndex[key].length == 1) keysToDel.push(key);
			}

			if (keysToDel.length > 0) removed = true;

			for (i = 0; i < keysToDel.length; i++) delete dictPointIndex[keysToDel[i]];
		}
		while (removed);
	}

    function getOneContour(inner)
    {
        var leftPtInd;
        var prevPtInd = -1;
        var minX = Number.MAX_VALUE;
        for (var key in dictPointIndex)
        {
            i = parseInt(key);
            if (TR.points[i][0] < minX)
            {
                leftPtInd = i;
                minX = TR.points[i][0];
            }
        }

        var res = [];
        var currPtInd = leftPtInd;

        var pointsNum = Object.keys(dictPointIndex).length;

        do
        {
			// if (res.length > pointsNum) throw new Error('Contour error');

            if (res.length > pointsNum) return null;

			var CW = ! (inner && res.length == 0);
            res.push(currPtInd);
            currPtInd = nextPt(currPtInd, prevPtInd, CW);
            prevPtInd = res[res.length - 1];
            if (currPtInd == -1) return null;
        }
        while (currPtInd != leftPtInd);

        return res;
    }

    function nextPt(targPtInd, prevPtInd, CW) // prevPtInd = -1 for first point
    {
        var targPt = TR.points[targPtInd];
        var prevPt;
        if (prevPtInd == -1)
        {
            prevPt = [targPt[0] - 10, targPt[1]];
        }
        else
        {
            prevPt = TR.points[prevPtInd];
        }

        var neighbIndices = dictPointIndex[targPtInd];
        if (! neighbIndices || neighbIndices.length <= 1) return -1;

        var maxAng = 0;
        var minAng = Number.MAX_VALUE;
        var maxPtIndex = -1;
        var minPtIndex = -1;

        for (var i = 0; i < neighbIndices.length; i++)
        {
            var a = TR.angleBetweenLines(   prevPt[0], prevPt[1],
                                            targPt[0], targPt[1],
                                            TR.points[neighbIndices[i]][0], TR.points[neighbIndices[i]][1],
                                            targPt[0], targPt[1]);
            if (a > maxAng)
            {
                maxAng = a;
                maxPtIndex = neighbIndices[i];
            }
            if (a < minAng)
            {
                minAng = a;
                minPtIndex = neighbIndices[i];
            }
        }

        if (maxPtIndex == -1 || minPtIndex == -1) return -1;
        if (CW) return maxPtIndex; else return minPtIndex;
    }
};

TR.filterContours = function(contours)
{
    var res = [];

    for (var i = 0; i < contours.length; i++)
    {
        var cont = TR.clearContour(contours[i]);
        if (cont) res.push(cont);
    }

    return res;
};

TR.triangulateContours = function(inpOuterContours, inpInnerContours, inpBoundContours, inpSubtrContours, cutPairs)
{
    var ptCoords = [];
    var edges = [];
    var allPts = [];

	var addSeg = function(A, B)
	{
		if (A.match(B)) return;
		var indexA = -1;
		var indexB = -1;
		for (var i = 0; i < ptCoords.length; i++)
		{
			if (Math.abs(ptCoords[i][0] - A.x) < TR.L_EPS && Math.abs(ptCoords[i][1] - A.y) < TR.L_EPS) indexA = i;
			if (Math.abs(ptCoords[i][0] - B.x) < TR.L_EPS && Math.abs(ptCoords[i][1] - B.y) < TR.L_EPS) indexB = i;
		}

		if (indexA >=0 && indexB >=0)
		{
			for (i = 0; i < edges.length; i++)
			{
				if (edges[i][0] == indexA && edges[i][1] == indexB) return;
				if (edges[i][0] == indexB && edges[i][1] == indexA) return;
			}
		}

		if (indexA == -1)
		{
			ptCoords.push([A.x, A.y]);
			indexA = ptCoords.length - 1;
		}

		if (indexB == -1)
		{
			ptCoords.push([B.x, B.y]);
			indexB = ptCoords.length - 1;
		}

		edges.push([indexA, indexB]);
	};

    var contours = inpInnerContours.concat(inpOuterContours, inpBoundContours, inpSubtrContours);

	for (var i = 0; i < contours.length; i++)
	{
		if (contours[i].length <= 1) continue;
		for (var j = 0; j < contours[i].length - 1; j++) addSeg(contours[i][j], contours[i][j + 1]);
		addSeg(contours[i][contours[i].length - 1], contours[i][0]);
	}

	for (i = 0; i < cutPairs.length; i++)
	{
		addSeg(cutPairs[i][0], cutPairs[i][1]);
	}

    edges = TR.resplitSegments(ptCoords, edges);

    imported_clean_graph(ptCoords, edges); ////////////////////////////////////////////////////////////////////////////

    TR.clear();
    TR.triangulate(ptCoords, edges);

    var fillTrs = [];
    var holeTrs = [];
    var emptyTrs = [];
    TR.fillGroups = [];

    for (i = 0; i < TR.groupedTriObjects.length; i++)       // TR.groupedTriObjects - in index form
    {
        if (TR.groupedTriObjects[i].length == 0) continue;
        var trForCenter = null;

        for (j = 0; j < TR.groupedTriObjects[i].length; j++)
        {
			var tri = TR.groupedTriObjects[i][j];
            if (! TR.triangleIsNarrow(ptCoords[tri.pointIndices[0]][0], ptCoords[tri.pointIndices[0]][1],
				ptCoords[tri.pointIndices[1]][0], ptCoords[tri.pointIndices[1]][1],
            	ptCoords[tri.pointIndices[2]][0], ptCoords[tri.pointIndices[2]][1]))
            {
				trForCenter = TR.groupedTriObjects[i][j];
				break;
            }
        }

		if (! trForCenter)
		{
			//console.log('bad group');
			continue;
		}

        var center = TR.triangleCenter( ptCoords[trForCenter.pointIndices[0]][0], ptCoords[trForCenter.pointIndices[0]][1],
            							ptCoords[trForCenter.pointIndices[1]][0], ptCoords[trForCenter.pointIndices[1]][1],
            							ptCoords[trForCenter.pointIndices[2]][0], ptCoords[trForCenter.pointIndices[2]][1]);
        var fill = false;
        var empty = false;
        var inside = TR.pointInContours(center, inpOuterContours);
        var outside = TR.pointInContours(center, inpInnerContours);

        if ((inpBoundContours.length > 0) && (inpSubtrContours.length > 0))
        {
            if (TR.pointInContours(center, inpBoundContours) >= TR.pointInContours(center, inpSubtrContours))
            {
                if (inside > outside)
                {
                    fill = true;
                }
                else
                {
                    empty = true;
                }
            }
        }
        else if (inpBoundContours.length > 0)
        {
            if (TR.pointInContours(center, inpBoundContours, true) > 0)
            {
                if (inside > outside)
                {
                    fill = true;
                }
                else
                {
                    empty = true;
                }
            }
        }
        else if (inpSubtrContours.length > 0)
        {
            if (TR.pointInContours(center, inpSubtrContours) == 0)
            {
                if (inside > outside)
                {
                    fill = true;
                }
                else
                {
                    empty = true;
                }
            }
        }
        else
        {
            if (inside > outside)
            {
                fill = true;
            }
            else
            {
                empty = true;
            }
        }

        if (fill)
        {
            fillTrs = fillTrs.concat(TR.groupedTriObjects[i]);
            TR.fillGroups.push(TR.groupedTriObjects[i]);
        }
        else
        {
            holeTrs = holeTrs.concat(TR.groupedTriObjects[i]);
        }

        if (empty) emptyTrs.push(TR.groupedTriObjects[i]);
    }

    return [fillTrs, holeTrs];
};

TR.rebuildContours = function(inpOuterContours, inpInnerContours, inpBoundContours, inpSubtrContours, cutPairs, separateContacting, filter)
{
    filter = typeof filter !== 'undefined' ? filter : true;
    separateContacting = typeof separateContacting !== 'undefined' ? separateContacting : false;

    var fOuterContours, fInnerContours, fBoundContours, fSubtrContours;
    if (filter)
    {
        fOuterContours = TR.filterContours(inpOuterContours);
        fInnerContours = TR.filterContours(inpInnerContours);
        fBoundContours = TR.filterContours(inpBoundContours);
        fSubtrContours = TR.filterContours(inpSubtrContours);
    }
    else
    {
        fOuterContours = inpOuterContours;
        fInnerContours = inpInnerContours;
        fBoundContours = inpBoundContours;
        fSubtrContours = inpSubtrContours;
    }

    var trs = TR.triangulateContours(fOuterContours, fInnerContours, fBoundContours, fSubtrContours, cutPairs);

    var fillGroups = TR.groupTriangles(trs[0], separateContacting); // true for covers
    var holeGroups = TR.groupTriangles(trs[1], false);

    var outerContours = [];
    var innerContours = [];
    var outerGroups = [];

    var totalOutline = null;

    if (TR.triObjects.length > 0) totalOutline = TR.contoursFromGroup(TR.triObjects, false)[0];

    for (var i = 0; i < fillGroups.length; i++)
    {
        var contours = TR.contoursFromGroup(fillGroups[i], true, true);

        var outline = contours[0];
        if (! outline) continue;

        outerContours.push(outline);
        outerGroups.push(fillGroups[i]);

		if (separateContacting)
		{
			if (contours.length > 1)
			{
				innerContours = innerContours.concat(contours.slice(1));
			}
		}
    }

	if (! separateContacting)
	{
		for (i = 0; i < holeGroups.length; i++)
		{
			outline = TR.contoursFromGroup(holeGroups[i])[0];
			if (! outline) continue;
			if (TR.contoursAdjacent(outline, totalOutline)) continue;
			innerContours.push(outline);
		}
	}

    return [outerContours, innerContours, outerGroups];
};

TR.contoursAdjacent = function(A, B) // A, B - arrays of point indices
{
    var cont1 = [].concat(A);
    cont1.push(cont1[0]);
    var cont2 = [].concat(B);
    cont2.push(cont2[0]);

    for (var i = 0; i < cont1.length - 1; i++)
    {
        for (var j = 0; j < cont2.length - 1; j++)
        {
            if (cont1[i] == cont2[j] && cont1[i + 1] == cont2[j + 1]) return true;
        }
    }

    return false;
};

TR.pointsIndexToVal = function(pointIndices, points)
{
    var res = new Array(pointIndices.length);
    for (var i = 0; i < pointIndices.length; i++)
    {
        res[i] = points[pointIndices[i]];
    }
    return res;
};

TR.indicesToPoints = function(input) // recursive
{
    if (typeof(input) == "number")
    {
        var x = TR.points[input][0];
        var y = TR.points[input][1];
        return new TR.Point(x, y);
    }
    else if (typeof(input.length) != "undefined")
    {
        var res = new Array(input.length);
        for (var i = 0; i < input.length; i++)
        {
            res[i] = TR.indicesToPoints(input[i]);
        }
        return res;
    }
    else
    {
        throw new Error('Invalid argument in TR.indicesToPoints()');
    }
};

WC.DataObject = function()
{
    EventDispatcher.call(this);
    var me = this;

    me.name = '';
    me.area = 0;
    me.materialID = 0;
    me.addMaterialID = "";
    me.materialRotation = 0;
    me.materialX = 0;
    me.materialY = 0;
    me.rotatingCenter = new TR.Point(0, 0);

    me.parts = [new WC.Part()];
    //me.triangles = [];
    //me.vertices = [];
    //me.uvs = [];
    //me.indices = [];

    Object.defineProperty(me, 'triangles', {
        get: function() {
            return me.parts[0].triangles;
        },
        set: function(triangles){
            me.parts[0].triangles = triangles;
        }
    });

    Object.defineProperty(me, 'vertices', {
        get: function() {
            return me.parts[0].vertices;
        },
        set: function(vertices){
            me.parts[0].vertices = vertices;
        }
    });

    Object.defineProperty(me, 'uvs', {
        get: function() {
            return me.parts[0].uvs;
        },
        set: function(uvs){
            me.parts[0].uvs = uvs;
        }
    });

    Object.defineProperty(me, 'indices', {
        get: function() {
            return me.parts[0].indices;
        },
        set: function(indices){
            me.parts[0].indices = indices;
        }
    });

    Object.defineProperty(me, 'area', {
        get: function() {
            return me.parts[0].area;
        },
        set: function(indices){
            // console.error('Propetry "area" is read-only');
        }
    });

    me.setMaterial = function(id, partNum)
    {
        if(!id) return;
        id = id.id ? id.id : id;
        if (id != me.materialID)
        {
            me.materialID = id;
            me.parts[0].materialID = id;
        }
        me.changed = true;
    };

    me.setAddMaterial = function(id, partNum)
    {
        if (id != me.addMaterialID) {
            me.addMaterialID = id;
            me.parts[0].addMaterialID = id;   
        }
        me.changed = true;
    };

    me.clearMaterial = function()
    {
        me.materialID = '';
        me.addMaterialID = '';
        me.materialRotation = 0;
        me.materialX = 0;
        me.materialY = 0;
        me.changed = true;
    };

    me.getMaterial = function()
    {
        return me.materialID;
    };

    me.getAddMaterial = function()
    {
        return me.addMaterialID;
    };

    me.getMaterials = function()
    {
        return [me.materialID];
    };

    me.setMaterialRotation = function(angle)
    {
        me.materialRotation = angle;
        me.parts[0].materialRotation = angle;
    };

    me.getMaterialRotation = function()
    {
        return me.materialRotation;
    };

    me.setMaterialShift = function(shift)
    {
        me.materialX = shift[0];
        me.materialY = shift[1];
    };

    me.getMaterialShift = function()
    {
        return [me.materialX, me.materialY];
    };

    me.dispatchUpdate = function()
    {
        me.dispatchEvent(new Event(WC.ELEMENT_UPDATE, me));
    };

    me.startRotateMaterial = function(point)
    {

    };

    me.rotateMaterial = function(angle)
    {
        //me.materialX = me.rotatingCenter.x;
        //me.materialY = me.rotatingCenter.y;

        me.materialRotation = angle;
        me.parts[0].materialRotation = angle;

        me.build3D();
    };

    me.stopRotateMaterial = function()
    {
        me.changed = true;
    };

    me.startMoveMaterial = function(point)
    {

    };

    me.moveMaterial = function(shift)
    {
        me.materialX = shift[0];
        me.materialY = shift[1];

        me.parts[0].materialX = shift[0];
        me.parts[0].materialY = shift[1];

        me.build3D();
    };

    me.stopMoveMaterial = function()
    {
        me.changed = true;
    };

    me.build3D = function()
    {
        console.error('WC.DataObject.build3D() must be overridden')
    };

    me.addNullData = function()
    {
        if (me.parts.length > 0 && me.parts[0].vertices.length > 0) return;

        var part = new WC.Part();
        part.vertices = [-1, -1, -1, -1, -1, -1, -1, -1, -1];
        part.uvs = [0, 0, 0, 0, 0, 0];
        part.indices = [0, 1, 2];
        me.parts = [part];
    }
};
R2D.extend(WC.DataObject, EventDispatcher);

WC.DataPoint = function(x, y, id)
{
    var me = this;
    me.x = x;
    me.y = y;
    me.id = id;
    me.type = 'point';

    me.distTo = function(P)
    {
        return Math.sqrt(Math.pow((me.x - P.x), 2) + Math.pow((me.y - P.y), 2));
    };

    me.clone = function()
    {
        return new WC.DataPoint(me.x, me.y);
    };

    me.match = function(P = {}, accuracy)
    {
        accuracy = typeof accuracy !== 'undefined' ? accuracy : TR.L_EPS;

        return ((Math.abs(P?.x - me.x) < accuracy) && (Math.abs(P?.y - me.y) < accuracy));
    };
};

WC.DataPlinth = function(wall, top, height)
{
    WC.DataObject.call(this);

    var me = this;

    me.height = typeof height !== 'undefined' ? height : 0;

    me.wall = wall;

    me.point1 = null;
    me.point2 = null;
    me.point1s = null;
    me.point2s = null;

    me.gaps = [];
    me.contours = []; // for selection in 3D

    // me.shapeNum = 0;

    if (top)
    {
        me.type = 'topPlinth';

        me.materialID = R2D.default.getDefaultMaterialByKey("molding");
        me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("molding");

        me.shapeNum = WC.plinthCreator?.defTopId;
        me.d = WC.plinthCreator?.getDefDepth(me.shapeNum);
        me.h = WC.plinthCreator?.getDefHeight(me.shapeNum);
    }
    else
    {
        me.type = 'bottomPlinth';

        me.materialID = R2D.default.getDefaultMaterialByKey("plinth");
        me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("plinth");

        me.shapeNum = WC.plinthCreator?.defBottomId;
        me.d = WC.plinthCreator?.getDefDepth(me.shapeNum);
        me.h = WC.plinthCreator?.getDefHeight(me.shapeNum);
    }

    me.visible = true;
    me.exists = true;
    me.length = 0;

    me.setDistToCeiling = function (dist) {
        me.height = me.wall.height - dist;
    };

    me.setShapeNum = function (n) {
        me.shapeNum = n;

        me.d = WC.plinthCreator.getDefDepth(n);
        me.h = WC.plinthCreator.getDefHeight(n);
    };

    me.setPoints = function(pt1, pt2, pt1s, pt2s)
    {
        me.point1 = pt1;
        me.point2 = pt2;
        me.point1s = pt1s;
        me.point2s = pt2s;
    };

    me.build3D = function()
    {
        let plinthShapeSrc = null;

        if (me.type == "bottomPlinth") {
            if (!WC.plinthCreator?.isSVGLoaded(me.shapeNum)) {
                me.shapeNum = WC.plinthCreator?.defBottomId;
            }
            plinthShapeSrc = WC.plinthCreator?.getShapePath(me.shapeNum);
        } else if (me.type == "topPlinth") {
            me.shapeNum =
                Number(me.shapeNum) < 8 ? `${Number(me.shapeNum) + 8}` : me.shapeNum;
            if (!WC.plinthCreator?.isSVGLoaded(me.shapeNum)) {
                me.shapeNum = WC.plinthCreator?.defTopId;
            }
            plinthShapeSrc = WC.plinthCreator?.getShapePath(me.shapeNum);
            me.setDistToCeiling(WC.plinthCreator?.getDistToCeiling(me.shapeNum));
        }

        var plinthShape = plinthShapeSrc?.length && new Array(plinthShapeSrc?.length);
        for (var i = 0; i < plinthShapeSrc?.length; i++)
        {
            if(plinthShape) plinthShape[i] = [plinthShapeSrc[i][0] * me.d, plinthShapeSrc[i][1] * me.h];
        }

        me.length = TR.euclDistP(me.point1, me.point2);

        var trs = [];
        if (me.gaps.length == 0)
        {
            trs = trs.concat(WC.findPlinthSegment(me.point1, me.point1, me.point2, me.point1s, me.point2s,
                plinthShape, me.h, me.d, me.height, me.materialX, me.materialY, me.materialRotation));
        }
        else
        {
            var gapsProj = [];
            for (i = 0; i < me.gaps.length; i++)
            {
                var pr1 = null;
                var pr2 = null;

                if (me.gaps[i][0]) pr1 = TR.projectionPointOnLine(me.gaps[i][0], me.point1s, me.point2s);
                if (me.gaps[i][1]) pr2 = TR.projectionPointOnLine(me.gaps[i][1], me.point1s, me.point2s);

                gapsProj.push([pr1, pr2]);
            }

            if (me.gaps[0][0])
            {
                trs = trs.concat(WC.findPlinthSegment(me.point1, me.point1, me.gaps[0][0], me.point1s, gapsProj[0][0],
                    plinthShape, me.h, me.d, me.height, me.materialX, me.materialY, me.materialRotation));
            }

            for (i = 0; i < me.gaps.length - 1; i++)
            {
                trs = trs.concat(WC.findPlinthSegment(me.point1, me.gaps[i][1], me.gaps[i + 1][0], gapsProj[i][1], gapsProj[i + 1][0],
                    plinthShape, me.h, me.d, me.height, me.materialX, me.materialY, me.materialRotation));
            }

            if (me.gaps[me.gaps.length - 1][1])
            {
                trs = trs.concat(WC.findPlinthSegment(me.point1, me.gaps[me.gaps.length - 1][1], me.point2, gapsProj[gapsProj.length - 1][1],  me.point2s,
                    plinthShape, me.h, me.d, me.height, me.materialX, me.materialY, me.materialRotation));
            }
        }

        var part = new WC.Part();
        me.parts = [part];

        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        //part.materialID = me.materialID;
        part.vertices = [];
        part.uvs = [];

        for (i = 0; i < trs.length; i++)
        {
            part.vertices = part.vertices.concat(trs[i][0]);
            part.uvs = part.uvs.concat(trs[i][1]);
        }

        part.indices = WC.generateIndices(part.vertices.length / 3);

        me.addNullData();

        var pt1sX = me.point1.x + (me.point1s.x - me.point1.x) * me.d;
        var pt1sY = me.point1.y + (me.point1s.y - me.point1.y) * me.d;
        var pt2sX = me.point2.x + (me.point2s.x - me.point2.x) * me.d;
        var pt2sY = me.point2.y + (me.point2s.y - me.point2.y) * me.d;

        if (me.type == 'bottomPlinth')
        {
            me.contours = [[{x: pt1sX, y: 0, z: -pt1sY},
                            {x: pt2sX, y: 0, z: -pt2sY},
                            {x: me.point2.x, y: me.h, z: -me.point2.y},
                            {x: me.point1.x, y: me.h, z: -me.point1.y}]];
        }
        else
        {
            me.contours = [[{x: pt1sX, y: me.height, z: -pt1sY},
                            {x: pt2sX, y: me.height, z: -pt2sY},
                            {x: me.point2.x, y: me.height - me.h, z: -me.point2.y},
                            {x: me.point1.x, y: me.height - me.h, z: -me.point1.y}]];
        }
    }
};
R2D.extend(WC.DataPlinth, WC.DataObject);

WC.DataArea = function(id)
{
    WC.DataObject.call(this);

    var me = this;
    me.id = id;
    me.materialID = R2D.default.getDefaultMaterialByKey("wall");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("wall");
    me.walls = [];
    me.cuts = [];
    me.points = [];
    me.type = 'area';
    me.ceiling = null;

    me.build3D = function()
    {
        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        me.parts[0].vertices = [];
        me.parts[0].uvs = [];

        me.parts[0].area = 0;

        var trs = me.parts[0].triangles;

        for (var i = 0; i < trs.length; i++)
        {
            var a = trs[i][0];
            var b = trs[i][1];
            var c = trs[i][2];

            me.parts[0].area += TR.triangleArea(a.x, a.y, b.x, b.y, c.x, c.y);
            var tr = WC.findTriCover(a, b, c, me.height, false, me.materialX, me.materialY, me.materialRotation);

            me.parts[0].vertices = me.parts[0].vertices.concat(tr[0]);
            me.parts[0].uvs = me.parts[0].uvs.concat(tr[1]);
        }

        me.parts[0].indices = WC.generateIndices(me.parts[0].vertices.length / 3);

        var minX = Number.MAX_VALUE;
        var maxX = -Number.MAX_VALUE;
        var minY = Number.MAX_VALUE;
        var maxY = -Number.MAX_VALUE;
        for (i = 0; i < me.points.length; i++)
        {
            if (me.points[i].x < minX) minX = me.points[i].x;
            if (me.points[i].x > maxX) maxX = me.points[i].x;
            if (me.points[i].y < minY) minY = me.points[i].y;
            if (me.points[i].y > maxY) maxY = me.points[i].y;
        }
        me.rotatingCenter = new TR.Point((minX + maxX) / 2, (minY + maxY) / 2);
        if (me.ceiling) me.ceiling.rotatingCenter = me.rotatingCenter;
    }
};
R2D.extend(WC.DataArea, WC.DataObject);

WC.DataCut = function(pt1, pt2, id)
{
    WC.DataObject.call(this);

    var me = this;
    me.materialID = R2D.default.getDefaultMaterialByKey("wall");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("wall");
    me.point1 = pt1;
    me.point2 = pt2;
    me.id = id;
    me.type = 'cut';
    me.heights = [];
    me.height = 0;
    me.low = 0;

    me.v1 = null;
    me.v2 = null;

    me.build3D = function()
    {
        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        var tr = me.parts[0].triangles;
        me.rotatingCenter = new TR.Point((Math.max(tr[0][0].x, tr[0][1].x, tr[0][2].x) + Math.min(tr[0][0].x, tr[0][1].x, tr[0][2].x)) / 2,
                                         (Math.max(tr[0][0].y, tr[0][1].y, tr[0][2].y) + Math.min(tr[0][0].y, tr[0][1].y, tr[0][2].y)) / 2);
        var tr1 = WC.findTriWall(tr[0][0], tr[0][1], tr[0][2], me.v1, me.v2, me.height, false, me.materialX, me.materialY, me.materialRotation, me.rotatingCenter.x, me.rotatingCenter.y);
        var tr2 = WC.findTriWall(tr[1][0], tr[1][1], tr[1][2], me.v1, me.v2, me.height, false, me.materialX, me.materialY, me.materialRotation, me.rotatingCenter.x, me.rotatingCenter.y);

        me.parts[0].vertices = tr1[0].concat(tr2[0]);
        me.parts[0].uvs = tr1[1].concat(tr2[1]);
        me.parts[0].indices = WC.generateIndices(me.parts[0].vertices.length / 3);
        me.parts[0].area = TR.euclDistP(me.point1, me.point2) * (me.height - me.low);
    }
};
R2D.extend(WC.DataCut, WC.DataObject);

WC.DataCover = function(id)
{
    WC.DataObject.call(this);

    var me = this;
    me.materialID = R2D.default.getDefaultMaterialByKey("cover");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("cover");
    me.points = [];
    me.id = id;
    me.type = 'cover';
    me.ceiling = null;
    me.title = null;
    me.materialRotation = 0;

    me.build3D = function()
    {
        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        me.parts[0].vertices = [];
        me.parts[0].uvs = [];
        me.parts[0].area = 0;

        for (var i = 0; i < me.triangles.length; i++)
        {
            var a = me.parts[0].triangles[i][0];
            var b = me.parts[0].triangles[i][1];
            var c = me.parts[0].triangles[i][2];

            me.parts[0].area += TR.triangleArea(a.x, a.y, b.x, b.y, c.x, c.y);

            var tr = WC.findTriCover(a, b, c, 0, false, me.materialX, me.materialY, me.materialRotation, me.rotatingCenter.x, me.rotatingCenter.y);
            me.parts[0].vertices = me.parts[0].vertices.concat(tr[0]);
            me.parts[0].uvs = me.parts[0].uvs.concat(tr[1]);
        }

        me.parts[0].indices = WC.generateIndices(me.parts[0].vertices.length / 3);

        var minX = Number.MAX_VALUE;
        var maxX = -Number.MAX_VALUE;
        var minY = Number.MAX_VALUE;
        var maxY = -Number.MAX_VALUE;
        for (i = 0; i < me.points.length; i++)
        {
            if (me.points[i].x < minX) minX = me.points[i].x;
            if (me.points[i].x > maxX) maxX = me.points[i].x;
            if (me.points[i].y < minY) minY = me.points[i].y;
            if (me.points[i].y > maxY) maxY = me.points[i].y;
        }
        me.rotatingCenter = new TR.Point((minX + maxX) / 2, (minY + maxY) / 2);
        if (me.ceiling) me.ceiling.rotatingCenter = me.rotatingCenter;

        me.area = me.parts[0].area;
    };
};
R2D.extend(WC.DataCover, WC.DataObject);

WC.DataCeiling = function(id)
{
    WC.DataObject.call(this);

    var me = this;
    me.materialID = R2D.default.getDefaultMaterialByKey("wall");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("wall");
    me.points = [];
    me.id = id;
    me.type = 'ceiling';
    me.height = WC.DEFAULT_WALLS_HEIGHT;
    me.visible = false;
    me.exists = true;

    me.build3D = function()
    {
        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        me.parts[0].vertices = [];
        me.parts[0].uvs = [];
        me.parts[0].area = 0;

        for (var i = 0; i < me.parts[0].triangles.length; i++)
        {
            var a = me.parts[0].triangles[i][0];
            var b = me.parts[0].triangles[i][1];
            var c = me.parts[0].triangles[i][2];

            me.parts[0].area += TR.triangleArea(a.x, a.y, b.x, b.y, c.x, c.y);

            var tr = WC.findTriCover(a, b, c, me.height, true, me.materialX, me.materialY, me.materialRotation, me.rotatingCenter.x, me.rotatingCenter.y);
            me.parts[0].vertices = me.parts[0].vertices.concat(tr[0]);
            me.parts[0].uvs = me.parts[0].uvs.concat(tr[1]);
        }

        me.parts[0].indices = WC.generateIndices(me.parts[0].vertices.length / 3);

        me.area = me.parts[0].area;
    };
};
R2D.extend(WC.DataCeiling, WC.DataObject);

WC.DataCap = function()
{
    WC.DataObject.call(this);

    var me = this;
    me.materialID = R2D.default.getDefaultMaterialByKey("cap");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("cap");
    me.type = 'cap';
    me.wallsHeight = WC.DEFAULT_WALLS_HEIGHT;

    me.build3D = function()
    {
        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        me.parts[0].vertices = [];
        me.parts[0].uvs = [];

        me.parts[0].area = 0;

        var trs = me.parts[0].triangles;
        if (me.solid) trs = me.parts[0].trianglesSolid;

        for (var i = 0; i < trs.length; i++)
        {
            var a = trs[i][0];
            var b = trs[i][1];
            var c = trs[i][2];

            me.parts[0].area += TR.triangleArea(a.x, a.y, b.x, b.y, c.x, c.y);
            var tr = WC.findTriCover(a, b, c, me.wallsHeight, false, me.materialX, me.materialY, me.materialRotation);

            me.parts[0].vertices = me.parts[0].vertices.concat(tr[0]);
            me.parts[0].uvs = me.parts[0].uvs.concat(tr[1]);
        }

        me.parts[0].indices = WC.generateIndices(me.parts[0].vertices.length / 3);
    };
};
R2D.extend(WC.DataCap, WC.DataObject);

WC.DataFrame = function(top, materialParams)
{
    WC.DataObject.call(this);

    var me = this;
    me.materialID = R2D.default.getDefaultMaterialByKey("wall");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("wall");
    if (top)
    {
        me.type = 'topFrame';
    }
    else
    {
        me.type = 'bottomFrame';
    }

    if (materialParams)
    {
        me.materialID = materialParams.materialID;
        me.addMaterialID = materialParams.addMaterialID;
        me.materialRotation = materialParams.materialRotation;
        me.materialX = materialParams.materialX;
        me.materialY = materialParams.materialY;
    }
    else
    {
        me.materialID = 0;
        me.addMaterialID = "";
        me.materialRotation = 0;
        me.materialX = 0;
        me.materialY = 0;
    }

    me.modelIDs = [];
    me.uvsDef = [];
    me.dirX = null;
    me.dirY = null;

    me.stopRotateMaterial = function () {
        me.changed = true;
        const curModelDataFromAxis = getCurModelDataFromAxis();
        if (me.type === "bottomFrame") {
            if(curModelDataFromAxis) curModelDataFromAxis.materialBottomRotation = me.parts[0].materialRotation;
        } else if (me.type === "topFrame") {
            if(curModelDataFromAxis) curModelDataFromAxis.materialFrameRotation = me.parts[0].materialRotation;
        }
    };

    me.setMaterial = function (id, partNum) {
        if(!id) return;
        if (id != me.materialID) {
            id = id.id ? id.id : id;
            me.materialID = id;
            me.parts[0].materialID = id;
        }
        me.changed = true;

        if (R2D.scene.currentConstructorElementData) {
            const curModelDataFromAxis = getCurModelDataFromAxis();
            if (me.type === "bottomFrame") {
                curModelDataFromAxis.materialBottom = me.parts[0].materialID;
            } else if (me.type === "topFrame") {
                curModelDataFromAxis.materialFrame = me.parts[0].materialID;
            }
        }
    };

    me.setAddMaterial = function (id, partNum) {
        if (id != me.addMaterialID) {
            me.addMaterialID = id;
            me.parts[0].addMaterialID = id;
        }
        me.changed = true;

        if (R2D.scene.currentConstructorElementData) {
            const curModelDataFromAxis = getCurModelDataFromAxis();
            if (me.type === "bottomFrame") {
                curModelDataFromAxis.addMaterialBottom = me.parts[0].addMaterialID;
            } else if (me.type === "topFrame") {
                curModelDataFromAxis.addMaterialFrame = me.parts[0].addMaterialID;
            }
        }
    };

    me.stopMoveMaterial = function () {
        me.changed = true;

        const curModelDataFromAxis = getCurModelDataFromAxis();
        if (me.type === "bottomFrame") {
            curModelDataFromAxis.materialBottomX = me.parts[0].materialX;
            curModelDataFromAxis.materialBottomY = me.parts[0].materialY;
        } else if (me.type === "topFrame") {
            curModelDataFromAxis.materialFrameX = me.parts[0].materialX;
            curModelDataFromAxis.materialFrameY = me.parts[0].materialY;
        }
    };

    function getCurModelDataFromAxis() {
        const curWallModelId = me.modelIDs[0];
        const curAxis = R2D.scene.constructor.dictModelAxis[curWallModelId];
        const curModelDataFromAxis = curAxis?.models.find(
            (modelData) => modelData.id === curWallModelId
        );
        return curModelDataFromAxis;
    }


    me.build3D = function()
    {
        me.parts[0].materialID = me.materialID;
        me.parts[0].addMaterialID = me.addMaterialID;
        me.parts[0].materialRotation = me.materialRotation;
        me.parts[0].materialX = me.materialX;
        me.parts[0].materialY = me.materialY;

        var pixPerMeter = 100;

        for (var i = 0; i < me.uvsDef.length / 6; i++)
        {
            var uA = me.uvsDef[i * 6];
            var vA = me.uvsDef[i * 6 + 1];
            var uB = me.uvsDef[i * 6 + 2];
            var vB = me.uvsDef[i * 6 + 3];
            var uC = me.uvsDef[i * 6 + 4];
            var vC = me.uvsDef[i * 6 + 5];

            var shiftX = me.materialX / pixPerMeter;
            var shiftY = me.materialY / pixPerMeter;

            var kr = 1;
            //if (reverse) kr = -1;

            var transformedA = TR.rotateXY(uA - kr * (shiftX + me.rotatingCenter.x), vA - shiftY - me.rotatingCenter.y, -me.materialRotation);
            var transformedB = TR.rotateXY(uB - kr * (shiftX + me.rotatingCenter.x), vB - shiftY - me.rotatingCenter.y, -me.materialRotation);
            var transformedC = TR.rotateXY(uC - kr * (shiftX + me.rotatingCenter.x), vC - shiftY - me.rotatingCenter.y, -me.materialRotation);

            me.parts[0].uvs[i * 6] =     transformedA[0] + kr * me.rotatingCenter.x;
            me.parts[0].uvs[i * 6 + 1] = transformedA[1] + me.rotatingCenter.y;
            me.parts[0].uvs[i * 6 + 2] = transformedB[0] + kr * me.rotatingCenter.x;
            me.parts[0].uvs[i * 6 + 3] = transformedB[1] + me.rotatingCenter.y;
            me.parts[0].uvs[i * 6 + 4] = transformedC[0] + kr * me.rotatingCenter.x;
            me.parts[0].uvs[i * 6 + 5] = transformedC[1] + me.rotatingCenter.y;
        }
    }
};
R2D.extend(WC.DataFrame, WC.DataObject);

WC.DataPlug = function(pt1, pt2, axis, height)
{
    WC.DataObject.call(this);

    var me = this;
    me.point1 = pt1;
    me.point2 = pt2;
    me.axis = axis;
    me.height = height;

    me.type = 'plug';
};
R2D.extend(WC.DataPlug, WC.DataObject);

WC.DataRoom = function(id)
{
    var me = this;
    me.points = [];
    me.walls = [];
    me.id = id;
    //me.name = '';

    me.rooms = null;
    me.covers = null;
    me.axes = null;
};

WC.Axis = function(wall1, wall2)
{
    var me = this;

    me.wall1 = wall1;
    me.wall2 = wall2;
    me.point1 = null;
    me.point2 = null;

    me.box = [];

    me.models = [];
    me.modelIDs = [];
    me.positions = [];
    me.frames = [];
    me.depth = 0;

    me.finalContours = [];
};

WC.RoomStyle = function(wall, cover)
{
    var me = this;
    me.target = '';
    me.wall = wall;
    me.cover = cover;

    me.toString = function()
    {
        var info = {target: me.target,
                    wall: WC.convert.wallToShort(me.wall),
                    cover: WC.convert.coverToShort(me.cover)};

        info.cover.points = [];

        return JSON.stringify(info);
    };

    me.fromObj = function(info)
    {
        me.target = info.target;
        me.wall = WC.convert.wallFromShort(info.wall);
        me.cover = WC.convert.coverFromShort(info.cover);
    };
};

WC.contourFromPairs = function(pairs)
{
    if (pairs.length == 0)
    {
        console.log('No pairs');
        return null;
    }

    var nextPt = function(targPt, prevPt, CW)
    {
        var neighbPoints = [];

        for (var i = 0; i < pairs.length; i++)
        {
            var p = pairs[i];
            if (p[0] == targPt && p[1] != prevPt) neighbPoints.push(p[1]);
            if (p[1] == targPt && p[0] != prevPt) neighbPoints.push(p[0]);
        }

        if (neighbPoints.length == 0) return null;

        var maxAng = 0;
        var minAng = Number.MAX_VALUE;
        var maxPt = null;
        var minPt = null;

        for (i = 0; i < neighbPoints.length; i++)
        {
            var a = TR.angleBetweenLines(prevPt.x, prevPt.y,
                                         targPt.x, targPt.y,
                                         neighbPoints[i].x, neighbPoints[i].y,
                                         targPt.x, targPt.y);

            if (a > maxAng)
            {
                maxAng = a;
                maxPt = neighbPoints[i];
            }
            if (a < minAng)
            {
                minAng = a;
                minPt = neighbPoints[i];
            }
        }

        if (! maxPt || ! minPt) return null;
        if (CW) return maxPt; else return minPt;
    };

    var leftPt;
    var minX = Number.MAX_VALUE;

    for (var i = 0; i < pairs.length; i++)
    {
        var pair = pairs[i];
        if (pair[0].x < minX)
        {
            minX = pair[0].x;
            leftPt = pair[0];
        }
        if (pair[1].x < minX)
        {
            minX = pair[1].x;
            leftPt = pair[1];
        }
    }

    var prevPt = new WC.DataPoint(leftPt.x - 10, leftPt.y);
    var currPt = leftPt;
    var res = [];

    do
    {
        res.push(currPt);

        currPt = nextPt(currPt, prevPt, true);
        prevPt = res[res.length - 1];
        if (! currPt) return null;
    }
    while (currPt != leftPt);

    return res;
};

WC.attachRoomContent = function(obj)
{
    for (var i = 0; i < obj.roomsInner.length; i++)
    {
        obj.roomsInner[i].rooms = [];
        obj.roomsInner[i].covers = [];
    }

    obj.roomsInner.sort(function(a, b)
    {
        if (a.area < b.area)
        {
            return -1;
        }
        else if (a.area > b.area)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    });

    for (i = 0; i < obj.roomsOuter.length; i++) obj.roomsOuter[i].used = false;
    for (i = 0; i < obj.covers.length; i++) obj.covers[i].used = false
    for (i = 0; i < obj.walls.length; i++)
    {
        for (var j = 0; j < obj.walls[i].axes.length; j++) obj.walls[i].axes[j].used = false;
    }

    for (i = 0; i < obj.roomsInner.length; i++)
    {
        var room = obj.roomsInner[i];

        for (j = 0; j < obj.covers.length; j++)
        {
            var cover = obj.covers[j];
            var contComp = TR.compareContours(room.points, cover.points);
            if (cover.used || ! (contComp == TR.CONTAIN || contComp == TR.CONTACT_CONTAIN || contComp == TR.COINCIDE)) continue;
            cover.used = true;
            room.covers.push(cover);
        }

        for (j = 0; j < obj.roomsOuter.length; j++)
        {
            var oRoom = obj.roomsOuter[j];
            contComp = TR.compareContours(room.points, oRoom.points);
            if (oRoom.used || ! (contComp == TR.CONTAIN || contComp == TR.CONTACT_CONTAIN || contComp == TR.COINCIDE)) continue;
            oRoom.used = true;
            room.rooms.push(oRoom);
        }

        room.axes = [];
        for (j = 0; j < room.walls.length; j++)
        {
            for (var k = 0; k < room.walls[j].axes.length; k++)
            {
                if (! room.walls[j].axes[k].used)
                {
                    room.axes.push(room.walls[j].axes[k]);
                    room.walls[j].axes[k].used = true;
                }
            }
        }

        for (j = 0; j < room.rooms.length; j++)
        {
            var chRoom = room.rooms[j];
            for (k = 0; k < chRoom.walls.length; k++)
            {
                for (var l = 0; l < chRoom.walls[k].axes.length; l++)
                {
                    if (! chRoom.walls[k].axes[l].used)
                    {
                        room.axes.push(chRoom.walls[k].axes[l]);
                        chRoom.walls[k].axes[l].used = true;
                    }
                }
            }
        }
    }
};

WC.downloadTextFile = function(filename, text)
{
    var element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
};

WC.generateIndices = function(length)
{
    var res = new Array(length);
    for (var i = 0; i < length; i++) res[i] = i;
    return res;
};

WC.findPlinthSegment = function(mainPt, pt1, pt2, pt1s, pt2s, shape = [], height, depth, elevation, shiftX, shiftY, rotation)
{
    if (! pt1 || ! pt2 || ! pt1s || ! pt2s) return [];

    rotation = typeof rotation !== 'undefined' ? rotation : 0;
    shiftX = typeof shiftX !== 'undefined' ? shiftX : 0;
    shiftY = typeof shiftY !== 'undefined' ? shiftY : 0;

    elevation = typeof elevation !== 'undefined' ? elevation : 100;

    var pixPerMeter = 100;
    var resTrs = [];
    var V = 0;

    for (var i = 0; i < shape?.length - 1; i++)
    {
        var d = shape[i][0];
        var h = shape[i][1];
        var ds = shape[i + 1][0];
        var hs = shape[i + 1][1];
        var k = d;
        var ks = ds;

        var X1  = pt1.x + (pt1s.x - pt1.x) * k;
        var Y1  = h + elevation;
        var Z1  = -pt1.y - (pt1s.y - pt1.y) * k;

        var X1s = pt1.x + (pt1s.x - pt1.x) * ks;
        var Y1s = hs + elevation;
        var Z1s = -pt1.y - (pt1s.y - pt1.y) * ks;

        var X2  = pt2.x + (pt2s.x - pt2.x) * k;
        var Y2  = h + elevation;
        var Z2  = -pt2.y - (pt2s.y - pt2.y) * k;

        var X2s = pt2.x + (pt2s.x - pt2.x) * ks;
        var Y2s = hs + elevation;
        var Z2s = -pt2.y - (pt2s.y - pt2.y) * ks;

        var ptU0 = TR.projectionPointOnLine(mainPt, new TR.Point(X1, -Z1), new TR.Point(X2, -Z2), false);
        var U1 = TR.euclDistP(new TR.Point(X1, -Z1), ptU0) / pixPerMeter;
        var U2 = TR.euclDistP(new TR.Point(X2, -Z2), ptU0) / pixPerMeter;
        ptU0 = TR.projectionPointOnLine(mainPt, new TR.Point(X1s, -Z1s), new TR.Point(X2s, -Z2s), false);
        var U1s = TR.euclDistP(new TR.Point(X1s, -Z1s), ptU0) / pixPerMeter;
        var U2s = TR.euclDistP(new TR.Point(X2s, -Z2s), ptU0) / pixPerMeter;
        if (TR.euclDistP(new TR.Point(X1s, -Z1s), new TR.Point(X2s, -Z2s)) > TR.euclDistP(new TR.Point(X2s, -Z2s), ptU0))
        {
            U1 = -U1;
            U1s = -U1s;
        }

        var Vs = V + Math.sqrt((ds - d) * (ds - d) + (hs - h) * (hs - h)) / pixPerMeter;

        var transformedA = TR.rotateXY(U1 - shiftX, V - shiftY, -rotation);
        var transformedB = TR.rotateXY(U2 - shiftX, V - shiftY, -rotation);
        var transformedC = TR.rotateXY(U2s - shiftX, Vs - shiftY, -rotation);

        var uA = transformedA[0] + shiftX;
        var vA = transformedA[1] + shiftY;
        var uB = transformedB[0] + shiftX;
        var vB = transformedB[1] + shiftY;
        var uC = transformedC[0] + shiftX;
        var vC = transformedC[1] + shiftY;

        var transformedD = TR.rotateXY(U1 - shiftX, V - shiftY, -rotation);
        var transformedE = TR.rotateXY(U2s - shiftX, Vs - shiftY, -rotation);
        var transformedF = TR.rotateXY(U1s - shiftX, Vs - shiftY, -rotation);

        var uD = transformedD[0] + shiftX;
        var vD = transformedD[1] + shiftY;
        var uE = transformedE[0] + shiftX;
        var vE = transformedE[1] + shiftY;
        var uF = transformedF[0] + shiftX;
        var vF = transformedF[1] + shiftY;

        resTrs.push([[X1, Y1, Z1, X2s, Y2s, Z2s, X2, Y2, Z2],    [uA, vA, uC, vC, uB, vB]],
                    [[X1, Y1, Z1, X1s, Y1s, Z1s, X2s, Y2s, Z2s], [uD, vD, uF, vF, uE, vE]]);

        V = Vs;
    }

    for (var j = 0; j < 2; j++)
    {
        var p = [[pt1, pt1s], [pt2, pt2s]][j][0];
        var ps = [[pt1, pt1s], [pt2, pt2s]][j][1];

        var cont1 = new Array(shape.length + 1);
        k = TR.euclDistP(p, ps);

        for (i = 0; i < shape.length; i++)
        {
            cont1[i] = new TR.Point(shape[i][0] * k, shape[i][1])
        }

        cont1[cont1.length - 1] = new TR.Point(0, 0);
        var rawTrs = TR.triangulateContours([cont1], [], [], [], []);
        var v1 = {x: p.x, y: 0, z: -p.y};
        var v2 = {x: ps.x, y: 0, z: -ps.y};

        for (i = 0; i < rawTrs[0].length; i++)
        {
            var i0 = rawTrs[0][i].pointIndices[0];
            var i1 = rawTrs[0][i].pointIndices[1];
            var i2 = rawTrs[0][i].pointIndices[2];

            var a = new TR.Point(TR.points[i0][0], TR.points[i0][1] + elevation);
            var b = new TR.Point(TR.points[i1][0], TR.points[i1][1] + elevation);
            var c = new TR.Point(TR.points[i2][0], TR.points[i2][1] + elevation);

            var tr = WC.findTriWall(a, b, c, v1, v2, height, false, shiftX, shiftY, rotation);

            resTrs.push(tr);
        }
    }

    return resTrs
};

WC.isDef = function(val)
{
    return (typeof val !== 'undefined')
};

WC.Part = function()
{
    var me = this;
    me.materialID = 0;
    me.addMaterialID = "";

    me.triangles = [];
    me.trianglesSolid = [];
    me.area = 0;
    me.vertices = [];
    me.uvs = [];
    me.indices = [];

    me.addNullData = function()
    {
        if (me.vertices.length > 0) return;

        me.vertices = [-1, -1, -1, -1, -1, -1, -1, -1, -1];
        me.uvs = [0, 0, 0, 0, 0, 0];
        me.indices = [0, 1, 2];
    }
};
WC.findTriWall = function(a, b, c, v1, v2, height, reverse, shiftX, shiftY, rotation, centerX, centerY)
{
    rotation = typeof rotation !== 'undefined' ? rotation : 0;
    shiftX = typeof shiftX !== 'undefined' ? shiftX : 0;
    shiftY = typeof shiftY !== 'undefined' ? shiftY : 0;
    reverse = typeof reverse !== 'undefined' ? reverse : false;
    centerX = typeof centerX !== 'undefined' ? centerX : 0;
    centerY = typeof centerY !== 'undefined' ? centerY : 0;

    var pixPerMeter = 100;

    var angle = Math.PI / 2 - WC.azimuth(v1.x, v1.z, v2.x, v2.z);
    var wallWidth = TR.euclDist(v1.x, v1.z, v2.x, v2.z);
    var pivotPoint = v1;

    var _currPoints = [a, b, c];

    var cX = (a.x + b.x + c.x) / 3;
    var cY = (a.y + b.y + c.y) / 3;

    a.az = WC.azimuth(cX, cY, a.x, a.y);
    b.az = WC.azimuth(cX, cY, b.x, b.y);
    c.az = WC.azimuth(cX, cY, c.x, c.y);

    _currPoints.sort(sortByAngle);
    if (reverse) _currPoints.reverse();

    a = _currPoints[0];
    b = _currPoints[1];
    c = _currPoints[2];

    var uA, vA, uB, vB, uC, vC;

    if (! reverse)
    {
        uA = (wallWidth - a.x);
        vA = (-a.y);

        uB = (wallWidth - b.x);
        vB = (-b.y);

        uC = (wallWidth - c.x);
        vC = (-c.y);
    }
    else
    {
        uA = (a.x);
        vA = (-a.y);

        uB = (b.x);
        vB = (-b.y);

        uC = (c.x);
        vC = (-c.y);
    }

    var transformedA = TR.rotateXY(uA - shiftX - centerX, vA + shiftY + centerY, -rotation);
    var transformedB = TR.rotateXY(uB - shiftX - centerX, vB + shiftY + centerY, -rotation);
    var transformedC = TR.rotateXY(uC - shiftX - centerX, vC + shiftY + centerY, -rotation);

    uA = transformedA[0] + centerX;
    vA = transformedA[1] - centerY;
    uB = transformedB[0] + centerX;
    vB = transformedB[1] - centerY;
    uC = transformedC[0] + centerX;
    vC = transformedC[1] - centerY;

    uA /= pixPerMeter;
    vA /= pixPerMeter;

    uB /= pixPerMeter;
    vB /= pixPerMeter;

    uC /= pixPerMeter;
    vC /= pixPerMeter;

    var vertices = [];
    var uvs = [];

    var X = pivotPoint.x + (a.x * Math.sin(angle));
    var Y = a.y;
    var Z = pivotPoint.z + (a.x * Math.cos(angle));
    vertices.push(X, Y, Z);

    X = pivotPoint.x + (b.x * Math.sin(angle));
    Y = b.y;
    Z = pivotPoint.z + (b.x * Math.cos(angle));
    vertices.push(X, Y, Z);

    X = pivotPoint.x + (c.x * Math.sin(angle));
    Y = c.y;
    Z = pivotPoint.z + (c.x * Math.cos(angle));
    vertices.push(X, Y, Z);

    uvs.push(uA, vA);
    uvs.push(uB, vB);
    uvs.push(uC, vC);

    return [vertices, uvs]
};

WC.findTriCover = function(a, b, c, elevation, reverse, shiftX, shiftY, rotation, centerX, centerY)
{
    rotation = typeof rotation !== 'undefined' ? rotation : 0;
    shiftX = typeof shiftX !== 'undefined' ? shiftX : 0;
    shiftY = typeof shiftY !== 'undefined' ? shiftY : 0;
    reverse = typeof reverse !== 'undefined' ? reverse : false;
    centerX = typeof centerX !== 'undefined' ? centerX : 0;
    centerY = typeof centerY !== 'undefined' ? centerY : 0;

    var pixPerMeter = 100;

    var _currPoints = [a, b, c];

    var cX = (a.x + b.x + c.x) / 3;
    var cY = (a.y + b.y + c.y) / 3;

    a.az = WC.azimuth(cX, cY, a.x, a.y);
    b.az = WC.azimuth(cX, cY, b.x, b.y);
    c.az = WC.azimuth(cX, cY, c.x, c.y);

    _currPoints.sort(sortByAngle);
    if (reverse) _currPoints.reverse();

    a = _currPoints[0];
    b = _currPoints[1];
    c = _currPoints[2];

    var uA, vA, uB, vB, uC, vC;

    if (! reverse)
    {
        uA = a.x;
        vA = a.y;

        uB = b.x;
        vB = b.y;

        uC = c.x;
        vC = c.y;
    }
    else
    {
        uA = -a.x;
        vA = a.y;

        uB = -b.x;
        vB = b.y;

        uC = -c.x;
        vC = c.y;
    }

    var kr = 1;
    if (reverse) kr = -1;
/*
    var transformedA = TR.rotateXY(uA - kr * shiftX, vA - shiftY, -rotation);
    var transformedB = TR.rotateXY(uB - kr * shiftX, vB - shiftY, -rotation);
    var transformedC = TR.rotateXY(uC - kr * shiftX, vC - shiftY, -rotation);

    uA = transformedA[0] ;//+ kr * shiftX;
    vA = transformedA[1] ;//+ shiftY;
    uB = transformedB[0] ;//+ kr * shiftX;
    vB = transformedB[1] ;//+ shiftY;
    uC = transformedC[0] ;//+ kr * shiftX;
    vC = transformedC[1] ;//+ shiftY;
*/

     var transformedA = TR.rotateXY(uA - kr * (shiftX + centerX), vA - shiftY - centerY, -rotation);
     var transformedB = TR.rotateXY(uB - kr * (shiftX + centerX), vB - shiftY - centerY, -rotation);
     var transformedC = TR.rotateXY(uC - kr * (shiftX + centerX), vC - shiftY - centerY, -rotation);

     uA = transformedA[0] + kr * centerX;
     vA = transformedA[1] + centerY;
     uB = transformedB[0] + kr * centerX;
     vB = transformedB[1] + centerY;
     uC = transformedC[0] + kr * centerX;
     vC = transformedC[1] + centerY;


    uA /= pixPerMeter;
    vA /= pixPerMeter;

    uB /= pixPerMeter;
    vB /= pixPerMeter;

    uC /= pixPerMeter;
    vC /= pixPerMeter;

    var vertices = [];
    var uvs = [];

    var X = a.x;
    var Y = elevation;
    var Z = -a.y;
    vertices.push(X, Y, Z);

    X = b.x;
    Y = elevation;
    Z = -b.y;
    vertices.push(X, Y, Z);

    X = c.x;
    Y = elevation;
    Z = -c.y;
    vertices.push(X, Y, Z);

    uvs.push(uA, vA);
    uvs.push(uB, vB);
    uvs.push(uC, vC);

    return [vertices, uvs]
};

WC.findTriWallTile = function(a, b, c, v1, v2, reverse, uv00, uv10, uv01, flip, rotation)
{
    var angle = Math.PI / 2 - WC.azimuth(v1.x, v1.z, v2.x, v2.z);
    var wallWidth = TR.euclDist(v1.x, v1.z, v2.x, v2.z);
    var pivotPoint = v1;

    var _currPoints = [a, b, c];

    var cX = (a.x + b.x + c.x) / 3;
    var cY = (a.y + b.y + c.y) / 3;

    a.az = WC.azimuth(cX, cY, a.x, a.y);
    b.az = WC.azimuth(cX, cY, b.x, b.y);
    c.az = WC.azimuth(cX, cY, c.x, c.y);

    _currPoints.sort(sortByAngle);
    if (reverse) _currPoints.reverse();

    a = _currPoints[0];
    b = _currPoints[1];
    c = _currPoints[2];

    var uA = TR.distanceBetweenPointAndLine(a, uv00, uv01) / 100;
    var uB = TR.distanceBetweenPointAndLine(b, uv00, uv01) / 100;
    var uC = TR.distanceBetweenPointAndLine(c, uv00, uv01) / 100;

    var vA = TR.distanceBetweenPointAndLine(a, uv00, uv10) / 100;
    var vB = TR.distanceBetweenPointAndLine(b, uv00, uv10) / 100;
    var vC = TR.distanceBetweenPointAndLine(c, uv00, uv10) / 100;

    var r;
    if (reverse)
    {
        r = rotation - Math.PI;
    }
    else
    {
        r = Math.PI - rotation;
    }

    var transformedA = TR.rotateXY(uA, vA, r);
    var transformedB = TR.rotateXY(uB, vB, r);
    var transformedC = TR.rotateXY(uC, vC, r);

    uA = transformedA[0];
    vA = transformedA[1];
    uB = transformedB[0];
    vB = transformedB[1];
    uC = transformedC[0];
    vC = transformedC[1];

    if (reverse ^ flip)
    {
        uA = -uA;
        uB = -uB;
        uC = -uC;
    }

    var vertices = [];
    var uvs = [];

    var X = pivotPoint.x + (a.x * Math.sin(angle));
    var Y = a.y;
    var Z = pivotPoint.z + (a.x * Math.cos(angle));
    vertices.push(X, Y, Z);

    X = pivotPoint.x + (b.x * Math.sin(angle));
    Y = b.y;
    Z = pivotPoint.z + (b.x * Math.cos(angle));
    vertices.push(X, Y, Z);

    X = pivotPoint.x + (c.x * Math.sin(angle));
    Y = c.y;
    Z = pivotPoint.z + (c.x * Math.cos(angle));
    vertices.push(X, Y, Z);

    uvs.push(uA, vA);
    uvs.push(uB, vB);
    uvs.push(uC, vC);

    return [vertices, uvs]
};
WC.DataWall = function(pt1, pt2, id)
{
    WC.DataObject.call(this);

    let me = this;
    me.materialID = R2D.default.getDefaultMaterialByKey("wall");
    me.addMaterialID = R2D.default.getDefaultAddMaterialByKey("wall");
    me.point1 = pt1;
    me.point2 = pt2;
    me.id = id;
    me.type = 'wall';
    me.height = WC.DEFAULT_WALLS_HEIGHT;
    me.faceRight = false;
    me.visible = true;

    me.materialRotation = 0;

    me.v1 = null;
    me.v2 = null;
    me.v3 = null;
    me.v4 = null;

    me.axes = [];
    me.topPlinth = null;
    me.bottomPlinth = null;
    me.room = null;

    me.pattern = [];
    me.configData = null;

    me.solid = false;
    me.contours = []; // for selection in 3D

    me.changed = true;

    me.getTotalArea = function()
    {
        let a = 0;
        for (let i = 0; i < me.parts.length; i++)
        {
            a += me.parts[i].area;
        }
        return a;
    };

    me.getAreaByID = function(id)
    {
        if (id == -1 && me.configData)
        {
            return me.parts[0].area;
        }
        else
        {
            let part = getPartByID(id);
            if (part) return part.area;
            return null;
        }
    };

    me.setMaterial = function(matID, partNum)
    {
        
        if (typeof(partNum) == 'undefined' || partNum == '-1')
        {
            matID = matID.id ? matID.id : matID;
            me.materialID = matID;
            getPartByID('-1').materialID = matID;
            me.changed = true;
            return true;
        }
        else if (me.configData)
        {
            if (me.configData.setMaterialByID(matID, partNum))
            {
                getPartByID(partNum).materialID = matID;
                me.changed = true;
                return true;
            }
        }
        return false;
    };

    me.setAddMaterial = function(addMatID, partNum)
    {
        
        if (typeof(partNum) == 'undefined' || partNum == '-1')
        {
            me.addMaterialID = addMatID;
            getPartByID('-1').addMaterialID = addMatID;
            me.changed = true;
            return true;
        }
        else if (me.configData)
        {
            if (me.configData.setAddMaterialByID(addMatID, partNum))
            {
                getPartByID(partNum).addMaterialID = addMatID;
                me.changed = true;
                return true;
            }
        }
        return false;
    };

    me.clearMaterial = function()
    {
        me.materialID = 0;
        me.addMaterialID = "";
        me.configData = null;
        me.changed = true;
    };

    function getPartByID(id)
    {
        for (let i = 0; i < me.parts.length; i++)
        {
            if (me.parts[i].id == id) return me.parts[i];
        }
    }

    me.setMaterialRotation = function(angle, partNum)
    {
        if (typeof(partNum) == "undefined" || partNum == '-1')
        {
            me.materialRotation = angle;
            getPartByID('-1').materialRotation = angle;
            return true;
        }
        else if (me.configData)
        {
            if (me.configData.setRotationByID(angle, partNum))
            {
                getPartByID(partNum).materialRotation = angle;
            }
        }
        return false;
    };

    me.getMaterialRotation = function(partNum)
    {
        if (typeof(partNum) == "undefined" || partNum == '-1')
        {
            return me.materialRotation;
        }
        else if (me.configData)
        {
            return me.configData.getRotationByID(partNum);

        }
        return false;
    };

    me.getMaterial = function(partNum)
    {
        if (typeof(partNum) == "undefined" || partNum == '-1' || ! me.configData)
        {
            return me.materialID;
        }
        else
        {
            return me.configData.getMaterialByID(partNum);
        }
    };

    me.getAddMaterial = function(partNum)
    {
        if (typeof(partNum) == "undefined" || partNum == '-1' || ! me.configData)
        {
            return me.addMaterialID;
        }
        else
        {
            return me.configData.getAddMaterialByID(partNum);
        }
    };

    me.setMaterialShift = function(shift, partNum)
    {
        if (typeof(partNum) == "undefined" || partNum == '-1')
        {
            me.materialX = shift[0];
            me.materialY = shift[1];
            getPartByID('-1').materialX = shift[0];
            getPartByID('-1').materialY = shift[1];

            return true;
        }
        else if (me.configData)
        {
            if (me.configData.setShiftByID(shift, partNum))
            {
                getPartByID(partNum).materialX = shift[0];
                getPartByID(partNum).materialY = shift[1];
            }
        }
        return false;
    };

    me.getMaterialShift = function(partNum)
    {
        if (typeof(partNum) == "undefined" || partNum == '-1')
        {
            return [me.materialX, me.materialY];
        }
        else if (me.configData)
        {
            return me.configData.getShiftByID(partNum)
        }
        return false;
    };

    me.getMaterials = function()
    {
        let matIDs = [];
        for (let i = 0; i < me.pattern.length; i++)
        {
            matIDs.push(me.pattern[i].materialID);
        }
        matIDs.push(me.materialID);

        return matIDs;
    };

    me.dispatchShowHide = function()
    {
        me.dispatchEvent(new Event(WC.ELEMENT_SHOW_HIDE, me));
    };

    function getHoles()
    {
        let holes = [];

        for (let k = 0; k < me.axes.length; k++)
        {
            let axis = me.axes[k];

            let parallel = TR.euclDist(me.point1.x, me.point1.y, axis.point1.x, axis.point1.y) <
                TR.euclDist(me.point1.x, me.point1.y, axis.point2.x, axis.point2.y);

            for (let i = 0; i < axis.models.length; i++)
            {
                let modelContour = axis.models[i].contour;

                if (! modelContour) continue;

                let holePoints = [];
                let axisLength = TR.euclDist(axis.point1.x, axis.point1.y, axis.point2.x, axis.point2.y);
                let flipX = 1;
                if (axis.models[i].flipX) flipX = -1;

                if (parallel)
                {
                    let proj = TR.projectionPointOnLine(axis.point1, me.point1, me.point2, false);
                    let axisShift = TR.euclDist(me.point1.x, me.point1.y, proj.x, proj.y);

                    for (let j = 0; j < modelContour.length; j++)
                    {
                        let P = new WC.DataPoint(modelContour[j].x, modelContour[j].y);
                        P.x *= axis.models[i].scaleX * flipX;
                        P.x = P.x + axis.positions[i] * axisLength + axisShift;
                        P.y *= axis.models[i].scaleY;
                        P.y = axis.models[i].elevation - P.y;

                        holePoints.push(P);
                    }
                }
                else
                {
                    proj = TR.projectionPointOnLine(axis.point2, me.point1, me.point2, false);
                    axisShift = TR.euclDist(me.point1.x, me.point1.y, proj.x, proj.y);

                    for (j = 0; j < modelContour.length; j++)
                    {
                        P = new WC.DataPoint(modelContour[j].x, modelContour[j].y);
                        P.x *= axis.models[i].scaleX * (-flipX);
                        P.x = P.x + (1 - axis.positions[i]) * axisLength + axisShift;
                        P.y *= axis.models[i].scaleY;
                        P.y = axis.models[i].elevation - P.y;

                        holePoints.push(P);
                    }
                }

                holes.push(holePoints);
            }
        }

        return holes;
    }

    function trianglesFromIndices(trs)  // todo: move to TR?
    {
        let res = new Array(trs[0].length);
        for (let j = 0; j < trs[0].length; j++) {
            let j0 = trs[0][j].pointIndices[0];
            let j1 = trs[0][j].pointIndices[1];
            let j2 = trs[0][j].pointIndices[2];

            let a = new TR.Point(TR.points[j0][0], TR.points[j0][1]);
            let b = new TR.Point(TR.points[j1][0], TR.points[j1][1]);
            let c = new TR.Point(TR.points[j2][0], TR.points[j2][1]);

            res[j] = [a, b, c];
        }

        return res;
    }

    me.build3D = function()
    {
        me.pattern = [];
        if (me.configData)
        {
            
            me.configData.setSize(TR.euclDistP(me.point1, me.point2), me.height);
            me.configData.calcAreas();
            me.configData.autoFillAll();
            
            let matTiles = me.configData.getTiles(me.height, TR.euclDistP(me.point1, me.point2), me.faceRight);

            for (let i = 0; i < matTiles.length; i++)
            {
                let seg = new WC.WallSegment();
                seg.materialID = matTiles[i][0].materialID;
                seg.addMaterialID = matTiles[i][0].addMaterialID;
                seg.tiles = matTiles[i];
                seg.id = matTiles[i][0].id;
                me.pattern.push(seg);
            }
        }

        me.v1 = new THREE.Vector3(me.point1.x, 0, - me.point1.y);
        me.v2 = new THREE.Vector3(me.point2.x, 0, - me.point2.y);
        me.v3 = new THREE.Vector3(me.point2.x, me.height, - me.point2.y);
        me.v4 = new THREE.Vector3(me.point1.x, me.height, - me.point1.y);

        let shiftVal = 0.1; // Displacement for overlaying tiles
        if (me.faceRight) shiftVal = -0.1;
        let shiftedP1 = TR.perpendicularPoint(me.point1, me.point2, shiftVal);
        let shiftedP2 = TR.perpendicularPoint(me.point2, me.point1, -shiftVal);
        let shiftedV1 = new THREE.Vector3(shiftedP1.x, 0, - shiftedP1.y);
        let shiftedV2 = new THREE.Vector3(shiftedP2.x, 0, - shiftedP2.y);

        me.contours = [[{x: me.v1.x, y: me.v1.y, z: me.v1.z},
            {x: me.v2.x, y: me.v2.y, z: me.v2.z},
            {x: me.v3.x, y: me.v3.y, z: me.v3.z},
            {x: me.v4.x, y: me.v4.y, z: me.v4.z}]];

        let wallLength = TR.euclDistP(me.point1, me.point2);
        let A = new TR.Point(0, 0);
        let B = new TR.Point(wallLength, 0);
        let C = new TR.Point(wallLength, me.height);
        let D = new TR.Point(0, me.height);
        me.rotatingCenter = new TR.Point((A.x + B.x) / 2, (B.y + C.y) / 2);
        me.areaRect = me.height * wallLength;

        let holes = [];
        if (! me.solid) holes = getHoles();

        for (let i = 0; i < holes.length; i++)
        {
            me.contours.push(WC.findContourWall(holes[i], me.v1, me.v2, me.faceRight));
        }

        me.parts = [];

        let partContours = [];
        for (let i = 0; i < me.pattern.length; i++) {

            let part = new WC.Part();
            part.id = me.pattern[i].id;
            part.materialID = me.pattern[i].materialID;
            part.addMaterialID = me.pattern[i].addMaterialID;
            me.parts.push(part);
            let tiles = me.pattern[i].tiles;

            part.vertices = [];
            part.uvs = [];
            part.area = 0;

            part.contour = WC.findContourWall(tiles[0].outerContours[0], me.v1, me.v2, me.faceRight);

            for (let j = 0; j < tiles.length; j++)
            {
                let tile = tiles[j];
                let trs = TR.triangulateContours(tile.outerContours, tile.innerContours.concat(holes), tile.boundContours, [], []); //[[A, B, C, D]], [], []);
                trs = trianglesFromIndices(trs);

                for (let k = 0; k < trs.length; k++)
                {
                    let a = trs[k][0];
                    let b = trs[k][1];
                    let c = trs[k][2];

                    part.area += TR.triangleArea(a.x, a.y, b.x, b.y, c.x, c.y);

                    let tr;
                    if (tile.isTile)
                    {
                        tr = WC.findTriWallTile(a, b, c, shiftedV1, shiftedV2, me.faceRight,
                            tile.outerContours[0][0], tile.outerContours[0][1], tile.outerContours[0][3],
                            tile.flip, tile.rotation);
                    }
                    else
                    {
                        tr = WC.findTriWall(a, b, c, me.v1, me.v2, me.height, me.faceRight, tile.materialX, tile.materialY, tile.rotation, tile.centerX, tile.centerY);
                    }

                    part.vertices = part.vertices.concat(tr[0]);
                    part.uvs = part.uvs.concat(tr[1]);
                }

                part.indices = WC.generateIndices(part.vertices.length / 3);
                part.addNullData();
                partContours = partContours.concat(tile.outerContours);
            }
        }

        let part = new WC.Part();
        part.id = -1;
        part.materialID = me.materialID;
        part.addMaterialID = me.addMaterialID;
        me.parts.push(part);
        trs = TR.triangulateContours([[A, B, C, D]], partContours.concat(holes), [], [], []);
        trs = trianglesFromIndices(trs);

        part.vertices = [];
        part.uvs = [];
        part.area = 0;

        for (let i = 0; i < trs.length; i++)
        {
            a = trs[i][0];
            b = trs[i][1];
            c = trs[i][2];

            part.area += TR.triangleArea(a.x, a.y, b.x, b.y, c.x, c.y);

            let matRotation = me.materialRotation;

            tr = WC.findTriWall(a, b, c, me.v1, me.v2, me.height, me.faceRight, me.materialX, me.materialY, matRotation, me.rotatingCenter.x, me.rotatingCenter.y);

            part.vertices = part.vertices.concat(tr[0]);
            part.uvs = part.uvs.concat(tr[1]);
        }

        part.indices = WC.generateIndices(part.vertices.length / 3);
        part.addNullData();

        me.addNullData();

        me.area = part.area;
    };

    me.startRotateMaterial = function(point)
    {
        me.solid = true;
    };

    me.rotateMaterial = function(angle, partNum)
    {
        //me.materialX = me.rotatingCenter.x;
        //me.materialY = me.rotatingCenter.y;

        if (typeof partNum === 'undefined' || isNaN(partNum) || partNum == -1)
        {
            me.materialRotation = angle;
            getPartByID('-1').materialRotation = angle;
        }
        else
        {
            if (me.configData.setRotationByID(angle, partNum))
            {
                getPartByID(partNum).materialRotation = angle;
            }
        }

        me.build3D();
    };

    me.getPartContour = function(partNum)
    {
        return getPartByID(partNum).contour;
    };

    me.stopRotateMaterial = function()
    {
        me.solid = false;
        me.changed = true;
        me.build3D();
    };

    me.startMoveMaterial = function(point)
    {
        me.solid = true;
    };

    me.moveMaterial = function(shift, partNum)
    {
        if (typeof partNum === 'undefined' || isNaN(partNum) || partNum == -1)
        {
            me.materialX = shift[0];
            me.materialY = shift[1];
            getPartByID('-1').materialX = shift[0];
            getPartByID('-1').materialY = shift[1];
        }
        else
        {
            if (me.configData.setShiftByID(shift, partNum))
            {
                getPartByID(partNum).materialX = shift[0];
                getPartByID(partNum).materialY = shift[1];
            }
        }

        me.build3D();
    };

    me.stopMoveMaterial = function()
    {
        me.solid = false;
        me.changed = true;
        me.build3D();
    };

    me.findPlinthGaps = function()
    {
        me.bottomPlinth.gaps = [];

        for (let i = 0; i < me.axes.length; i++)
        {
            for (let j = 0; j < me.axes[i].finalContours.length; j++)
            {
                let pt1 = me.axes[i].point1;
                let pt2 = me.axes[i].point2;
                let cont = me.axes[i].finalContours[j];

                let bounds = TR.findMinMax(cont);

                if (-bounds.maxY >= me.bottomPlinth.h) continue;

                let ang = WC.azimuth(pt1.x, pt1.y, pt2.x, pt2.y);

                let minP = new TR.Point(pt1.x + bounds.minX * Math.cos(ang), pt1.y + bounds.minX * Math.sin(ang));
                let maxP = new TR.Point(pt1.x + bounds.maxX * Math.cos(ang), pt1.y + bounds.maxX * Math.sin(ang));

                let proj1 = TR.projectionPointOnLine(minP, me.point1, me.point2, false);
                let proj2 = TR.projectionPointOnLine(maxP, me.point1, me.point2, false);
                let in1 = TR.pointInBounds(proj1, me.point1, me.point2);
                let in2 = TR.pointInBounds(proj2, me.point1, me.point2);

                if (! in1 && ! in2) continue;

                let reverse = (me.point2.x - me.point1.x) * (proj2.x - proj1.x) + (me.point2.y - me.point1.y) * (proj2.y - proj1.y) < 0;

                if (! in1) proj1 = null;
                if (! in2) proj2 = null;

                if (reverse)
                {
                    me.bottomPlinth.gaps.push([proj2, proj1]);
                }
                else
                {
                    me.bottomPlinth.gaps.push([proj1, proj2]);
                }

                //console.log('----------');
                //console.log(me.point1, me.point2);
                //console.log(me.bottomPlinth.gaps[me.bottomPlinth.gaps.length - 1]);
            }
        }

        let delimiters = [];
        for (let i = 0; i < me.bottomPlinth.gaps.length; i++)
        {
            let gap = me.bottomPlinth.gaps[i];
            delimiters.push({'point': gap[0], 'type': 'start'});
            delimiters.push({'point': gap[1], 'type': 'end'});
        }

        delimiters.sort(sortDelimiters);

        let mergedGaps = [];
        let open = 0;
        let startPt = null;
        for (let i = 0; i < delimiters.length; i++)
        {
            let d = delimiters[i];
            if (d.type == 'start')
            {
                if (open == 0) startPt = d.point;
                open++;
            }
            else
            {
                open--;
                if (open == 0)
                {
                    mergedGaps.push([startPt, d.point])
                }
            }
        }

        me.bottomPlinth.gaps = mergedGaps;
    };
/*
    me.clonePattern = function()
    {
        let res = new Array(me.pattern.length);
        for (let i = 0; i < me.pattern.length; i++)
        {
            res[i] = me.pattern[i].clone();
        }
        return res;
    };

    me.setPattern = function(pattern)
    {
        console.log(pattern);

        me.pattern = new Array(pattern.length);
        for (let i = 0; i < pattern.length; i++)
        {
            me.pattern[i] = pattern[i].clone();
        }

    };
    */
    function sortDelimiters(A, B)
    {
        if (! A.point)
        {
            if (A.type == 'start') return -1; else return 1;
        }
        if (! B.point)
        {
            if (B.type == 'start') return 1; else return -1;
        }

        if (TR.euclDistP(me.point1, A.point) < TR.euclDistP(me.point1, B.point))
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }
};
R2D.extend(WC.DataWall, WC.DataObject);

WC.WallSegment = function()
{
    let me = this;
    me.materialID = 370;
    me.addMaterialID = "";
    me.materialRotation = 0;
    me.materialX = 0;
    me.materialY = 0;

    me.contours = [];
/*
    me.clone = function()
    {
        let seg = new WC.WallSegment();
        seg.height = me.height;
        seg.materialID = me.materialID;
        seg.materialRotation = me.materialRotation;
        seg.materialX = me.materialX;
        seg.materialY = me.materialY;
        return seg;
    }
*/
};

WC.convert = {};

WC.convert.structureToApp = function(obj)
{
    var res = {};

    res.points = new Array(obj.roomPoints.length);
    for (var i = 0; i < obj.roomPoints.length; i++)
    {
        var DP = obj.roomPoints[i];
        var rounderP = TR.roundCoord(DP);
        res.points[i] = {id:DP.id, x:rounderP.x, y:rounderP.y};
    }

    res.walls = new Array(obj.walls.length);
    for (i = 0; i < obj.walls.length; i++)
    {
        var w = WC.convert.wallToShort(obj.walls[i]);
        res.walls[i] = {id: w.id, pa: w.pa, pb: w.pb, contours: obj.walls[i].contours}
    }

    res.rooms = new Array(obj.roomsOuter.length + obj.roomsInner.length);
    for (i = 0; i < obj.roomsOuter.length; i++)
    {
        var DR = obj.roomsOuter[i];
        var points = new Array(DR.points.length);
        for (var j = 0; j < points.length; j++)
        {
            points[j] = DR.points[j].id;
        }

        var walls = new Array(DR.walls.length);
        for (j = 0; j < walls.length; j++)
        {
            walls[j] = DR.walls[j].id;
        }

        res.rooms[i] = {id: DR.id, points: points, walls: walls, outer: 1}
    }

    for (var k = 0; k < obj.roomsInner.length; k++)
    {
        DR = obj.roomsInner[k];
        points = new Array(DR.points.length);
        for (j = 0; j < points.length; j++)
        {
            points[j] = DR.points[j].id;
        }

        walls = new Array(DR.walls.length);
        for (j = 0; j < walls.length; j++)
        {
            walls[j] = DR.walls[j].id;
        }

        res.rooms[i] = {id: DR.id, points: points, walls: walls, outer: 0};
        i++;
    }

    res.cap = {wh: obj.cap.wallsHeight};

    return res;
};

WC.convert.structureToShort = function(obj)
{
    var res = {};

    res.points = new Array(obj.roomPoints.length + obj.coverPoints.length);
    for (var i = 0; i < obj.roomPoints.length; i++)
    {
        var DP = obj.roomPoints[i];
        var rounderP = TR.roundCoord(DP);
        res.points[i] = {id:DP.id, x:rounderP.x, y:rounderP.y, type:'rp', control:0};
    }
    for (var j = 0; j < obj.coverPoints.length; j++)
    {
        DP = obj.coverPoints[j];
        rounderP = TR.roundCoord(DP);
        res.points[i] = {id:DP.id, x:rounderP.x, y:rounderP.y, type:'cp', control:0};
        i++;
    }

    res.walls = new Array(obj.walls.length);
    for (i = 0; i < obj.walls.length; i++)
    {
        res.walls[i] = WC.convert.wallToShort(obj.walls[i])
    }

    res.cuts = new Array(obj.cuts.length);
    for (i = 0; i < obj.cuts.length; i++)
    {
        var dCut = obj.cuts[i];
        res.cuts[i] = {id:dCut.id, pa:dCut.point1.id, pb:dCut.point2.id,
            m:dCut.materialID, addM: dCut.addMaterialID, mr:dCut.materialRotation, mx:dCut.materialX, my:dCut.materialY};
    }

    res.rooms = new Array(obj.roomsOuter.length + obj.roomsInner.length);
    for (i = 0; i < obj.roomsOuter.length; i++)
    {
        var DR = obj.roomsOuter[i];
        var points = new Array(DR.points.length);
        for (j = 0; j < points.length; j++)
        {
            points[j] = DR.points[j].id;
        }

        var walls = new Array(DR.walls.length);
        for (j = 0; j < walls.length; j++)
        {
            walls[j] = DR.walls[j].id;
        }

        res.rooms[i] = {id:DR.id, points:points, walls:walls, outer:1}
    }

    for (var k = 0; k < obj.roomsInner.length; k++)
    {
        DR = obj.roomsInner[k];
        points = new Array(DR.points.length);
        for (j = 0; j < points.length; j++)
        {
            points[j] = DR.points[j].id;
        }

        walls = new Array(DR.walls.length);
        for (j = 0; j < walls.length; j++)
        {
            walls[j] = DR.walls[j].id;
        }

        res.rooms[i] = {id:DR.id, points:points, walls:walls, outer:0};
        i++;
    }

    res.covers = new Array(obj.covers.length + obj.coverHoles.length);
    for (i = 0; i < obj.covers.length; i++)
    {
        var DC = obj.covers[i];
        res.covers[i] = WC.convert.coverToShort(DC);
    }

    for (k = 0; k < obj.coverHoles.length; k++)
    {
        DC = obj.coverHoles[k];
        res.covers[i] =  WC.convert.coverToShort(DC);
        i++;
    }

    res.areas = new Array(obj.areas.length);
    for (i = 0; i < obj.areas.length; i++)
    {
        var DA = obj.areas[i];
        walls = new Array(DA.walls.length);
        for (j = 0; j < walls.length; j++)
        {
            walls[j] = DA.walls[j].id;
        }
        var cuts = new Array(DA.cuts.length);
        for (j = 0; j < cuts.length; j++)
        {
            cuts[j] = DA.cuts[j].id;
        }

        res.areas[i] = {id:DA.id, name:DA.name, walls:walls, cuts:cuts, h:DA.height,
            ch:DA.ceiling.height, cv:DA.ceiling.exists,
            m:DA.materialID, addM:DA.addMaterialID, mr:DA.materialRotation, mx:DA.materialX, my:DA.materialY,
            mc:DA.ceiling.materialID, addMc: DA.ceiling.addMaterialID, mcr:DA.ceiling.materialRotation,
            mcx:DA.ceiling.materialX, mcy:DA.ceiling.materialY};
    }

    res.cap = {m:obj.cap.materialID, addM: obj.cap.addMaterialID, mr:obj.cap.materialRotation,
        mx:obj.cap.materialX, my:obj.cap.materialY, wh:obj.cap.wallsHeight};

    var matIDs = [];
    for (i = 0; i < res.walls.length; i++)
    {
        matIDs.push(res.walls[i].addM||res.walls[i].m);
        matIDs.push(res.walls[i].plbAddm||res.walls[i].plbm);
        matIDs.push(res.walls[i].pltAddm||res.walls[i].pltm);
        if (res.walls[i].conf)
        {
            for (j = 0; j < res.walls[i].conf.areas.length; j++)
            {
                matIDs.push(String(res.walls[i].conf.areas[j].addM)||String(res.walls[i].conf.areas[j].m));
            }
        }
    }

    for (i = 0; i < res.cuts.length; i++) matIDs.push(String(res.cuts[i].addM)||String(res.cuts[i].m));
    for (i = 0; i < res.covers.length; i++) matIDs.push(String(res.covers[i].addM)||String(res.covers[i].m));
    for (i = 0; i < res.areas.length; i++) matIDs.push(String(res.areas[i].addM)||String(res.areas[i].m));
    matIDs.push(res.cap.addM||res.cap.m);

    const frameIds = obj.axes
        .flatMap((axis) => axis.frames)
        .map((frame) => frame.addMaterialID || frame.materialID)
        .filter((id) => !(id === 0 || id === "0"));
    
    matIDs.push(...frameIds);

    return {construction: res, list_materials: [...new Set(matIDs)]}
};

WC.convert.wallToShort = function(DW)
{
    var conf = '';
    if (DW.configData) conf = DW.configData.toData();

    return {id:DW.id, name:DW.name, pa:DW.point1.id, pb:DW.point2.id, pm:'',
        m:DW.materialID, addM:DW.addMaterialID, mr:DW.materialRotation, mx:DW.materialX, my:DW.materialY,
        pltv:DW.topPlinth.exists? 1 : 0,
        pltm:DW.topPlinth.materialID, pltAddm:DW.topPlinth.addMaterialID, pltmr: DW.topPlinth.materialRotation,
        pltmx:DW.topPlinth.materialX, pltmy:DW.topPlinth.materialY,
        plth:DW.topPlinth.h, pltd:DW.topPlinth.d, pltsh:DW.topPlinth.shapeNum,
        plbv:DW.bottomPlinth.exists? 1 : 0,
        plbm:DW.bottomPlinth.materialID, plbAddm:DW.bottomPlinth.addMaterialID, plbmr: DW.bottomPlinth.materialRotation,
        plbmx:DW.bottomPlinth.materialX, plbmy:DW.bottomPlinth.materialY,
        plbh:DW.bottomPlinth.h, plbd:DW.bottomPlinth.d, plbsh:DW.bottomPlinth.shapeNum,
        conf: conf};
};

WC.convert.coverToShort = function(DC)
{
    var points = new Array(DC.points.length);
    for (var i = 0; i < points.length; i++)
    {
        points[i] = DC.points[i].id;
    }

    if (DC.outer)
    {
        return {id:DC.id, name:DC.name, points:points, o:1, ch:DC.ceiling.height, cv:DC.ceiling.exists ? 1 : 0,
                m:DC.materialID, addM:DC.addMaterialID, mr:DC.materialRotation, mx:DC.materialX, my:DC.materialY,
                mc:DC.ceiling.materialID, addMc:DC.ceiling.addMaterialID, mcr:DC.ceiling.materialRotation,
                mcx:DC.ceiling.materialX, mcy:DC.ceiling.materialY, title:DC.title};
    }
    else
    {
        return {id:DC.id, points:points, o:0, ch:DC.ceiling.height, cv:DC.ceiling.exists ? 1 : 0,
                m:'1', mr:0, mx:0, my:0, mc:'0', mcr:0, mcx:0, mcy:0};
    }
};

WC.convert.wallFromShort = function(wi)
{
    var DW = new WC.DataWall(null, null, parseInt(wi['id']));

    DW.materialID = wi['m'];
    DW.addMaterialID = wi['addM'];
    DW.materialRotation = TR.parseNanFloat(wi['mr']);
    DW.materialX = TR.parseNanFloat(wi['mx']);
    DW.materialY = TR.parseNanFloat(wi['my']);

    DW.topPlinth = new WC.DataPlinth(DW, true);
    DW.bottomPlinth = new WC.DataPlinth(DW, false);

    //var conf = '';
    //if (DW.configData) conf = DW.configData.toData();

    if (WC.isDef(wi['class'])) DW.name = wi['name'];

    if (WC.isDef(wi['conf']) && wi['conf'] != '')
    {
        DW.configData = new TConf.Field();
        DW.configData.fromData(wi['conf']);
    }

    if (WC.isDef(wi['pltv'])) DW.topPlinth.exists = Boolean(TR.parseNanFloat(wi['pltv']));
    if (WC.isDef(wi['pltm'])) DW.topPlinth.materialID = wi['pltm'];
    if (WC.isDef(wi['pltAddm'])) DW.topPlinth.addMaterialID = wi['pltAddm'];
    if (WC.isDef(wi['pltmr'])) DW.topPlinth.materialRotation = TR.parseNanFloat(wi['pltmr']);
    if (WC.isDef(wi['pltmx'])) DW.topPlinth.materialX = TR.parseNanFloat(wi['pltmx']);
    if (WC.isDef(wi['pltmy'])) DW.topPlinth.materialY = TR.parseNanFloat(wi['pltmy']);

    if (WC.isDef(wi['pltsh'])) DW.topPlinth.shapeNum = parseInt(wi['pltsh']);
    if (WC.isDef(wi['plth']))
    {
        var h = TR.parseNanFloat(wi['plth']);
        if (h > 0) DW.topPlinth.h = h;
    }
    if (WC.isDef(wi['pltd']))
    {
        var d = TR.parseNanFloat(wi['pltd']);
        if (d > 0) DW.topPlinth.d = d;
    }

    if (WC.isDef(wi['plbv'])) DW.bottomPlinth.exists = Boolean(TR.parseNanFloat(wi['plbv']));
    if (WC.isDef(wi['plbm'])) DW.bottomPlinth.materialID = wi['plbm'];
    if (WC.isDef(wi['plbAddm'])) DW.bottomPlinth.addMaterialID = wi['plbAddm'];
    if (WC.isDef(wi['plbmr'])) DW.bottomPlinth.materialRotation = TR.parseNanFloat(wi['plbmr']);
    if (WC.isDef(wi['plbmx'])) DW.bottomPlinth.materialX = TR.parseNanFloat(wi['plbmx']);
    if (WC.isDef(wi['plbmy'])) DW.bottomPlinth.materialY = TR.parseNanFloat(wi['plbmy']);

    if (WC.isDef(wi['plbsh'])) DW.bottomPlinth.shapeNum = parseInt(wi['plbsh']);
    if (WC.isDef(wi['plbh']))
    {
        h = TR.parseNanFloat(wi['plbh']);
        if (h > 0) DW.bottomPlinth.h = h;
    }
    if (WC.isDef(wi['plbd']))
    {
        d = TR.parseNanFloat(wi['plbd']);
        if (d > 0) DW.bottomPlinth.d = d;
    }

    return DW;
};

WC.convert.coverFromShort = function(ci)
{
    var DC = new WC.DataCover(parseInt(ci.id));

    DC.materialID = ci.m;
    DC.addMaterialID = ci.addM;
    DC.materialRotation = parseFloat(ci.mr);
    DC.materialX = parseFloat(ci.mx);
    DC.materialY = parseFloat(ci.my);
    DC.outer = ci['o'] == 1;

    if (ci.title) DC.title = ci.title;

    var dCeil = new WC.DataCeiling(parseInt(ci.id));
    dCeil.cover = DC;
    dCeil.exists = ci.cv == 1;
    dCeil.height = parseInt(ci.ch);
    dCeil.materialID = ci.mc;
    dCeil.addMaterialID = ci.addMc;
    dCeil.materialX = parseFloat(ci.mcx);
    dCeil.materialY = parseFloat(ci.mcy);
    dCeil.materialRotation = parseFloat(ci.mcr);

    DC.ceiling = dCeil;

    if (WC.isDef(ci['class'])) DC.name = ci['name'];

    return DC;
};

WC.convert.shortToStructure = function(data)
{
    var res = {};
    res.roomPoints = [];
    res.coverPoints = [];
    res.walls = [];
    res.cuts = [];
    res.areas = [];
    res.ceilings = [];

    res.covers = [];
    res.coverHoles = [];
    res.innerCoverConts = [];

    res.roomsInner = [];
    res.roomsOuter = [];
    res.outerRoomConts = [];
    res.innerRoomConts = [];

    res.cap = new WC.DataCap();
    res.cap.wallsHeight = parseInt(data.cap['wh']);
    if (! res.cap.wallsHeight) res.cap.wallsHeight = WC.core.wallsHeight; // WC.DEFAULT_WALLS_HEIGHT;
    res.cap.materialX = parseFloat(data.cap['mx']);
    res.cap.materialY = parseFloat(data.cap['my']);
    res.cap.materialRotation = parseFloat(data.cap['mr']);
    res.cap.materialID = data.cap['m'];
    res.cap.addMaterialID = data.cap['addM'];

    var dictPoints = {};
    var dictWalls = {};
    var dictCuts = {};

    function key(id)
    {
        return 'k' + String(id);
    }

    for  (var i = 0; i < data.points.length; i++)
    {
        var snappedCoord = TR.roundCoord({x: parseFloat(data.points[i].x), y: parseFloat(data.points[i].y)});
        var DP = new WC.DataPoint(snappedCoord.x, snappedCoord.y, parseInt(data.points[i].id));

        dictPoints[key(data.points[i].id)] = DP;

        if (data.points[i].type == WC.ROOM_POINT)
        {
            res.roomPoints.push(DP);
        }
        else
        {
            res.coverPoints.push(DP);
        }
    }

    for (i = 0; i < data.walls.length; i++)
    {
        var wi = data.walls[i];
        var pt1 = dictPoints[key(wi['pa'])];
        var pt2 = dictPoints[key(wi['pb'])];
        if (! pt1 || ! pt2) continue;

        var DW = WC.convert.wallFromShort(wi);
        DW.point1 = pt1;
        DW.point2 = pt2;
        DW.height = res.cap.wallsHeight;
        DW.topPlinth.height = res.cap.wallsHeight;

        res.walls.push(DW);

        dictWalls[key(wi['id'])] = DW;
    }

    for (i = 0; i < data.cuts.length; i++)
    {
        pt1 = dictPoints[key(data.cuts[i]['pa'])];
        pt2 = dictPoints[key(data.cuts[i]['pb'])];

        if (! pt1 || ! pt2) continue;
        if (key(data.cuts[i]['id']) in dictCuts) continue;

        var dcut = new WC.DataCut(pt1, pt2, parseInt(data.cuts[i]['id']));

        dcut.materialID = data.cuts[i]['m'];
        dcut.addMaterialID = data.cuts[i]['addM'];
        dcut.materialRotation = parseFloat(data.cuts[i]['mr']);
        dcut.materialX = parseFloat(data.cuts[i]['mx']);
        dcut.materialY = parseFloat(data.cuts[i]['my']);

        res.cuts.push(dcut);

        dictCuts[key(data.cuts[i]['id'])] = dcut;
    }

    for (i = 0; i < data.areas.length; i++)
    {
        var ai = data.areas[i];

        var DA = new WC.DataArea(parseInt(ai.id));

        DA.height = parseInt(ai.h);

        var breaked = false;
        for (var j = 0; j < ai.walls.length; j++)
        {

            if (key(ai.walls[j]) in dictWalls)
            {
                DW = dictWalls[key(ai.walls[j])];
                DA.walls.push(DW);
                DW.height = DA.height;
                DW.topPlinth.exists = false;
            }
            else
            {
                breaked = true;
                break;
            }
        }

        for (j = 0; j < ai.cuts.length; j++)
        {
            if (key(ai.cuts[j]) in dictCuts)
            {
                dcut = dictCuts[key(ai.cuts[j])];
                DA.cuts.push(dcut);
                dcut.height = DA.height;
            }
            else
            {
                breaked = true;
                break;
            }
        }

        if (breaked) continue;

        DA.materialID = ai.m;
        DA.addMaterialID = ai.addM;
        DA.materialRotation = parseFloat(ai.mr);
        DA.materialX = parseFloat(ai.mx);
        DA.materialY = parseFloat(ai.my);

        var pairs = [];

        for (j = 0; j < DA.walls.length; j++) pairs.push([DA.walls[j].point1, DA.walls[j].point2]);

        for (j = 0; j < DA.cuts.length; j++) pairs.push([DA.cuts[j].point1, DA.cuts[j].point2]);

        DA.points = WC.contourFromPairs(pairs);
        if (! DA.points || DA.points == [])
        {
            continue;
        }

        var dCeil = new WC.DataCeiling(parseInt(ai.id));
        dCeil.cover = DA;
        dCeil.exists = ai.cv == 1;
        dCeil.height = parseInt(ai.ch);
        dCeil.materialID = ai.mc;
        dCeil.addMaterialID = ai.addMc;
        dCeil.materialX = parseFloat(ai.mcx);
        dCeil.materialY = parseFloat(ai.mcy);
        dCeil.materialRotation = parseFloat(ai.mcr);

        DA.ceiling = dCeil;

        res.areas.push(DA);
        res.ceilings.push(dCeil);
    }

    for (i = 0; i < res.cuts.length; i++)
    {
        var cut = res.cuts[i];
        if (cut.heights.length == 2)
        {
            cut.height = Math.max(cut.heights[0], cut.heights[1]);
            cut.low = Math.min(cut.heights[0], cut.heights[1]);
        }
        else
        {
            cut.height = parseInt(res.cap.wallsHeight);
            if (cut.heights.length == 1) cut.low = cut.heights[0];
        }
    }

    // covers

    for (i = 0; i < data.covers.length; i++)
    {
        var ci = data.covers[i];
        var DC = WC.convert.coverFromShort(ci);

        if (ci.title)
        {
            if(ci.title.visible.viewConstructor){
                DC.title = ci.title;
            } else {
                DC.title = {...ci.title, areaVisible: {view3d: ci.title.visible, view2d: ci.title.visible, viewConstructor: ci.title.visible}, visible: {view3d: ci.title.visible, view2d: ci.title.visible, viewConstructor: ci.title.visible}};
            }
        }
        else
        {
            DC.title = null;
        }

        breaked = false;
        for (j = 0; j < ci.points.length; j++)
        {
            if (key(ci.points[j]) in dictPoints)
            {
                DC.points.push(dictPoints[key(ci.points[j])])
            }
            else
            {
                breaked = true;
                break;
            }
        }

        if (breaked) continue;

        if (DC.outer)
        {
            res.covers.push(DC)
        }
        else
        {
            res.coverHoles.push(DC);
            res.innerCoverConts.push(DC.points);
        }

        res.ceilings.push(dCeil);
    }

    // rooms

    for (i = 0; i < data.rooms.length; i++)
    {
        var DR = new WC.DataRoom(parseInt(data.rooms[i].id));

        breaked = false;
        for (j = 0; j < data.rooms[i].points.length; j++)
        {
            if (key(data.rooms[i].points[j]) in dictPoints)
            {
                DR.points.push(dictPoints[key(data.rooms[i].points[j])]);
            }
            else
            {
                breaked = true;
                break;
            }
        }

        for (j = 0; j < data.rooms[i].walls.length; j++)
        {
            if (key(data.rooms[i].walls[j]) in dictWalls)
            {
                DW = dictWalls[key(data.rooms[i].walls[j])];

                DR.walls.push(DW);
                DW.room = DR;
            }
            else
            {
                breaked = true;
                break;
            }
        }

        if (breaked) continue;

        if (data.rooms[i].outer == 1)
        {
            res.roomsOuter.push(DR);
            DR.outer = true;
        }
        else
        {
            res.roomsInner.push(DR);
            DR.outer = false;
        }
    }

    var allRooms = res.roomsInner.concat(res.roomsOuter);

    for (i = 0; i < allRooms.length; i++)
    {
        DR = allRooms[i];

        var roomOuter = DR.outer;
        var roomCW = TR.contourArea(DR.points) > 0;

        for (j = 0; j < DR.walls.length; j++)
        {
            DW = DR.walls[j];

            var ptind1 = DR.points.indexOf(DW.point1);
            var ptind2 = DR.points.indexOf(DW.point2);

            var L = DR.points.length - 1;

            var parallel;
            if (ptind2 == 0 && ptind1 == L)
            {
                parallel = true;
            }
            else if(ptind2 == L && ptind1 == 0)
            {
                parallel = false;
            }
            else
            {
                parallel = ptind2 > ptind1
            }

            DW.faceRight = roomOuter ^ roomCW ^ parallel;
            DW.outer = roomOuter
        }
    }

    if (res.roomsOuter.length == 0 && res.roomsInner.length > 0) // for very old plans
    {
        var maxArea = 0;
        var maxContInd = 0;

        for (i = 0; i < res.roomsInner.length; i++)
        {
            var area = Math.abs(TR.contourArea(res.roomsInner[i].points));
            if (area > maxArea)
            {
                maxArea = area;
                maxContInd = i;
            }
        }

        res.roomsOuter.push(res.roomsInner[maxContInd]);
        res.roomsInner = res.roomsInner.slice(0, maxContInd).concat(res.roomsInner.slice(maxContInd + 1));
    }

    for (i = 0; i < res.roomsOuter.length; i++)
    {
        res.outerRoomConts.push(res.roomsOuter[i].points);
    }

    for (i = 0; i < res.roomsInner.length; i++)
    {
        res.innerRoomConts.push(res.roomsInner[i].points);
    }

    return res;
};

WC.convert.structureToEstimate = function(obj)
{
    function wallMaterialsToDict(room, matDict) {
        for (var i = 0; i < room.walls.length; i++)
        {
            var w = room.walls[i];
            for (var j = 0; j < w.parts.length; j++)
            {
                if (w.parts[j].materialID in matDict)
                {
                    if(!w.parts[j].addMaterialID && matDict[w.parts[j].materialID].addMaterialID == undefined) {
                        matDict[w.parts[j].materialID] += w.parts[j].area / 10000;
                    }
                    else {
                        if(w.parts[j].addMaterialID == matDict[w.parts[j].materialID].addMaterialID) {
                            matDict[w.parts[j].materialID].area += w.parts[j].area / 10000;
                        }
                        else {
                            matDict[w.parts[j].materialID] = w.parts[j].addMaterialID ? { addMaterialID: w.parts[j].addMaterialID, area: w.parts[j].area / 10000 } : w.parts[j].area / 10000;
                        }
                    }
                    
                }
                else matDict[w.parts[j].materialID] = w.parts[j].addMaterialID ? { addMaterialID: w.parts[j].addMaterialID, area: w.parts[j].area / 10000 } : w.parts[j].area / 10000;
            };

            let plinth = w.bottomPlinth;
            let areaPlinth = plinth.h * plinth.length / 10000;
            let plinthType = plinth.type;
            let plinthShapeNum = plinth.shapeNum;

            plinthsDict.push({ materialID: plinth.materialID, addMaterialID: plinth.addMaterialID, area: areaPlinth, type: plinthType, shapeNum: plinthShapeNum })

            let molding = w.topPlinth;
            let areaMolding = molding.h * molding.length / 10000;
            let moldingType = molding.type;
            let moldingShapeNum = molding.shapeNum;

            plinthsDict.push({ materialID: molding.materialID, addMaterialID: molding.addMaterialID, area: areaMolding, type: moldingType, shapeNum: moldingShapeNum })

        }

        for (i = 0; i < room.axes.length; i++)
        {
            for (j = 0; j < room.axes[i].frames.length; j++)
            {
                var fr = room.axes[i].frames[j];
                if (fr.materialID in matDict)
                {
                    if(!fr.addMaterialID && matDict[fr.materialID].addMaterialID == undefined) {
                        matDict[fr.materialID] += fr.area / 10000;
                    }
                    else {
                        if(fr.addMaterialID == matDict[fr.materialID].addMaterialID) {
                            matDict[fr.materialID].area += fr.area / 10000;
                        }
                        else {
                            matDict[fr.materialID] = fr.addMaterialID ? { addMaterialID: fr.addMaterialID, area: fr.area / 10000 } : fr.area / 10000;
                        }
                    }
                }
                else
                {
                    matDict[fr.materialID] = fr.addMaterialID ? { addMaterialID: fr.addMaterialID, area: fr.area / 10000 } : fr.area / 10000;
                }
            }
        }
    }

    WC.attachRoomContent(obj);

    var res = {rooms:[], wallsHeight: obj.cap.wallsHeight / 100};

    var matWallDict = {};
    var matFloorDict = {};
    var matCeilDict = {};
    var plinthsDict = [];

    for (var i = 0; i < obj.roomsInner.length; i++)
    {
        var room = obj.roomsInner[i];
        
        var ri = {};
        var names = [];
        res.rooms.push(ri);
        //ri.name = '1'; //room.title.text; todo!!!
        ri.area = Math.abs(TR.contourArea(room.points)) / 10000;
        ri.perimeter = TR.contourPerim(room.points) / 100;

        wallMaterialsToDict(room, matWallDict);

        for (var j = 0; j < room.covers.length; j++)
        {
            var cover = room.covers[j];

            if (cover.materialID in matFloorDict)
            {
                if(!cover.addMaterialID && matFloorDict[cover.materialID].addMaterialID == undefined) matFloorDict[cover.materialID] += cover.area / 10000;
                else {
                    if(cover.addMaterialID == matFloorDict[cover.materialID].addMaterialID) matFloorDict[cover.materialID].area += cover.area / 10000;
                    else matFloorDict[cover.materialID] = cover.addMaterialID ? { addMaterialID: cover.addMaterialID, area: cover.area / 10000 } : cover.area / 10000;
                }
            }

            else matFloorDict[cover.materialID] = cover.addMaterialID ? { addMaterialID: cover.addMaterialID, area: cover.area / 10000 } : cover.area / 10000;


            
            if (cover.ceiling.exists)
            {
                if (cover.ceiling.materialID in matCeilDict) {
                    if(!cover.ceiling.addMaterialID && matCeilDict[cover.ceiling.materialID].addMaterialID == undefined) matCeilDict[cover.ceiling.materialID] += cover.area / 10000;
                    else {
                        if(cover.ceiling.addMaterialID == matCeilDict[cover.ceiling.materialID].addMaterialID) matCeilDict[cover.ceiling.materialID].area += cover.area / 10000;
                        else matCeilDict[cover.ceiling.materialID] = cover.ceiling.addMaterialID ? { addMaterialID: cover.ceiling.addMaterialID, area: cover.area / 10000 } : cover.area / 10000;
                    }
                }
                else matCeilDict[cover.ceiling.materialID] = cover.ceiling.addMaterialID ? { addMaterialID: cover.ceiling.addMaterialID, area: cover.area / 10000 } : cover.area / 10000;
            }

            if (cover.title) names.push(cover.title?.text);
        }

        ri.name = names.join(', ');

        for (j = 0; j < room.rooms.length; j++)
        {
            var oRoom = room.rooms[j];

            wallMaterialsToDict(oRoom, matWallDict);
            ri.perimeter += TR.contourPerim(oRoom.points) / 100;
        }

        ri.wallsArea = 0;
        for (var key in matWallDict) ri.wallsArea += matWallDict[key].area ? matWallDict[key].area : matWallDict[key];

        ri.width = Math.sqrt(ri.area / 1.42);
        ri.length = ri.area / ri.width;
    }

    res.materialsWall = matWallDict;
    res.materialsFloor = matFloorDict;
    res.materialsCeiling = matCeilDict;
    res.plinths = plinthsDict;

    return res;
};

WC.convert.copyWallData = function(source, target)
{
    target.materialID = source.materialID;
    target.addMaterialID = source.addMaterialID;
    target.materialRotation = source.materialRotation;
    target.materialX = source.materialX;
    target.materialY = source.materialY;

    if (source.configData)
    {
        target.configData = source.configData.getData();
    }
    else
    {
        target.configData = null;
    }

    WC.convert.copyPlinthData(source.topPlinth, target.topPlinth);
    WC.convert.copyPlinthData(source.bottomPlinth, target.bottomPlinth);
};

WC.convert.copyPlinthData = function(source, target)
{
    target.setMaterial(source.materialID);
    target.setAddMaterial(source.addMaterialID);
    target.setMaterialRotation(source.materialRotation);
    target.exists = source.exists;
    target.d = source.d;
    target.h = source.h;
    target.shapeNum = source.shapeNum;
};

WC.convert.copyCoverData = function(source, target)
{
    target.setMaterial(source.materialID);
    target.setAddMaterial(source.addMaterialID);
    target.setMaterialRotation(source.materialRotation);

    target.ceiling.setMaterial(source.ceiling.materialID);
    target.ceiling.setAddMaterial(source.ceiling.addMaterialID);
    target.ceiling.setMaterialRotation(source.ceiling.materialRotation);
};
WC.MAX_WALL_WIDTH = 80;
WC.MIN_WALL_LENGTH = 15;

WC.createConnectors = function(axes, walls, cuts)
{
    var maxConnectorLength = 40;

    var connectPairs = [];
    var pairsAxes = [];
    var heights = [];

    for (var i = 0; i < axes.length; i++)
    {
        var axis = axes[i];
        var P11 = axis.wall1.point1;
        var P12 = axis.wall1.point2;
        var P21 = axis.wall2.point1;
        var P22 = axis.wall2.point2;

        if (TR.euclDistP(P11, P21) + TR.euclDistP(P12, P22) > TR.euclDistP(P11, P22) + TR.euclDistP(P12, P21))
        {
            var tmpPt = P21;
            P21 = P22;
            P22 = tmpPt;
        }

        for (var k = 0; k < 2; k ++)
        {
            var pair = [[P11, P21], [P12, P22]][k];
            if (TR.euclDistP(pair[0], pair[1]) > maxConnectorLength) continue;

            var breaked = false;
            for (var j = 0; j < walls.length; j++)
            {
                if ((pair[0].match(walls[j].point1) && pair[1].match(walls[j].point2)) ||
                    (pair[0].match(walls[j].point2) && pair[1].match(walls[j].point1)))
                {
                    breaked = true;
                    break;
                }

                if (TR.pointOnLine(walls[j].point1, pair[0], pair[1]) &&
                    ! (walls[j].point1.match(pair[0]) || walls[j].point1.match(pair[1])))
                {
                    breaked = true;
                    break;
                }

                if (TR.pointOnLine(walls[j].point2, pair[0], pair[1], true, true) &&
                    ! (walls[j].point2.match(pair[0]) || walls[j].point2.match(pair[1])))
                {
                    breaked = true;
                    break;
                }

                var P = TR.lineIntersectLine(pair[0], pair[1], walls[j].point1, walls[j].point2, true, false);
                if (P && ! P.match(walls[j].point1) && ! P.match(walls[j].point2))
                {
                    breaked = true;
                    break;
                }

            }

            for (j = 0; j < cuts.length; j++)
            {
                if ((pair[0].match(cuts[j].point1) && pair[1].match(cuts[j].point2)) ||
                    (pair[0].match(cuts[j].point2) && pair[1].match(cuts[j].point1)))
                {
                    if (cuts[j].height == axes[i].wall1.height)
                    {
                        breaked = true;
                        break;
                    }
                }
            }

            if (breaked) continue;

            connectPairs.push(pair);
            pairsAxes.push(axis);
            heights.push(axis.wall1.height);
        }
    }

    
/*
    for (i = 0; i < connectPairs.length; i++)
    {
        for (var j = 0; j < walls.length; j++)
        {
            var DW = walls[j];
            if (connectPairs[i][0].equals(DW.point1) || connectPairs[i][0].equals(DW.point2) ||
                connectPairs[i][1].equals(DW.point1) || connectPairs[i][1].equals(DW.point2))
            {
                if (DW.height < heights[i]) heights[i] = DW.height;
            }

        }
    }
*/

    var plugs = [];
    for (i = 0; i < connectPairs.length; i++)
    {
        plugs.push(new WC.DataPlug(connectPairs[i][0], connectPairs[i][1], pairsAxes[i], heights[i]));
    }

    for (i = 0; i < plugs.length; i++)
    {
        WC.createPlug3D(plugs[i]);
    }
    
    return plugs;
};

WC.createPlug3D = function(plug)
{
    var v1 = new THREE.Vector3(plug.point1.x, 0, - plug.point1.y);
    var v2 = new THREE.Vector3(plug.point2.x, 0, - plug.point2.y);
    var v3 = new THREE.Vector3(plug.point2.x, plug.height, - plug.point2.y);
    var v4 = new THREE.Vector3(plug.point1.x, plug.height, - plug.point1.y);

    var A = new WC.DataPoint(0, 0);
    var B = new WC.DataPoint(TR.euclDistP(plug.point1, plug.point2), 0);
    var C = new WC.DataPoint(TR.euclDistP(plug.point1, plug.point2), plug.height);
    var D = new WC.DataPoint(0, plug.height);

    var tr1 = WC.findTriWall(A, B, C, v1, v2, plug.height, false);
    var tr2 = WC.findTriWall(A, C, D, v1, v2, plug.height, false);

    plug.vertices = tr1[0].concat(tr2[0]);
    plug.uvs = tr1[1].concat(tr2[1]);
    plug.indices = WC.generateIndices(plug.vertices.length / 3);

    plug.addNullData();
};

WC.createWall3D = function(wall, defHeight)
{
    if (isNaN(wall.height)) wall.height = defHeight;

    wall.build3D();
};

WC.createPlinth3D = function(plinth)
{
    plinth.build3D();
};

WC.createCover3D = function(cover, innerContours)
{
    var trs = [];
    var holes = [];

    for (var i = 0; i < innerContours.length; i++)
    {
        if (TR.compareContours(cover.points, innerContours[i]) == TR.CONTAIN)
        {
            holes.push(innerContours[i]);
        }
    }

    var ceiling = cover.ceiling;

    if (cover.outer)
    {
        trs = TR.triangulateContours([cover.points], holes, [], [], []);
        cover.contours = [WC.findContourCover(cover.points, 0, false)];
        ceiling.contours = [WC.findContourCover(cover.points, ceiling.height, true)];
    }
    else
    {
        trs = TR.triangulateContours([cover.points], [], [], [], []);
        cover.contours = [];
        ceiling.contours = [];
    }

    cover.triangles = new Array(trs[0].length);
    ceiling.triangles = new Array(trs[0].length);
    for (i = 0; i < trs[0].length; i++)
    {
        var i0 = trs[0][i].pointIndices[0];
        var i1 = trs[0][i].pointIndices[1];
        var i2 = trs[0][i].pointIndices[2];

        var a = new TR.Point(TR.points[i0][0], TR.points[i0][1]);
        var b = new TR.Point(TR.points[i1][0], TR.points[i1][1]);
        var c = new TR.Point(TR.points[i2][0], TR.points[i2][1]);

        cover.triangles[i] = [a, b, c];
        ceiling.triangles[i] = [a, b, c];
    }

    cover.build3D();
    ceiling.build3D();
    cover.addNullData();
    ceiling.addNullData();
};

WC.createCut3D = function(cut)
{
    var v1 = new THREE.Vector3(cut.point1.x, 0, - cut.point1.y);
    var v2 = new THREE.Vector3(cut.point2.x, 0, - cut.point2.y);
    var v3 = new THREE.Vector3(cut.point2.x, cut.height, - cut.point2.y);
    var v4 = new THREE.Vector3(cut.point1.x, cut.height, - cut.point1.y);

    var A = new WC.DataPoint(0, 0);
    var B = new WC.DataPoint(TR.euclDistP(cut.point1, cut.point2), 0);
    var C = new WC.DataPoint(TR.euclDistP(cut.point1, cut.point2), cut.height);
    var D = new WC.DataPoint(0, cut.height);
    cut.rotatingCenter = new TR.Point((A.x + B.x) / 2, (B.y + C.y) / 2);

    cut.triangles = [[A, B, C], [A, C, D]];
    cut.v1 = v1;
    cut.v2 = v2;

    cut.build3D();

    cut.contours = [[{x: v1.x, y: v1.y, z: v1.z},
                     {x: v2.x, y: v2.y, z: v2.z},
                     {x: v3.x, y: v3.y, z: v3.z},
                     {x: v4.x, y: v4.y, z: v4.z}]];

    cut.addNullData();
};

WC.createFrame3D = function(inpContour, point1, point2, depth, model)
{
    var bottomHeight = 2;
    var pixPerMeter = 100;
    var vertTop = [];
    var uvsTop = [];
    var indTop = [];
    var vertBottom = [];
    var uvsBottom = [];
    var indBottom = [];

    var maxY = -Number.MAX_VALUE;
    var maxX = -Number.MAX_VALUE;
    var iCorner;
    for (var i = 0; i < inpContour.length; i++)
    {
        if (inpContour[i].y > maxY) maxY = inpContour[i].y;
        if (inpContour[i].y > maxY || inpContour[i].x > maxX)
        {
            maxX = inpContour[i].x;
            iCorner = i;
        }
    }

    var contour = inpContour.slice(iCorner).concat(inpContour.slice(0, iCorner));

    var coordV = 0;
    var len = TR.euclDist(point1.x, point1.y, point2.x, point2.y);
    var ang = WC.azimuth(point1.x, -point1.y, point2.x, -point2.y);
    var center = {x:point1.x, y:0, z:-point1.y};

    contour.push(contour[0]);

    var cont3dtop1 = [];
    var cont3dtop2 = [];
    var cont3dbot1 = [];
    var cont3dbot2 = [];
    var areaTop = 0;
    var areaBot = 0;

    for (i = 0; i < contour.length - 1; i++)
    {
        var P1 = contour[i];
        var P2 = contour[i + 1];

        var dV = Math.sqrt(Math.pow((P1.x - P2.x), 2) + Math.pow((P1.y - P2.y), 2));

        var V1 = {};
        V1.x = center.x + P1.x * Math.cos(ang) - depth / 2 * Math.sin(-ang);
        V1.y = -P1.y;
        V1.z = center.z + P1.x * Math.sin(ang) - depth / 2 * Math.cos(-ang);

        var V2 = {};
        V2.x = center.x + P2.x * Math.cos(ang) - depth / 2 * Math.sin(-ang);
        V2.y = -P2.y;
        V2.z = center.z + P2.x * Math.sin(ang) - depth / 2 * Math.cos(-ang);

        var V3 = {};
        V3.x = center.x + P2.x * Math.cos(ang) + depth / 2 * Math.sin(-ang);
        V3.y = -P2.y;
        V3.z = center.z + P2.x * Math.sin(ang) + depth / 2 * Math.cos(-ang);

        var V4 = {};
        V4.x = center.x + P1.x * Math.cos(ang) + depth / 2 * Math.sin(-ang);
        V4.y = -P1.y;
        V4.z = center.z + P1.x * Math.sin(ang) + depth / 2 * Math.cos(-ang);

        var uv1 = new TR.Point(0, coordV / pixPerMeter);
        var uv2 = new TR.Point(0, (coordV + dV) / pixPerMeter);
        var uv3 = new TR.Point(depth / pixPerMeter, (coordV + dV) / pixPerMeter);
        var uv4 = new TR.Point(depth / pixPerMeter, coordV / pixPerMeter);

        var d1 = Math.sqrt(Math.pow(V2.x - V1.x, 2) + Math.pow(V2.y - V1.y, 2) + Math.pow(V2.z - V1.z, 2));
        var d2 = Math.sqrt(Math.pow(V4.x - V1.x, 2) + Math.pow(V4.y - V1.y, 2) + Math.pow(V4.z - V1.z, 2));

        if (P1.y > maxY - bottomHeight && P2.y > maxY - bottomHeight)
        {
            vertBottom.push(V3.x, V3.y, V3.z, V2.x, V2.y, V2.z, V1.x, V1.y, V1.z,
                            V1.x, V1.y, V1.z, V4.x, V4.y, V4.z, V3.x, V3.y, V3.z);

            uvsBottom.push(uv3.x, uv3.y, uv2.x, uv2.y, uv1.x, uv1.y,
                           uv1.x, uv1.y, uv4.x, uv4.y, uv3.x, uv3.y);

            indBottom = WC.generateIndices(vertBottom.length / 3);

            cont3dbot1.push(V1, V2);
            cont3dbot2.push(V4, V3);
            areaBot += d1 * d2;
        }
        else
        {
            vertTop.push(V3.x, V3.y, V3.z, V2.x, V2.y, V2.z, V1.x, V1.y, V1.z,
                         V1.x, V1.y, V1.z, V4.x, V4.y, V4.z, V3.x, V3.y, V3.z);

            uvsTop.push(uv3.x, uv3.y, uv2.x, uv2.y, uv1.x, uv1.y,
                        uv1.x, uv1.y, uv4.x, uv4.y, uv3.x, uv3.y);

            indTop = WC.generateIndices(vertTop.length / 3);

            cont3dtop1.push(V1, V2);
            cont3dtop2.push(V4, V3);
            areaTop += d1 * d2;
        }

        coordV += dV;
    }

    var frameB = new WC.DataFrame(false, {materialID: model.materialBottom, addMaterialID: model.addMaterialBottom, materialRotation: model.materialBottomRotation,
                                          materialX: model.materialBottomX, materialY: model.materialBottomY});
    frameB.vertices = vertBottom;
    frameB.uvs = uvsBottom;
    frameB.uvsDef = [].concat(uvsBottom);
    frameB.indices = indBottom;
    frameB.contours = [cont3dbot1, cont3dbot2];
    frameB.area = areaBot;

    var frameT = new WC.DataFrame(true, {materialID: model.materialFrame, addMaterialID: model.addMaterialFrame, materialRotation: model.materialFrameRotation,
                                         materialX: model.materialFrameX, materialY: model.materialFrameY});
    frameT.vertices = vertTop;
    frameT.uvs = uvsTop;
    frameT.uvsDef = [].concat(uvsTop);
    frameT.indices = indTop;
    frameT.contours = [cont3dtop1, cont3dtop2];
    frameT.area = areaTop;

    frameT.addNullData();
    frameB.addNullData();

    frameT.build3D();
    frameB.build3D();

    var pointC = point1.clone();
    var pointX = point2.clone();
    var pointY = TR.perpendicularPoint(point1, point2, 1);

    frameB.dirX = new TR.Point(pointX.x - pointC.x, pointX.y - pointC.y);
    frameB.dirY = new TR.Point(pointY.x - pointC.x, pointY.y - pointC.y);

    var lenX = TR.euclDist(0, 0, frameB.dirX.x, frameB.dirX.y);
    frameB.dirX.x /= lenX;
    frameB.dirX.y /= lenX;

    var lenY = TR.euclDist(0, 0, frameB.dirY.x, frameB.dirY.y);
    frameB.dirY.x /= lenY;
    frameB.dirY.y /= lenY;

    return [frameT, frameB];
};

WC.findContourWall = function(cont2d, v1, v2, reverse)
{
    reverse = typeof reverse !== 'undefined' ? reverse : false;

    var angle = Math.PI / 2 - WC.azimuth(v1.x, v1.z, v2.x, v2.z);
    var pivotPoint = v1;

    if (reverse) cont2d.reverse();

    var vertices = [];

    for (var i = 0; i < cont2d.length; i++)
    {
        var p = cont2d[i];

        var X = pivotPoint.x + (p.x * Math.sin(angle));
        var Y = p.y;
        var Z = pivotPoint.z + (p.x * Math.cos(angle));
        vertices.push({x: X, y: Y, z: Z});
    }

    return vertices
};

WC.findContourCover = function(cont2d, elevation, reverse)
{
    reverse = typeof reverse !== 'undefined' ? reverse : false;

    if (reverse) cont2d.reverse();

    var vertices = [];

    for (var i = 0; i < cont2d.length; i++)
    {
        var X = cont2d[i].x;
        var Y = elevation;
        var Z = -cont2d[i].y;
        vertices.push({x: X, y: Y, z: Z});
    }

    return vertices
};

WC.azimuth = function(Ax, Ay, Bx, By)
{
    var dx = Bx - Ax;
    var dy = By - Ay;

    var a = Math.atan2(dy, dx);
    if (a < 0) a += Math.PI * 2;

    return a;
};

var sortByAngle = function(a, b)
{
    if (a.az < b.az)
    {
        return -1;
    }
    else if (a.az > b.az)
    {
        return  1;
    }
    return 0;
};

WC.boxFromWalls = function(dataWall1, dataWall2)
{
    if (! dataWall1 || ! dataWall2) return null;

    if (! TR.parallelLines(dataWall1.point1, dataWall1.point2, dataWall2.point1, dataWall2.point2)) return null;

    if (! WC.rightOriented(dataWall1, dataWall2)) return null;

    return parallelBox(dataWall1.point1, dataWall1.point2, dataWall2.point1, dataWall2.point2);
};

var parallelBox = function(A, B, C, D, maxAngle)
{
    maxAngle = typeof maxAngle !== 'undefined' ? maxAngle : 0.05;

    if (! TR.parallelLines(A, B, C, D, maxAngle)) return null;

    var projC = TR.projectionPointOnLine(C, A, B, false);
    var projD = TR.projectionPointOnLine(D, A, B, false);
    var insC = TR.projectionPointOnLine(C, A, B, true);
    var insD = TR.projectionPointOnLine(D, A, B, true);

    var E, F, G, H;

    var ac = TR.euclDist(A.x, A.y, C.x, C.y);
    var bc = TR.euclDist(B.x, B.y, C.x, C.y);
    var ad = TR.euclDist(A.x, A.y, D.x, D.y);
    var bd = TR.euclDist(B.x, B.y, D.x, D.y);

    if (insC && insD)
    {
        if (ac < ad)
        {
            E = projC.clone();
            F = projD.clone();
        }
        else
        {
            E = projD.clone();
            F = projC.clone();
        }
    }
    else if (! insC && ! insD)
    {
        if (((ac < bc) && (ad > bd)) || ((ac > bc) && (ad < bd)))
        {
            E = A.clone();
            F = B.clone();
        }
        else
        {
            return null;
        }
    }
    else if (insC && ! insD)
    {
        if (ad > bd)
        {
            E = projC.clone();
            F = B.clone();
        }
        else
        {
            E = A.clone();
            F = projC.clone();
        }
    }
    else if (! insC && insD)
    {
        if (ac > bc)
        {
            E = projD.clone();
            F = B.clone();
        }
        else
        {
            E = A.clone();
            F = projD.clone();
        }
    }

    if (! E || ! F || (TR.manhDist(E.x, E.y, F.x, F.y) < TR.L_EPS))	return null;

    G = TR.projectionPointOnLine(F, C, D, false);
    H = TR.projectionPointOnLine(E, C, D, false);

    return [E, F, G, H];
};

WC.boxCenterSeg = function(A, B, C, D)
{
    if (TR.euclDist(B.x, B.y, C.x, C.y) > WC.MAX_WALL_WIDTH) return null;
    if (TR.euclDist(A.x, A.y, B.x, B.y) < WC.MIN_WALL_LENGTH) return null;

    var P1 = new TR.Point((D.x + A.x) / 2, (D.y + A.y) / 2);
    var P2 = new TR.Point((B.x + C.x) / 2, (B.y + C.y) / 2);

    return [P1, P2];
};

WC.rightOriented = function(DW1, DW2)
{
    var ang = TR.angleBetweenLines(DW1.point1.x, DW1.point1.y, DW1.point2.x, DW1.point2.y,
                                   DW2.point1.x, DW2.point1.y, DW2.point2.x, DW2.point2.y);

    var parallel = ((ang < Math.PI / 2) || (ang > Math.PI * 3 / 2));

    var LR = (DW2.point1.x - DW1.point1.x) * (DW1.point2.y - DW1.point1.y) - (DW2.point1.y - DW1.point1.y) * (DW1.point2.x - DW1.point1.x) < 0;

    var res = false;

    if ( parallel &&  LR && !DW1.faceRight &&  DW2.faceRight) res = true;

    if ( parallel && !LR &&  DW1.faceRight && !DW2.faceRight) res = true;

    if (!parallel &&  LR && !DW1.faceRight && !DW2.faceRight) res = true;

    if (!parallel && !LR &&  DW1.faceRight &&  DW2.faceRight) res = true;

    return res;
};

WC.compareAndRebuildContours = function(inputContours, filter)
{
    var contours = [].concat(inputContours);
    var contourGroups = [];

    while (contours.length > 0)
    {
        var lastGroup = [contours.shift()];
        contourGroups.push(lastGroup);

        for (var i = 0; i < lastGroup.length; i++)
        {
            var L = contours.length;
            for (var j = 0; j < L; j++)
            {
                var cont = contours[j];
                var comp = TR.compareContours(lastGroup[i], cont);

                if (comp != TR.OUTSIDE)
                {
                    lastGroup.push(cont);
                    contours.splice(j, 1);
                    j--;
                    L--;
                }
            }
        }
    }

    var corresp = new Array(contourGroups);
    for (i = 0; i < contourGroups.length; i++)
    {
        corresp[i] = [];
        for (j = 0; j < contourGroups[i].length; j++)
        {
            corresp[i].push(inputContours.indexOf(contourGroups[i][j]));
        }
    }

    var resContours = [];

    for (i = 0; i < contourGroups.length; i++)
    {
        var remade = TR.rebuildContours(contourGroups[i], [], [], [], [], false, filter);

        remade = remade[0][0];

        remade = TR.indicesToPoints(remade);
        resContours.push(remade);
    }

    return [resContours, corresp];
};

//constructor

WC.ELEMENT_CREATE = 'elementCreate';
WC.ELEMENT_DELETE = 'elementDelete';
WC.ELEMENT_UPDATE = 'elementUpdate';
WC.ELEMENT_SHOW_HIDE = 'elementShowHide';
WC.RESET_MODELS = 'resetModels';
WC.ELEMENT_VISIBLE = 'elementVisible';
WC.MODELS_VISIBLE = 'modelsVisible';
WC.REMOVE_ALL = 'removeAll';
WC.ASK_ELEMENT_NAME = 'askElementName';

WC.WallsData = function()
{
    EventDispatcher.call(this);

    var me = this;

    me.roomPoints = [];
    me.coverPoints = [];
    me.walls = [];
    me.areas = [];
    me.cuts = [];
    me.covers = [];
    me.ceilings = [];
    me.plugs = [];
    me.plinths = [];
    me.coverHoles = [];
    me.innerCoverConts = [];
    me.outerRoomConts = [];
    me.innerRoomConts = [];
    me.axes = [];
    me.roomsInner = [];
    me.roomsOuter = [];
    me.cap = new WC.DataCap();
    me.dictModelAxis = {};
    me.newModelsData = [];
    me.frames = [];
    me.customRulers = [];

    me.isChanged = function()
    {
        return WC.wallsEditor.changed;
    };

    me.setData = function(data)
    {
        
        if (! WC.wallsEditor) WC.wallsEditor = new WC.SubEditor(me);

        WC.wallsEditor.delImageDrawing();
        
        var struct = WC.convert.shortToStructure(data);

        me.setStructure(struct);
        
        R2D.view3d.coversTitleViewer3D.enable();

    //    for (var i = 0; i < me.roomsInner.length; i++)
    //    {
    //        if (! me.roomsInner[i].title.text) me.roomsInner[i].title.text = String(i + 1);
    //    }
    };

    me.setAllElementsChanged = function()
    {
        for (var i = 0; i < me.walls.length; i++) me.walls[i].changed = true;
        for (i = 0; i < me.frames.length; i++) me.frames[i].changed = true;
    };

    me.setAllElementsUnchanged = function()
    {
        for (var i = 0; i < me.walls.length; i++) me.walls[i].changed = false;
        //for (i = 0; i < me.frames.length; i++) me.frames[i].changed = false;
    };

    me.delImageDrawing = function()
    {
        if (! WC.wallsEditor) WC.wallsEditor = new WC.SubEditor(me);

        WC.wallsEditor.delImageDrawing();
    };
    
    me.getData = function()
    {
        return WC.convert.structureToShort(me);
    };

    me.getDataForApp = function()
    {
        return WC.convert.structureToApp(me);
    };

    me.getEstimate = function()
    {
        return WC.convert.structureToEstimate(me);
    };

    me.setStructure = function(struct)
    {

        me.removeAll();

        for (var k in struct)
        {
            me[k] = struct[k];
        }

        findAxes();

        createPlinths();

        build3D();

        findRoomsForCovers();
    };

    me.removeAll = function()
    {
        for (var i = 0; i < me.walls.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.walls[i]));
        for (i = 0; i < me.cuts.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.cuts[i]));
        for (i = 0; i < me.covers.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.covers[i]));
        for (i = 0; i < me.ceilings.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.ceilings[i]));
        for (i = 0; i < me.areas.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.areas[i]));
        for (i = 0; i < me.plugs.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.plugs[i]));
        for (i = 0; i < me.plinths.length; i++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.plinths[i]));

        for (i = 0; i < me.axes.length; i++)
        {
            for (var j = 0; j < me.axes[i].frames.length; j++) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.axes[i].frames[j]));
            me.axes[i].frames = [];
        }

        if (me.cap && me.cap.vertices && me.cap.vertices.length > 0) me.dispatchEvent(new Event(WC.ELEMENT_DELETE, me.cap));

        me.roomPoints = [];
        me.coverPoints = [];
        me.walls = [];
        me.areas = [];
        me.cuts = [];
        me.covers = [];
        me.ceilings = [];
        me.plugs = [];
        me.plinths = [];
        me.coverHoles = [];
        me.innerCoverConts = [];
        me.outerRoomConts = [];
        me.innerRoomConts = [];
        me.axes = [];
        me.roomsInner = [];
        me.roomsOuter = [];
        me.cap = new WC.DataCap();
        me.dictModelAxis = {};
        //me.newModelsData = [];
        me.customRulers = [];

        //me.dispatchEvent(new Event(WC.REMOVE_ALL));
    };

    me.isEmpty = function()
    {
        return me.roomPoints.length == 0 && me.coverPoints.length == 0;
    };

	me.moveElement = function(dataObj, snapDist)
	{
		snapDist = typeof snapDist !== 'undefined' ? snapDist : 10;

		var center = new WC.DataPoint(parseFloat(dataObj.x), parseFloat(dataObj.y));
		var axis = getAxis(center, snapDist);

		if (! axis) return null;

		var proj = TR.projectionPointOnLine(center, axis.point1, axis.point2);
		var ang = -Math.atan2(axis.point2.y - axis.point1.y, axis.point2.x - axis.point1.x);

		return {x: proj.x,
				y: proj.y,
				rotation: Math.PI + ang,
				depth: axis.depth};
	};

    me.dropElement = function(dataObj, snapDist)
    {
        snapDist = typeof snapDist !== 'undefined' ? snapDist : 10;

        var center = new WC.DataPoint(parseFloat(dataObj.x), parseFloat(dataObj.y));
        var axis = getAxis(center, snapDist);

        if (! axis) return null;

        var proj = TR.projectionPointOnLine(center, axis.point1, axis.point2);

        var modelData = {};
        modelData.x = proj.x;
        modelData.y = proj.y;
        modelData.rotation = axis.angle;
        modelData.scaleX = parseFloat(dataObj.scaleX);
        modelData.scaleY = parseFloat(dataObj.scaleY);

        modelData.flipX = dataObj.flipX;
        modelData.flipY = dataObj.flipY;

        // modelData.contour = GEOM.P.contourFromString(dataObj.contour);
        modelData.contour = GEOM.P.scalePoints(-1, 1, GEOM.P.contourFromString(dataObj.contour));
        modelData.elevation = parseFloat(dataObj.elevation);
        modelData.id = dataObj.id;
        modelData.depth = axis.depth;

        modelData.materialBottom = dataObj.materialBottom;
        modelData.addMaterialBottom = dataObj.addMaterialBottom;
        modelData.materialBottomRotation = parseFloat(dataObj.materialBottomRotation);
        modelData.materialBottomX = parseFloat(dataObj.materialBottomX);
        modelData.materialBottomY = parseFloat(dataObj.materialBottomY);
        modelData.materialFrame = dataObj.materialFrame;
        modelData.addMaterialFrame = dataObj.addMaterialFrame;
        modelData.materialFrameRotation = parseFloat(dataObj.materialFrameRotation);
        modelData.materialFrameX = parseFloat(dataObj.materialFrameX);
        modelData.materialFrameY = parseFloat(dataObj.materialFrameY);
        modelData.axisPos = TR.euclDist(axis.point1.x, axis.point1.y, modelData.x, modelData.y);

        me.dictModelAxis[modelData.id] = axis;
        axis.models.push(modelData);
        axis.modelIDs.push(modelData.id);

        var pos = TR.euclDist(axis.point1.x, axis.point1.y, modelData.x, modelData.y) /
                  TR.euclDist(axis.point1.x, axis.point1.y, axis.point2.x, axis.point2.y);
        axis.positions.push(pos);

        createFramesForAxis(axis);

        WC.createWall3D(axis.wall1, me.cap.wallsHeight);
        WC.createWall3D(axis.wall2, me.cap.wallsHeight);
        axis.wall1.changed = true;
        axis.wall1.changed = true;
        axis.wall1.dispatchUpdate();
        axis.wall2.dispatchUpdate();

        axis.wall1.findPlinthGaps();
        axis.wall2.findPlinthGaps();
        WC.createPlinth3D(axis.wall1.bottomPlinth);
        WC.createPlinth3D(axis.wall2.bottomPlinth);
        axis.wall1.bottomPlinth.dispatchUpdate();
        axis.wall2.bottomPlinth.dispatchUpdate();

        return {x: modelData.x,
                y: modelData.y,
                rotation: modelData.rotation,
                depth: axis.depth};
    };

    me.pickElement = function(id)
    {
        var axis = me.dictModelAxis[id];
        if (! axis) return false;
        delete me.dictModelAxis[id];

        for (var i = 0; i < axis.models.length; i++)
        {
            if (axis.models[i].id == id)
            {
                axis.models.splice(i, 1);
                axis.positions.splice(i, 1);
                axis.modelIDs.splice(i, 1);

                createFramesForAxis(axis);

                WC.createWall3D(axis.wall1, me.cap.wallsHeight);
                WC.createWall3D(axis.wall2, me.cap.wallsHeight);
                axis.wall1.changed = true;
                axis.wall2.changed = true;
                axis.wall1.dispatchUpdate();
                axis.wall2.dispatchUpdate();

                axis.wall1.findPlinthGaps();
                axis.wall2.findPlinthGaps();
                WC.createPlinth3D(axis.wall1.bottomPlinth);
                WC.createPlinth3D(axis.wall2.bottomPlinth);
                axis.wall1.bottomPlinth.dispatchUpdate();
                axis.wall2.bottomPlinth.dispatchUpdate();

                return true;
            }
        }
    };

    me.setDrawingData = function(data)
    {
        if (! WC.wallsEditor) WC.wallsEditor = new WC.SubEditor(me);

        WC.wallsEditor.drawingScale = parseFloat(data.drawing.scale);
        WC.wallsEditor.drawingRotation = parseFloat(data.drawing.rotation);
        // loader for data.drawing.source

        var loader = new R2D.ImageUrlLoader();
        var loaderListener = function(e)
        {
            if (e.type == Event.COMPLETE)
            {
                WC.wallsEditor.setImageDrawing(loader.getImage());
                WC.wallsEditor.dispatchEvent(new Event(WC.DRAWING_UPLOADED, me));
                me.dispatchEvent(new Event(WC.DRAWING_CHANGED, me));
            }
            else
            {
                console.error('Drawing loader error!');
            }
            loader.removeEventListener(Event.COMPLETE, loaderListener);
            loader.removeEventListener(Event.ERROR, loaderListener);
            loader.close();
            loader = null;
        };

        loader.addEventListener(Event.COMPLETE, loaderListener);
        loader.addEventListener(Event.ERROR, loaderListener);
        loader.load(data.drawing.source);

        WC.wallsEditor.stateAlignDrawing.setRulersData(data.rulers);
    };

    me.getDrawingData = function()
    {
        if (! WC.wallsEditor) WC.wallsEditor = new WC.SubEditor(me);

        if (! WC.wallsEditor.imgDrawing) return null;

        return {
            drawing: {
                scale:WC.wallsEditor.drawingScale,
                rotation:WC.wallsEditor.drawingRotation,
                source:WC.wallsEditor.imgDrawing.src
            },
            rulers: WC.wallsEditor.stateAlignDrawing.getRulersData()
        };
    };

    function findRoomsForCovers()
    {
        for (var room of me.roomsInner)
        {
            for (var cover of me.covers)
            {
                if (TR.pointInContour(cover.points[0], room.points) || TR.pointOnContour(cover.points[0], room.points))
                {
                    cover.room = room;
                }
            }
        }
    }

    var getAxis = function(center, snapDist)
    {
        var minDist = Number.MAX_VALUE;
        var resAxis;

        for (var i = 0; i < me.axes.length; i++)
        {
            var proj = TR.projectionPointOnLine(center, me.axes[i].point1, me.axes[i].point2, true);
            if (! proj) continue;

            var d = Math.abs(TR.distanceBetweenPointAndLine(center, me.axes[i].point1, me.axes[i].point2));

            if (d < minDist)
            {
                minDist = d;
                resAxis = me.axes[i];
            }
        }

        if (! resAxis || (minDist > snapDist)) return null;

        return resAxis;
    };

    var findAxes = function()
    {
        for (var i = 0; i < me.walls.length - 1; i++)
        {
            for (var j = i + 1; j < me.walls.length; j++)
            {
                var DW1 = me.walls[i];
                var DW2 = me.walls[j];

                var box = WC.boxFromWalls(DW1, DW2);
                if (! box) continue;

                var pts = WC.boxCenterSeg(box[0], box[1], box[2], box[3]);

                if (! pts) continue;

                var axis = new WC.Axis(DW1, DW2);

                axis.point1 = pts[0];
                axis.point2 = pts[1];
                axis.box = box;
                axis.depth = TR.euclDist(box[1].x, box[1].y, box[2].x, box[2].y);
                me.axes.push(axis);

                DW1.axes.push(axis);
                DW2.axes.push(axis);

                var ax = axis.point2.x - axis.point1.x;
                var ay = axis.point2.y - axis.point1.y;
                var bx = DW1.point1.x - axis.point1.x;
                var by = DW1.point1.y - axis.point1.y;

                var pt1, pt2;
                if (DW1.outer && (ax * by - ay * bx) > 0)
                {
                    pt1 = axis.point2;
                    pt2 = axis.point1;
                }
                else
                {
                    pt1 = axis.point1;
                    pt2 = axis.point2;
                }

                axis.angle = -Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x);
            }
        }
    };

    var createPlinths = function()
    {
        var d = 1;
        var maxDist = d * 2;

        var rooms = me.roomsInner.concat(me.roomsOuter);

        for (var i = 0; i < rooms.length; i++)
        {
            var room = rooms[i];
            for (var j = 0; j < room.walls.length; j++)
            {
                var wall = room.walls[j];
                var pti1 = room.points.indexOf(wall.point1);
                var pti2 = room.points.indexOf(wall.point2);

                var pti0 = pti1 - 1;
                if (pti0 < 0) pti0 = room.points.length - 1;
                var pti3 = pti2 + 1;
                if (pti3 > room.points.length - 1) pti3 = 0;

                var A = room.points[pti0];
                var B = room.points[pti1];
                var C = room.points[pti2];
                var D = room.points[pti3];

                var Ap, Bp, Cp, Dp, Bpc, Cpc;

                if (wall.faceRight)
                {
                    Bpc = TR.perpendicularPoint(B, C, -d);
                    Cpc = TR.perpendicularPoint(C, B, d);

                    Ap = TR.perpendicularPoint(A, B, -d);
                    Bp = TR.perpendicularPoint(B, A, d);
                    Cp = TR.perpendicularPoint(C, D, -d);
                    Dp = TR.perpendicularPoint(D, C, d);
                }
                else
                {
                    Bpc = TR.perpendicularPoint(B, C, d);
                    Cpc = TR.perpendicularPoint(C, B, -d);

                    Ap = TR.perpendicularPoint(A, B, d);
                    Bp = TR.perpendicularPoint(B, A, -d);
                    Cp = TR.perpendicularPoint(C, D, d);
                    Dp = TR.perpendicularPoint(D, C, -d);
                }

                var Bx = TR.lineIntersectLine(Ap, Bp, Bpc, Cpc, false);
                var Cx = TR.lineIntersectLine(Bpc, Cpc, Cp, Dp, false);

                if (! Bx || TR.euclDistP(B, Bx) > maxDist) Bx = Bpc;
                if (! Cx || TR.euclDistP(C, Cx) > maxDist) Cx = Cpc;

                wall.bottomPlinth.setPoints(B, C, Bx, Cx);
                me.plinths.push(wall.bottomPlinth);

                wall.topPlinth.setPoints(B, C, Bx, Cx);
                me.plinths.push(wall.topPlinth);
            }
        }
    };

    var build3D = function()
    {
        for (var i = 0; i < me.walls.length; i++)
        {
            WC.createWall3D(me.walls[i], me.cap.wallsHeight);
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.walls[i]));
        }

        for (i = 0; i < me.cuts.length; i++)
        {
            WC.createCut3D(me.cuts[i]);
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.cuts[i]));
        }

        for (i = 0; i < me.walls.length; i++)
        {
            me.walls[i].findPlinthGaps();
        }

        for (i = 0; i < me.plinths.length; i++)
        {
            WC.createPlinth3D(me.plinths[i]);
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.plinths[i]));
        }

        me.ceilings = [];

        for (i = 0; i < me.covers.length; i++)
        {
            me.ceilings.push(me.covers[i].ceiling);
            WC.createCover3D(me.covers[i], me.innerCoverConts);
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.covers[i]));
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.covers[i].ceiling));
            checkCeilingVisible(me.covers[i].ceiling, true);
        }

        // cap and areas

        for (i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].ceiling.exists) me.ceilings.push(me.areas[i].ceiling);
            me.areas[i].triangles = [];
        }

        var cutPairs = [];
        for (i = 0; i < me.cuts.length; i++) cutPairs.push([me.cuts[i].point1, me.cuts[i].point2]);

        var trs = TR.triangulateContours(me.outerRoomConts, me.innerRoomConts, [], [], cutPairs);

        me.cap.triangles = [];
        if (isNaN(me.cap.wallsHeight)) me.cap.wallsHeight = WC.core.wallsHeight; //WC.DEFAULT_WALLS_HEIGHT;

        for (i = 0; i < trs[0].length; i++)
        {
            var i0 = trs[0][i].pointIndices[0];
            var i1 = trs[0][i].pointIndices[1];
            var i2 = trs[0][i].pointIndices[2];

            var a = new TR.Point(TR.points[i0][0], TR.points[i0][1]);
            var b = new TR.Point(TR.points[i1][0], TR.points[i1][1]);
            var c = new TR.Point(TR.points[i2][0], TR.points[i2][1]);

            var center = TR.triangleCenter(a.x, a.y, b.x, b.y, c.x, c.y);

            var inArea = false;
            for (var j = 0; j < me.areas.length; j++)
            {
                if (TR.pointInContour(center, me.areas[j].points))
                {
                    me.areas[j].triangles.push([a, b, c]);
                    me.areas[j].ceiling.triangles.push([a, b, c]);

                    inArea = true;
                    break;
                }
            }

            if (inArea) continue;
            me.cap.triangles.push([a, b, c]);
        }

        me.cap.contours = [];
        for (i = 0; i < me.outerRoomConts.length; i++)
        {
            me.cap.contours.push(WC.findContourCover(me.outerRoomConts[i], me.cap.wallsHeight, false));
        }

        for (i = 0; i < me.areas.length; i++)
        {
            me.areas[i].build3D();
            me.areas[i].ceiling.build3D();

            me.areas[i].contours = [WC.findContourCover(me.areas[i].points, me.areas[i].height, false)];
            me.areas[i].ceiling.contours = [WC.findContourCover(me.areas[i].points, me.areas[i].ceiling.height, true)];
        }
        
        me.cap.build3D();

        if (me.cap && me.cap.vertices && me.cap.vertices.length > 0) me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.cap));

        for (i = 0; i < me.areas.length; i++)
        {
            me.areas[i].addNullData();

            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.areas[i]));
            if (me.areas[i].ceiling.exists)
            {
                me.areas[i].ceiling.addNullData();

                me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.areas[i].ceiling));
                checkCeilingVisible(me.areas[i].ceiling, true);
            }
        }

        for (i = 0; i < me.cuts.length; i++)
        {
            var cut = me.cuts[i];
            cut.walls = [];
            var pts = [cut.point1, cut.point2];

            for (var k = 0; k < 2; k++)
            {
                var P = pts[k];
                var highWall = null;

                for (j = 0; j < me.walls.length; j++)
                {
                    if (me.walls[j].point1 == P || me.walls[j].point2 == P)
                    {
                        if (! highWall || me.walls[j].height > highWall.height) highWall = me.walls[j];
                    }
                }

                cut.walls.push(highWall);
            }
        }

        for (i = 0; i < me.walls.length; i++)
        {
            var wall = me.walls[i];
            wall.neighbours = [];
            pts = [wall.point1, wall.point2];

            for (k = 0; k < 2; k++)
            {
                P = pts[k];

                for (j = 0; j < me.walls.length; j++)
                {
                    if (i == j) continue;
                    if (me.walls[j].point1 == P || me.walls[j].point2 == P)
                    {
                        wall.neighbours.push(me.walls[j]);
                    }
                }
            }
        }

        me.plugs = WC.createConnectors(me.axes, me.walls, me.cuts);

        for (i = 0; i < me.plugs.length; i++)
        {
            var plug = me.plugs[i];
            plug.walls = [];
            pts = [plug.point1, plug.point2];

            for (k = 0; k < 2; k++)
            {
                P = pts[k];

                for (j = 0; j < me.walls.length; j++)
                {
                    if (me.walls[j].point1 == P || me.walls[j].point2 == P)
                    {
                        plug.walls.push(me.walls[j]);
                    }
                }
            }
        }

        for (i = 0; i < me.plugs.length; i++)
        {
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, me.plugs[i]));
        }
    };

    var createAny3D = function(model, final)
    {
        switch(model.type)
        {
            case 'wall':
                WC.createWall3D(model, 0, !final);
                break;
            case 'cover':
                WC.createCover3D(model, me.innerCoverConts);
                break;
            case 'cut':
                WC.createCut3D(model);
                break;
        }
    };

    var createFramesForAxis = function(axis)
    {
        for (var i = 0; i < axis.frames.length; i++)
        {
            me.dispatchEvent(new Event(WC.ELEMENT_DELETE, axis.frames[i]));
        }

        axis.frames = [];

        var shiftedContours = [];
        for (i = 0; i < axis.models.length; i++)
        {
            var shiftX = TR.euclDist(axis.point1.x, axis.point1.y, axis.point2.x, axis.point2.y) * axis.positions[i];
            var shiftY = axis.models[i].elevation;
            var scaleX = axis.models[i].scaleX;
            var scaleY = axis.models[i].scaleY;
            var flipX = 1;
            if (axis.models[i].flipX) flipX = -1;
            var modelCont = axis.models[i].contour;
            var shiftCont = new Array(modelCont.length);

            for (var j = 0; j < modelCont.length; j++)
            {
                shiftCont[j] = new TR.Point(Math.round((modelCont[j].x * scaleX * flipX + shiftX) * 100) / 100,
                                            Math.round((modelCont[j].y * scaleY - shiftY) * 100) / 100);
            }

            shiftedContours.push(shiftCont);
        }

        var recalc = WC.compareAndRebuildContours(shiftedContours, false);
        var newContours = recalc[0];
        var corresp = recalc[1];

        for (i = 0; i < newContours.length; i++)
        {
            var modelIndex = corresp[i][0];
            var frames = WC.createFrame3D(newContours[i], axis.point1, axis.point2, axis.depth, axis.models[modelIndex]);

            var modelIDs = [];
            for (j = 0; j < corresp[i].length; j++) modelIDs.push(axis.models[corresp[i][j]].id);
            frames[0].modelIDs = modelIDs;
            frames[1].modelIDs = modelIDs;

            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, frames[0]));
            me.dispatchEvent(new Event(WC.ELEMENT_CREATE, frames[1]));

            axis.frames.push(frames[0], frames[1]);
        }

        axis.finalContours = shiftedContours;
    };

    var cameraFrom = null;
    var cameraTo = null;

    me.setCameraPosition = function(camFrom, camTo, hideWalls = true) // {x, y, h}
    {
        cameraFrom = camFrom;
        cameraTo = camTo;

        for (var i = 0; i < me.ceilings.length; i++) checkCeilingVisible(me.ceilings[i]);

        //findWallsToHide(camFrom, camTo, ! hideWalls);

        if (plinthsVisible) for (i = 0; i < me.plinths.length; i++) checkPlinthVisible(me.plinths[i]);
    };

    var plinthsVisible = true;

    me.hidePlinths = function()
    {
        for (var i = 0; i < me.plinths.length; i++)
        {
            me.plinths[i].visible = false;
            me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, me.plinths[i]));
        }
        plinthsVisible = false;
    };

    me.showPlinths = function()
    {
        plinthsVisible = true;
    };

    function checkCeilingVisible(ceiling, mandatory)
    {
        if (! cameraFrom || !ceiling) return;

        if (cameraFrom.z < me.cap.wallsHeight)
        {
            if (ceiling.visible && ! mandatory) return;
            ceiling.visible = true;
            me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, ceiling));
        }
        else
        {
            if (! ceiling.visible && ! mandatory) return;
            ceiling.visible = false;
            me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, ceiling));
        }
    }

    function checkPlinthVisible(plinth, mandatory)
    {
        plinth.wasVisible = plinth.visible;

        var wallVisible = plinth.wall.visible;
        var ceilVisible = true;
        if (plinth.type == 'topPlinth' && cameraFrom && cameraFrom.z > me.cap.wallsHeight) ceilVisible = false;

        plinth.visible = ! (! wallVisible || ! ceilVisible);

    //    if (! plinth.exists) plinth.visible = false;

        if (plinth.visible ^ plinth.wasVisible || mandatory || (typeof plinth.wasVisible == 'undefined')) me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, plinth));
    }

    me.dispatchModelsReset = function()
    {
        me.dispatchEvent(new Event(WC.RESET_MODELS, me.newModelsData));
    };

    me.getRect = function()
    {
        if (me.roomPoints.length == 0 && me.coverPoints.length == 0) return null;

        var minX =  Number.MAX_VALUE;
        var minY =  Number.MAX_VALUE;
        var maxX = -Number.MAX_VALUE;
        var maxY = -Number.MAX_VALUE;

        for (var i = 0; i < me.roomPoints.length; i++)
        {
            var P = me.roomPoints[i];
            if (P.x < minX) minX = P.x;
            if (P.y < minY) minY = P.y;
            if (P.x > maxX) maxX = P.x;
            if (P.y > maxY) maxY = P.y;
        }

        for (i = 0; i < me.coverPoints.length; i++)
        {
            P = me.coverPoints[i];
            if (P.x < minX) minX = P.x;
            if (P.y < minY) minY = P.y;
            if (P.x > maxX) maxX = P.x;
            if (P.y > maxY) maxY = P.y;
        }

        return new GEOM.Bounds(minX, minY, maxX, maxY);
    };

    me.getLines = function()
    {
        //var allRooms = me.roomsInner.concat(me.roomsOuter);
        var lines = [];
        for (var i = 0; i < me.roomsInner.length; i++)
        {
            var room = me.roomsInner[i];
            for (var j = 0; j < room.points.length - 1; j++)
            {
                lines.push({x1: room.points[j].x, y1: room.points[j].y,
                            x2: room.points[j + 1].x, y2: room.points[j + 1].y})
            }
            lines.push({x1: room.points[room.points.length - 1].x, y1: room.points[room.points.length - 1].y,
                        x2: room.points[0].x, y2: room.points[0].y});
        }

        for (i = 0; i < me.roomsOuter.length; i++)
        {
            room = me.roomsOuter[i];
            for (j = 0; j < room.points.length - 1; j++)
            {
                lines.push({x1: room.points[j + 1].x, y1: room.points[j + 1].y,
                            x2: room.points[j].x, y2: room.points[j].y})
            }
            lines.push({x1: room.points[0].x, y1: room.points[0].y,
                        x2: room.points[room.points.length - 1].x, y2: room.points[room.points.length - 1].y});
        }

        return(lines);
    };

    me.getObjects = function()
    {
        var frames = [];
        for (var i = 0; i < me.axes.length; i++)
        {
            frames = frames.concat(me.axes[i].frames);
        }

        return {
            walls:      me.walls,
            covers:     me.covers,
            ceilings:   me.ceilings,
            areas:      me.areas,
            cuts:       me.cuts,
            cap:        me.cap,
            frames:     frames,
            plinths:    me.plinths
        };
    };

    var findWallsToHide = function(lookFrom, lookTo, showAll)
    {
        var hideDistInside = 60;
        var hideDistOutside = 150;
        var backAngle = 0.1;
        showAll = showAll || (lookFrom.z >= me.cap.wallsHeight);
        var maxDistHide;

        var cameraInside = TR.pointInContours(lookFrom, me.innerRoomConts, true);

        if (cameraInside)
        {
            maxDistHide = hideDistInside;
        }
        else
        {
            maxDistHide = hideDistOutside;
        }

        for (var  i = 0; i < me.walls.length; i++)
        {
            me.walls[i].wasVisible = me.walls[i].visible;
            me.walls[i].visible = true;
        }
        for (i = 0; i < me.cuts.length; i++)
        {
            me.cuts[i].wasVisible = me.cuts[i].visible;
            me.cuts[i].visible = true;
        }
        for (i = 0; i < me.areas.length; i++)
        {
            me.areas[i].wasVisible = me.areas[i].visible;
            me.areas[i].visible = true;
        }
        for (i = 0; i < me.plugs.length; i++)
        {
            me.plugs[i].wasVisible = me.plugs[i].visible;
            me.plugs[i].visible = true;
        }
        for (i = 0; i < me.axes.length; i++)
        {
            me.axes[i].visible = true;
            for (var j = 0; j < me.axes[i].frames.length; j++)
            {
                me.axes[i].frames[j].wasVisible = me.axes[i].frames[j].visible;
                me.axes[i].frames[j].visible = true;
            }
        }

        if (! showAll)
        {
            for (i = 0; i < me.walls.length; i++)
            {
                var DW = me.walls[i];
                var proj = TR.projectionPointOnLine(lookFrom, DW.point1, DW.point2, false);
                var a = TR.angleBetweenLines(lookFrom.x, lookFrom.y, lookTo.x, lookTo.y, lookFrom.x, lookFrom.y, proj.x, proj.y);

                if (a > Math.PI / 2 + backAngle && a < Math.PI * 3 / 2 - backAngle) continue;

                var d = Math.abs(TR.distanceBetweenPointAndLine(lookFrom, DW.point1, DW.point2));
                a = TR.angleBetweenLines(lookFrom.x, lookFrom.y, lookTo.x, lookTo.y, DW.point1.x, DW.point1.y, DW.point2.x, DW.point2.y);

                var s = 0.5;    //HIDE_WALLS_DIRECTION_SENSITIVITY;
                var k = Math.abs(Math.sin(a)) * s + (1 - s);

                var dist = maxDistHide * k;

                if (TR.pointInBounds(proj, DW.point1, DW.point2) && d < dist)
                {
                    for (j = 0; j < DW.axes.length; j++) DW.axes[j].visible = false;
                }
                else if (TR.euclDistP(lookFrom, DW.point1) < dist || TR.euclDistP(lookFrom, DW.point2) < dist)
                {
                    for (j = 0; j < DW.axes.length; j++) DW.axes[j].visible = false;
                }
            }

            for (i = 0; i < me.axes.length; i++)
            {
                if (me.axes[i].visible) continue;
                me.axes[i].wall1.visible = false;
                me.axes[i].wall2.visible = false;

                for (j = 0; j < me.axes[i].frames.length; j++)
                {
                    me.axes[i].frames[j].visible = false;
                }
            }

            for (i = 0; i < me.areas.length; i++)
            {
                for (j = 0; j < me.areas[i].walls.length; j++)
                {
                    if (! me.areas[i].walls[j].visible)
                    {
                        me.areas[i].visible = false;
                        break;
                    }
                }
            }

            for (i = 0; i < me.areas.length; i++)
            {
                if (me.areas[i].visible) continue;
                for (j = 0; j < me.areas[i].walls.length; j++) me.areas[i].walls[j].visible = false;
            }

            for (i = 0; i < me.cuts.length; i++)
            {
                if (! me.cuts[i].walls[0].visible || ! me.cuts[i].walls[1].visible) me.cuts[i].visible = false;
            }

            for (i = 0; i < me.plugs.length; i++)
            {
                me.plugs[i].visible = false;
                for (j = 0; j < me.plugs[i].walls.length; j++)
                {
                    if (me.plugs[i].walls[j].height == me.plugs[i].height && me.plugs[i].walls[j].visible)
                    {
                        me.plugs[i].visible = true;
                        break;
                    }
                }
            }

            for (i = 0; i < me.walls.length; i++)
            {
                var wall = me.walls[i];
                if (wall.neighbours[0] && wall.neighbours[1] && !wall.neighbours[0].visible && !wall.neighbours[1].visible)
                {
                    wall.visible = false;
                }
            }
        }

        // ---

        for (i = 0; i < me.walls.length; i++)
        {
            /*if ((typeof me.walls[i].wasVisible == 'undefined') || (me.walls[i].visible ^ me.walls[i].wasVisible))*/ me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, me.walls[i]));
        }

        for (i = 0; i < me.areas.length; i++)
        {
            /*if ((typeof me.areas[i].wasVisible == 'undefined') || (me.areas[i].visible ^ me.areas[i].wasVisible))*/ me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, me.areas[i]));
        }

        for (i = 0; i < me.cuts.length; i++)
        {
             /*if ((typeof me.cuts[i].wasVisible == 'undefined') || (me.cuts[i].visible ^ me.cuts[i].wasVisible))*/ me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, me.cuts[i]));
        }

        for (i = 0; i < me.plugs.length; i++)
        {
             /*if ((typeof me.plugs[i].wasVisible == 'undefined') || (me.plugs[i].visible ^ me.plugs[i].wasVisible))*/ me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, me.plugs[i]));
        }

        var modelsVisibility = {visible:[], invisible:[]};
        for (i = 0; i < me.axes.length; i++)
        {
            for (j = 0; j < me.axes[i].frames.length; j++)
            {
                var fr = me.axes[i].frames[j];
                if ((typeof fr.wasVisible == 'undefined') || (fr.visible ^ fr.wasVisible)) me.dispatchEvent(new Event(WC.ELEMENT_VISIBLE, fr));
            }

            if (me.axes[i].visible)
            {
                modelsVisibility.visible = modelsVisibility.visible.concat(me.axes[i].modelIDs);
            }
            else
            {
                modelsVisibility.invisible = modelsVisibility.invisible.concat(me.axes[i].modelIDs);
            }
        }

        me.dispatchEvent(new Event(WC.MODELS_VISIBLE, modelsVisibility));
    };

    me.setPlinthToRoom = function(plinth)
    {
        var rooms = me.roomsInner.concat(me.roomsOuter);
        for (var i = 0; i < rooms.length; i++)
        {
            if (rooms[i].walls.indexOf(plinth?.wall) < 0) continue;

            var walls = rooms[i].walls;
            for (var j = 0; j < walls.length; j++)

            if (plinth.type == 'topPlinth')
            {
                WC.convert.copyPlinthData(plinth, walls[j].topPlinth);
                walls[j].topPlinth.build3D();
                walls[j].topPlinth.dispatchUpdate();
            }
            else
            {
                WC.convert.copyPlinthData(plinth, walls[j].bottomPlinth);
                walls[j].bottomPlinth.build3D();
                walls[j].bottomPlinth.dispatchUpdate();
            }
        }
    };

    me.rebuildAllPlinths = function()
    {
        for (var i = 0; i < me.plinths.length; i++)
        {
            me.plinths[i].build3D();
            me.plinths[i].dispatchUpdate();
        }
    };

    me.setWallToRoom = function(wall)
    {
        var rooms = me.roomsInner.concat(me.roomsOuter);
        for (var i = 0; i < rooms.length; i++)
        {
            if (rooms[i].walls.indexOf(wall) < 0) continue;

            var walls = rooms[i].walls;
            for (var j = 0; j < walls.length; j++)
            {
                WC.convert.copyWallData(wall, walls[j]);
                walls[j].changed = true;
                walls[j].build3D();
                walls[j].dispatchUpdate();
            }
        }
    };

    me.setStyleFromJSON = function(str)
    {
        console.log('Not done');
        return;

        var style = new WC.RoomStyle();
        style.fromObj(str);

        WC.attachRoomContent(me);

        var room = null;

        for (var i = 0; i < me.roomsInner.length; i++)
        {
            if (me.roomsInner[i].title.text == style.target)
            {
                room = me.roomsInner[i];
                break;
            }
        }

        if (! room) return;

        for (var j = 0; j < room.walls.length; j++)
        {
            WC.convert.copyWallData(style.wall, room.walls[j]);

            room.walls[j].changed = true;
            room.walls[j].build3D();
            room.walls[j].dispatchUpdate();

            room.walls[j].topPlinth.changed = true;
            room.walls[j].topPlinth.build3D();
            room.walls[j].topPlinth.dispatchUpdate();

            room.walls[j].bottomPlinth.changed = true;
            room.walls[j].bottomPlinth.build3D();
            room.walls[j].bottomPlinth.dispatchUpdate();
        }

        for (j = 0; j < room.rooms.length; j++)
        {
            for (var k = 0; k < room.rooms[j].walls.length; k++)
            {
                var w = room.rooms[j].walls[k];
                WC.convert.copyWallData(style.wall, w);

                w.changed = true;
                w.build3D();
                w.dispatchUpdate();

                w.topPlinth.changed = true;
                w.topPlinth.build3D();
                w.topPlinth.dispatchUpdate();

                w.bottomPlinth.changed = true;
                w.bottomPlinth.build3D();
                w.bottomPlinth.dispatchUpdate();
            }
        }

        for (j = 0; j < room.covers.length; j++)
        {
            WC.convert.copyCoverData(style.cover, room.covers[j]);

            room.covers[j].changed = true;
            room.covers[j].build3D();
            room.covers[j].dispatchUpdate();

            room.covers[j].ceiling.changed = true;
            room.covers[j].ceiling.build3D();
            room.covers[j].ceiling.dispatchUpdate();
        }

        for (j = 0; j < room.axes.length; j++)
        {
            for (k = 0; k < room.axes[j].frames.length; k++)
            {
                var fr = room.axes[j].frames[k];
                fr.materialID = style.wall.materialID;
                fr.materialRotation = style.wall.materialRotation;
                fr.materialX = style.wall.materialX;
                fr.materialY = style.wall.materialY;

                fr.changed = true;
                fr.build3D();
                fr.dispatchUpdate();
            }
        }
    };

    me.selectRoomByName = function(name)  // todo: move it anywhere!
    {
        var room = null;
        for (var i = 0; i < me.roomsInner.length; i++)
        {
            if (me.roomsInner[i].title.text == name)
            {
                room = me.roomsInner[i];
                break;
            }
        }
        if (! room) return;

        var contours = new Array(room.walls.length);
        for (i = 0; i < room.walls.length; i++) contours[i] = room.walls[i].contours[0];
        R2D.commonSceneObject.showContour(contours);

        room.walls[0].dispatchUpdate();
    };

    me.unselectRoom = function()
    {
        R2D.commonSceneObject.hideContour();

        if (me.roomsInner.length > 0) me.roomsInner[0].walls[0].dispatchUpdate();
    };

    me.setElementClass = function(name)
    {
        if (! R2D.scene.currentConstructorElementData || R2D.scene.currentConstructorElementData.type != 'wall') return;
        var dw = R2D.scene.currentConstructorElementData;
        for (var i = 0; i < me.roomsInner.length; i++)
        {
            if (me.roomsInner[i].walls.indexOf(dw) >= 0)
            {
                me.roomsInner[i].title.text = name;
                return;
            }
        }
        for (i = 0; i < me.roomsOuter.length; i++)
        {
            if (me.roomsOuter[i].walls.indexOf(dw) >= 0)
            {
                me.roomsOuter[i].title.text = name;
                return;
            }
        }
    };

    me.getElementClass = function()
    {
        console.log('TODO: get element name');
        return 'TODO';
        //return me.room.data.name;
    };

    let tileConfigurator;

    me.runConfigurator = function(wall, callback)
    {
        
        
        tileConfigurator = new TConf.TileConfig();

        tileConfigurator.setWallSize(TR.euclDistP(wall.point1, wall.point2), wall.height);

        if (wall.configData)
        {
            tileConfigurator.setData(wall.configData);
        }
        else
        {
            tileConfigurator.setDefaultMaterial(wall.materialID, wall.addMaterialID);
        }

        //tileConfigurator.addEventListener(TConf.TILE_CONFIG_DONE, tileConfigDoneListener);

        //R2D.DialogStage.show(tileConfigurator);

        function tileConfigDoneListener(e) {
            var dw = R2D.scene.currentConstructorElementData;
            var configData = tileConfigurator.getData();
            if (configData.areas.length == 1)
            {
            dw.configData = null;
            }
            else
            {
            dw.configData = configData;
            }

            dw.changed = true;
            dw.build3D();
            dw.dispatchUpdate();
            R2D.scene.history.saveState();

            R2D.DialogStage.hide(tileConfigurator);
            tileConfigurator.removeEventListener(TConf.TILE_CONFIG_DONE, tileConfigDoneListener);
            tileConfigurator.destroy();
            tileConfigurator = null;
        }
        
    };

    me.getConfigurator = () => tileConfigurator;
    
    me.cameraInside = function()
    {
        return Boolean(TR.pointInContours(cameraFrom, me.innerRoomConts, true));
    };

    var modelUploader = null;
    var materialUploader = null;

    document.addEventListener('keydown', function(e){
        if (e.ctrlKey && e.altKey && e.code == 'KeyU')
        {
            modelUploader = new R2D.WindowModelUploader(R2D.User.loadToken());

            R2D.DialogStage.show(modelUploader);

            window.addEventListener('resize', resizeModelListener);

            function resizeModelListener()
            {
                modelUploader.updateSizes(document.body.clientWidth, document.body.clientHeight);
            }

            setTimeout(function() {
                modelUploader.updateSizes(document.body.clientWidth, document.body.clientHeight);
                modelUploader.update()
            }, 100);
        }
        else if (e.ctrlKey && e.altKey && e.code == 'KeyM')
        {
            materialUploader = new R2D.WindowMaterialUploader(R2D.User.loadToken());

            R2D.DialogStage.show(materialUploader);

            window.addEventListener('resize', resizeMaterialListener);

            function resizeMaterialListener()
            {
                materialUploader.updateSizes(document.body.clientWidth, document.body.clientHeight);
            }

            setTimeout(function() {
                materialUploader.updateSizes(document.body.clientWidth, document.body.clientHeight);
                materialUploader.update()
            }, 100);
        }
    });

};

R2D.extend(WC.WallsData, EventDispatcher);
// constructor

WC.SubEditor = function(wallsData)
{
    var me = this;

    me.imgDrawing = null;

    var allImgLoader = new WC.EditorImgLoader();
    allImgLoader.loadImages();

    me.setImageDrawing = function(img)
    {
        me.imgDrawing = img;
        me.drawingRotation = (isNaN(me.drawingRotation) || typeof me.drawingRotation === 'undefined' || me.drawingRotation == null) ? 0 : me.drawingRotation; //Math.PI * 0.3333;

        me.drawingScale = (isNaN(me.drawingScale) || typeof me.drawingScale === 'undefined' || me.drawingScale == null) ? 1 : me.drawingScale;
        me.drawingX = -me.imgDrawing.width / 2;
        me.drawingY = -me.imgDrawing.height / 2;
    };

    me.delImageDrawing = function()
    {
        me.imgDrawing = null;

        wallsData.dispatchEvent(new Event(WC.DRAWING_CHANGED, me));
    };

    me.dispatchEvent = function() {};

    me.stateAlignDrawing = {
        alignerV1: {center: new TR.Point(0, -250)},
        alignerV2: {center: new TR.Point(0, -50)},
        alignerH1: {center: new TR.Point(50, 0)},
        alignerH2: {center: new TR.Point(250, 0)},

        distanceV: 200,
        distanceH: 200,

        getRulersData: function(data)
        {
            return {
                horizontal:{
                    size: this.distanceH,
                    ax: this.alignerH1.center.x,
                    ay: this.alignerH1.center.y,
                    bx: this.alignerH2.center.x,
                    by: this.alignerH2.center.y
                },
                vertical:{
                    size: this.distanceV,
                    ax: this.alignerV1.center.x,
                    ay: this.alignerV1.center.y,
                    bx: this.alignerV2.center.x,
                    by: this.alignerV2.center.y
                }
            }
        },

        setRulersData: function(data)
        {
            this.distanceH = parseFloat(data.horizontal.size);
            this.alignerH1.center.x = parseFloat(data.horizontal.ax);
            this.alignerH1.center.y = parseFloat(data.horizontal.ay);
            this.alignerH2.center.x = parseFloat(data.horizontal.bx);
            this.alignerH2.center.y = parseFloat(data.horizontal.by);

            this.distanceV = parseFloat(data.vertical.size);
            this.alignerV1.center.x = parseFloat(data.vertical.ax);
            this.alignerV1.center.y = parseFloat(data.vertical.ay);
            this.alignerV2.center.x = parseFloat(data.vertical.bx);
            this.alignerV2.center.y = parseFloat(data.vertical.by);
        }
    }

};
class PlinthShape {
    constructor(depth, height, path, distToCeiling = 0) {
        this.defDepth = depth;
        this.defHeight = height;
        this.path = path;
        this.distToCeiling = distToCeiling;
    }
}

class PlinthCreator {
    constructor() {
        this.PLINTH_TYPES = {
            PLINTHS: "plinths",
            MOLDINGS: "moldings",
        };

        this.PoolPlinthShape = {
            // BOTTOM
            0: new PlinthShape(2, 6, [
                [0, 1], [1, 1], [1, 0],
            ]),
            1: new PlinthShape(4, 6, [
                [0, 1], [0.5, 1], [0.5, 0.5], [1, 0.5], [1, 0],
            ]),
            2: new PlinthShape(4, 9, [
                [0, 1], [0.5, 1], [0.5, 0.67], [1, 0.67], [1, 0],
            ]),
            3: new PlinthShape(3, 10, [
                [0, 1],
                [0.33, 1],
                [0.33, 0.8],
                [0.67, 0.8],
                [0.67, 0.2],
                [1, 0.2],
                [1, 0],
            ]),
            4: new PlinthShape(3, 10, [
                [0, 1],
                [1, 1],
                [1, 0.6],
                [0.8, 0.6],
                [0.8, 0.4],
                [1, 0.4],
                [1, 0],
            ]),
            5: new PlinthShape(4, 12, [
                [0, 1],
                [0.33, 1],
                [0.33, 0.67],
                [0.67, 0.67],
                [0.67, 0.33],
                [1, 0.33],
                [1, 0],
            ]),
            6: new PlinthShape(3, 14, [
                [0, 1],
                [1, 1],
                [1, 0.875],
                [0.75, 0.875],
                [0.75, 0.75],
                [0.5, 0.75],
                [0.5, 0.25],
                [0.75, 0.25],
                [0.75, 0.125],
                [1, 0.125],
                [1, 0],
            ]),
            7: new PlinthShape(4, 16, [
                [0, 1],
                [1, 1],
                [1, 0.88],
                [0.66, 0.88],
                [0.66, 0.77],
                [1, 0.77],
                [1, 0.66],
                [0.66, 0.66],
                [0.66, 0.33],
                [1, 0.33],
                [1, 0.22],
                [0.66, 0.22],
                [0.66, 0.11],
                [1, 0.11],
                [1, 0],
            ]),

            // TOP
            8: new PlinthShape(2, 3, [
                    [0, -1], [1, -1], [1, 0], [0, 0],
                ].reverse()
            ),
            9: new PlinthShape(4, 4, [
                    [0, -1], [0.5, -1], [0.5, -0.5], [1, -0.5], [1, 0],
                ].reverse()
            ),
            10: new PlinthShape(3, 5, [
                    [0, -1], [0.5, -1], [0.5, -0.67], [1, -0.67], [1, 0],
                ].reverse()
            ),
            11: new PlinthShape(3, 7, [
                    [0, -1],
                    [0.33, -1],
                    [0.33, -0.8],
                    [0.67, -0.8],
                    [0.67, -0.2],
                    [1, -0.2],
                    [1, 0],
                ].reverse()
            ),
            12: new PlinthShape(3, 6, [
                    [0, -1],
                    [1, -1],
                    [1, -0.6],
                    [0.8, -0.6],
                    [0.8, -0.4],
                    [1, -0.4],
                    [1, 0],
                ].reverse()
            ),
            13: new PlinthShape(3, 6, [
                    [0, -1],
                    [0.33, -1],
                    [0.33, -0.67],
                    [0.67, -0.67],
                    [0.67, -0.33],
                    [1, -0.33],
                    [1, 0],
                ].reverse()
            ),
            14: new PlinthShape(3, 9, [
                    [0, -1],
                    [1, -1],
                    [1, -0.875],
                    [0.75, -0.875],
                    [0.75, -0.75],
                    [0.5, -0.75],
                    [0.5, -0.25],
                    [0.75, -0.25],
                    [0.75, -0.125],
                    [1, -0.125],
                    [1, 0],
                ].reverse()
            ),
            15: new PlinthShape(3, 10, [
                    [0, -1],
                    [1, -1],
                    [1, -0.88],
                    [0.66, -0.88],
                    [0.66, -0.77],
                    [1, -0.77],
                    [1, -0.66],
                    [0.66, -0.66],
                    [0.66, -0.33],
                    [1, -0.33],
                    [1, -0.22],
                    [0.66, -0.22],
                    [0.66, -0.11],
                    [1, -0.11],
                    [1, 0],
                ].reverse()
            ),
        };

        this.PoolData = {};

        this.order = {};
        this.order[this.PLINTH_TYPES.PLINTHS] = [];
        this.order[this.PLINTH_TYPES.MOLDINGS] = [];

        this.loadPlinthsData(this.PLINTH_TYPES.PLINTHS).then(() => {
            this.defBottomId = R2D.config.data.default_materials.plinth.entityId || 0;
            this.loadSVG(this.defBottomId);
        });
        this.loadPlinthsData(this.PLINTH_TYPES.MOLDINGS).then(() => {
            this.defTopId = R2D.config.data.default_materials.molding.entityId || 8;
            this.loadSVG(this.defTopId);
        });
    }

    // ----------------------METHODS----------------------
    getShapePath(id) {
        return this.PoolPlinthShape[id]?.path;
    }

    getDistToCeiling(id) {
        return this.PoolPlinthShape[id]?.distToCeiling;
    }

    getDefDepth(id) {
        return this.PoolPlinthShape[id]?.defDepth;
    }

    getDefHeight(id) {
        return this.PoolPlinthShape[id]?.defHeight;
    }

    getImgSrc(id, plinthType) {
        let imgSrc = "";
        const type =
            plinthType === "bottomPlinth"
                ? this.PLINTH_TYPES.PLINTHS
                : this.PLINTH_TYPES.MOLDINGS;

        if (this.PoolData[type][id]) {
            imgSrc = R2D.makeURL(
                R2D.URL.DOMAIN,
                this.PoolData[type][id].source.images.preview
            );
        } else if (plinthType === "bottomPlinth") {
            imgSrc = `/src_designer/images/plinth/b${id}.png`;
        } else if (plinthType === "topPlinth") {
            const fixId = Number(id) > 7 ? Number(id) - 8 : Number(id);
            imgSrc = `/src_designer/images/molding/t${fixId}.png`;
        }

        return imgSrc;
    }

    getPlinthName(id, plinthType) {
        let imgName = "";
        const type =
            plinthType === "bottomPlinth"
                ? this.PLINTH_TYPES.PLINTHS
                : this.PLINTH_TYPES.MOLDINGS;
        if (this.PoolData[type][id]) {
            imgName = this.PoolData[type][id].name;
        }
        return imgName;
    }

    isSVGLoaded(id) {
        return !!this.PoolPlinthShape[id];
    }

    async loadProductData(id) {
        const json = { ids: id };
        const body = `json=${JSON.stringify(json)}`;
        const response = await fetch(R2D.URL.DOMAIN + R2D.URL.URL_GET_PRODUCT, {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            body,
        });
        const data = await response.json();
        return data;
    }

    async loadPlinthsData(type) {
        if (!this.PoolData[type]) {

            const siteKey = R2D.URL.MERCHANT_SITE_KEY ? `&key=${R2D.URL.MERCHANT_SITE_KEY}` : '';

            let url = `${R2D.URL.DOMAIN}/api/category/products?category_tag=${type}${siteKey}`;
            let headers = {};
            if (R2D.token)
            {
                headers["x-token"] = R2D.token;
            }
    
            if (R2D.language)
            {
                headers["x-lang"] = R2D.language;
            }

            const response = await fetch(
                url,
                {
                    method: "GET",
                    credentials: 'include',
                    mode: 'cors',
                    headers
                }
            );
            const data = await response.json();

            this.PoolData[type] = {};
            data.products.forEach((product) => {
                this.order[type].push(product.id);
                this.PoolData[type][product.id] = product;
            });
        }
        return this.PoolData[type];
    }

    getPlinthsList(type) {
        return this.order[type].map((id) => ({
            id,
            imgSrc: R2D.makeURL(
                R2D.URL.DOMAIN,
                this.PoolData[type][id].source.images.preview
            ),
            name: this.PoolData[type][id].name,
        }));

    }

    loadSVG(id) {
        return new Promise((resolve, reject) => {
            if (this.isSVGLoaded(id)) {
                resolve();
            } else {
                this.createPlinthShape(id).then(() => resolve());
            }
        });
    }

    async createPlinthShape(id) {
        let productData = null;
        let curType = "";

        if (this.PoolData[this.PLINTH_TYPES.PLINTHS]?.[id]) {
            productData = this.PoolData[this.PLINTH_TYPES.PLINTHS][id];
            curType = this.PLINTH_TYPES.PLINTHS;
        } else if (this.PoolData[this.PLINTH_TYPES.MOLDINGS]?.[id]) {
            productData = this.PoolData[this.PLINTH_TYPES.MOLDINGS][id];
            curType = this.PLINTH_TYPES.MOLDINGS;
        } else {
            console.log("Plinth doesn't exist");
            return;
        }

        const url = R2D.makeURL(R2D.URL.DOMAIN, productData.source.body.package);
        const height = parseInt(productData.property.sizes.height) || 6;
        const depth = parseInt(productData.property.sizes.depth) || 3;
        const distToCeiling = parseInt(productData.property.position.y) || 0;

        const response = await fetch(url);
        const textSVG = await response.text();

        const pathSVG = getPathFromSVG(textSVG);
        const spacedPath = addSpaces(pathSVG);
        const arr = spacedPath.split(" ");

        let path = [];
        const res = [];
        const cur = { x: 0, y: 0 };

        arr.forEach((ch, i) => {
            if (!Number(ch)) {
                switch (ch) {
                    case "M":
                        cur.x = Number(arr[i + 1]);
                        cur.y = Number(arr[i + 2]);
                        res.push([cur.x, cur.y]);
                        break;

                    case "V":
                        cur.y = Number(arr[i + 1]);
                        res.push([cur.x, cur.y]);
                        break;

                    case "H":
                        cur.x = Number(arr[i + 1]);
                        res.push([cur.x, cur.y]);
                        break;

                    case "L":
                        cur.x = Number(arr[i + 1]);
                        cur.y = Number(arr[i + 2]);
                        res.push([cur.x, cur.y]);
                        break;

                    default:
                        break;
                }
            }
        });

        const maxX = Math.max(...res.map((el) => el[0]));
        const maxY = Math.max(...res.map((el) => el[1]));

        if (curType === this.PLINTH_TYPES.PLINTHS) {
            path = res.map((el) => [
                Number((el[0] / maxX).toFixed(2)),
                Number((1 - el[1] / maxY).toFixed(2)),
            ]);
        } else if (curType === this.PLINTH_TYPES.MOLDINGS) {
            path = res.map((el) => [
                Number((el[0] / maxX).toFixed(2)),
                Number((-el[1] / maxY).toFixed(2)),
            ]);
        }

        this.PoolPlinthShape[id] = new PlinthShape(depth, height, path, distToCeiling);

        // ------functions---------
        function getPathFromSVG(SVGString) {
            const startIndex = SVGString.indexOf("d=") + 3;
            let newString = SVGString.substring(startIndex);
            const endIndex = newString.indexOf("Z") + 1;
            newString = newString.substring(0, endIndex);
            return newString;
        }

        function addSpaces(str) {
            let spacedString = "";
            for (let i = 0; i < str.length; i++) {
                if (str[i] === "M") {
                    spacedString += "M ";
                } else if (str[i] === "V" || str[i] === "H" || str[i] === "L") {
                    spacedString += ` ${str[i]} `;
                } else if (str[i] === "Z") {
                    spacedString += " Z";
                } else {
                    spacedString += str[i];
                }
            }
            return spacedString;
        }
    }
}

WC.ROOM_POINT = 'rp';
WC.COVER_POINT = 'cp';

WC.UP = 'up';
WC.OVER = 'over';
WC.DOWN = 'down';

WC.CPoint = function(x, y, type)
{
    var me = this;

    me.x = x;
    me.y = y;
    me.type = type;
    me.state = WC.UP;
    me.children = [];
    me.parent = null;
    me.contour = null;
    me.areas = [];

    me.move = function(x, y)
    {
        me.x = x;
        me.y = y;

        for (var i = 0; i < me.children.length; i++)
        {
            me.children[i].x = x;
            me.children[i].y = y;
        }
    };

    me.disconnect = function()
    {
        if (me.type == WC.ROOM_POINT)
        {
            for (var i = 0; i < me.children.length; i++) me.children[i].parent = null;
            me.children = [];
        }
        else if (me.type == WC.COVER_POINT)
        {
            if (me.parent)
            {
                i = me.parent.children.indexOf(me);
                if (i >= 0) me.parent.children.splice(i, 1);
                me.parent = null;
            }
        }
    };

    me.clone = function()
    {
        return new WC.CPoint(me.x, me.y, me.type);
    };

    me.match = function(P = {}, accuracy)
    {
        accuracy = typeof accuracy !== 'undefined' ? accuracy : TR.L_EPS;

        return ((Math.abs(P?.x - me.x) < accuracy) && (Math.abs(P?.y - me.y) < accuracy));
    }
};

WC.CWall = function(point1, point2, data)
{
    var me = this;

    me.point1 = point1;
    me.point2 = point2;

    me.data = data;
};

WC.CCut = function(point1, point2, data)
{
    var me = this;

    me.point1 = point1;
    me.point2 = point2;

    me.data = data;
};

WC.CContour = function(outer)
{
    var me = this;

    me.area = 0;
    me.outer = outer;
    me.points = [];
    me.holes = [];
    me.triangles = [];

    me.addPoint = function(point)
    {
        me.points.push(point);
        point.contour = me;
    };

    me.addPointAt = function(point, index)
    {
        me.points.splice(index, 0, point);
        point.contour = me;
    };

    me.delPoint = function(point)
    {
        var i = me.points.indexOf(point);
        if (i >= 0) me.points.splice(i, 1);
    };

    me.calcArea = function()
    {
        var a = 0;
        for (var i = 0; i < me.points.length - 1; i++)
        {
            a += (me.points[i].y + me.points[i + 1].y) / 2 * (me.points[i + 1].x - me.points[i].x);
        }

        a += (me.points[me.points.length - 1].y + me.points[0].y) / 2 * (me.points[0].x - me.points[me.points.length - 1].x);

        me.area = a;
        return a;
    };

    me.getFillArea = function()
    {
        var area = 0;
        for (var i = 0; i < me.triangles.length; i++)
        {
            var a =  me.triangles[i][0];
            var b =  me.triangles[i][1];
            var c =  me.triangles[i][2];
            area += TR.triangleArea(a[0], a[1], b[0], b[1], c[0], c[1]);
        }
        return area;
    }
};

WC.CRoom = function(outer, data)
{
    WC.CContour.call(this, outer);

    var me = this;

    if (data)
    {
        me.data = data;
    }
    else
    {
        me.data = {}
    }
};

WC.CRoom.prototype = Object.create(WC.CContour.prototype);
WC.CRoom.prototype.constructor = WC.CRoom;

WC.CCover = function(outer, data)
{
    WC.CContour.call(this, outer);

    var me = this;

    if (data)
    {
        me.data = data;
    }
    else
    {
        me.data =
        {
            materialID:R2D.default.getDefaultMaterialByKey("cover"),
            addMaterialID:R2D.default.getDefaultAddMaterialByKey("cover"),
            materialRotation:0,
            materialX:0,
            materialY:0,

            ceiling:
            {
                exists:true,
                height:WC.DEFAULT_WALLS_HEIGHT,
                materialID:R2D.default.getDefaultMaterialByKey("ceiling"),
                addMaterialID:R2D.default.getDefaultAddMaterialByKey("ceiling"),
                materialRotation:0,
                materialX:0,
                materialY:0
            }
        };
    }

    me.getCeilingHeight = function()
    {
        return me.data.ceiling.height;
    };

    me.setCeilingHeight = function(h)
    {
        me.data.ceiling.height = h;
    };

    me.getCeilingVisible = function()
    {
        return me.data.ceiling.exists;
    };

    me.setCeilingVisible = function(v)
    {
        me.data.ceiling.exists = v;
    }
};

WC.CCover.prototype = Object.create(WC.CContour.prototype);
WC.CCover.prototype.constructor = WC.CCover;

WC.CArea = function(data)
{
    WC.CContour.call(this, true);

    var me = this;

    me.data = data;
    me.height = 100;

    if (!me.data)
    {
        me.data =
        {
            materialID:R2D.default.getDefaultMaterialByKey("cap"),
            addMaterialID:R2D.default.getDefaultAddMaterialByKey("cap"),
            materialRotation:0,
            materialX:0,
            materialY:0,

            ceiling:
            {
                exists:true,
                height:WC.DEFAULT_WALLS_HEIGHT,
                materialID:R2D.default.getDefaultMaterialByKey("cap"),
                addMaterialID:R2D.default.getDefaultAddMaterialByKey("cap"),
                materialRotation:0,
                materialX:0,
                materialY:0
            }
        }
    }

    me.addPoint = function(point)
    {
        me.points.push(point);
        point.areas.push(me);
    };

    me.addPointAt = function(point, index)
    {
        me.points.splice(index, 0, point);
        point.areas.push(me);
    };

    me.delPoint = function(point)
    {
        var i = me.points.indexOf(point);
        if (i >= 0) me.points.splice(i, 1);

        i = point.areas.indexOf(me);
        if (i >= 0) point.areas.splice(i, 1);
    };

    me.getAllPairs = function()
    {
        var pts = me.points.concat(me.points[0]);
        var cutPairs = [];

        for (var i = 0; i < pts.length - 1; i++)
        {
            cutPairs.push([pts[i], pts[i + 1]]);
        }

        return cutPairs;
    };

    me.getCutWallPairs = function() // [cutPairs, wallPairs]
    {
        var pts = me.points.concat(me.points[0]);
        var cutPairs = [];
        var wallPairs = [];

        for (var i = 0; i < pts.length - 1; i++)
        {
            var A = pts[i];
            var B = pts[i + 1];
            if (A.contour != B.contour)
            {
                cutPairs.push([A, B]);
                continue;
            }

            var cont = A.contour.points;
            var indA = cont.indexOf(A);
            var indB = cont.indexOf(B);

            if (Math.abs(indA - indB) > 1 && Math.abs(indA - indB) != cont.length - 1)
            {
                cutPairs.push([A, B]);
            }
            else
            {
                wallPairs.push([A, B]);
            }
        }

        return [cutPairs, wallPairs];
    };

    me.getHeight = function()
    {
        return me.height;
    };

    me.setHeight = function(h)
    {
        me.height = h;
    };

    me.getCeilingHeight = function()
    {
        return me.data.ceiling.height;
    };

    me.setCeilingHeight = function(h)
    {
        me.data.ceiling.height = h;
    };

    me.getCeilingVisible = function()
    {
        return me.data.ceiling.exists;
    };

    me.setCeilingVisible = function(v)
    {
        me.data.ceiling.exists = v;
    }
};

WC.CArea.prototype = Object.create(WC.CContour.prototype);
WC.CArea.prototype.constructor = WC.CArea;


WC.CRawContour = function()
{
    var me = this;

    me.points = [];

    me.addPoint = function(point)
    {
        me.points.push(point);
        point.contour = me;
    };

    me.delPoint = function(point)
    {
        var i = me.points.indexOf(point);
        if (i >= 0) me.points.splice(i, 1);
    };

    me.addPointAt = function(point, index)
    {
        me.points.splice(index, 0, point);
        point.contour = me;
    };
};

WC.Ruler = function(A, B)
{
    var me = this;
    me.aligner1 = {center: new TR.Point(A.x, A.y), dragPt: new TR.Point(0, 0), state: 'up'};
    me.aligner2 = {center: new TR.Point(B.x, B.y), dragPt: new TR.Point(0, 0), state: 'up'};

    me.calcDragPoints = function()
    {
        me.aligner1.dragPt.x = me.aligner1.center.x;
        me.aligner1.dragPt.y = me.aligner1.center.y - 20 / WC.wallsEditor.scale;
        me.aligner2.dragPt.x = me.aligner2.center.x;
        me.aligner2.dragPt.y = me.aligner2.center.y - 20 / WC.wallsEditor.scale;
    };

    me.getDragPoints = function()
    {
        return [me.aligner1.dragPt, me.aligner2.dragPt];
    };

    me.calcDragPoints();
};
WC.SnapTool = function()
{
    var me = this;

    me.allPoints = [];

    me.findNearSegments = function(P)
    {
        var res = [];

        for (var i = 0; i < WC.core.arrRooms.length; i++)
        {
            for (var j = 0; j < WC.core.arrRooms[i].points.length; j++)
            {
                var p1 = WC.core.arrRooms[i].points[j];
                var p2 = WC.core.arrRooms[i].points[0];
                if (j < WC.core.arrRooms[i].points.length - 1) p2 = WC.core.arrRooms[i].points[j + 1];

                var d1 = TR.manhDist(P.x, P.y, p1.x, p1.y);
                var d2 = TR.manhDist(P.x, P.y, p2.x, p2.y);

                if (d1 < TR.B_EPS)
                {
                    res.push(p2);
                }
                else if (d2 < TR.B_EPS)
                {
                    res.push(p1);
                }
            }
        }

        if (res.length == 2) return res;
        if (res.length != 0) return [];

        for (i = 0; i < WC.core.arrRooms.length; i++)
        {
            for (j = 0; j < WC.core.arrRooms[i].points.length; j++)
            {
                p1 = WC.core.arrRooms[i].points[j];
                p2 = WC.core.arrRooms[i].points[0];
                if (j < WC.core.arrRooms[i].points.length - 1) p2 = WC.core.arrRooms[i].points[j + 1];

                if (TR.pointOnLine(P, p1, p2, TR.B_EPS))
                {
                    res.push(p1);
                    res.push(p2);
                }
            }
        }

        if (res.length == 2) return res;
        return [];
    };

    me.reset = function()
    {
        if (WC.core.rawCont)
        {
            me.allPoints = WC.core.roomPoints.concat(WC.core.rawCont.points);
            me.allPoints = me.allPoints.concat(WC.core.coverPoints);
        }
        else
        {
            me.allPoints = WC.core.roomPoints;
            me.allPoints = me.allPoints.concat(WC.core.coverPoints);
        }
    };

    me.findNearest = function(P, points, maxDist)
    {
        if (! P) return null;

        var nearestPt;
        var minDist = Number.MAX_VALUE;
        var pts = points;

        for (var i = 0; i < pts.length; i++)
        {
            var Q = pts[i];
            var d = TR.manhDist(P.x, P.y, Q.x, Q.y);

            if (d < minDist)
            {
                nearestPt = Q;
                minDist = d;
            }
        }

        if (minDist <= maxDist) return nearestPt;
        return null;
    };

    me.snapToNearest = function(P, snapDist, exceptPoints)
    {
        var nearestPt;
        var minDist = Number.MAX_VALUE;
        var pts = me.allPoints;

        for (var i = 0; i < pts.length; i++)
        {
            var Q = pts[i];
            var d = TR.manhDist(P.x, P.y, Q.x, Q.y);

            if (d < minDist && exceptPoints.indexOf(Q) == -1)
            {
                nearestPt = Q;
                minDist = d;
            }
        }

        if (minDist <= snapDist) return nearestPt;
        return null;
    };

    var pointInFrame = function(P)
    {
        if (P.x < WC.framePointLT.x) return false;
        if (P.y < WC.framePointLT.y) return false;
        if (P.x > WC.framePointRB.x) return false;
        if (P.y > WC.framePointRB.y) return false;

        return true;
    };

    function snapX(P, snapDist, allPoints, exceptPoints, farPoints)
    {
        var pts;

        if (allPoints && allPoints.length > 0)
        {
            pts = allPoints;
        }
        else
        {
            pts = me.allPoints;
        }

        var minDistM = Number.MAX_VALUE;
        var minDistP = Number.MAX_VALUE;
        var minSideDistM = Number.MAX_VALUE;
        var minSideDistP = Number.MAX_VALUE;
        var alignerM = null;
        var alignerP = null;

        for (var i = 0; i < pts.length; i++)
        {
            var Q = pts[i];
            if (exceptPoints.indexOf(Q) >= 0 || (! pointInFrame(Q) && farPoints.indexOf(Q) == -1)) continue;

            var dx = Math.abs(P.x - Q.x);
            var dy = Math.abs(P.y - Q.y);

            if (Q.y < P.y)
            {
                if ((dx < minDistM - TR.L_EPS) || (dx < minDistM + TR.L_EPS && dy < minSideDistM - TR.L_EPS))
                {
                    alignerM = Q;
                    minDistM = dx;
                    minSideDistM = dy;
                }
            }
            else
            {
                if ((dx < minDistP - TR.L_EPS) || (dx < minDistP + TR.L_EPS && dy < minSideDistP - TR.L_EPS))
                {
                    alignerP = Q;
                    minDistP = dx;
                    minSideDistP = dy;
                }
            }
        }

        if (minDistM > snapDist) alignerM = null;
        if (minDistP > snapDist) alignerP = null;

        if (minDistM > minDistP + TR.B_EPS) alignerM = null;
        if (minDistP > minDistM + TR.B_EPS) alignerP = null;

        return [alignerM, alignerP];
    }

    function snapY(P, snapDist, allPoints, exceptPoints, farPoints)
    {
        var pts;

        if (allPoints && allPoints.length > 0)
        {
            pts = allPoints;
        }
        else
        {
            pts = me.allPoints;
        }

        var minDistM = Number.MAX_VALUE;
        var minDistP = Number.MAX_VALUE;
        var minSideDistM = Number.MAX_VALUE;
        var minSideDistP = Number.MAX_VALUE;
        var alignerM = null;
        var alignerP = null;

        for (var i = 0; i < pts.length; i++)
        {
            var Q = pts[i];
            if (exceptPoints.indexOf(Q) >= 0 || (! pointInFrame(Q) && farPoints.indexOf(Q) == -1)) continue;

            var dy = Math.abs(P.y - Q.y);
            var dx = Math.abs(P.x - Q.x);

            if (Q.x < P.x)
            {
                if ((dy < minDistM - TR.L_EPS) || (dy < minDistM + TR.L_EPS && dx < minSideDistM - TR.L_EPS))
                {
                    alignerM = Q;
                    minDistM = dy;
                    minSideDistM = dx;
                }
            }
            else
            {
                if ((dy < minDistP - TR.L_EPS) || (dy < minDistP + TR.L_EPS && dx < minSideDistP - TR.L_EPS))
                {
                    alignerP = Q;
                    minDistP = dy;
                    minSideDistP = dx;
                }
            }
        }

        if (minDistM > snapDist) alignerM = null;
        if (minDistP > snapDist) alignerP = null;

        if (minDistM > minDistP + TR.B_EPS) alignerM = null;
        if (minDistP > minDistM + TR.B_EPS) alignerP = null;

        return [alignerM, alignerP];
    }

    me.snapPerpendicular = function(P, snapDist, allPoints, exceptPoints, farPoints)
    {
        var alignersX = snapX(P, snapDist, allPoints, exceptPoints, farPoints);
        var alignersY = snapY(P, snapDist, allPoints, exceptPoints, farPoints);

        var newX = P.x;
        var newY = P.y;

        var alignerX = null;
        var alignerY = null;

        if (alignersX[0] && ! alignersX[1])
        {
            alignerX = alignersX[0];
        }
        else if (! alignersX[0] && alignersX[1])
        {
            alignerX = alignersX[1];
        }
        else if (alignersX[0] && alignersX[1])
        {
            alignerX = alignersX[0];
            if (TR.manhDistP(alignersX[0], P) > TR.manhDistP(alignersX[1], P)) alignerX = alignersX[1];
        }

        if (alignersY[0] && ! alignersY[1])
        {
            alignerY = alignersY[0];
        }
        else if (! alignersY[0] && alignersY[1])
        {
            alignerY = alignersY[1];
        }
        else if (alignersY[0] && alignersY[1])
        {
            alignerY = alignersY[0];
            if (TR.manhDistP(alignersY[0], P) > TR.manhDistP(alignersY[1], P)) alignerY = alignersY[1];
        }

        if (alignerX) newX = alignerX.x;
        if (alignerY) newY = alignerY.y;

        if (! alignerX && ! alignerY) return [null, null, null];

        return [new WC.CPoint(newX, newY), alignerX, alignerY, alignersX, alignersY];
    };

    me.orthogonalSnap = function(P, snapDist)
    {
        var resPt = P.clone();
        var snapPts;

        var cont = WC.core.rawCont;
        if (cont && (cont.points.length > 1))
        {
            snapPts = [cont.points[cont.points.length - 2], cont.points[0]];

            return me.snapPerpendicular(P, snapDist, snapPts, [], []);
        }

        return [null, null, null];
    };

    me.bisectorSnap = function(P, snapDist, exceptPoints)
    {
        var searchRadius = snapDist * 10;
        var nearPt = me.snapToNearest(P, searchRadius, exceptPoints);

        if (! nearPt) return null;

        if (! nearPt.contour) return null;
        var pts = nearPt.contour.points;

        var A, B;

        var i = pts.indexOf(nearPt);
        if (i == -1) return null;

        if (i == 0)
        {
            A = pts[pts.length - 1];
            B = pts[1];
        }
        else if (i == pts.length - 1)
        {
            A = pts[pts.length - 2];
            B = pts[0];
        }
        else
        {
            A = pts[i - 1];
            B = pts[i + 1];
        }

        var Q = TR.bisectorPoint(nearPt, A, B);

        if (! Q) return null;

        if (Math.abs(TR.distanceBetweenPointAndLine(P, nearPt, Q, false)) > snapDist) return null;

        return [nearPt, Q];
    };

    me.pointsSnap = true;
    me.pointsAlign = true;
    me.orthoAlign = false;
    me.bisectorAlign = true;

    me.getSnapPoint = function(P, exceptNodes, snapDist, farNodes)
    {
        var resTarget = P;

        var pointPt = null;
        var orthoPt = null;
        var nearPt = null;

        var orthoX = null;
        var orthoY = null;

        var alignerX = null;
        var alignerY = null;
        var alignersX = null;
        var alignersY = null;

        var bisCenter = null;
        var bisDirect = null;
        var alignerD = null;

        if (me.pointsSnap)
        {
            nearPt = me.snapToNearest(P, snapDist, exceptNodes);
        }
        else
        {
            nearPt = me.snapToNearest(P, 2, exceptNodes);
        }

        if (me.pointsAlign)
        {
            var pts = me.snapPerpendicular(P, snapDist, [], exceptNodes, farNodes);

            pointPt = pts[0];
            alignerX = pts[1];
            alignerY = pts[2];
            alignersX = pts[3];
            alignersY = pts[4];
        }

        if (me.orthoAlign)
        {
            pts = me.orthogonalSnap(P, snapDist);
            if (pts)
            {
                orthoPt = pts[0];
                orthoX = pts[1];
                orthoY = pts[2];
            }
        }

        if (me.bisectorAlign)
        {
            pts = me.bisectorSnap(P, snapDist, exceptNodes);
            if (pts)
            {
                bisCenter = pts[0];
                bisDirect = pts[1];
            }
        }

        if (nearPt && TR.manhDist(P.x, P.y, nearPt.x, nearPt.y) < snapDist)
        {
            resTarget = nearPt;
        }
        else if (me.pointsAlign && pointPt && alignerX && alignerY)
        {
            resTarget = pointPt;
        }
        else if (me.pointsAlign && bisCenter && bisDirect && alignerX)
        {
            var A = TR.lineIntersectLine(bisCenter, bisDirect, alignerX, new TR.Point(alignerX.x, alignerX.y + 10), false);
            if (A && TR.manhDist(P.x, P.y, A.x, A.y) < snapDist)
            {
                resTarget = A;
                alignerD = bisCenter;
            }
            else
            {
                resTarget = pointPt;
            }
        }
        else if (me.pointsAlign && bisCenter && bisDirect && alignerY)
        {
            A = TR.lineIntersectLine(bisCenter, bisDirect, alignerY, new TR.Point(alignerY.x + 10, alignerY.y), false);
            if (A && TR.manhDist(P.x, P.y, A.x, A.y) < snapDist)
            {
                resTarget = A;
                alignerD = bisCenter;
            }
            else
            {
                resTarget = pointPt;
            }
        }
        else if (me.orthoAlign && orthoPt && bisCenter && bisDirect)
        {
            A = null;
            if (orthoX) A = TR.lineIntersectLine(bisCenter, bisDirect, orthoX, new TR.Point(orthoX.x, orthoX.y + 10), false);
            if (orthoY) A = TR.lineIntersectLine(bisCenter, bisDirect, orthoY, new TR.Point(orthoY.x + 10, orthoY.y), false);

            if (A && TR.manhDist(P.x, P.y, A.x, A.y) < snapDist)
            {
                resTarget = A;
                alignerD = bisCenter;
            }
            else
            {
                resTarget = orthoPt;
            }
        }
        else if (me.pointsAlign && pointPt)
        {
            resTarget = pointPt;
        }
        else if (me.orthoAlign && orthoPt)
        {
            resTarget = orthoPt;
        }
        else if (me.bisectorAlign && bisCenter && bisDirect)
        {
            A = TR.projectionPointOnLine(P, bisCenter, bisDirect, false);

            if (A && TR.manhDist(P.x, P.y, A.x, A.y) < snapDist)
            {
                resTarget = A;
                alignerD = bisCenter;
            }
        }

        resTarget = TR.roundCoord(resTarget);

        return [resTarget, alignerX, alignerY, alignerD, alignersX, alignersY];
    };

    
};

WC.DrawTool = function()
{
    var me = this;

    me.drawWallSize = function(A, B, showDimension = true)
    {
        if (!A || !B) return;
        var ang = Math.atan2(B.y - A.y, B.x - A.x);
        var shA = new TR.Point(A.x, A.y);
        var shB = new TR.Point(B.x, B.y);

        var d = 3 / WC.wallsEditor.scale;
        var eps = 0.2;

        if (showDimension) {
            if (ang > - Math.PI / 2 - eps && ang < Math.PI / 2 - eps)
            {
                shA = TR.perpendicularPoint(A, B, d);
                shB = TR.perpendicularPoint(B, A, -d);
            }
            else
            {
                shA = TR.perpendicularPoint(A, B, -d);
                shB = TR.perpendicularPoint(B, A, d);
            }
        };

        var locA = WC.wallsEditor.realToView(shA);
        var locB = WC.wallsEditor.realToView(shB);

        WC.context.strokeStyle = '#dd0066';
        WC.context.beginPath();
        WC.context.moveTo(locA.x + 0.5, locA.y + 0.5);
        WC.context.lineTo(locB.x + 0.5, locB.y + 0.5);
        WC.context.stroke();
        WC.context.closePath();

        if (showDimension) {
            var txt = R2D.DimensionSystem.toString(TR.euclDistP(A, B).toFixed(1));
            if (R2D.DimensionSystem.isMetric()) txt = txt + ' ' + R2D.DimensionSystem.getName();

            var locPos = WC.wallsEditor.realToView(WC.realPos);
            WC.context.save();
            WC.context.translate(locPos.x + 20, locPos.y + 30);
            WC.context.textAlign = "center";
            WC.context.textBaseline = "middle";
            WC.context.font = "10pt Arial";
            //WC.context.strokeStyle = 'white';
            WC.context.strokeStyle = "rgba(255, 255, 255, 0.7)";
            WC.context.lineWidth = 4;
            WC.context.fillStyle = '#dd0066';
            WC.context.strokeText(txt, 0, 0);
            WC.context.fillText(txt, 0, 0);
            WC.context.restore();
        }
    };

    me.blocksFromContour = function(inputCont, wallsWidth, startNeighbSegments)
    {
        var recalcAng = Math.PI * 0.75;

        if (inputCont.length <= 1) return [];
        if (inputCont.length == 2 && TR.euclDistP(inputCont[0], inputCont[1]) < wallsWidth) return [];

        var res = [];
        var d = -wallsWidth;
        var maxDist = wallsWidth * 2;

        var contour;

        if  (inputCont.length == 2)
        {
            var P0 = inputCont[0];
            var P1 = inputCont[1];

            var P0s = TR.perpendicularPoint(P0, P1, d);
            var P1s = TR.perpendicularPoint(P1, P0, -d);

            var X = null;
            if (startNeighbSegments && startNeighbSegments.length > 0)
            {
                var X0 = TR.lineIntersectLine(P0s, P1s, P0, startNeighbSegments[0], false);
                if (X0 && ! TR.pointOnLine(X0, P0, startNeighbSegments[0])) X0 = null;
                var X1 = TR.lineIntersectLine(P0s, P1s, P0, startNeighbSegments[1], false);
                if (X1 && ! TR.pointOnLine(X1, P0, startNeighbSegments[1])) X1 = null;
                if (X0 && X1)
                {
                    var d0 = TR.euclDistP(X0, P1s);
                    var d1 = TR.euclDistP(X1, P1s);
                    X = X0;
                    if (d0 > d1) X = X1;
                }
                else if (X0)
                {
                    X = X0;
                }
                else if (X1)
                {
                    X = X1;
                }
            }

            if (X)
            {
                return [[X.clone(), P1s.clone(), P1.clone(), P0.clone()]];
            }
            else
            {
                return [[P0s.clone(), P1s.clone(), P1.clone(), P0.clone()]];
            }

        }
        else if (! inputCont[0].match(inputCont[inputCont.length - 1]))
        {
            var block;
            if (TR.euclDistP(inputCont[inputCont.length - 1], inputCont[inputCont.length - 2]) < wallsWidth)
            {
                contour = inputCont.slice(0, -1);
            }
            else
            {
                contour = [].concat(inputCont);
            }

            P0 = contour[0];
            P1 = contour[1];

            P0s = TR.perpendicularPoint(P0, P1, d);
            P1s = TR.perpendicularPoint(P1, P0, -d);

            X = null;
            if (startNeighbSegments && startNeighbSegments.length > 0)
            {
                X0 = TR.lineIntersectLine(P0s, P1s, P0, startNeighbSegments[0], false);
                if (X0 && ! TR.pointOnLine(X0, P0, startNeighbSegments[0])) X0 = null;
                X1 = TR.lineIntersectLine(P0s, P1s, P0, startNeighbSegments[1], false);
                if (X1 && ! TR.pointOnLine(X1, P0, startNeighbSegments[1])) X1 = null;
                if (X0 && X1)
                {
                    d0 = TR.euclDistP(X0, P1s);
                    d1 = TR.euclDistP(X1, P1s);
                    X = X0;
                    if (d0 > d1) X = X1;
                }
                else if (X0)
                {
                    X = X0;
                }
                else if (X1)
                {
                    X = X1;
                }
            }

            var A = TR.perpendicularPoint(contour[0], contour[1], d);
            if (X) A = X;
            var B = contour[0];

            for (var i = 1; i < contour.length - 1; i++)
            {
                P0 = contour[i - 1];
                P1 = contour[i];
                var P2 = contour[i + 1];

                var L0 = TR.perpendicularPoint(P0, P1, d);
                var R0 = P0;
                var L01 = TR.perpendicularPoint(P1, P0, -d);
                var R01 = P1;

                var L12 = TR.perpendicularPoint(P1, P2, d);
                var R12 = P1;
                var L2 = TR.perpendicularPoint(P2, P1, -d);
                var R2 = P2;

                var C = TR.lineIntersectLine(L0, L01, L12, L2, false);
                var D = TR.lineIntersectLine(R0, R01, R12, R2, false);
                if (! C) C = L01;
                if (! D) D = R01;

                var ang = TR.angleBetweenLines(P0.x, P0.y, P1.x, P1.y, P1.x, P1.y, P2.x, P2.y);

                if (ang > recalcAng && ang < 2 * Math.PI - recalcAng && ! TR.pointInBounds(C, D, L2))
                {
                    C = L01;
                    D = R01;

                    block = [];
                    block.push(A.clone(), C.clone(), D.clone(), B.clone());
                    res.push(block);

                    A = L12;
                    B = R12;
                }
                else
                {
                    block = [];
                    block.push(A.clone(), C.clone(), D.clone(), B.clone());
                    res.push(block);

                    A = C;
                    B = D;
                }
            }

            C = TR.perpendicularPoint(contour[contour.length - 1], contour[contour.length - 2], -d);
            D = contour[contour.length - 1];

            block = [];
            block.push(A.clone(), C.clone(), D.clone(), B.clone());
            res.push(block);

            return res;
        }
        else
        {
            contour = [].concat(inputCont);
            contour.push(contour[1], contour[2]);

            for (i = 1; i < contour.length - 1; i++)
            {
                P0 = contour[i - 1];
                P1 = contour[i];
                P2 = contour[i + 1];

                L0 = TR.perpendicularPoint(P0, P1, d);
                R0 = P0;
                L01 = TR.perpendicularPoint(P1, P0, -d);
                R01 = P1;

                L12 = TR.perpendicularPoint(P1, P2, d);
                R12 = P1;
                L2 = TR.perpendicularPoint(P2, P1, -d);
                R2 = P2;

                C = TR.lineIntersectLine(L0, L01, L12, L2, false);
                D = TR.lineIntersectLine(R0, R01, R12, R2, false);
                if (! C) C = L01;
                if (! D) D = R01;

                ang = TR.angleBetweenLines(P0.x, P0.y, P1.x, P1.y, P1.x, P1.y, P2.x, P2.y);

                if (ang > recalcAng && ang < 2 * Math.PI - recalcAng)
                {
                    C = L01;
                    D = R01;

                    if (A && B)
                    {
                        block = [];
                        block.push(A.clone(), C.clone(), D.clone(), B.clone());
                        res.push(block);
                    }

                    A = L12;
                    B = R12;
                }
                else
                {
                    if (A && B)
                    {
                        block = [];
                        block.push(A.clone(), C.clone(), D.clone(), B.clone());
                        res.push(block);
                    }

                    A = C;
                    B = D;
                }
            }

            return res;
        }
    };
};

WC.WallsCommander = function()
{
    var me = this;
    var stack = [];
    var pointer = -1;

    me.save = function()
    {
    //    console.log('save');

        if (pointer < stack.length - 1) stack.splice(pointer + 1);
        stack.push(me.getData());
        pointer = stack.length - 1;

    //    me.printStack();
    //    console.log(pointer + '/' + stack.length);
    };

    me.undo = function()
    {
        if (pointer < 1) return;
        pointer--;
        me.setData(stack[pointer]);
    };

    me.redo = function()
    {
        if (pointer >= stack.length - 1) return;
        pointer++;
        me.setData(stack[pointer]);
    };

    me.canUndo = function()
    {
        return pointer >= 1;
    };

    me.canRedo = function()
    {
        return pointer < stack.length - 1;
    };

    me.printStack = function()
    {
        console.log('- stack -');
        for (var i = 0; i < stack.length; i++)
        {
            var obj = stack[i];
            var str =   'Points: ' + obj.roomPoints.length + ', ' +
                        'rooms: ' + obj.arrRooms.length + ', ' +
                        'areas: ' + obj.arrAreas.length;
            if (pointer == i) str += '  <<<';
            console.log(str);
        }

        console.log('---------');
    };

    me.getData = function()
    {
        var dataObj = {};

        dataObj.roomPoints = new Array(WC.core.roomPoints.length);
        for (var i = 0; i < WC.core.roomPoints.length; i++)
        {
            WC.core.roomPoints[i].num = i;
            dataObj.roomPoints[i] = WC.core.roomPoints[i].clone(); // Clones x, y, type
        }

        dataObj.coverPoints = new Array(WC.core.coverPoints.length);
        for (i = 0; i < WC.core.coverPoints.length; i++)
        {
            WC.core.coverPoints[i].num = i;
            dataObj.coverPoints[i] = WC.core.coverPoints[i].clone();
        }

        dataObj.arrRooms = new Array(WC.core.arrRooms.length);
        for (i = 0; i < WC.core.arrRooms.length; i++)
        {
            dataObj.arrRooms[i] = new WC.CRoom(WC.core.arrRooms[i].outer);
            dataObj.arrRooms[i].points = new Array(WC.core.arrRooms[i].points.length);
            for (var j = 0; j < WC.core.arrRooms[i].points.length; j++)
            {
                var P = dataObj.roomPoints[WC.core.arrRooms[i].points[j].num];
                if(P) P.contour = dataObj.arrRooms[i];
                dataObj.arrRooms[i].points[j] = P;
            }
            dataObj.arrRooms[i].triangles = WC.core.arrRooms[i].triangles;
            dataObj.arrRooms[i].data = WC.core.arrRooms[i].data;
        }

        dataObj.arrCovers = new Array(WC.core.arrCovers.length);
        for (i = 0; i < WC.core.arrCovers.length; i++)
        {
            dataObj.arrCovers[i] = new WC.CCover(WC.core.arrCovers[i].outer);
            dataObj.arrCovers[i].points = new Array(WC.core.arrCovers[i].points.length);
            for (j = 0; j < WC.core.arrCovers[i].points.length; j++)
            {
                P = dataObj.coverPoints[WC.core.arrCovers[i].points[j].num];
                P.contour = dataObj.arrCovers[i];
                dataObj.arrCovers[i].points[j] = P;
            }
            dataObj.arrCovers[i].triangles = WC.core.arrCovers[i].triangles;
            dataObj.arrCovers[i].data = WC.core.arrCovers[i].data;
        }

        dataObj.arrAreas = new Array(WC.core.arrAreas.length);
        for (i = 0; i < WC.core.arrAreas.length; i++)
        {
            dataObj.arrAreas[i] = new WC.CArea();
            dataObj.arrAreas[i].points = new Array(WC.core.arrAreas[i].points.length);
            for (j = 0; j < WC.core.arrAreas[i].points.length; j++)
            {
                P = dataObj.roomPoints[WC.core.arrAreas[i].points[j].num];
                P && P?.areas.push(dataObj.arrAreas[i]);
                dataObj.arrAreas[i].points[j] = P;
            }
            dataObj.arrAreas[i].triangles = WC.core.arrAreas[i].triangles;
            dataObj.arrAreas[i].data = WC.core.arrAreas[i].data;
        }

        dataObj.walls = new Array(WC.core.walls.length);
        for (i = 0; i < WC.core.walls.length; i++)
        {
            var pi1 = WC.core.walls[i].point1.num;
            var pi2 = WC.core.walls[i].point2.num;
            dataObj.walls[i] = new WC.CWall(dataObj.roomPoints[pi1], dataObj.roomPoints[pi2], WC.core.walls[i].data);
        }

        return dataObj;
    };

    me.setData = function(dataObj)
    {
        WC.core.roomPoints = new Array(dataObj.roomPoints.length);
        for (var i = 0; i < dataObj.roomPoints.length; i++)
        {
            dataObj.roomPoints[i].num = i;
            WC.core.roomPoints[i] = dataObj.roomPoints[i].clone(); // Clones x, y, type
        }

        WC.core.coverPoints = new Array(dataObj.coverPoints.length);
        for (i = 0; i < dataObj.coverPoints.length; i++)
        {
            dataObj.coverPoints[i].num = i;
            WC.core.coverPoints[i] = dataObj.coverPoints[i].clone();
        }

        WC.core.arrRooms = new Array(dataObj.arrRooms.length);
        for (i = 0; i < dataObj.arrRooms.length; i++)
        {
            WC.core.arrRooms[i] = new WC.CRoom(dataObj.arrRooms[i].outer);
            WC.core.arrRooms[i].points = new Array(dataObj.arrRooms[i].points.length);
            for (var j = 0; j < dataObj.arrRooms[i].points.length; j++)
            {
                var P = WC.core.roomPoints[dataObj.arrRooms[i].points[j].num];
                P.contour = WC.core.arrRooms[i];
                WC.core.arrRooms[i].points[j] = P;
            }
            WC.core.arrRooms[i].triangles = dataObj.arrRooms[i].triangles;
            WC.core.arrRooms[i].data = dataObj.arrRooms[i].data;
        }

        WC.core.arrCovers = new Array(dataObj.arrCovers.length);
        for (i = 0; i < dataObj.arrCovers.length; i++)
        {
            WC.core.arrCovers[i] = new WC.CCover(dataObj.arrCovers[i].outer);
            WC.core.arrCovers[i].points = new Array(dataObj.arrCovers[i].points.length);
            for (j = 0; j < dataObj.arrCovers[i].points.length; j++)
            {
                P = WC.core.coverPoints[dataObj.arrCovers[i].points[j].num];
                P.contour = WC.core.arrCovers[i];
                WC.core.arrCovers[i].points[j] = P;
            }
            WC.core.arrCovers[i].triangles = dataObj.arrCovers[i].triangles;
            WC.core.arrCovers[i].data = dataObj.arrCovers[i].data;
        }

        WC.core.arrAreas = new Array(dataObj.arrAreas.length);
        for (i = 0; i < dataObj.arrAreas.length; i++)
        {
            WC.core.arrAreas[i] = new WC.CArea();
            WC.core.arrAreas[i].points = new Array(dataObj.arrAreas[i].points.length);
            for (j = 0; j < dataObj.arrAreas[i].points.length; j++)
            {
                P = WC.core.roomPoints[dataObj.arrAreas[i].points[j].num];
                P.areas.push(WC.core.arrAreas[i]);
                WC.core.arrAreas[i].points[j] = P;
            }
            WC.core.arrAreas[i].triangles = dataObj.arrAreas[i].triangles;
            WC.core.arrAreas[i].data = dataObj.arrAreas[i].data;
        }

        WC.core.walls = new Array(dataObj.walls.length);
        for (i = 0; i < dataObj.walls.length; i++)
        {
            var pi1 = dataObj.walls[i].point1.num;
            var pi2 = dataObj.walls[i].point2.num;
            WC.core.walls[i] = new WC.CWall(WC.core.roomPoints[pi1], WC.core.roomPoints[pi2], dataObj.walls[i].data);

        }
        
//        WC.core.roomPoints = dataObj.roomPoints;
//        WC.core.coverPoints = dataObj.coverPoints;
//        WC.core.arrRooms = dataObj.arrRooms;
//        WC.core.arrCovers = dataObj.arrCovers;
//        WC.core.arrAreas = dataObj.arrAreas;
    };

    me.clear = function()
    {
        stack = [];
        pointer = -1;
    }
};

// constructor

WC.EditorController = function()
{
    var me = this;

    // todo: public functions
/*
    var pageConstruction = new R2D.RightPanel.PageConstruction();
    var pageCover = new R2D.RightPanel.PageConstructionCover();
    var pageArea = new R2D.RightPanel.PageConstructionLowContour();
    var pageDrawing = new R2D.RightPanel.PageConstructionDrawing();

    var windowAlignerSize = R2D.DialogStage.getWindowInputValue(R2D.TRANSLATION.TEXT_RULER_TYPE_SIZE + ' (' + R2D.DimensionSystem.getName() + ')', R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);
    windowAlignerSize.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, alignerSizeListener);
    windowAlignerSize.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, alignerSizeListener);

    var windowMergeCovers = R2D.DialogStage.getWindowConfirm(R2D.TRANSLATION.TEXT_CONFIRM_MERGE_COVERS, R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);
    windowMergeCovers.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, mergeCoversListener);
    windowMergeCovers.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, mergeCoversListener);

    var windowDelDrawing = R2D.DialogStage.getWindowConfirm(R2D.TRANSLATION.TEXT_DELETE_PLAN, R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);
    windowDelDrawing.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, delDrawingListener);
    windowDelDrawing.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, delDrawingListener);

    var windowRotateDrawing = R2D.DialogStage.getWindowConfirm(R2D.TRANSLATION.TEXT_ROTATE_PLAN, R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);
    windowRotateDrawing.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, rotateDrawingListener);
    windowRotateDrawing.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, rotateDrawingListener);

    var windowAreaHeight = R2D.DialogStage.getWindowInputValue(R2D.TRANSLATION.TEXT_SET_HEIGHT_LOWER_CONTOUR, R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);
    windowAreaHeight.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, areaHeightListener);
    windowAreaHeight.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, areaHeightListener);

    var windowAlignerArea = R2D.DialogStage.getWindowInputValue(R2D.TRANSLATION.TEXT_RULER_TYPE_SIZE, R2D.TRANSLATION.BUTTON_OK, R2D.TRANSLATION.BUTTON_CANCEL);
    windowAlignerArea.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, alignerAreaListener);
    windowAlignerArea.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE, alignerAreaListener);

    var windowDrawingError = R2D.DialogStage.getWindowAlert(R2D.TRANSLATION.TEXT_INCORRECT_RULERS, R2D.TRANSLATION.BUTTON_OK);
*/
/*
    var quickPanel = new R2D.QuickPanel();
    var btnDelete = R2D.QuickPanel.getButtonDelete();
    quickPanel.add(btnDelete);
    btnDelete.addLeftMouseClickListener(btnDeleteListener);

    var historyButtonUndo = new R2D.TopLeftPanel.Button.makeButtonIcon(R2D.STYLE.TLP_ICON_HISTORY_UNDO);
    var historyButtonRedo = new R2D.TopLeftPanel.Button.makeButtonIcon(R2D.STYLE.TLP_ICON_HISTORY_REDO);
    var historyElementUndo = new R2D.TopLeftPanel.Element(50, false, [historyButtonUndo]);
    var historyElementRedo = new R2D.TopLeftPanel.Element(50, false, [historyButtonRedo]);
    historyButtonUndo.setHint('HINT_BUTTON_UNDO');
    historyButtonRedo.setHint('HINT_BUTTON_REDO');
*/
    function btnDeleteListener()
    {
        WC.wallsEditor.quickDelete();

        WC.wallsEditor.changed = true;
    }

    function showDelButton(x, y)
    {
        /*
        quickPanel.setPosition(x, y);
        if (! quickPanel.getDomElement().parentNode)
        {
            WC.wallsEditor.domElement.appendChild(quickPanel.getDomElement());
        }
        */
    }

    function hideDelButton()
    {
        /*
        if (quickPanel.getDomElement().parentNode)
        {
            WC.wallsEditor.domElement.removeChild(quickPanel.getDomElement());
        }
        */
    }

    WC.wallsEditor.addEventListener(Event.ENABLED, editorEnabledListener);
    WC.wallsEditor.addEventListener(Event.DISABLED, editorDisabledListener);
    WC.wallsEditor.addEventListener(WC.EDITOR_CHANGE_STATE, changeStateListener);
    WC.wallsEditor.addEventListener(WC.SHOW_AREA_PAGE, showAreaListener);
    WC.wallsEditor.addEventListener(WC.HIDE_AREA_PAGE, hideAreaListener);
    WC.wallsEditor.addEventListener(WC.SHOW_COVER_PAGE, showCoverListener);
    WC.wallsEditor.addEventListener(WC.HIDE_COVER_PAGE, hideCoverListener);

    WC.wallsEditor.addEventListener(WC.DRAWING_UPLOADED, drawingUploadedListener);
    WC.wallsEditor.addEventListener(WC.ASK_ALIGNER_SIZE, askAlignerSizeListener);
    WC.wallsEditor.addEventListener(WC.ASK_ALIGNER_AREA, askAlignerAreaListener);
    WC.wallsEditor.addEventListener(WC.ASK_MERGE_COVERS, askMergeCoversListener);
    WC.wallsEditor.addEventListener(WC.ASK_AREA_HEIGHT, askAreaHeightListener);
    WC.wallsEditor.addEventListener(WC.SHOW_DEL_BUTTON, showDelButtonListener);
    WC.wallsEditor.addEventListener(WC.UPDATE_DIMENSION, updateDimensionListener);
    WC.wallsEditor.addEventListener(WC.HISTORY_STATE, historyStateListener);
    WC.wallsEditor.addEventListener(WC.DRAWING_REMOVED, drawingRemovedListener);
/*
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_WALL, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_WALL, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_ROOM, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_ROOM, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FILL, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FILL, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FILL_CUT, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FILL_CUT, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FLOOR, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FLOOR, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FLOOR_CUT, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FLOOR_CUT, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_LOW_CONTOUR, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.NEEDS_CLOSE_LOW_CONTOUR, pageConstructionListener);

    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.DRAWING_UPLOAD, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.DRAWING_SETTING, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.DRAWING_REMOVED, pageConstructionListener);
    pageConstruction.addEventListener(R2D.RightPanel.PageConstruction.WALLS_HEIGHT_CHANGED, pageConstructionListener);

    pageCover.addEventListener(R2D.RightPanel.PageConstructionCover.DELETE_COVER, pageCoverListener);
    pageCover.addEventListener(R2D.RightPanel.PageConstructionCover.CEILING_VISIBLE_CHANGED, pageCoverListener);
    pageCover.addEventListener(R2D.RightPanel.PageConstructionCover.CEILING_HEIGHT_CHANGED, pageCoverListener);

    pageArea.addEventListener(R2D.RightPanel.PageConstructionLowContour.DELETE_AREA, pageAreaListener);
    pageArea.addEventListener(R2D.RightPanel.PageConstructionLowContour.AREA_HEIGHT_CHANGED, pageAreaListener);
    pageArea.addEventListener(R2D.RightPanel.PageConstructionLowContour.CEILING_VISIBLE_CHANGED, pageAreaListener);
    pageArea.addEventListener(R2D.RightPanel.PageConstructionLowContour.CEILING_HEIGHT_CHANGED, pageAreaListener);

    pageDrawing.addEventListener(R2D.RightPanel.PageConstructionDrawing.ACTION_SAVE, pageDrawingListener);
    pageDrawing.addEventListener(R2D.RightPanel.PageConstructionDrawing.ACTION_DELETE, pageDrawingListener);
*/
    function alignerSizeListener(e)
    {
        /*
        switch (e.type)
        {
            case R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE:
                var inputSizeStr = windowAlignerSize.getValue();

                R2D.DialogStage.hide(windowAlignerSize);

                if (R2D.TutStage.getHintForAlignPlan()) R2D.TutStage.setHintForAlignPlan(false);

                WC.wallsEditor.stateAlignDrawing.setSizeFirstTime = false;
                var windowDimension = new R2D.DialogStage.WindowChooseUnits();
                windowDimension.setHid();
                R2D.DialogStage.show(windowDimension);
                windowDimension.addEventListener(R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE, function(){
                    WC.wallsEditor.stateAlignDrawing.setAlignerValue(R2D.DimensionSystem.fromString(inputSizeStr));
                });

                break;

            case R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE:
                WC.wallsEditor.stateAlignDrawing.setAlignerValue(-1);
                R2D.DialogStage.hide(windowAlignerSize);
                break;
        }
        */
    }

    function alignerAreaListener(e)
    {
        /*
        switch (e.type)
        {
            case R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE:
                WC.wallsEditor.stateAlignDrawingByArea.setAlignerValue(R2D.DimensionSystem.squareFromString((parseFloat(windowAlignerArea.getValue()))));
                R2D.DialogStage.hide(windowAlignerArea);

                break;

            case R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE:
                WC.wallsEditor.stateAlignDrawingByArea.setAlignerValue(-1);
                R2D.DialogStage.hide(windowAlignerArea);
                break;
        }
        */
    }

    function mergeCoversListener(e)
    {
        /*
        switch (e.type)
        {
            case R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE:

                WC.wallsEditor.rebuildCoversByUser();
                R2D.DialogStage.hide(windowMergeCovers);
                break;

            case R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE:
                R2D.DialogStage.hide(windowMergeCovers);
                break;
        }

        WC.wallsEditor.changed = true;
        */
    }

    function delDrawingListener(e)
    {
        /*
        switch (e.type)
        {
            case R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE:
                R2D.DialogStage.hide(windowDelDrawing);
                WC.wallsEditor.delImageDrawing();
                WC.wallsEditor.stopAlignDrawing();
                break;

            case R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE:
                R2D.DialogStage.hide(windowDelDrawing);
                break;
        }

        WC.wallsEditor.changed = true;
        */
    }

    function rotateDrawingListener(e)
    {
        /*
        switch (e.type)
        {
            case R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE:
                R2D.DialogStage.hide(windowRotateDrawing);
                WC.wallsEditor.stopAlignDrawing(true);
                break;

            case R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE:
                R2D.DialogStage.hide(windowRotateDrawing);
                WC.wallsEditor.stopAlignDrawing(false);
                break;
        }

        WC.wallsEditor.changed = true;
        */
    }

    function areaHeightListener(e)
    {
        /*
        switch (e.type)
        {
            case R2D.DialogStage.WindowBase.WINDOW_ACTION_POSITIVE:
                WC.wallsEditor.setAreaHeight(R2D.DimensionSystem.fromString(windowAreaHeight.getValue()));
                R2D.DialogStage.hide(windowAreaHeight);
                break;

            case R2D.DialogStage.WindowBase.WINDOW_ACTION_NEGATIVE:
                WC.wallsEditor.setAreaHeight();
                R2D.DialogStage.hide(windowAreaHeight);
                break;
        }

        WC.wallsEditor.changed = true;
        */
    }

    function pageConstructionListener(event) {
        /*
        switch ( event.type ) {
            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_WALL:
                WC.wallsEditor.startMakeWalls();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_WALL:
                WC.wallsEditor.stopMake();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_ROOM:
                WC.wallsEditor.startMakeRect();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_ROOM:
                WC.wallsEditor.stopMake();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FILL:
                WC.wallsEditor.startMakeRoom();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FILL:
                WC.wallsEditor.stopMake();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FILL_CUT:
                WC.wallsEditor.startCutRoom();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FILL_CUT:
                WC.wallsEditor.stopMake();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FLOOR:
                WC.wallsEditor.startMakeCover();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FLOOR:
                WC.wallsEditor.stopMake();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_FLOOR_CUT:
                WC.wallsEditor.startCutCover();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_FLOOR_CUT:
                WC.wallsEditor.stopMake();
                break;

            case R2D.RightPanel.PageConstruction.DRAWING_UPLOAD:
                WC.wallsEditor.startUploadDrawing();
                break;

            case R2D.RightPanel.PageConstruction.DRAWING_SETTING:
                WC.wallsEditor.startAlignDrawing();
                break;

            case R2D.RightPanel.PageConstruction.DRAWING_REMOVED:
                pageConstruction.setActiveDrawing(false);
                break;

            case R2D.RightPanel.PageConstruction.WALLS_HEIGHT_CHANGED:
                WC.wallsEditor.setWallsHeight(pageConstruction.getWallHeight());
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_ACTIVE_LOW_CONTOUR:
                WC.wallsEditor.startMakeArea();
                break;

            case R2D.RightPanel.PageConstruction.NEEDS_CLOSE_LOW_CONTOUR:
                WC.wallsEditor.stopMake();
                break;

            default:
                throw "Error! Unknown type of event!";
        }

        WC.wallsEditor.changed = true;
        */
    }

    function drawingRemovedListener(event)
    {
        //pageConstruction.setActiveDrawing(false);
    }

    function pageDrawingListener(event)
    {
        /*
        switch (event.type)
        {
            case R2D.RightPanel.PageConstructionDrawing.ACTION_SAVE:
                var drCorrect = WC.wallsEditor.state.drawingCorrect();
                if (drCorrect)
                {
                    WC.wallsEditor.stopAlignDrawing(false);
                }
                else
                {
                    windowDrawingError.updateMessage(R2D.TRANSLATION.TEXT_INCORRECT_LENGTH);

                    R2D.DialogStage.show(windowDrawingError);
                }
                break;

            case R2D.RightPanel.PageConstructionDrawing.ACTION_DELETE:
                R2D.DialogStage.show(windowDelDrawing);
                break;

        }
        */
    }

    function pageAreaListener(event)
    {
        /*
        switch (event.type)
        {
            case R2D.RightPanel.PageConstructionLowContour.DELETE_AREA:
                WC.wallsEditor.delSelectedAreas();
                break;

            case R2D.RightPanel.PageConstructionLowContour.AREA_HEIGHT_CHANGED:
                WC.wallsEditor.setAreaHeight(pageArea.getHeightSegment());
                break;

            case R2D.RightPanel.PageConstructionLowContour.CEILING_VISIBLE_CHANGED:
                WC.wallsEditor.setAreaCeilingVisible(pageArea.getCeilingVisible());
                break;

            case R2D.RightPanel.PageConstructionLowContour.CEILING_HEIGHT_CHANGED:
                WC.wallsEditor.setAreaCeilingHeight(pageArea.getHeightCeiling());
                break;
        }

        WC.wallsEditor.changed = true;
        */
    }

    function pageCoverListener(event)
    {
        /*
        switch (event.type)
        {
            case R2D.RightPanel.PageConstructionCover.DELETE_COVER:
                WC.wallsEditor.stateSelectedCover.delSelectedCovers();
                break;

            case R2D.RightPanel.PageConstructionCover.CEILING_VISIBLE_CHANGED:
                WC.wallsEditor.stateSelectedCover.setCeilingVisible(pageCover.getVisibleCeiling());
                break;

            case R2D.RightPanel.PageConstructionCover.CEILING_HEIGHT_CHANGED:
                WC.wallsEditor.stateSelectedCover.setCeilingHeight(pageCover.getCeilingHeight());
                break;
        }

        WC.wallsEditor.changed = true;
        */
    }

    function changeStateListener(e)
    {
        /*
        switch (WC.wallsEditor.state)
        {
            case WC.wallsEditor.stateEditing:
                pageConstruction.setActiveWall(false);
                pageConstruction.setActiveRoom(false);
                pageConstruction.setActiveFill(false);
                pageConstruction.setActiveFloor(false);
                pageConstruction.setActiveFillCut(false);
                pageConstruction.setActiveFloorCut(false);
                pageConstruction.setActiveLowContour(false);
                if (pageCover.inHistory()) R2D.rightPanel.removePage(pageCover);
                if (pageDrawing.inHistory()) R2D.rightPanel.removePage(pageDrawing);
                hideDelButton();

                if (WC.wallsEditor.imgDrawing)
                {
                    pageConstruction.setActiveDrawing(true);
                    if (! drawingSetting.elementIsShown()) drawingSetting.showElement();
                }
                else
                {
                    pageConstruction.setActiveDrawing(false);
                    if (drawingSetting.elementIsShown()) drawingSetting.hideElement();
                }

                break;

            case WC.wallsEditor.stateMakingRoom:
                pageConstruction.setActiveWall(false);
                pageConstruction.setActiveRoom(false);
                pageConstruction.setActiveFloor(false);
                pageConstruction.setActiveFloorCut(false);
                pageConstruction.setActiveLowContour(false);

                if (WC.wallsEditor.state.makingOuter)
                {
                    pageConstruction.setActiveFill(true);
                    pageConstruction.setActiveFillCut(false);
                }
                else
                {
                    pageConstruction.setActiveFill(false);
                    pageConstruction.setActiveFillCut(true);
                }
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateMakingCover:
                pageConstruction.setActiveWall(false);
                pageConstruction.setActiveRoom(false);
                pageConstruction.setActiveFill(false);
                pageConstruction.setActiveFillCut(false);
                pageConstruction.setActiveLowContour(false);

                if (WC.wallsEditor.state.makingOuter)
                {
                    pageConstruction.setActiveFloor(true);
                    pageConstruction.setActiveFloorCut(false);
                }
                else
                {
                    pageConstruction.setActiveFloor(false);
                    pageConstruction.setActiveFloorCut(true);
                }
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateMakingWalls:
                pageConstruction.setActiveWall(true);
                pageConstruction.setActiveRoom(false);
                pageConstruction.setActiveFill(false);
                pageConstruction.setActiveFloor(false);
                pageConstruction.setActiveFillCut(false);
                pageConstruction.setActiveFloorCut(false);
                pageConstruction.setActiveLowContour(false);
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateMakingRect:
                pageConstruction.setActiveWall(false);
                pageConstruction.setActiveRoom(true);
                pageConstruction.setActiveFill(false);
                pageConstruction.setActiveFloor(false);
                pageConstruction.setActiveFillCut(false);
                pageConstruction.setActiveFloorCut(false);
                pageConstruction.setActiveLowContour(false);
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateMakingArea:
                pageConstruction.setActiveWall(false);
                pageConstruction.setActiveRoom(false);
                pageConstruction.setActiveFill(false);
                pageConstruction.setActiveFloor(false);
                pageConstruction.setActiveFillCut(false);
                pageConstruction.setActiveFloorCut(false);
                pageConstruction.setActiveLowContour(true);
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateAlignDrawing:
                R2D.rightPanel.addPage(pageDrawing);
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateDraggingRoom:
                hideDelButton();
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateSelectedCover:
                hideDelButton();
                break;

            case WC.wallsEditor.stateSelectedPoint:
                if (pageCover.inHistory()) R2D.rightPanel.removePage(pageCover);
                WC.wallsEditor.changed = true;
                break;

            case WC.wallsEditor.stateDraggingPoint:
                WC.wallsEditor.changed = true;
                break;
        }

        if (WC.wallsEditor.state == WC.wallsEditor.stateAlignDrawing)
        {
            hideHistoryButtons();
            if (elementSetting.isAdded()) R2D.TopLeftPanel.remove(elementSetting, 1);
            if (drawingSetting.elementIsShown()) drawingSetting.hideElement();
        }
        else
        {
            showHistoryButtons();
            if (! elementSetting.isAdded()) R2D.TopLeftPanel.add(elementSetting, 1);
            updateFaces();
            if (! drawingSetting.elementIsShown() && WC.wallsEditor.imgDrawing) drawingSetting.showElement();
        }
        */
    }

    function showCoverListener(e)
    {
        /*
        var currentCover = WC.wallsEditor.stateDraggingCoverPoint.covers[0];
        if (! currentCover) currentCover = WC.wallsEditor.stateSelectedCover.covers[0];

        pageCover.setCeilingHeight(currentCover.getCeilingHeight());
        pageCover.setVisibleCeiling(currentCover.getCeilingVisible());
        pageCover.setArea(currentCover.getFillArea());

        if (! pageCover.inHistory()) R2D.rightPanel.addPage(pageCover);
        */
    }

    function hideCoverListener(e)
    {
        //if (pageCover.inHistory()) R2D.rightPanel.removePage(pageCover);
    }

    function showAreaListener(e)
    {
        /*
        pageArea.setHeightCeiling(WC.wallsEditor.selectedAreas[0].getCeilingHeight());
        pageArea.setHeightSegment(WC.wallsEditor.selectedAreas[0].getHeight());
        pageArea.setCeilingVisible(WC.wallsEditor.selectedAreas[0].getCeilingVisible());
        if (! pageArea.inHistory()) R2D.rightPanel.addPage(pageArea);
        */
    }

    function hideAreaListener(e)
    {
        //R2D.rightPanel.removePage(pageArea);
    }

    function drawingUploadedListener(e)
    {
        //pageConstruction.setActiveDrawing(true);
    }

    function askAlignerSizeListener(e)
    {
        //windowAlignerSize.setValue(R2D.DimensionSystem.toString(WC.wallsEditor.stateAlignDrawing.getAlignerValue()));
        //R2D.DialogStage.show(windowAlignerSize);
    }

    function askAlignerAreaListener(e)
    {
        //R2D.DialogStage.show(windowAlignerArea);
    }

    function askMergeCoversListener(e)
    {
        //R2D.DialogStage.show(windowMergeCovers);
    }

    function askAreaHeightListener(e)
    {
        //windowAreaHeight.setValue(R2D.DimensionSystem.toString(WC.DEFAULT_AREA_HEIGHT));
        //R2D.DialogStage.show(windowAreaHeight);
    }

    function showDelButtonListener(e)
    {
        //showDelButton(WC.viewPos.x, WC.viewPos.y - 30);
    }

    function updateDimensionListener(e)
    {
        /*
        var currentCover = WC.wallsEditor.stateDraggingCoverPoint.covers[0];
        if (! currentCover) currentCover = WC.wallsEditor.stateSelectedCover.covers[0];
        if (currentCover)
        {
            if (pageCover.inHistory()) pageCover.setCeilingHeight(currentCover.getCeilingHeight());
        }

        windowAlignerSize.updateMessage(R2D.TRANSLATION.TEXT_RULER_TYPE_SIZE + ' (' + R2D.DimensionSystem.getName() + ')');
        */
    }

    function hideAllPages()
    {
        /*
        if (pageConstruction.inHistory()) R2D.rightPanel.removePage(pageConstruction);
        if (pageCover.inHistory()) R2D.rightPanel.removePage(pageCover);
        if (pageArea.inHistory()) R2D.rightPanel.removePage(pageArea);
        */
    }

    function editorEnabledListener(e)
    {
        /*
        R2D.catalogLoader.addEventListener(Event.COMPLETE, catalogLoaderEventHandler);

        pageConstruction.setWallHeight(WC.core.cap.wallsHeight);

        R2D.rightPanel.addPage(pageConstruction);
        showHistoryButtons();

        R2D.TopLeftPanel.add(elementSetting, 1);
        updateFaces();

        if (WC.wallsEditor.imgDrawing && ! drawingSetting.elementIsShown()) drawingSetting.showElement();
        */
    }

    function editorDisabledListener(e)
    {
        /*
        R2D.catalogLoader.removeEventListener(Event.COMPLETE, catalogLoaderEventHandler);

        hideAllPages();
        hideHistoryButtons();

        R2D.TopLeftPanel.remove(elementSetting, 1);
        
        if (drawingSetting.elementIsShown()) drawingSetting.hideElement();
        */
    }

    function catalogLoaderEventHandler(e)
    {
        //R2D.rightPanel.addPage(pageConstruction);
    }

    function showHistoryButtons()
    {
        /*
        if (! historyElementUndo.isAdded())
        {
            historyButtonUndo.addLeftMouseClickListener(buttonUndoListener);
            historyButtonRedo.addLeftMouseClickListener(buttonRedoListener);

            R2D.TopLeftPanel.add(historyElementUndo, 2);
            R2D.TopLeftPanel.add(historyElementRedo, 2);
        }
        */
    }
    function hideHistoryButtons()
    {
        /*
        if (historyElementUndo.isAdded())
        {
            historyButtonUndo.removeLeftMouseClickListener(buttonUndoListener);
            historyButtonRedo.removeLeftMouseClickListener(buttonRedoListener);

            R2D.TopLeftPanel.remove(historyElementUndo, 2);
            R2D.TopLeftPanel.remove(historyElementRedo, 2);
        }
        */
    }

    function buttonUndoListener()
    {
        WC.wallsEditor.undo();
    }

    function buttonRedoListener()
    {
        WC.wallsEditor.redo();
    }

    function historyStateListener(e)
    {
        //historyElementUndo.setActive(e.data.undo);
        //historyElementRedo.setActive(e.data.redo);
    }

    // -------------------------------- snap interface --------------------------------

    //flags
    var flagSnapToPoints = true;
    var flagAlignByPoints = true;
    var flagAlignAxises = true;
    var flagAlignMediana = true;
    var flagShowSizes = true;

/*
    //faces
    var faceSettingSimple =  new R2D.TopLeftPanel.FaceIcon(R2D.STYLE.TLP_ICON_SETTING);
    var faceSettingExtend =  new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.TLP_ICON_SETTING, R2D.TRANSLATION.TEXT_SETTINGS, R2D.TopLeftPanel.Face.ALIGN_LEFT);

    var faceSnapToPointsChecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_CHECKED, R2D.TRANSLATION.SNAP_TO_POINTS, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    var faceSnapToPointsUnchecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_UNCHECKED, R2D.TRANSLATION.SNAP_TO_POINTS, R2D.TopLeftPanel.Face.ALIGN_LEFT);

    var faceAlignByPointsChecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_CHECKED, R2D.TRANSLATION.ALIGN_BY_POINTS, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    var faceAlignByPointsUnchecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_UNCHECKED, R2D.TRANSLATION.ALIGN_BY_POINTS, R2D.TopLeftPanel.Face.ALIGN_LEFT);

    var faceAlignAxisesChecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_CHECKED, R2D.TRANSLATION.ALIGN_BY_ORTO, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    var faceAlignAxisesUnchecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_UNCHECKED, R2D.TRANSLATION.ALIGN_BY_ORTO, R2D.TopLeftPanel.Face.ALIGN_LEFT);

    var faceAlignBisectorChecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_CHECKED, R2D.TRANSLATION.ALIGN_BY_BISECTOR, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    var faceAlignBisectorUnchecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_UNCHECKED, R2D.TRANSLATION.ALIGN_BY_BISECTOR, R2D.TopLeftPanel.Face.ALIGN_LEFT);

    var faceShowSizesChecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_CHECKED, R2D.TRANSLATION.SHOW_SIZES, R2D.TopLeftPanel.Face.ALIGN_LEFT);
    var faceShowSizesUnchecked = new R2D.TopLeftPanel.FaceIconText(R2D.STYLE.ICON_CHECK_UNCHECKED, R2D.TRANSLATION.SHOW_SIZES, R2D.TopLeftPanel.Face.ALIGN_LEFT);

    //buttons
    var buttonSetting = new R2D.TopLeftPanel.Button(faceSettingSimple);
    var buttonSnapToPoints = new R2D.TopLeftPanel.Button(faceSnapToPointsChecked);
    var buttonAlignByPoints = new R2D.TopLeftPanel.Button(faceAlignByPointsChecked);
    var buttonAlignAxises = new R2D.TopLeftPanel.Button(faceAlignAxisesChecked);
    var buttonAlignMediana = new R2D.TopLeftPanel.Button(faceAlignBisectorChecked);
    var buttonShowSizes = new R2D.TopLeftPanel.Button(faceShowSizesChecked);

    //element
    var elementSetting = new R2D.TopLeftPanel.Element(25, false, [buttonSetting]);

    function updateFaces()
    {
        buttonSnapToPoints.setFace(WC.snapTool.pointsSnap ? faceSnapToPointsChecked : faceSnapToPointsUnchecked);
        buttonAlignByPoints.setFace(WC.snapTool.pointsAlign ? faceAlignByPointsChecked : faceAlignByPointsUnchecked);
        buttonAlignAxises.setFace(WC.snapTool.orthoAlign ? faceAlignAxisesChecked : faceAlignAxisesUnchecked);
        buttonAlignMediana.setFace(WC.snapTool.bisectorAlign ? faceAlignBisectorChecked : faceAlignBisectorUnchecked);
        buttonShowSizes.setFace(WC.wallsEditor.sizesVisible ? faceShowSizesChecked : faceShowSizesUnchecked);
    }
    function updateTranslations() {
        faceSettingExtend.setText(R2D.TRANSLATION.TEXT_SETTINGS);
        faceSnapToPointsChecked.setText(R2D.TRANSLATION.SNAP_TO_POINTS);
        faceSnapToPointsUnchecked.setText(R2D.TRANSLATION.SNAP_TO_POINTS);
        faceAlignByPointsChecked.setText(R2D.TRANSLATION.ALIGN_BY_POINTS);
        faceAlignByPointsUnchecked.setText(R2D.TRANSLATION.ALIGN_BY_POINTS);
        faceAlignAxisesChecked.setText(R2D.TRANSLATION.ALIGN_BY_ORTO);
        faceAlignAxisesUnchecked.setText(R2D.TRANSLATION.ALIGN_BY_ORTO);
        faceAlignBisectorChecked.setText(R2D.TRANSLATION.ALIGN_BY_BISECTOR);
        faceAlignBisectorUnchecked.setText(R2D.TRANSLATION.ALIGN_BY_BISECTOR);
        faceShowSizesChecked.setText(R2D.TRANSLATION.SHOW_SIZES);
        faceShowSizesUnchecked.setText(R2D.TRANSLATION.SHOW_SIZES);

        windowAlignerSize.updateMessage(R2D.TRANSLATION.TEXT_RULER_TYPE_SIZE + ' (' + R2D.DimensionSystem.getName() + ')');
        windowAlignerSize.updateButtonNamePositive(R2D.TRANSLATION.BUTTON_OK);
        windowAlignerSize.updateButtonNameNegative(R2D.TRANSLATION.BUTTON_CANCEL);

        windowMergeCovers.updateMessage(R2D.TRANSLATION.TEXT_CONFIRM_MERGE_COVERS);
        windowMergeCovers.updateButtonNamePositive(R2D.TRANSLATION.BUTTON_OK);
        windowMergeCovers.updateButtonNameNegative(R2D.TRANSLATION.BUTTON_CANCEL);

        windowDelDrawing.updateMessage(R2D.TRANSLATION.TEXT_DELETE_PLAN);
        windowDelDrawing.updateButtonNamePositive(R2D.TRANSLATION.BUTTON_OK);
        windowDelDrawing.updateButtonNameNegative(R2D.TRANSLATION.BUTTON_CANCEL);

        windowRotateDrawing.updateMessage(R2D.TRANSLATION.TEXT_ROTATE_PLAN);
        windowRotateDrawing.updateButtonNamePositive(R2D.TRANSLATION.BUTTON_OK);
        windowRotateDrawing.updateButtonNameNegative(R2D.TRANSLATION.BUTTON_CANCEL);

        windowAreaHeight.updateMessage(R2D.TRANSLATION.TEXT_SET_HEIGHT_LOWER_CONTOUR);
        windowAreaHeight.updateButtonNamePositive(R2D.TRANSLATION.BUTTON_OK);
        windowAreaHeight.updateButtonNameNegative(R2D.TRANSLATION.BUTTON_CANCEL);

        windowDrawingError.updateMessage(R2D.TRANSLATION.TEXT_INCORRECT_RULERS);
        windowDrawingError.updateButtonName(R2D.TRANSLATION.BUTTON_OK);
    }

    function clickOnButton(event)
    {
        switch ( event.currentTarget )
        {
            case buttonSnapToPoints:
                WC.snapTool.pointsSnap = !WC.snapTool.pointsSnap;
                break;

            case buttonAlignByPoints:
                WC.snapTool.pointsAlign = !WC.snapTool.pointsAlign;
                break;

            case buttonAlignAxises:
                WC.snapTool.orthoAlign = !WC.snapTool.orthoAlign;
                break;

            case buttonAlignMediana:
                WC.snapTool.bisectorAlign = !WC.snapTool.bisectorAlign;
                break;

            case buttonShowSizes:
                WC.wallsEditor.sizesVisible = !WC.wallsEditor.sizesVisible;
                WC.wallsEditor.draw();
                break;
        }

        updateFaces();
    }

    buttonSnapToPoints.addLeftMouseClickListener(clickOnButton);
    buttonAlignByPoints.addLeftMouseClickListener(clickOnButton);
    buttonAlignAxises.addLeftMouseClickListener(clickOnButton);
    buttonAlignMediana.addLeftMouseClickListener(clickOnButton);
    buttonShowSizes.addLeftMouseClickListener(clickOnButton);

    function mouseEnter(event)
    {
        elementSetting.updateButtons([
            buttonSetting,
            buttonSnapToPoints,
            buttonAlignByPoints,
            buttonAlignAxises,
            buttonAlignMediana,
            buttonShowSizes
        ]);

        buttonSetting.setFace(faceSettingExtend);

        R2D.MouseEventController.removeListener(elementSetting, elementSetting.getDomElement(), R2D.MouseEventController.MOUSE_ENTER, mouseEnter);
        R2D.MouseEventController.addListener(elementSetting, elementSetting.getDomElement(), R2D.MouseEventController.MOUSE_LEAVE, mouseLeave);
    }

    function mouseLeave(event)
    {
        elementSetting.updateButtons([buttonSetting]);
        buttonSetting.setFace(faceSettingSimple);

        R2D.MouseEventController.removeListener(elementSetting, elementSetting.getDomElement(), R2D.MouseEventController.MOUSE_LEAVE, mouseLeave);
        R2D.MouseEventController.addListener(elementSetting, elementSetting.getDomElement(), R2D.MouseEventController.MOUSE_ENTER, mouseEnter);
    }

    R2D.MouseEventController.addListener(elementSetting, elementSetting.getDomElement(), R2D.MouseEventController.MOUSE_ENTER, mouseEnter);

    var drawingSetting = new R2D.DrawingDisplaySetting();
    drawingSetting.setCurrentState(R2D.DrawingDisplaySetting.STATE_ABOVE);
    if (drawingSetting.elementIsShown()) drawingSetting.hideElement();

    function drawingRequireState(event)
    {
        switch (event.type)
        {
            case R2D.DrawingDisplaySetting.REQUIRE_STATE_ABOVE:
                WC.wallsEditor.drawingPosition = WC.DRAWING_ABOVE;
                WC.wallsEditor.draw();
                drawingSetting.setCurrentState(R2D.DrawingDisplaySetting.STATE_ABOVE);
                break;

            case R2D.DrawingDisplaySetting.REQUIRE_STATE_BELOW:
                WC.wallsEditor.drawingPosition = WC.DRAWING_BELOW;
                WC.wallsEditor.draw();
                drawingSetting.setCurrentState(R2D.DrawingDisplaySetting.STATE_BELOW);
                break;

            case R2D.DrawingDisplaySetting.REQUIRE_STATE_OFF:
                WC.wallsEditor.drawingPosition = WC.DRAWING_HIDE;
                WC.wallsEditor.draw();
                drawingSetting.setCurrentState(R2D.DrawingDisplaySetting.STATE_OFF);
                break;
        }
    }

    drawingSetting.addEventListener(R2D.DrawingDisplaySetting.REQUIRE_STATE_ABOVE, drawingRequireState);
    drawingSetting.addEventListener(R2D.DrawingDisplaySetting.REQUIRE_STATE_BELOW, drawingRequireState);
    drawingSetting.addEventListener(R2D.DrawingDisplaySetting.REQUIRE_STATE_OFF, drawingRequireState);

    R2D.Translation.addEventListener(Event.UPDATE, updateTranslations);
    */
};
WC.EditorImgLoader = function()
{
    var me = this;

    var imagesData = [
        {path:R2D.STYLE.CONSTR_FLOOR, prop:'imgFloor'},
        {path:R2D.STYLE.CONSTR_FLOOR_SELECTED, prop:'imgSelectedFloor'},
        {path:R2D.STYLE.CONSTR_POINT, prop:'imgPoint'},
        {path:R2D.STYLE.CONSTR_COVER_POINT, prop:'imgCoverPoint'},
        {path:R2D.STYLE.DRAWING_RULER_ICON_UP, prop:'imgAlignerIconUp'},
        {path:R2D.STYLE.DRAWING_RULER_ICON_OVER, prop:'imgAlignerIconOver'},
        {path:R2D.STYLE.DRAWING_RULER_ICON_DOWN, prop:'imgAlignerIconDown'}
    ];

    me.loadImages = function()
    {
        for (var i = 0; i < imagesData.length; i++)
        {
            var imgLoader = new R2D.ImageUrlLoader();
            var imgLoaderListener = function(e)
            {
                var loader = e.data;
                if ( e.type == Event.COMPLETE )
                {
                    WC[loader.params.prop] = loader.getImage();
                } else
                {
                    console.error('Error load image for "' + loader.params.prop + '"');
                }

                var params = loader.params;
                loader.removeEventListener(Event.COMPLETE, params.listener);
                loader.removeEventListener(Event.ERROR, params.listener);
                loader.close();
                params.loader = null;
            };

            imgLoader.addEventListener(Event.COMPLETE, imgLoaderListener);
            imgLoader.addEventListener(Event.ERROR, imgLoaderListener);
            imgLoader.params = imagesData[i];
            imgLoader.params.loader = imgLoader;
            imgLoader.params.listener = imgLoaderListener;
            imgLoader.load(imagesData[i].path);
        }
    };
};
WC.DEFAULT_WALLS_HEIGHT = 280;
WC.DEFAULT_AREA_HEIGHT = 100;

WC.WallsCore = function()
{
    var me = this;

    me.arrRooms = [];
    me.arrCovers = [];
    me.arrAreas = [];
    me.roomPoints = [];
    me.coverPoints = [];
    me.walls = [];
    me.cuts = [];
    me.rawCont = null;
    me.wallsHeight = WC.DEFAULT_WALLS_HEIGHT;

    me.relatedCovers = [];

	me.printData = function()
	{
		console.log('Room points:');
		console.log(me.roomPoints);
		console.log('Rooms:');
		console.log(me.arrRooms);
		console.log('Cover points:');
		console.log(me.coverPoints);
		console.log('Covers:');
		console.log(me.arrCovers);
	};

    me.addRoomPoints = function(points)
    {
        me.roomPoints = me.roomPoints.concat(points);
    };

    me.addCoverPoints = function(points)
    {
        me.coverPoints = me.coverPoints.concat(points);
    };

    me.delPoint = function(point)
    {
        point.contour.delPoint(point);
        
        for (var i = 0; i < point.areas.length; i++)
        {
            var a = point.areas[i];
            a.delPoint(point);

            if (a.points.length <= 2)
            {
                me.delArea(a);
            }
        }

        if (point.type == WC.ROOM_POINT)
        {
            var j = me.roomPoints.indexOf(point);
            if (j >= 0)
            {
                me.roomPoints.splice(j, 1);

                if (point.contour.points.length <= 2)
                {
                    me.delRoom(point.contour);
                }
            }

            for (j = 0; j < point.children.length; j++)
            {
                me.delPoint(point.children[j]);
            }

            var removedWalls = [];
            var wallPoints = [];
            for (i = 0; i < me.walls.length; i++)
            {
                var w = me.walls[i];
                if (w.point1 == point)
                {
                    wallPoints.push(w.point2);
                    removedWalls.push(w);
                }
                else if (w.point2 == point)
                {
                    wallPoints.push(w.point1);
                    removedWalls.push(w);
                }
            }

            if (wallPoints.length == 2 && removedWalls.length == 2)
            {
                me.walls.splice(me.walls.indexOf(removedWalls[0]), 1);
                me.walls.splice(me.walls.indexOf(removedWalls[1]), 1);
                w = removedWalls[0];
                if (TR.euclDistP(removedWalls[1].point1, removedWalls[1].point2) >
                    TR.euclDistP(removedWalls[0].point1, removedWalls[0].point2))
                    w = removedWalls[1];
                var nw = new WC.CWall(wallPoints[0], wallPoints[1], w.data);
                me.walls.push(nw);
            }
        }
        else if (point.type == WC.COVER_POINT)
        {
            j = me.coverPoints.indexOf(point);

            if (j >= 0)
            {
                me.coverPoints.splice(j, 1);

                if (point.contour.points.length <= 2)
                {
                    me.delCover(point.contour);
                }
            }
        }
    };

    me.delRoom = function(room)
    {
        var j = me.arrRooms.indexOf(room);
        if (j == -1) return;

        me.arrRooms.splice(j, 1);

        for (var i = 0; i < room.points.length; i++)
        {
            j = me.roomPoints.indexOf(room.points[i]);
            if (j >= 0)
            {
                me.roomPoints.splice(j, 1);
            }
        }
    };

    me.delCover = function(cover)
    {
        var j = me.arrCovers.indexOf(cover);
        if (j == -1) return;

        me.arrCovers.splice(j, 1);

        for (var i = 0; i < cover.points.length; i++)
        {
            j = me.coverPoints.indexOf(cover.points[i]);
            if (j >= 0)
            {
                me.coverPoints.splice(j, 1);
            }
        }

        if (WC.wallsEditor.state == WC.wallsEditor.stateSelectedCover)
        {
            WC.wallsEditor.stateSelectedCover.delCover(cover);
        }
    };

    me.delArea = function(area)
    {
        var j = me.arrAreas.indexOf(area);
        if (j == -1) return;

        me.arrAreas.splice(j, 1);

        for (var i = 0; i < area.points.length; i++)
        {
            j = area.points[i].areas.indexOf(area);
            if (j >= 0) area.points[i].areas.splice(j, 1);
        }
    };

    function sortByArea(room1, room2)
    {
		var eps = 10;
        var s1 = Math.abs(room1.area);
        var s2 = Math.abs(room2.area);

		if (Math.abs(s1 - s2) < eps)
		{
			if (room1.outer && ! room2.outer)
			{
				return 1;
			}
			else if (! room1.outer && room2.outer)
			{
				return -1;
			}
		}
        else if (s1 < s2)
        {
            return 1;
        }
        else if (s1 > s2)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }

    me.sortRooms = function()
    {
        for (var i = 0; i < me.arrRooms.length; i++)
        {
            me.arrRooms[i].calcArea();
        }

        me.arrRooms.sort(sortByArea);
    };

    me.rebuildWallsAndCovers = function()
    {
        delIntersectedAreas();

        me.roundAllPoints();

        me.rebuildWalls();
        me.rebuildCovers();

        me.findAutoCovers();

        me.connectAllPoints();
        me.findCoverHoles();
        me.findAllCoverTriangles();

        WC.snapTool.reset();
        WC.wallsEditor.draw();
    };

    me.roundAllPoints = function()
    {
        for (var i = 0; i < me.roomPoints.length; i++)
        {
            var rp = TR.roundCoord(me.roomPoints[i]);
            me.roomPoints[i].x = rp.x;
            me.roomPoints[i].y = rp.y;
        }

        for (i = 0; i < me.coverPoints.length; i++)
        {
            rp = TR.roundCoord(me.coverPoints[i]);
            me.coverPoints[i].x = rp.x;
            me.coverPoints[i].y = rp.y;
        }
    };

/*
    me.tempAutoCovers = function()
    {
		me.findAutoCovers();

		me.connectAllPoints();
		me.findCoverHoles();
		me.findAllCoverTriangles();

		WC.snapTool.reset();
		WC.wallsEditor.draw();
    };
*/
    me.rebuildWalls = function(addPairs)
    {
        if (me.arrAreas.length >= 2)
        {
            var badAreas = [];
            for (var i = 0; i < me.arrAreas.length - 1; i++)
            {
                if (me.arrAreas[i].bad) continue;
                for (var j = i + 1; j < me.arrAreas.length; j++)
                {
                    if (me.arrAreas[j].bad) continue;
                    var comp = TR.compareContours(me.arrAreas[i].points, me.arrAreas[j].points);
                    if (comp != TR.OUTSIDE && comp != TR.CONTACT)
                    {
                        me.arrAreas[j].bad = true;
                        badAreas.push(me.arrAreas[j]);
                    }
                }
            }

            for (i = 0; i < badAreas.length; i++) me.delArea(badAreas[i]);
        }

        var outerContours = [];
        var innerContours = [];

        for (i = 0; i < me.arrRooms.length; i++)
        {
            if (me.arrRooms[i].outer)
            {
                outerContours.push(me.arrRooms[i].points);
            }
            else
            {
                innerContours.push(me.arrRooms[i].points);
            }
        }

        var cutPairs = [];      // no intersected pairs here!!!
        if(addPairs) cutPairs = cutPairs.concat(addPairs);

        for (i = 0; i < me.arrAreas.length; i++)
        {
            cutPairs = cutPairs.concat(me.arrAreas[i].getAllPairs());
        }

        var oldRooms = me.arrRooms;

        var newContours = TR.rebuildContours(outerContours, innerContours, [], [], cutPairs, false);

        me.roomPoints = [];
        me.arrRooms = [];

        for (i = 0; i < newContours[0].length; i++)
        {
            var room = new WC.CRoom(true);

            for (j = 0; j < newContours[0][i].length; j++)
            {
                var x = TR.points[newContours[0][i][j]][0];
                var y = TR.points[newContours[0][i][j]][1];

                var P = new WC.CPoint(x, y, WC.ROOM_POINT);
                room.addPoint(P);
            }

            if (! TR.contourValid(room.points)) continue;

            me.arrRooms.push(room);
            me.roomPoints = me.roomPoints.concat(room.points);

            // attach triangle groups
            var trs = newContours[2][i];
            room.triangles = new Array(trs.length);
            for (j = 0; j < trs.length; j++)
            {
                var pt1 = TR.points[trs[j].pointIndices[0]];
                var pt2 = TR.points[trs[j].pointIndices[1]];
                var pt3 = TR.points[trs[j].pointIndices[2]];
                room.triangles[j] = [pt1, pt2, pt3];
            }
        }

        var holes = new Array(newContours[1].length);

        for (i = 0; i < newContours[1].length; i++)
        {
            room = new WC.CRoom(false);

            for (j = 0; j < newContours[1][i].length; j++)
            {
                if(!TR.points[newContours[1][i][j]]) continue;
                x = TR.points[newContours[1][i][j]][0];
                y = TR.points[newContours[1][i][j]][1];

                P = new WC.CPoint(x, y, WC.ROOM_POINT);
                room.addPoint(P);
            }

            if (! TR.contourValid(room.points)) continue;

            me.arrRooms.push(room);
            me.roomPoints = me.roomPoints.concat(room.points);
            holes[i] = room.points;
        }

        // attach data

        for (i = 0; i < me.arrRooms.length; i++)
        {
            for (j = 0; j < oldRooms.length; j++)
            {
                if (me.arrRooms[i].outer != oldRooms[j].outer) continue;
                if (TR.compareContoursByArea(oldRooms[j].points, me.arrRooms[i].points) == TR.INTERSECT)
                {
                    me.arrRooms[i].data = oldRooms[j].data;
                    break;
                }
            }
        }

        me.sortRooms();                 // ?

        resetWalls();
        resetAreas();
        resetCuts();

        findAreasTriangles();

        return holes;
    };

    me.findAutoCovers = function()
    {
        var outerCoverContours = [];
        var innerCoverContours = [];
        var outerRoomContours = [];
        var innerRoomContours = [];

        for (var i = 0; i < me.arrCovers.length; i++)
        {
            if (me.arrCovers[i].outer)
            {
                outerCoverContours.push(me.arrCovers[i].points);
            }
            else
            {
                innerCoverContours.push(me.arrCovers[i].points);
            }
        }

        for (i = 0; i < me.arrRooms.length; i++)
        {
            if (me.arrRooms[i].outer)
            {
                outerRoomContours.push(me.arrRooms[i].points);
            }
            else
            {
                innerRoomContours.push(me.arrRooms[i].points);
            }
        }

        var newContours = TR.rebuildContours(innerRoomContours, [], innerRoomContours, outerRoomContours.concat(outerCoverContours), [], true);

        var relatedCoversArrays = [];
        for (i = 0; i < newContours[0].length; i++)
        {
            var cover = new WC.CCover(true);
            cover.data.ceiling.height = me.wallsHeight;

            for (var j = 0; j < newContours[0][i].length; j++)
            {
                var x = TR.points[newContours[0][i][j]][0];
                var y = TR.points[newContours[0][i][j]][1];

                var P = new WC.CPoint(x, y, WC.COVER_POINT);
                cover.addPoint(P);
            }

            if (! TR.contourValid(cover.points)) continue;

            me.coverPoints = me.coverPoints.concat(cover.points);

            // attach triangle groups

            var trs = newContours[2][i];
            cover.triangles = new Array(trs.length);
            for (j = 0; j < trs.length; j++)
            {
                var pt1 = TR.points[trs[j].pointIndices[0]];
                var pt2 = TR.points[trs[j].pointIndices[1]];
                var pt3 = TR.points[trs[j].pointIndices[2]];
                cover.triangles[j] = [pt1, pt2, pt3];
            }

            me.findRelatedCovers(cover);
            if (me.relatedCovers.length >= 2) relatedCoversArrays.push(me.relatedCovers.slice(me.relatedCovers.length - 2));

            me.arrCovers.push(cover);
        }

        for (i = 0; i < relatedCoversArrays.length; i++)
        {
            me.relatedCovers = relatedCoversArrays[i];
            me.rebuildRelatedCovers(false);
        }

        for (i = 0; i < newContours[1].length; i++)
        {
            cover = new WC.CCover(false);
            cover.data.ceiling.height = me.wallsHeight;

            for (j = 0; j < newContours[1][i].length; j++)
            {
                if(!TR.points[newContours[1][i][j]]) continue;
                x = TR.points[newContours[1][i][j]][0];
                y = TR.points[newContours[1][i][j]][1];

                P = new WC.CPoint(x, y, WC.COVER_POINT);
                cover.addPoint(P);
            }

            me.arrCovers.push(cover);
            me.coverPoints = me.coverPoints.concat(cover.points);
        }
    };

    me.rebuildRelatedCovers = function(separateContacting)
    {
        separateContacting = typeof separateContacting !== 'undefined' ? separateContacting : false;
        if (me.relatedCovers.length == 0) return;

        for (var i = 0; i < me.relatedCovers.length; i++)
        {
            var j = me.arrCovers.indexOf(me.relatedCovers[i]);
            if (j >= 0) me.arrCovers.splice(j, 1);
        }

		me.coverPoints = [];
		for (i = 0; i < me.arrCovers.length; i++)
		{
			me.coverPoints = me.coverPoints.concat(me.arrCovers[i].points);
		}

        var outerContours = [];
        var innerContours = [];

        for (i = 0; i < me.relatedCovers.length; i++)
        {
            if (me.relatedCovers[i].outer)
            {
                outerContours.push(me.relatedCovers[i].points);
            }
            else
            {
                innerContours.push(me.relatedCovers[i].points);
            }
        }

        var newContours = TR.rebuildContours(outerContours, innerContours, [], [], [], separateContacting);

        var oldCovers = me.relatedCovers;

        for (i = 0; i < newContours[0].length; i++)
        {
            var cover = new WC.CCover(true);
            cover.data.ceiling.height = me.wallsHeight;

            for (j = 0; j < newContours[0][i].length; j++)
            {
                var x = TR.points[newContours[0][i][j]][0];
                var y = TR.points[newContours[0][i][j]][1];

                var P = new WC.CPoint(x, y, WC.COVER_POINT);
                cover.addPoint(P);
            }

            for (j = 0; j < oldCovers.length; j++)
            {
                if (TR.compareContoursByArea(oldCovers[j].points, cover.points) == TR.INTERSECT)
                {
                    cover.data = {...oldCovers[j].data, ceiling: {...oldCovers[j].data.ceiling}};
                    break;
                }
            }

            if (! TR.contourValid(cover.points)) continue;

            me.arrCovers.push(cover);
            me.coverPoints = me.coverPoints.concat(cover.points);

            // attach triangle groups

            var trs = newContours[2][i];
            cover.triangles = new Array(trs.length);
            for (j = 0; j < trs.length; j++)
            {
                var pt1 = TR.points[trs[j].pointIndices[0]];
                var pt2 = TR.points[trs[j].pointIndices[1]];
                var pt3 = TR.points[trs[j].pointIndices[2]];
                cover.triangles[j] = [pt1, pt2, pt3];
            }
        }

        for (i = 0; i < newContours[1].length; i++)
        {
            cover = new WC.CCover(false);
            cover.data.ceiling.height = me.wallsHeight;

            for (j = 0; j < newContours[1][i].length; j++)
            {
                if(!TR.points[newContours[1][i][j]]) continue;
                x = TR.points[newContours[1][i][j]][0];
                y = TR.points[newContours[1][i][j]][1];

                P = new WC.CPoint(x, y, WC.COVER_POINT);
                cover.addPoint(P);
            }

            me.arrCovers.push(cover);
            me.coverPoints = me.coverPoints.concat(cover.points);
        }

        me.relatedCovers = [];
    };

    me.rebuildCovers = function()
    {
        var outerContours = [];
        var innerContours = [];

        for (var i = 0; i < me.arrCovers.length; i++)
        {
            var pts = me.arrCovers[i].points;
            if (pts && me.arrCovers[i].outer)
            {
                outerContours.push(pts);
            }
            else if (pts)
            {
                innerContours.push(pts);
            }
        }

        var outerRooms = [];
        var innerRooms = [];

        for (i = 0; i < me.arrRooms.length; i++)
        {
            if (me.arrRooms[i].outer)
            {
                outerRooms.push(me.arrRooms[i].points);
            }
            else
            {
                innerRooms.push(me.arrRooms[i].points);
            }
        }

        var newContours = TR.rebuildContours(outerContours, innerContours, innerRooms, outerRooms, [], true);

        var oldCovers = me.arrCovers;
        me.coverPoints = [];
        me.arrCovers = [];

        for (i = 0; i < newContours[0].length; i++)
        {
            var cover = new WC.CCover(true);
            cover.data.ceiling.height = me.wallsHeight;

            for (var j = 0; j < newContours[0][i].length; j++)
            {
                var x = TR.points[newContours[0][i][j]][0];
                var y = TR.points[newContours[0][i][j]][1];

                var P = new WC.CPoint(x, y, WC.COVER_POINT);
                cover.addPoint(P);
            }

            if (! TR.contourValid(cover.points)) continue;

            me.arrCovers.push(cover);
            me.coverPoints = me.coverPoints.concat(cover.points);

            // attach triangle groups

            var trs = newContours[2][i];
            cover.triangles = new Array(trs.length);
            for (j = 0; j < trs.length; j++)
            {
                var pt1 = TR.points[trs[j].pointIndices[0]];
                var pt2 = TR.points[trs[j].pointIndices[1]];
                var pt3 = TR.points[trs[j].pointIndices[2]];
                cover.triangles[j] = [pt1, pt2, pt3];
            }

            // attach data

            for (j = 0; j < oldCovers.length; j++)
            {
                if (TR.compareContoursByArea(oldCovers[j].points, cover.points) == TR.INTERSECT)
                {
                    cover.data = {...oldCovers[j].data, ceiling: {...oldCovers[j].data.ceiling}};
                    break;
                }
            }
        }

        for (i = 0; i < newContours[1].length; i++)
        {
            cover = new WC.CCover(false);
            cover.data.ceiling.height = me.wallsHeight;

            for (j = 0; j < newContours[1][i].length; j++)
            {
                if(!TR.points[newContours[1][i][j]]) continue;
                x = TR.points[newContours[1][i][j]][0];
                y = TR.points[newContours[1][i][j]][1];

                P = new WC.CPoint(x, y, WC.COVER_POINT);
                cover.addPoint(P);
            }

            me.arrCovers.push(cover);
            me.coverPoints = me.coverPoints.concat(cover.points);
        }
    };

    me.findRelatedCovers = function(cover)
    {
        me.relatedCovers = [];

        var hasContact = false;
        var hasIntersect = false;

        for (var i = 0; i < me.arrCovers.length; i++)
        {
            if (!me.arrCovers[i].outer) continue;
            if (cover == me.arrCovers[i]) continue;

            var contact = false;
            var intersect = false;

            var comp = TR.compareContours(cover.points, me.arrCovers[i].points);

            if (comp == TR.INTERSECT || comp == TR.BELONG || comp == TR.CONTACT_BELONG)
            {
                intersect = true;
            }
            else if (comp == TR.CONTACT)
            {
                contact = true;
            }

            for (var j = 0; j < me.arrCovers[i].holes.length; j++)
            {
                var hole = me.arrCovers[i].holes[j];
                if (cover == hole) continue;

                comp = TR.compareContours(cover.points, hole.points);

                if (comp == TR.INTERSECT)
                {
                    intersect = true;
                }
                else if (comp == TR.CONTACT) {
                    contact = true;
                }
            }

            if (! contact && ! intersect) continue;

            if (me.arrCovers[i] != cover) me.relatedCovers.push(me.arrCovers[i]);

            for (j = 0; j < me.arrCovers[i].holes.length; j++)
            {
                hole = me.arrCovers[i].holes[j];
                if (cover != hole) me.relatedCovers.push(hole);
            }

            if (contact) hasContact = true;
            if (intersect) hasIntersect = true;
        }

        me.relatedCovers.push(cover);

        return [hasIntersect, hasContact];
    };

    var findAreasTriangles = function()
    {
        for (var i = 0; i < me.arrAreas.length; i++)
        {
            var area = me.arrAreas[i];

            var trs = [];
            for (var j = 0; j < TR.fillGroups.length; j++)
            {
                var tr = TR.fillGroups[j][0];

                var center = TR.triangleCenter(TR.points[tr.pointIndices[0]][0], TR.points[tr.pointIndices[0]][1],
                                               TR.points[tr.pointIndices[1]][0], TR.points[tr.pointIndices[1]][1],
                                               TR.points[tr.pointIndices[2]][0], TR.points[tr.pointIndices[2]][1]);

                if (TR.pointInContour(center, area.points)) trs = trs.concat(TR.fillGroups[j]);
            }

            area.triangles = new Array(trs.length);
            for (j = 0; j < trs.length; j++)
            {
                var pt1 = TR.points[trs[j].pointIndices[0]];
                var pt2 = TR.points[trs[j].pointIndices[1]];
                var pt3 = TR.points[trs[j].pointIndices[2]];
                area.triangles[j] = [pt1, pt2, pt3];
            }
        }
    };

    var delIntersectedAreas = function()
    {
        var badAreas = [];

        for (var i = 0; i < me.arrAreas.length; i++)
        {
            var area = me.arrAreas[i];
            var bad = false;
            var cutPairs = area.getCutWallPairs()[0];
            for (var j = 0; j < cutPairs.length; j++)
            {
                for (var k = 0; k < me.arrRooms.length; k++)
                {
                    var pts = me.arrRooms[k].points;
                    for (var l = 0; l < pts.length - 1; l++)
                    {
                        if (TR.lineIntersectLine(pts[l], pts[l + 1], cutPairs[j][0], cutPairs[j][1], true, false))
                        {
                            bad = true;
                            break;
                        }
                    }
                    if (TR.lineIntersectLine(pts[pts.length - 1], pts[0], cutPairs[j][0], cutPairs[j][1], true, false)) bad = true;

                    if (bad) break;
                }
                if (bad) break;
            }

            if (bad) badAreas.push(area);
        }

        for (i = 0; i < badAreas.length; i++)
        {
            me.delArea(badAreas[i]);
        }
    };

    var resetWalls = function()
    {
        var roomSides = [];
        for (var i = 0; i < me.arrRooms.length; i++)
        {
            var room = me.arrRooms[i];
            for (var j = 0; j < room.points.length - 1; j++)
            {
                roomSides.push([room.points[j], room.points[j + 1]]);
            }
            roomSides.push([room.points[room.points.length - 1], room.points[0]]);
        }

        var oldWalls = me.walls;
        me.walls = [];

        for (i = 0; i < roomSides.length; i++)
        {
            var side = roomSides[i];
            var breaked = false;

            for (j = 0; j < oldWalls.length; j++)
            {
                var oldWall = oldWalls[j];

                if ((side[0].match(oldWall.point1) && side[1].match(oldWall.point2)) ||
                    (side[1].match(oldWall.point1) && side[0].match(oldWall.point2)))
                {
                    me.walls.push(new WC.CWall(side[0], side[1], oldWall.data));
                    breaked = true;
                    break;
                }
            }

            if (breaked) continue;

            for (j = 0; j < oldWalls.length; j++)
            {
                oldWall = oldWalls[j];

                if (TR.pointOnLine(side[0], oldWall.point1, oldWall.point2) && TR.pointOnLine(side[1], oldWall.point1, oldWall.point2))
                {
                    me.walls.push(new WC.CWall(side[0], side[1], oldWall.data));
                    break;
                }
            }
        }
    };

    var resetCuts = function()
    {
        var areaSides = [];
        for (var i = 0; i < me.arrAreas.length; i++)
        {
            var area = me.arrAreas[i];
            for (var j = 0; j < area.points.length - 1; j++)
            {
                areaSides.push([area.points[j], area.points[j + 1]]);
            }
            areaSides.push([area.points[area.points.length - 1], area.points[0]]);
        }

        var oldCuts = me.cuts;
        me.cuts = [];

        for (i = 0; i < areaSides.length; i++)
        {
            var side = areaSides[i];

            for (j = 0; j < oldCuts.length; j++)
            {
                var oldCut = oldCuts[j];

                if ((side[0].match(oldCut.point1) && side[1].match(oldCut.point2)) ||
                    (side[1].match(oldCut.point1) && side[0].match(oldCut.point2)))
                {
                    me.cuts.push(new WC.CCut(side[0], side[1], oldCut.data));
                }
            }
        }
    };

    var resetAreas = function()      // + remove intersecting areas...
    {
        var badAreas = [];

        for (var i = 0; i < me.arrAreas.length; i++)
        {
            var area = me.arrAreas[i];
            if (TR.contourSelfIntersected(area.points))
            {
                badAreas.push(area);
                continue;
            }
/*
            var bad = false;
            var cutPairs = area.getCutWallPairs()[0];
            for (var j = 0; j < cutPairs.length; j++)
            {
                for (var k = 0; k < me.arrRooms.length; k++)
                {
                    var pts = me.arrRooms[k].points;
                    for (var l = 0; l < pts.length - 1; l++)
                    {
                        if (TR.lineIntersectLine(pts[l], pts[l + 1], cutPairs[j][0], cutPairs[j][1], true, false))
                        {
                            bad = true;
                            break;
                        }
                    }
                    if (TR.lineIntersectLine(pts[pts.length - 1], pts[0], cutPairs[j][0], cutPairs[j][1], true, false)) bad = true;

                    if (bad) break;
                }
                if (bad) break;
            }

            if (bad)
            {
                badAreas.push(area);
                continue;
            }
*/
            for (var j = 0; j < area.points.length; j++)
            {
                var oldP = area.points[j];
                var newP = WC.snapTool.findNearest(oldP, me.roomPoints, TR.L_EPS);

                if (newP)
                {
                    area.points[j] = newP;
                    newP.areas.push(area);
                }
                else
                {
                    badAreas.push(area); // not delete but splice?
                }
            }
        }

        for (i = 0; i < badAreas.length; i++)
        {
            me.delArea(badAreas[i]);
        }
    };

    me.connectAllPoints = function()
    {
        for (var i = 0; i < me.coverPoints.length; i++)
        {
            me.coverPoints[i].parent = null;
        }

        for (i = 0; i < me.roomPoints.length; i++)
        {
            var rpt = me.roomPoints[i];
            rpt.children = [];

            for (var j = 0; j < me.coverPoints.length; j++)
            {
                var cpt = me.coverPoints[j];
                if (cpt.parent == null && TR.manhDist(rpt.x, rpt.y, cpt.x, cpt.y) < TR.L_EPS)
                {
					cpt.x = rpt.x;
					cpt.y = rpt.y;

                    rpt.children.push(cpt);
                    cpt.parent = rpt
                }
            }
        }
    };

    me.getWallByPoints = function(p1, p2)
    {
        for (var i = 0; i < me.walls.length; i++)
        {
            var cw = me.walls[i];
            if (cw.point1 == p1 && cw.point2 == p2) return cw;
            if (cw.point2 == p1 && cw.point1 == p2) return cw;
        }
    };

    me.getCoversByPoint = function(P)       // returns [outer, hole1, hole2...]
    {
        var covers = [];
        for (var i = 0; i < me.arrCovers.length; i++)
        {
            if (TR.pointInContour(P, me.arrCovers[i].points))
            {
                covers.push(me.arrCovers[i]);
            }
        }

        if (covers.length == 0) return [];

        for (i = 0; i < covers.length; i++) covers[i].calcArea();
        covers.sort(sortByArea);    // O -> o

        var resContours = [];

        resContours.push(covers[covers.length - 1]);

        if (! resContours[0].outer) return [];

        resContours = resContours.concat(resContours[0].holes);

        return resContours;
    };

    me.getSideByPoint = function(P, contours)     // returns [room, i, i + 1], where wall is room[i] - room[i + 1]
    {
        contours = typeof contours !== 'undefined' ? contours : me.arrRooms;
        var accuracy = WC.SNAP_DIST / 2 / WC.wallsEditor.scale;

        for (var i = 0; i < contours.length; i++)
        {
            var pts = contours[i]?.points;
            if(pts) {
                for (var j = 0; j < pts.length - 1; j++)
                {
                    if (TR.pointOnLine(P, pts[j], pts[j + 1], accuracy)) return [contours[i], j, j + 1];
                }

                if (TR.pointOnLine(P, pts[pts.length - 1], pts[0], accuracy)) return [contours[i], pts.length - 1, 0];
            }
        }

        return null;
    };

    me.getAreaByPoint = function(P)
    {
        for (var i = 0; i < me.arrAreas.length; i++)
        {
            if (TR.pointInContour(P, me.arrAreas[i].points))
            {
                return me.arrAreas[i];
            }
        }
    };

    me.pointInMeat = function (P) {
        let inside = 0;
        let outside = 0;
        let minMeatArea = Infinity;
        let minMeat = null;

        for (let i = 0; i < me.arrRooms.length; i++) {
            if (TR.pointInContour(P, me.arrRooms[i].points)) {
                if (me.arrRooms[i].outer) {
                    if (me.arrRooms[i].area == 0) me.arrRooms[i].calcArea();
                    if (me.arrRooms[i].area < minMeatArea) {
                        minMeatArea = me.arrRooms[i].area;
                        minMeat = me.arrRooms[i];
                    }
                    inside++;
                } else {
                    outside++;
                }
            }
        }

        return inside > outside ? minMeat : null;
        // return inside > outside;
    };

    me.findCoverHoles = function()
    {
        var outerCovers = [];
        var innerCovers = [];

        for (var i = 0; i < me.arrCovers.length; i++)
        {
            if (me.arrCovers[i].outer)
            {
                outerCovers.push(me.arrCovers[i]);
            }
            else
            {
                innerCovers.push(me.arrCovers[i]);
            }
        }

        for (i = 0; i < outerCovers.length; i++) outerCovers[i].calcArea();
        outerCovers.sort(sortByArea);
        outerCovers.reverse();  // o -> O

        for (i = 0; i < outerCovers.length; i++)
        {
            var cover = outerCovers[i];
            cover.holes = [];
            for (var j = 0; j < innerCovers.length; j++)
            {
                var hole = innerCovers[j];
                if (! hole) continue;
                var res = TR.compareContoursOnePoint(cover.points, hole.points);
                if (res == TR.CONTAIN)
                {
                    cover.holes.push(hole);
                    innerCovers[j] = null;
                }
            }
        }

        for (i = 0; i < innerCovers.length; i++)
        {
            if (innerCovers[i]) me.delCover(innerCovers[i]);
        }
    };

    me.findAllCoverTriangles = function()
    {
        for (var i = 0; i < me.arrCovers.length; i++)
        {
            me.findCoverTriangles(me.arrCovers[i]);
        }
    };

    me.findCoverTriangles = function(cover)
    {
        var holeContours = new Array(cover.holes.length);
        for (var i = 0; i < holeContours.length; i++)
        {
            holeContours[i] = cover.holes[i].points;
        }

        var trs = TR.triangulateContours([cover.points], holeContours, [], [], [])[0];

        cover.triangles = new Array(trs.length);
        for (i = 0; i < trs.length; i++)
        {
            var pt1 = TR.points[trs[i].pointIndices[0]];
            var pt2 = TR.points[trs[i].pointIndices[1]];
            var pt3 = TR.points[trs[i].pointIndices[2]];
            cover.triangles[i] = [pt1, pt2, pt3];
        }

    };

    me.clearCoverHoles = function()
    {
        for (var i = 0; i < me.arrCovers.length; i++) me.arrCovers[i].holes = [];
    };
};
// constructor

WC.SCALE_DELTA = 0.1;
WC.ANGLE_DELTA = 0.1;

WC.MODEL_FILL_STYLE = "rgba(150, 150, 150, 0.2)";
WC.FOR_WALL_FILL_STYLE = "rgba(250, 250, 250, 0.3)";
WC.AREA_FILL_STYLE = "rgba(200, 200, 100, 0.3)";
WC.SELECTED_AREA_FILL_STYLE = "rgba(150, 200, 100, 0.5)";
WC.MEAT_FILL_STYLE = "rgba(100, 100, 100, 0.5)";
WC.MEAT_STROKE_STYLE = "rgba(100, 100, 100, 0.05)";

WC.EDITOR_CHANGE_STATE = 'editorChangeState';
WC.SHOW_MEAT_PAGE = 'showMeatPage';
WC.HIDE_MEAT_PAGE = 'hideMeatPage';
WC.SHOW_AREA_PAGE = 'showAreaPage';
WC.HIDE_AREA_PAGE = 'hideAreaPage';
WC.SHOW_COVER_PAGE = 'showCoverPage';
WC.HIDE_COVER_PAGE = 'hideCoverPage';
WC.DRAWING_UPLOADED = 'drawingUploaded';
WC.DRAWING_REMOVED = 'drawingRemoved';
WC.DRAWING_CHANGED = 'drawingChanged';
WC.DRAWING_ALIGNED = 'drawingChanged';
WC.ASK_ALIGNER_SIZE = 'askAlignerSize';
WC.ASK_ALIGNER_AREA = 'askAlignerArea';
WC.ASK_MERGE_COVERS = 'askMergeCovers';
WC.ASK_AREA_HEIGHT = 'askAreaHeight';
WC.SHOW_DEL_BUTTON = 'showDelButton';
WC.UPDATE_DIMENSION = 'updateDimension';
WC.HISTORY_STATE = 'historyState';

WC.DRAWING_ABOVE = 'drawingAbove';
WC.DRAWING_BELOW = 'drawingBelow';
WC.DRAWING_HIDE = 'drawingHide';

WC.events = {};

WC.WallsEditor = function(data, scene, apiDispatcher)
{
    R2D.Viewer.call(this, 'constructor', data, scene, true, true);

    let me = this;
    WC.wallsEditor = me;

    let width = 1000;
    let height = 600;
    me.sizesVisible = true;

    me.isTipShowed = { "TAB": false, "ENTER": false, "ENTER_TAB": false };
    me.isTipOnScreen = false;

    me.api = apiDispatcher;

    let wallsData = scene.getConstructor();
    me.sceneObjects =  scene.getSceneObjects();

    me.domElement = data.domElement;
    me.domElement.style.position = 'absolute';
    me.domElement.style.left = 0;
    me.domElement.style.top = 0;
    me.domElement.style.margin = 0;
    me.domElement.style.padding = 0;

    let canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    canvas.style.position = 'absolute';
    canvas.style.left = 0;
    canvas.style.top = 0;
    canvas.style.margin = 0;
    canvas.style.padding = 0;
    me.domElement.appendChild(canvas);
    canvas.id = 'canvasConstructor';

    let toolsHTML = document.createElement('div');
    toolsHTML.classList.add("tools");

    me.domElement.appendChild(toolsHTML);

    me.objCanvas = document.createElement('canvas');
    me.objContext = me.objCanvas.getContext('2d');
    me.objCanvas.width = width;
    me.objCanvas.height = height;

    let cameraZoomMin = -0.5;
    let cameraZoomCurrent = 1;
    let sensitivePan = 0.01;
    let sensitiveTilt = 0.01;
    let sensitiveZoom = 0.05;
    let cameraSteps = 0.1;

    let scaleVaues = [0.55, 0.58, 0.62, 0.67, 0.71, 0.76, 0.83, 0.9, 1, 1.11, 1.25, 1.43, 1.67, 2, 2.49, 3.33, 5, 7, 10];
    let scalePointer = 8;

    let enabled = false;
    me.changed = false;

    WC.core = new WC.WallsCore();
    WC.wallsCommander = new WC.WallsCommander();
    WC.snapTool = new WC.SnapTool();
    WC.drawTool = new WC.DrawTool();
    WC.editorController = new WC.EditorController();
    let allImgLoader = new WC.EditorImgLoader();
    allImgLoader.loadImages();
    WC.realPos = new TR.Point(0, 0);
    WC.snapPos = new TR.Point(0, 0);


    WC.context = canvas.getContext('2d');
    WC.canvasWidth = canvas.width;
    WC.canvasHeight = canvas.height;
    WC.SNAP_DIST = 10;
    WC.POINT_SIZE = 6;
    WC.CENTER_SIZE = 4;
    WC.CLICK_DELTA = 200;   // ms
    WC.CLICK_SHIFT = 3;     // px

    //canvas.addEventListener('mousedown', e => me.onCanvasMouseDown(e), false);
    //canvas.addEventListener('mouseup', e => me.onCanvasMouseUp(e), false);
    //canvas.addEventListener('mousemove', e => me.onCanvasMouseMove(e), false);
    canvas.addEventListener('dblclick', onCanvasDblClick, false);
    canvas.addEventListener('wheel', onCanvasWheel, false);

    //canvas.addEventListener('mousewheel', onCanvasWheel, false);
    //canvas.addEventListener('DOMMouseScroll', onCanvasWheel, false);

    me.domElement.addEventListener('contextmenu', function (e) { e.preventDefault(); });

    scene.addEventListener(R2D.Scene.SCENE_CLEARED, function() {
        me.setStructure(wallsData);
        WC.wallsCommander.clear();
        me.imgModels = null;
        me.draw();
    });

    me.stateEditing = new WC.StateEditing();
    me.stateDraggingPoint = new WC.StateDraggingPoint();
    me.stateDraggingWall = new WC.StateDraggingWall();
    me.stateDraggingCoverSide = new WC.StateDraggingCoverSide();
    me.stateDraggingRoom = new WC.StateDraggingRoom();
    me.stateDraggingCoverPoint = new WC.StateDraggingCoverPoint();
    me.stateMakingRoom = new WC.StateMakingRoom();
    me.stateMakingCover = new WC.StateMakingCover();
    me.stateMakingArea = new WC.StateMakingArea();
    me.stateMakingRect = new WC.StateMakingRect();
    me.stateMakingWalls = new WC.StateMakingWalls();
    me.stateDraggingCanvas = new WC.StateDraggingCanvas(this.api);
    me.stateSelectedCover = new WC.StateSelectedCover();
    me.stateSelectedRoom = new WC.StateSelectedRoom();
    me.stateSelectedPoint = new WC.StateSelectedPoint();
    me.stateSelectedArea = new WC.StateSelectedArea();
    me.stateAlignDrawing = new WC.StateAlignDrawing();
    me.stateAlignDrawingByArea = new WC.StateAlignDrawingByArea();
    me.stateMakingRuler = new WC.StateMakingRuler();
    me.stateDraggingRuler = new WC.StateDraggingRuler();
    me.stateSelectedRuler = new WC.StateSelectedRuler();

    me.state = me.stateEditing;
    me.prevState = me.stateEditing;

    me.dblClickToDel = true;
    me.fastUp = false;
    me.nearUp = false;
    me.wheelEnabled = true;
    me.rightEnabled = true;

    me.drawingPosition = WC.DRAWING_ABOVE;

    me.rulers = [];

    me.getCameraData = function() {};

    me.hideCursor = function()
    {
        canvas.style.cursor = 'none';
    };

    me.showCursor = function()
    {
        canvas.style.cursor = '';
    };

    me.cursorPointer = function()
    {
        canvas.style.cursor = 'pointer';
    };

    me.startMakeRoom = function()
    {
        me.changeState(me.stateMakingRoom, {makingOuter: true});
    };

    me.startCutRoom = function()
    {
        me.changeState(me.stateMakingRoom, {makingOuter: false});
    };

    me.startMakeCover = function()
    {
        me.changeState(me.stateMakingCover, {makingOuter: true});
    };

    me.startCutCover = function()
    {
        me.changeState(me.stateMakingCover, {makingOuter: false});
    };

    me.startMakeArea = function()
    {
        me.changeState(me.stateMakingArea);
    };

    me.startMakeRect = function()
    {
        me.changeState(me.stateMakingRect);
    };

    me.startMakeWalls = function()
    {
        me.changeState(me.stateMakingWalls);
    };

    me.cancelMake = function()
    {
        WC.core.rawCont = null;
        me.stopMake();
    };

    me.stopMake = function()
    {
        if (me.state == me.stateMakingRoom || me.state == me.stateMakingCover || me.state == me.stateMakingArea ||
            me.state == me.stateMakingRect || me.state == me.stateMakingWalls || me.state == me.stateMakingRuler)
		{
			me.changeState(me.stateEditing);
		}
    };

    me.startAlignDrawing = function()
    {
        me.changeState(me.stateAlignDrawing);
    };

    me.stopAlignDrawing = function(rotate)
    {
        if(!me.state || !me.state.drawingCorrect || typeof me.state.drawingCorrect !== 'function') return;
        let drCorrect = me.state.drawingCorrect();
        if (drCorrect)
        {
            me.stateAlignDrawing.rotateDrawing = rotate;
            

            me.dispatchEvent(new Event(WC.DRAWING_ALIGNED));

            me.changeState(me.stateEditing);

            return {state: "stateEditing"}
        }
        else
        {
            return {state: "error", type: "text_incorrect_length", data: "TEXT_INCORRECT_LENGTH"};
        }
    };

    me.rebuildCoversByUser = function()
    {
        WC.core.rebuildRelatedCovers();
        WC.core.findCoverHoles();
        WC.wallsEditor.save();
        me.draw();
    };

    me.quickDelete = function()
    {
        if (me.state == me.stateSelectedRoom)
        {
            me.stateSelectedRoom.delSelectedRoom();
            WC.core.rebuildWallsAndCovers();
            me.state.afterRebuild();
            me.titlesTool.hide();
            me.titlesTool.show(false);
            WC.wallsEditor.save();
            WC.snapTool.reset();
        }
        else if (me.state == me.stateSelectedPoint)
        {
            if (me.stateSelectedPoint.point.type == WC.COVER_POINT)
            {
                me.stateSelectedPoint.delSelectedPoint();
                WC.core.findCoverHoles();
                WC.core.findAllCoverTriangles();
                me.titlesTool.hide();
                me.titlesTool.show();
                WC.wallsEditor.save();
                WC.snapTool.reset();
            }
            else
            {
                me.stateSelectedPoint.delSelectedPoint();
                WC.core.rebuildWallsAndCovers();
                me.state.afterRebuild();
                me.titlesTool.hide();
                me.titlesTool.show();
                WC.wallsEditor.save();
                WC.snapTool.reset();
            }
        }
        else if (me.state == me.stateSelectedRuler)
        {
            me.stateSelectedRuler.delSelectedRuler();
        }
        else if (me.state == me.stateSelectedCover)
        {
            me.stateSelectedCover.delSelectedCovers();
            me.titlesTool.hide();
            me.titlesTool.show(false);
            WC.wallsEditor.save();
        }
        else if (me.state == me.stateSelectedArea)
        {
            me.delSelectedAreas();
            me.titlesTool.hide();
            me.titlesTool.show(false);
            WC.wallsEditor.save();
        }

        me.draw();
    };

    me.zoom = function(x, y, dir)
    {
        var shX, shY, oldScale;

        if (dir > 0)
        {
            scalePointer += 1;
            if (scalePointer >= scaleVaues.length) scalePointer = scaleVaues.length - 1;
            oldScale = me.scale;
            me.scale = scaleVaues[scalePointer];

            shX = (x + me.shiftX) * (me.scale / oldScale - 1);
            shY = (y + me.shiftY) * (me.scale / oldScale - 1);

            me.shiftX += shX;
            me.shiftY += shY;
        }
        else
        {
            scalePointer -= 1;
            if (scalePointer < 0) scalePointer = 0;
            oldScale = me.scale;
            me.scale = scaleVaues[scalePointer];

            shX = (x + me.shiftX) * (me.scale / oldScale - 1);
            shY = (y + me.shiftY) * (me.scale / oldScale - 1);

            me.shiftX += shX;
            me.shiftY += shY;
        }

        WC.SFK.state.updateInputsAfterDraggingCanvasOrZoom();

        WC.framePointLT = WC.wallsEditor.viewToReal(new TR.Point(0, 0));
        WC.framePointRB = WC.wallsEditor.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));

        me.titlesTool.viewUpdate();

        me.drawObjLayer();
        me.draw();

        return {x: me.shiftX, y: me.shiftY};
    };

    me.zoomIn = function()
    {
        me.zoom(WC.canvasWidth / 2, WC.canvasHeight / 2, 1);
    };

    me.zoomOut = function()
    {
        me.zoom(WC.canvasWidth / 2, WC.canvasHeight / 2, -1);
    };

    me.toCenter = function()
    {
        let planBounds = getRect();
        if (! planBounds)
        {
            me.shiftX = WC.canvasWidth / 2;
            me.shiftY = WC.canvasHeight / 2;
        }
        else
        {
            me.shiftX = (planBounds.maxX + planBounds.minX) * me.scale / 2 - WC.canvasWidth / 2;
            me.shiftY = (planBounds.maxY + planBounds.minY) * me.scale / 2 - WC.canvasHeight / 2;
        }

        me.drawObjLayer();
        me.draw();
    };
    me.getViewStateData = function() {
        return {
            state:'2d',
            camera:{
                px:0,
                py:0,
                pz:0,
                tilt:90,
                pan:0,
                zoom:0.1
            }
        };
    };
    me.makePreviewScreenShot = function ()
    {
        let oldWidth = width;
        let oldHeight = height;
        let image = null;

        me.setSize(1280 , 720);

        let tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = 1280 ;
        tmpCanvas.height = 720;
        let tmpContext = tmpCanvas.getContext('2d');
        tmpContext.fillStyle = "#FFFFFF";
        tmpContext.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);
        tmpContext.drawImage(canvas, 0, 0);

        image = tmpCanvas.toDataURL('image/jpeg');

        me.setSize(oldWidth, oldHeight);

        return image;
    };

    let fixCameraOutside = function()
    {
        let margin = WC.canvasHeight * 0.1;
        let planBounds = getRect();

        if (! planBounds) return;

        if ((planBounds.maxX < WC.framePointLT.x + margin) ||
            (planBounds.maxY < WC.framePointLT.y + margin) ||
            (planBounds.minX > WC.framePointRB.x - margin) ||
            (planBounds.minY > WC.framePointRB.y - margin))
        {
            me.shiftX = (planBounds.maxX + planBounds.minX) / 2 - WC.canvasWidth / 2;
            me.shiftY = (planBounds.maxY + planBounds.minY) / 2 - WC.canvasHeight / 2;

            R2D.ViewerScene2D._instance.toCenter()
        }
    };

    let getRect = function()
    {
        if (WC.core.roomPoints.length == 0 && WC.core.coverPoints.length == 0) return null;

        let minX =  Number.MAX_VALUE;
        let minY =  Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;

        for (let i = 0; i < WC.core.roomPoints.length; i++)
        {
            let P = WC.core.roomPoints[i];
            if (P.x < minX) minX = P.x;
            if (P.y < minY) minY = P.y;
            if (P.x > maxX) maxX = P.x;
            if (P.y > maxY) maxY = P.y;
        }

        for (let i = 0; i < WC.core.coverPoints.length; i++)
        {
            P = WC.core.coverPoints[i];
            if (P.x < minX) minX = P.x;
            if (P.y < minY) minY = P.y;
            if (P.x > maxX) maxX = P.x;
            if (P.y > maxY) maxY = P.y;
        }

        return {minX: minX, minY: minY, maxX:maxX, maxY:maxY};
    };

    me.stateUserUnknown = function()
    {
        console.log('State user unknown from WallsEditor');

        //R2D.User.showElementCurrentProject(true);
        //R2D.User.showElementUser(false);
        //R2D.User.showElementLogin(true);
        //R2D.User.showElementLanguages(true);
        //R2D.User.showElementSaveProject(true);
    };

    me.stateUserLogged = function()
    {
        console.log('State user logged from WallsEditor');

        //R2D.User.showElementCurrentProject(true);
        //R2D.User.showElementUser(true);
        //R2D.User.showElementLogin(false);
        //R2D.User.showElementLanguages(true);
        //R2D.User.showElementSaveProject(true);
    };

    function onCanvasWheel(e)
    {
        
        if (me.wheelEnabled)
        {
            
            let x = e.offsetX == undefined ? e.layerX : e.offsetX;
            let y = e.offsetY == undefined ? e.layerY : e.offsetY;

            //event.deltaY || event.detail || event.wheelDelta
            apiDispatcher.dispatchEvent(new Event(apiDispatcher.WHEEL_ZOOM, {x, y, delta: -e.deltaY || -e.detail || e.wheelDelta}));
            //me.zoom(x, y, -e.deltaY || -e.detail || e.wheelDelta);
        }

        me.state.mouseWheel();
    }

    me.cameraZoom = function(delta)
    {
        me.zoom(WC.canvasWidth / 2, WC.canvasHeight / 2, -delta);
    };

    function onCanvasDblClick(e)
    {
        let x = e.offsetX == undefined ? e.layerX : e.offsetX;
        let y = e.offsetY == undefined ? e.layerY : e.offsetY;
        WC.viewPos = new TR.Point(x, y);
        WC.realPos = me.viewToReal(WC.viewPos);

        me.state.dblClick(WC.realPos.x, WC.realPos.y);
    }

    let downPos = null;
    let downTime = null;

    me.onCanvasMouseDown = e =>
    {
        if(!me.state || !me.state.mouseDown) return;
        let x = e.offsetX == undefined ? e.layerX : e.offsetX;
        let y = e.offsetY == undefined ? e.layerY : e.offsetY;
        WC.viewPos = new TR.Point(x, y);
        WC.realPos = me.viewToReal(WC.viewPos);

        downPos = new TR.Point(x, y);
        downTime = Date.now();

        if (e.button == 0)
        {
            me.state.mouseDown(WC.realPos.x, WC.realPos.y);
            
        }
        else if (e.button == 2)
        {
            me.state.mouseRDown(x, y);
            if(R2D.Viewers.getCurrentViewerType() == "constructor") R2D.MouseInteractionHelper.mousedown(e);
        }
    }

    me.onCanvasMouseUp = e =>
    {
        if(!me.state || (!me.state.mouseUp && !me.state.mouseRUp)) return;
        let x = e.offsetX == undefined ? e.layerX : e.offsetX;
        let y = e.offsetY == undefined ? e.layerY : e.offsetY;
        WC.viewPos = new TR.Point(x, y);
        WC.realPos = me.viewToReal(WC.viewPos);
        
        if (downPos)
        {
            let shift = TR.manhDist(WC.realPos.x, WC.realPos.y, downPos.x, downPos.y);
            let delta = Date.now() - downTime;

            me.fastUp = delta < WC.CLICK_DELTA;
            me.nearUp = shift < WC.CLICK_SHIFT;
        }
        if (e.button == 0)
        {
            if (me.state.mouseUp && typeof me.state.mouseUp == "function") {
                me.state.isCtrl = e.ctrlKey;
                return me.state.mouseUp(WC.realPos.x, WC.realPos.y);
            }
        }
        else if (e.button == 2)
        {
            if(me.state.mouseRUp && typeof me.state.mouseRUp == "function") {
                me.state.mouseRUp(x, y);
                if(R2D.Viewers.getCurrentViewerType() == "constructor") {
                    R2D.MouseInteractionHelper._instance.rightMouseUpEventHandler(e);
                    R2D.ViewerScene2D._instance.rendererCameraPositionUpdateEventHandler();
                }
            }
        }
    }

    me.onCanvasMouseMove = e =>
    {
        if(R2D.Viewers.getCurrentViewerType() == "walk") {
            R2D.MouseInteractionHelper.mousemove(e);
            return;
        }
        let result = null;   
        let x = e.offsetX == undefined ? e.layerX : e.offsetX;
        let y = e.offsetY == undefined ? e.layerY : e.offsetY;

        WC.viewPos = new TR.Point(x, y);
        WC.realPos = me.viewToReal(WC.viewPos);
        me.state.findSnap();   // updates WC.snapData: [snapedPoint, alignerX, alignerY]
        if(e.buttons == 2) {
            
            me.state.mouseRMove(WC.viewPos.x, WC.viewPos.y);
            
            if(R2D.Viewers.getCurrentViewerType() == "constructor") {
                R2D.MouseInteractionHelper.mousemove(e);
            }
            return;
        }
        result = me.state.mouseMove(WC.realPos.x, WC.realPos.y);
        return result;
    }

    me.changeState = function(newState, params)
    {
        
        me.prevState = me.state;
        
        let stopResult = me.state.stop();
        me.state = newState;
        let startResult = me.state.start();
        me.state.setParams(params);
        WC.snapTool.reset();
        me.dispatchEvent(new Event(WC.EDITOR_CHANGE_STATE, me));

        me.dispatchHistoryState();
        if( me.prevState.name !== "stateEditing" && me.state.name == "stateEditing" ) {
            apiDispatcher.dispatchEvent(new Event(apiDispatcher.ESTIMATION_SEND, {}));
        }
        if(stopResult) return stopResult;
        if(startResult) return startResult;
        
    };

    let pushedState = null;

    me.pushState = function(newState)
    {
        // no stop() for old state
        me.state.pause();
        pushedState = me.state;
        me.state = newState;
        me.state.start();
    };

    me.popState = function()
    {
        me.state.stop();
        me.state = pushedState;
        pushedState = null;
        me.state.restore();
    };

    me.save = function()
    {
        WC.wallsCommander.save();
        me.dispatchHistoryState();
    };

    me.undo = function()
    {
        me.state.undo();
        me.titlesTool.hide();
        me.titlesTool.show(false);
        me.draw();
        me.dispatchHistoryState();
        WC.SFK.state.hideInputs();
    };

    me.redo = function()
    {
        me.state.redo();
        me.titlesTool.hide();
        me.titlesTool.show(false);
        me.draw();
        me.dispatchHistoryState();
        WC.SFK.state.hideInputs();
    };

    me.canUndo = function()
    {
        return me.state.canUndo();
    };

    me.canRedo = function()
    {
        return me.state.canRedo();
    };

    me.dispatchHistoryState = function()
    {
        WC.wallsEditor.dispatchEvent(new Event(WC.HISTORY_STATE, {undo: me.state.canUndo(), redo: me.state.canRedo()}));
    };

    me.draw = function()
    {
        me.state.draw();
    };

    me.pushedStateDraw = function()
    {
        pushedState.draw();
    };

    me.realToView = function(P)
    {
        return new TR.Point(Math.round(P?.x * me.scale - me.shiftX), Math.round(P?.y * me.scale - me.shiftY));
    };

    me.viewToReal = function(P)
    {
        return new TR.Point((P.x + me.shiftX) / me.scale, (P.y + me.shiftY) / me.scale);
    };

    me.draw();
    me.save();

    me.shiftX = - width / 2;
    me.shiftY = - height / 2;
    me.scale = 1.0;


    WC.framePointLT = me.viewToReal(new TR.Point(0, 0));
    WC.framePointRB = me.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));

    me.delSelectedAreas = function()
    {
        let areasToDel = [].concat(me.stateSelectedArea.areas);
        for (let i = 0; i < areasToDel.length; i++)
        {
            WC.core.delArea(areasToDel[i]);
        }

        areasToDel = [];
        me.stateSelectedArea.areas = [];
        WC.wallsEditor.dispatchEvent(new Event(WC.HIDE_AREA_PAGE, WC.wallsEditor));

        me.changeState(WC.wallsEditor.stateEditing);
        me.draw();
    };

    me.setAreaCeilingVisible = function(v)
    {
        for (let i = 0; i < me.stateSelectedArea.areas.length; i++)
        {
            me.stateSelectedArea.areas[i].setCeilingVisible(v);
        }
    };

    me.setAreaCeilingHeight = function(h)
    {
        for (let i = 0; i < me.stateSelectedArea.areas.length; i++)
        {
            me.stateSelectedArea.areas[i].setCeilingHeight(h);
        }
    };

    me.setAreaHeight = function(h)
    {
        let newHeight = (isNaN(h) || typeof h === 'undefined' || h == null) ? WC.DEFAULT_AREA_HEIGHT : h;

        for (let i = 0; i < me.stateSelectedArea.areas.length; i++)
        {
            me.stateSelectedArea.areas[i].setHeight(newHeight);
        }
    };

    me.setWallsHeight = function(h)
    {
        //let oldHeight = WC.core.cap.wallsHeight;
        WC.core.cap.wallsHeight = h;
        WC.core.wallsHeight = h;

        for (let i = 0; i < WC.core.arrCovers.length; i++)
        {
            //if (WC.core.arrCovers[i].data.ceiling.height == oldHeight)
            WC.core.arrCovers[i].data.ceiling.height = h;
        }

        for (let i = 0; i < WC.core.arrAreas.length; i++)
        {
            //if (WC.core.arrAreas[i].data.ceiling.height == oldHeight)
            WC.core.arrAreas[i].data.ceiling.height = h;
        }
    };

    me.setStructure = function(obj)
    {
        WC.core.initialStructure = obj;

        WC.core.roomPoints = [];
        WC.core.coverPoints = [];
        WC.core.arrRooms = [];
        WC.core.arrCovers = [];
        WC.core.arrAreas = [];
        WC.core.walls = [];
        WC.core.cuts = [];
        WC.core.rawCont = null;
        WC.core.cap = obj.cap;

        let dictPoints = {};

        for (let i = 0; i < obj.roomPoints.length; i++)
        {
            let cpoint = new WC.CPoint(obj.roomPoints[i].x, obj.roomPoints[i].y, WC.ROOM_POINT);
            dictPoints[obj.roomPoints[i].id] = cpoint;
            WC.core.roomPoints.push(cpoint);
        }

        for (let i = 0; i < obj.coverPoints.length; i++)
        {
            cpoint = new WC.CPoint(obj.coverPoints[i].x, obj.coverPoints[i].y, WC.COVER_POINT);
            dictPoints[obj.coverPoints[i].id] = cpoint;
            WC.core.coverPoints.push(cpoint);
        }

        for (let i = 0; i < obj.roomsOuter.length; i++)
        {
            let croom = new WC.CRoom(true, obj.roomsOuter[i]);

            for (let j = 0; j < obj.roomsOuter[i].points.length; j++)
            {
                let pt = dictPoints[obj.roomsOuter[i].points[j].id];

                croom.points.push(pt);
                pt.contour = croom;
            }
            WC.core.arrRooms.push(croom);
        }

        for (let i = 0; i < obj.roomsInner.length; i++)
        {
            croom = new WC.CRoom(false, obj.roomsInner[i]);

            for (let j = 0; j < obj.roomsInner[i].points.length; j++)
            {
                pt = dictPoints[obj.roomsInner[i].points[j].id];

                croom.points.push(pt);
                pt.contour = croom;
            }
            WC.core.arrRooms.push(croom);
        }

        for (let i = 0; i < obj.covers.length; i++)
        {
            let ccover = new WC.CCover(true, obj.covers[i]);

            for (let j = 0; j < obj.covers[i].points.length; j++)
            {
                pt = dictPoints[obj.covers[i].points[j].id];

                ccover.points.push(pt);
                pt.contour = ccover;
            }
            WC.core.arrCovers.push(ccover);
        }

        for (let i = 0; i < obj.coverHoles.length; i++)
        {
            ccover = new WC.CCover(false);
            ccover.data.ceiling.height = WC.core.wallsHeight;

            for (let j = 0; j < obj.coverHoles[i].points.length; j++)
            {
                pt = dictPoints[obj.coverHoles[i].points[j].id];

                ccover.points.push(pt);
                pt.contour = ccover;
            }
            WC.core.arrCovers.push(ccover);
        }

        for (let i = 0; i < obj.areas.length; i++)
        {
            let a = obj.areas[i];

            let area = new WC.CArea(a);
            area.height = a.height;

            for (let j = 0; j < a.points.length; j++)
            {
                area.points.push(dictPoints[a.points[j].id]);
            }

            for (let k = 0; k < area.points.length; k++)
            {
                area.points[k].areas.push(area);
            }

            WC.core.arrAreas.push(area);
        }

        for (let i = 0; i < obj.walls.length; i++)
        {
            let w = obj.walls[i];
            let wall = new WC.CWall(dictPoints[w.point1.id], dictPoints[w.point2.id], w);
            WC.core.walls.push(wall);
        }

        for (let i = 0; i < obj.cuts.length; i++)
        {
            let c = obj.cuts[i];
            let cut = new WC.CCut(dictPoints[c.point1.id], dictPoints[c.point2.id], c);
            WC.core.cuts.push(cut);
        }

        WC.core.connectAllPoints();
        WC.core.rebuildWallsAndCovers();

        while (me.rulers.length > 0) me.rulers.splice(0, 1);
        if (obj.customRulers)
        {
            for (let i = 0; i < obj.customRulers.length; i++)
            {
                let r = obj.customRulers[i];
                me.rulers.push(new WC.Ruler(new TR.Point(r[0].x, r[0].z), new TR.Point(r[1].x, r[1].z)));
            }
        }
    };

    me.getStructure = function()
    {
        
        let res = {};

        res.roomPoints = [];
        res.coverPoints = [];
        res.walls = [];
        res.cuts = [];
        res.areas = [];
        res.roomsOuter = [];
        res.roomsInner = [];
        res.outerRoomConts = [];
        res.innerRoomConts = [];
        res.covers = [];
        res.coverHoles = [];
        res.innerCoverConts = [];

        let savedWalls = [];
        for (let i = 0; i < WC.core.arrRooms.length; i++)
        {
            let croom = WC.core.arrRooms[i];
            let dataWalls = [];
            let dataPoints = [];

            for (let j = 0; j < croom.points.length; j++)
            {
                let DP = new WC.DataPoint(croom.points[j].x, croom.points[j].y);
                dataPoints.push(DP);
                croom.points[j].link = DP;
            }

            for (let j = 0; j < croom.points.length; j++)
            {
                let DP1 = croom.points[j].link;
                let DP2;
                if (j == croom.points.length - 1)
                {
                    DP2 = croom.points[0].link;
                }
                else
                {
                    DP2 = croom.points[j + 1].link;
                }

                let DW = new WC.DataWall(DP1, DP2);
                dataWalls.push(DW);

                DW.topPlinth = new WC.DataPlinth(DW, true, WC.core.cap.wallsHeight);
                DW.bottomPlinth = new WC.DataPlinth(DW, false, 0);

                for (let k = 0; k < WC.core.walls.length; k++)
                {
                    let cwall = WC.core.walls[k];

                    let p1 = cwall.point1;
                    let p2 = cwall.point2;

                    if (!(p1.match(DP1) && p2.match(DP2)) && !(p2.match(DP1) && p1.match(DP2))) continue;

                    DW.materialID = cwall.data.materialID;
                    DW.addMaterialID = cwall.data.addMaterialID;
                    DW.materialRotation = cwall.data.materialRotation;
                    DW.materialX = cwall.data.materialX;
                    DW.materialY = cwall.data.materialY;
                    DW.configData = cwall.data.configData;

                    savedWalls.push(cwall.data);
                    cwall.data.point1 = p1;
                    cwall.data.point2 = p2;

                    WC.convert.copyPlinthData(cwall.data.topPlinth, DW.topPlinth);
                    WC.convert.copyPlinthData(cwall.data.bottomPlinth, DW.bottomPlinth);

                    if (cwall.data.configData) DW.configData = cwall.data.configData.getData();
                    //DW.pattern = cwall.data.pattern;
                }
            }

            let dataRoom = new WC.DataRoom();
            dataRoom.points = dataPoints;
            dataRoom.walls = dataWalls;
            dataRoom.outer = croom.outer;
            for (let j = 0; j < dataWalls.length; j++) dataWalls[j].room = dataRoom;

            if (croom.outer)
            {
                res.roomsOuter.push(dataRoom);
                res.outerRoomConts.push(dataRoom.points);
            }
            else
            {
                res.roomsInner.push(dataRoom);
                res.innerRoomConts.push(dataRoom.points);
            }

            res.roomPoints = res.roomPoints.concat(dataPoints);
            res.walls = res.walls.concat(dataWalls);

            // ---

            for (let j = 0; j < dataRoom.walls.length; j++)
            {
                DW = dataRoom.walls[j];

                let ptind1 = dataRoom.points.indexOf(DW.point1);
                let ptind2 = dataRoom.points.indexOf(DW.point2);
                let L = dataRoom.points.length - 1;

                let parallel;
                if (ptind2 == 0 && ptind1 == L)
                {
                    parallel = true;
                }
                else if(ptind2 == L && ptind1 == 0)
                {
                    parallel = false;
                }
                else
                {
                    parallel = ptind2 > ptind1
                }

                let roomCW = TR.contourArea(dataRoom.points) > 0;
                DW.faceRight = dataRoom.outer ^ roomCW ^ parallel;
                DW.outer = dataRoom.outer;
                if (DW.outer) {
                    DW.bottomPlinth.exists = false;
                    DW.topPlinth.exists = false;
                }
            }
        }

        for (let i = 0; i < res.walls.length; i++)
        {
            res.walls[i].height = WC.core.cap.wallsHeight;
        }

        for (let i = 0; i < WC.core.arrCovers.length; i++)
        {
            
            let ccover = WC.core.arrCovers[i];
            dataPoints = [];

            for (let j = 0; j < ccover.points.length; j++)
            {
                dataPoints.push(new WC.DataPoint(ccover.points[j].x, ccover.points[j].y))
            }

            let dataCover = new WC.DataCover();
            dataCover.points = dataPoints;
            dataCover.outer = ccover.outer;
            let dataCeiling = new WC.DataCeiling();
            dataCover.ceiling = dataCeiling;

            if (ccover.data && ccover.data.title) {
                dataCover.title = {
                    ...ccover.data.title,
                    visible: { ...ccover.data.title.visible },
                    areaVisible: { ...ccover.data.title.areaVisible },
                };
            }

            if (ccover.outer)
            {
                res.covers.push(dataCover);
            }
            else
            {
                res.coverHoles.push(dataCover);
                res.innerCoverConts.push(dataCover.points);
            }

            res.coverPoints = res.coverPoints.concat(dataPoints);
            
            dataCover.materialID = ccover.data.materialID;
            dataCover.addMaterialID = ccover.data.addMaterialID;
            dataCover.materialRotation = ccover.data.materialRotation;
            dataCover.materialX = ccover.data.materialX;
            dataCover.materialY = ccover.data.materialY;
            dataCeiling.exists = ccover.data.ceiling.exists;
            dataCeiling.height = ccover.data.ceiling.height;
            dataCeiling.materialID = ccover.data.ceiling.materialID;
            dataCeiling.addMaterialID = ccover.data.ceiling.addMaterialID;
            dataCeiling.materialRotation = ccover.data.ceiling.materialRotation;
            dataCeiling.materialX = ccover.data.ceiling.materialX;
            dataCeiling.materialY = ccover.data.ceiling.materialY;
        }

        for (let i = 0; i < WC.core.arrAreas.length; i++)
        {
            let cArea = WC.core.arrAreas[i];

            let DA = new WC.DataArea();
            res.areas.push(DA);
            DA.height = cArea.height;

            dataCeiling = new WC.DataCeiling();
            DA.ceiling = dataCeiling;

            let pairs = cArea.getCutWallPairs();
            let cutPairs = pairs[0];
            let wallPairs = pairs[1];

            let dataCuts = [];
            dataWalls = [];

            for (let j = 0; j < wallPairs.length; j++)
            {
                DP1 = wallPairs[j][0].link;
                DP2 = wallPairs[j][1].link;
                for (k = 0; k < res.walls.length; k++)
                {
                    DW = res.walls[k];
                    if ((DW.point1 == DP1 && DW.point2 == DP2) ||
                        (DW.point1 == DP2 && DW.point2 == DP1))
                    {
                        DW.height = DA.height;
                        DW.topPlinth.exists = false;
                        dataWalls.push(DW);
                        break;
                    }
                }
            }

            for (let j = 0; j < res.walls.length; j++)
            {
                DW = res.walls[j];
                if (dataWalls.indexOf(DW) != -1) continue;

                let p1in = TR.pointInContour(DW.point1, cArea.points);
                let p2in = TR.pointInContour(DW.point2, cArea.points);
                let p1on = TR.pointOnContour(DW.point1, cArea.points);
                let p2on = TR.pointOnContour(DW.point2, cArea.points);

                if ((p1in && p2in) || (p1in && p2on) || (p1on && p2in))
                {
                    DW.height = DA.height;
                    dataWalls.push(DW);
                }
            }

            for (let j = 0; j < cutPairs.length; j++)
            {
                DP1 = cutPairs[j][0].link;
                DP2 = cutPairs[j][1].link;
                let exists = false;
                for (k = 0; k < res.cuts.length; k++)
                {
                    let dCut = res.cuts[k];
                    if ((dCut.point1 == DP1 && dCut.point2 == DP2) ||
                        (dCut.point1 == DP2 && dCut.point2 == DP1))
                    {
                        dataCuts.push(dCut);
                        dCut.heights.push(DA.height);
                        exists = true;
                        break;
                    }
                }

                if (exists) continue;

                dCut = new WC.DataCut(DP1, DP2);
                dCut.heights.push(DA.height);
                res.cuts.push(dCut);
                dataCuts.push(dCut);

                for (k = 0; k < WC.core.cuts.length; k++)
                {
                    p1 = WC.core.cuts[k].point1;
                    p2 = WC.core.cuts[k].point2;

                    if (!(p1.match(DP1) && p2.match(DP2)) && !(p2.match(DP1) && p1.match(DP2))) continue;

                    dCut.materialID = WC.core.cuts[k].data.materialID;
                    dCut.addMaterialID = WC.core.cuts[k].data.addMaterialID;
                    dCut.materialRotation = WC.core.cuts[k].data.materialRotation;
                    dCut.materialX = WC.core.cuts[k].data.materialX;
                    dCut.materialY = WC.core.cuts[k].data.materialY;

                    WC.core.cuts[k].data.point1 = p1;
                    WC.core.cuts[k].data.point2 = p2;
                }
            }

            DA.walls = dataWalls;
            DA.cuts = dataCuts;

            DA.points = new Array(cArea.points.length);
            for (let j = 0; j < DA.points.length; j++)
            {
                DA.points[j] = cArea.points[j].link;
            }
            
            DA.materialID = cArea.data.materialID;
            DA.addMaterialID = cArea.data.addMaterialID;
            DA.materialRotation = cArea.data.materialRotation;
            DA.materialX = cArea.data.materialX;
            DA.materialY = cArea.data.materialY;

            dataCeiling.exists = cArea.data.ceiling.exists;
            dataCeiling.height = cArea.data.ceiling.height;
            dataCeiling.materialID = cArea.data.ceiling.materialID;
            dataCeiling.addMaterialID = cArea.data.ceiling.addMaterialID;
            dataCeiling.materialRotation = cArea.data.ceiling.materialRotation;
            dataCeiling.materialX = cArea.data.ceiling.materialX;
            dataCeiling.materialY = cArea.data.ceiling.materialY;
        }

        for (let i = 0; i < res.cuts.length; i++)
        {
            let cut = res.cuts[i];
            if (cut.heights.length == 2)
            {
                cut.height = Math.max(cut.heights[0], cut.heights[1]);
            }
            else
            {
                cut.height = WC.core.cap.wallsHeight;
            }
        }

        for (let i = 0; i < WC.core.roomPoints.length; i++) delete WC.core.roomPoints[i].link;

        let pointID = 1, wallID = 1, coverID = 1, roomID = 1, cutID = 1, areaID = 1, ceilingID = 1;

        for (let i = 0; i < res.roomPoints.length; i++) res.roomPoints[i].id = String(pointID++);
        for (let i = 0; i < res.coverPoints.length; i++) res.coverPoints[i].id = String(pointID++);
        for (let i = 0; i < res.walls.length; i++) res.walls[i].id = String(wallID++);
        for (let i = 0; i < res.cuts.length; i++) res.cuts[i].id = String(cutID++);
        for (let i = 0; i < res.areas.length; i++) res.areas[i].id = String(areaID++);
        for (let i = 0; i < res.roomsOuter.length; i++) res.roomsOuter[i].id = String(roomID++);
        for (let i = 0; i < res.roomsInner.length; i++) res.roomsInner[i].id = String(roomID++);
        for (let i = 0; i < res.covers.length; i++)
        {
            res.covers[i].id = String(coverID++);
            res.covers[i].ceiling.id = String(ceilingID++);
        }
        for (let i = 0; i < res.coverHoles.length; i++) res.coverHoles[i].id = String(coverID++);

        res.cap = WC.core.cap;

        wallsData.newModelsData = [];

        for (let i = 0; i < wallsData.axes.length; i++)
        {
            let axis = wallsData.axes[i];

            if (savedWalls.indexOf(axis.wall1) == -1 || savedWalls.indexOf(axis.wall2) == -1) continue;
            if (axis.models.length == 0) continue;

            let box = WC.boxFromWalls(axis.wall1, axis.wall2);
            if (! box) continue;
            let pts = WC.boxCenterSeg(box[0], box[1], box[2], box[3]);
            if (! pts) continue;

            axis.point1 = pts[0];
            axis.point2 = pts[1];

            let ang = Math.atan2(axis.point2.y - axis.point1.y, axis.point2.x - axis.point1.x);

            for (let j = 0; j < axis.models.length; j++)
            {
                let model = axis.models[j];
                
                if (model.axisPos > TR.euclDistP(axis.point1, axis.point2) - 5) continue;

                wallsData.newModelsData.push({id:model.id, x: axis.point1.x + model.axisPos * Math.cos(ang),
                                                           y: axis.point1.y + model.axisPos * Math.sin(ang)});
            }
        }

        res.customRulers = [];
        for (let i = 0; i < me.rulers.length; i++)
        {
            let ruler = me.rulers[i];
            res.customRulers.push([new THREE.Vector3(ruler.aligner1.center.x, 0, ruler.aligner1.center.y),
                                   new THREE.Vector3(ruler.aligner2.center.x, 0, ruler.aligner2.center.y)]);
        }

        findTitles(res.covers, res.coverHoles);

        return res;
    };

    function findTitles(covers, holes)
    {
        for (let cover of covers)
        {
            let positions = [];

            if (! cover.title) cover.title = {text: 'Room', visible: {view3d: true, view2d: true, viewConstructor: true}, areaVisible: {view3d: true, view2d: true, viewConstructor: true}, x: NaN, y: NaN};

            if (! isNaN(cover.title.x) && ! isNaN(cover.title.y)) positions.push({x: cover.title.x, y: cover.title.y});

            let minX = Number.MAX_VALUE;
            let maxX = -Number.MAX_VALUE;
            let minY = Number.MAX_VALUE;
            let maxY = -Number.MAX_VALUE;
            let minXY = Number.MAX_VALUE;
            let tlPoint = null;

            let sumX = 0;
            let sumY = 0;

            for (let p of cover.points)
            {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
                if (p.x + p.y < minXY)
                {
                    minXY = p.x + p.y;
                    tlPoint = p;
                }
            }

            positions.push({x: (maxX + minX) / 2, y: (maxY + minY) / 2});

            let gridSize = 4;

            for (let i = 1; i < gridSize; i++)
            {
                for (let j = 1; j < gridSize; j++)
                {
                    positions.push({x: minX + (maxX - minX) / gridSize * i, y: minY + (maxY - minY) / gridSize * j});
                }
            }

            positions.push({x: tlPoint.x + 20, y: tlPoint.y + 10});

            for (let pos of positions)
            {
                if (! TR.pointInContour(pos, cover.points)) continue;

                let insideColumn = false;
                for (let hole of holes)
                {
                    if (TR.pointInContour(hole.points[0], cover.points) &&
                        TR.pointInContour(pos, hole.points))
                    {
                        insideColumn = true;
                        break;
                    }
                }
                if (insideColumn) continue;

                cover.title.x = pos.x;
                cover.title.y = pos.y;
                break;
            }
        }
        covers = null;
    }

    me.imgDrawing = null;

    me.setImageDrawing = function(img)
    {
        me.imgDrawing = img;
        me.drawingRotation = (isNaN(me.drawingRotation) || typeof me.drawingRotation === 'undefined' || me.drawingRotation == null) ? 0 : me.drawingRotation; //Math.PI * 0.3333;

        me.drawingScale = (isNaN(me.drawingScale) || typeof me.drawingScale === 'undefined' || me.drawingScale == null) ? 1 : me.drawingScale;
        me.drawingX = -me.imgDrawing.width / 2;
        me.drawingY = -me.imgDrawing.height / 2;
    };

    me.delImageDrawing = function()
    {
        me.imgDrawing = null;
        
        me.stateAlignDrawing.initValues();

        me.dispatchEvent(new Event(WC.DRAWING_REMOVED, me));

        me.dispatchDrawingChanged();
    };

    me.dispatchDrawingChanged = function()
    {
        wallsData.dispatchEvent(new Event(WC.DRAWING_CHANGED, me));
    };

    me.startUploadDrawing = (preloaderNeed = false) =>
    {
        return new Promise((resolve, reject) => {
            let loader = new R2D.ImagesLoader();
        
            let loaderListener = function(e)
            {
                me.setImageDrawing(e.data[0]);
                me.draw();
                //me.dispatchEvent(new Event(WC.DRAWING_UPLOADED, me));
                loader.removeEventListener(Event.COMPLETE, loaderListener);
                me.stateAlignDrawing.newDrawing = true;
                
                loader.close();
                R2D.commonSceneHelper.drawingHelper.state = R2D.DrawingHelper.STATE_ABOVE;
                resolve(me.changeState(me.stateAlignDrawing));

                //added by Kos
                //R2D.DialogStage.show(R2D.DialogStage.getWindowAlert(R2D.TRANSLATION.TEXT_SETTING_RULERS, R2D.TRANSLATION.BUTTON_OK));
            };

            let procImg = function(imgSrc)
            {
                loader.addEventListener(Event.COMPLETE, loaderListener);
                loader.load([imgSrc]);
            };

            FILE.openImage(procImg, "image/png, image/gif, image/jpeg, application/pdf", preloaderNeed);
        })
        
    };

    me.isEnabled = function()
    {
        return enabled;
    };

    me.setViewStateData = function(data)
    {
        // nothing
        return false;
    };

    me.getWidth = function()
    {
        return width;
    };

    me.getHeight = function()
    {
        return height;
    };

    me.setSize = function(w, h)
    {
        let oldWidth = width;
        let oldHeight = height;

        width = w;
        height = h;

        me.domElement.style.width = width + 'px';
        me.domElement.style.height = height + 'px';

        canvas.width = width;
        canvas.height = height;

        me.objCanvas.width = width;
        me.objCanvas.height = height;

        WC.canvasWidth = width;
        WC.canvasHeight = height;

        WC.framePointLT = WC.wallsEditor.viewToReal(new TR.Point(0, 0));
        WC.framePointRB = WC.wallsEditor.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));

        me.shiftX -= (width - oldWidth) / 2;
        me.shiftY -= (height - oldHeight) / 2;

        me.titlesTool.setSize(w, h);

        me.drawObjLayer();
        me.draw();
    };

    let contoursRenderTool = new ContoursRenderTool();
    me.imgModels = null; // = new Image();
    me.modelsX = 0;
    me.modelsY = 0;

    me.titlesTool = new R2D.TitlesTool(me, R2D.scene.constructor, apiDispatcher);

    me.enable = function()
    {
        if (enabled) return;

        enabled = true;
        me.changed = false;

        R2D.keyboardInteractionHelper.updateComponents(canvas);

        document.addEventListener('keydown', keyDownListener, false);
        R2D.DimensionSystem.addEventListener(Event.CHANGE, updateDimensionListener);

        me.setStructure(wallsData);

        me.titlesTool.updateComponents(null, toolsHTML, canvas, me);

        fixCameraOutside();

        me.dispatchEvent(new Event(Event.ENABLED, me));

        me.drawObjLayer();
        me.draw();

        WC.wallsCommander.clear();
        me.save();

        me.state.start();

        WC.framePointLT = me.viewToReal(new TR.Point(0, 0));
        WC.framePointRB = me.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));

        let modelsRenderData = contoursRenderTool.getRender();
        if (modelsRenderData)
        {
            me.imgModels = new Image();
            me.imgModels.onload = function()
            {
                me.draw();
            };
            me.imgModels.src = modelsRenderData.src;
            me.modelsX = modelsRenderData.x;
            me.modelsY = modelsRenderData.y;
        }
        else
        {
            me.imgModels = null;
        }

        R2D.controller.savedLastChanges = false;

        //R2D.User.showElementHistory(false);

        //R2D.User.showElementLanguages(true);
    };

    me.titlesToolUpdate = () => me.titlesTool.updateComponents(null, toolsHTML, canvas, me);

    me.setStructureToWallsData = function()
    {
        wallsData.setStructure(me.getStructure());
    };

    me.disable = function()
    {
        if (!enabled) return;

        enabled = false;

        document.removeEventListener('keydown', keyDownListener, false);
        R2D.DimensionSystem.removeEventListener(Event.UPDATE, updateDimensionListener);

        WC.SFK.state.hideInputs();

        me.changeState(me.stateEditing);

        wallsData.setStructure(me.getStructure());

        me.dispatchEvent(new Event(Event.DISABLED, me));

        wallsData.dispatchModelsReset();

        WC.wallsCommander.clear();

        //R2D.User.showElementHistory(true);

        //R2D.User.showElementLanguages(false);
    };

    me.draw();

    function startAlignByDrawing()
    {
        me.changeState(me.stateAlignDrawingByArea);
    }

    function keyDownListener(e)
    {
        switch (e.keyCode)
        {
            case 13: // enter

                break;

            case 27: // escape
            if (WC.SFK.state.name == "baseState" && me.state.name == "stateSelectedCover") {
                WC.SFK.stateSelectedCover.hideInputs();
            } else {
                WC.wallsEditor.api.dispatchEvent(
                    new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {})
                );
                WC.SFK.state.hideInputs();
            }
            me.cancelMake();
                break;

            case 90: // z
                if (e.ctrlKey) me.undo();
                break;

            case 89: // y
                if (e.ctrlKey) me.redo();
                break;

            case 70: // f
                if (e.ctrlKey && e.altKey && me.state.name == "stateAlignDrawing") startAlignByDrawing();
                break;
            case 9: // tab
                e.preventDefault();

                WC.SFK.state.makeNextInputSelected();
                break;

            case 46: // delete
            case 8: // backspace
                if (e.target.matches("input")) break;

                me.quickDelete();
                WC.SFK.state.hideInputs();
        }
    }

    function updateDimensionListener()
    {
        me.draw();
        me.dispatchEvent(new Event(WC.UPDATE_DIMENSION));
    }

    me.drawObjLayer = function()
    {
        me.objContext.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        for (let i = 0; i < WC.wallsEditor.sceneObjects.length; i++)
        {
            let obj = WC.wallsEditor.sceneObjects[i];

            let x = obj.x;
            let y = obj.z;
            let sx = obj?.getWidth() / 2;
            let sy = obj?.getDepth() / 2;
            let ang = TR.degToRad(-obj.rotationY);

            let dA = TR.rotateXY(-sx, -sy, ang);
            let dB = TR.rotateXY(-sx,  sy, ang);
            let dC = TR.rotateXY( sx,  sy, ang);
            let dD = TR.rotateXY( sx, -sy, ang);

            let A = WC.wallsEditor.realToView(new TR.Point(x + dA[0], y + dA[1]));
            let B = WC.wallsEditor.realToView(new TR.Point(x + dB[0], y + dB[1]));
            let C = WC.wallsEditor.realToView(new TR.Point(x + dC[0], y + dC[1]));
            let D = WC.wallsEditor.realToView(new TR.Point(x + dD[0], y + dD[1]));

            if (obj?.getType() == R2D.ProductType.MODEL && obj?.getForWall())
            {
                me.objContext.fillStyle = WC.FOR_WALL_FILL_STYLE;
                me.objContext.strokeStyle = WC.FOR_WALL_FILL_STYLE;
            }
            else
            {
                me.objContext.fillStyle = WC.MODEL_FILL_STYLE;
                me.objContext.strokeStyle = WC.MODEL_FILL_STYLE;
            }

            me.objContext.beginPath();

            me.objContext.moveTo(A.x, A.y);
            me.objContext.lineTo(B.x, B.y);
            me.objContext.lineTo(C.x, C.y);
            me.objContext.lineTo(D.x, D.y);
            me.objContext.lineTo(A.x, A.y);

            me.objContext.stroke();
            me.objContext.fill();
            me.objContext.closePath();
        }
    };

    me.getUseRulers = function()
    {
        return true;
    };

    me.addRuler = function()
    {
        
        if (me.state == me.stateMakingRuler)
        {
            me.stopMake();
        }
        else
        {
            
            me.changeState(me.stateMakingRuler); 
        }
    };

    me.doneSomething = function()
    {
        return WC.core.roomPoints.length >= 1 || WC.core.coverPoints.length >= 1;
    };

    me.doneALot = function()
    {
        return WC.core.roomPoints.length >= 20 || WC.core.coverPoints.length >= 20;
    };

    me.updateTip = function(position, tabCount, position_second) {
        if (!position) return;

        if(!R2D.UserCore._instance.data.tips) return;

        if (((me.isTipShowed.TAB && me.isTipShowed.ENTER) || me.isTipShowed.ENTER_TAB) && !me.isTipOnScreen) return;
            
        if(WC.SFK.tabElements.length > 1) {
            if(me.isTipShowed.ENTER_TAB && !me.isTipOnScreen) return;
            else {
                if(WC.wallsEditor.state.name == "stateMakingWalls") {
                    if((me.isTipShowed.ENTER && !me.isTipOnScreen) || me.isTipShowed.TAB) {
                        if (!me.isTipShowed.TAB) {
                            me.isTipShowed.TAB = true;
                            me.isTipOnScreen = true;
                            me.api.dispatchEvent(
                                new Event(me.api.USE_TAB_TIP_START, {position})
                            );
                        } else if (me.isTipOnScreen) {
                            me.api.dispatchEvent(
                                new Event(me.api.USE_TAB_TIP_MOVE, {position})
                            );
                        }
                    } else {
                        if (!me.isTipShowed.ENTER) {
                            me.isTipShowed.ENTER = true;
                            me.isTipOnScreen = true;
                            me.api.dispatchEvent(
                                new Event(me.api.USE_ENTER_TIP_START, {position})
                            );
                        } else if (me.isTipOnScreen) {
                            me.api.dispatchEvent(
                                new Event(me.api.USE_ENTER_TIP_MOVE, {position})
                            );
                        }
                    }
                }
                else {
                    if(me.isTipShowed.ENTER) {
                        if (!me.isTipShowed.TAB) {
                            me.isTipShowed.TAB = true;
                            me.isTipOnScreen = true;
                            me.api.dispatchEvent(
                                new Event(me.api.USE_TAB_TIP_START, {position})
                            );
                        } else if (me.isTipOnScreen) {
                            me.api.dispatchEvent(
                                new Event(me.api.USE_TAB_TIP_MOVE, {position})
                            );
                        }
                    } else {
                        if (!me.isTipShowed.ENTER_TAB) {
                            me.isTipShowed.ENTER_TAB = true;
                            me.isTipOnScreen = true;
                            me.api.dispatchEvent(
                                new Event(me.api.USE_ENTER_TAB_TIP_START, {position, position_second})
                            );
                        } else if (me.isTipOnScreen) {
                            me.api.dispatchEvent(
                                new Event(me.api.USE_ENTER_TAB_TIP_MOVE, {position, position_second})
                            );
                        }
                    }
                }   
            }
        } else {
            
            if (!me.isTipShowed.ENTER) {
                me.isTipShowed.ENTER = true;
                me.isTipOnScreen = true;
                me.api.dispatchEvent(
                    new Event(me.api.USE_ENTER_TIP_START, {position})
                );
            } else if (me.isTipOnScreen) {
                me.api.dispatchEvent(
                    new Event(me.api.USE_ENTER_TIP_MOVE, {position})
                );
            }
        }
    }
};


WC.WallsEditor._instance = null;

WC.WallsEditor.init = (data, scene, apiDispatcher) => {
    
    WC.WallsEditor._instance = new WC.WallsEditor(data, scene, apiDispatcher)
    return WC.WallsEditor._instance;
};


// WC.events.wheel = (e) => inst.onCanvasWheel(e);
// WC.events.dblclick = (e) => inst.onCanvasDblClick(e);
WC.events.mousedown = e => WC.WallsEditor._instance.onCanvasMouseDown(e);
WC.events.mouseup = e => WC.WallsEditor._instance.onCanvasMouseUp(e);
WC.events.mousemove = e => WC.WallsEditor._instance.onCanvasMouseMove(e);


R2D.extend(WC.WallsEditor, R2D.Viewer);

// viewers

WC.TitlesToolConstr = function(scene3d, wallsData, api)
{
    let me = this;
    let currentToolContainer = null;
    let currentCanvas = null;
    let currentViewer = null;

    let width = 800;
    let height = 600;

    let movingElem = null;
    let movingShiftX = 0;
    let movingShiftY = 0;

    let elements = [];

    wallsData.addEventListener(WC.REMOVE_ALL, removeAllListener);

    function removeAllListener(e)
    {
        me.hide();
    }

    me.setSize = function(w, h) {
        width = w;
        height = h;
        me.viewUpdate();
    };

    me.updateComponents = function(toolContainer, canvas, viewer)
    {
        
        if (viewer != R2D.view2d && viewer != R2D.viewConstructor) me.hide();

        currentToolContainer = toolContainer;
        currentCanvas = canvas;
        currentViewer = viewer;

        if (viewer == R2D.view2d || viewer == R2D.viewConstructor)
        {
            setTimeout(function() {

                me.show();
            }, 100);
        }
    };

    me.rightPanelToggle = status => {
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;
        me.setSize(status ? width - 270 : width + 270, height);
    }

    let active = true;

    me.hide = function() {
        if (! active) return;

        active = false;

        R2D.MEC.remove(window, window, R2D.MEC.LEFT_MOUSE_UP, windowUpListener);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_WHEEL, windowWheelListener);
        R2D.MEC.remove(window, window, R2D.MEC.MOUSE_MOVE, windowMoveListener);
        R2D.DimensionSystem.removeEventListener(Event.CHANGE, dimensionSystemChangeEvent);

        removeTitles();
    //    me.exportData();
    };

    me.show = function()
    {
        WC.wallsEditor.setStructureToWallsData();
        WC.wallsEditor.setStructure(R2D.scene.constructor);
        
        if (active) return;

        active = true;

        createTitles();

        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_UP, windowUpListener);
        R2D.MEC.add(window, window, R2D.MEC.LEFT_MOUSE_DOWN, windowDownListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_WHEEL, windowWheelListener);
        R2D.MEC.add(window, window, R2D.MEC.MOUSE_MOVE, windowMoveListener);
        R2D.DimensionSystem.addEventListener(Event.CHANGE, dimensionSystemChangeEvent);

        //me.updateOnZoom();
        me.viewUpdate();
    };

    function createTitles()
    {
        if(!currentToolContainer) return;
        for (let cover of wallsData.covers)
        {
            
            if (!cover.title) continue;
            let elem = new WC.TitleElementConstr(cover);

            elements.push(elem);
            currentToolContainer.appendChild(elem.getDomElement());
            elem.getDomElement().addEventListener('mousedown', elemDownListener);
            elem.getDomElement().addEventListener('mouseup', elemUpListener);

            let inputName = elem.getInputElement();
            let spanText = elem.getSpanElement();

            elem.updateValue(spanText.offsetWidth);

            inputName.addEventListener("focus", e => document.addEventListener("keydown", onKeyDown))

            let onKeyDown = e => e.code == "Enter" ? e.target.blur() : null;

            inputName.addEventListener("blur", e => {
                if(!R2D.mouseInteractionHelper.getObjectSelection()) return;
                cover.title.text = e.target.value;
                inputName.style.pointerEvents = "none";
                document.removeEventListener("keydown", onKeyDown)
                api.dispatchEvent(new Event(api.CHANGED_TITLE_TEXT, cover.title.text))
            });
            inputName.addEventListener("input", e => {
                spanText.innerHTML = e.target.value;
                inputName.style.width = spanText.offsetWidth + "px";
            });
            elem.updatePosition()
        }
    }

    function removeTitles()
    {
        if(!currentToolContainer) return;
        for (let elem of elements)
        {
            elem.getDomElement().removeEventListener('mousedown', elemDownListener);
            elem.getDomElement().removeEventListener('mouseup', elemUpListener);
            if(currentToolContainer.contains(elem.getDomElement())) currentToolContainer.removeChild(elem.getDomElement());
        }
        elements = [];
    }

    me.updateValues = function(id)
    {
        elements[id - 1].updatePosition();
        elements[id - 1].updateValue();
    };

    let autoUpdate = null;

    me.viewUpdate = function()
    {
        if (! active) return;

        for (let elem of elements) elem.updatePosition();
    };

    me.updateOnZoom = function()
    {
    };

    me.isCreating = function()
    {
        return creating;
    };

    function dimensionSystemChangeEvent()
    {
        me.viewUpdate();
    }

    function windowWheelListener()
    {
        me.updateOnZoom();
    }

    let downTime = null;
    let upTime = null;

    function elemDownListener(e)
    {
        if(!R2D.mouseInteractionHelper.getObjectSelection()) return;
        downTime = Date.now();
        for (let elem of elements)
        {
            if (elem.getDomElement() == e.currentTarget)
            {
                
                movingElem = elem;
                movingShiftX = e.clientX - elem.scrX;
                movingShiftY = e.clientY - elem.scrY;
                movingElem.getDomElement().style.cursor = 'grabbing';
                break;
            }
        }
    }

    function elemUpListener(e)
    {
        if(!R2D.mouseInteractionHelper.getObjectSelection()) return;
        upTime = Date.now();
        if(upTime - downTime < 200) {
            for (let elem of elements)
            {
                if (elem.getDomElement() == e.target)
                {
                    //elem.select();
                    break;
                }
            }
        }
        
    }

    let downX = 0;
    let downY = 0;
    let downT = 0;
    function windowDownListener(e)
    {
        downX = e.clientX;
        downY = e.clientY;
        downT = new Date();
    }

    function windowUpListener(e)
    {
        if (! movingElem) return;

        movingElem.scrX = e.clientX - movingShiftX;
        movingElem.scrY = e.clientY - movingShiftY;
        movingElem.repositionByScreen();
        movingElem.getDomElement().style.cursor = 'grab';

        if (TR.manhDist(downX, downY, e.clientX, e.clientY) < 5 && new Date() - downT < 200)
        {
            if(R2D.mouseInteractionHelper.getObjectSelection()) movingElem.select();
            
        }

        movingElem = null;
    }

    function windowMoveListener(e)
    {
        if (! movingElem) return;

        movingElem.scrX = e.clientX - movingShiftX;
        movingElem.scrY = e.clientY - movingShiftY;
        movingElem.moveDiv();
    }

};

WC.TitleElementConstr = function(constrObj)
{
    let me = this;

    let titleObj = constrObj.title;
    let div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.fontFamily = '"Roboto", sans-serif';
    div.style.color = '#202122';
    div.style.textAlign = 'center';
    div.style.userSelect = 'none';
    div.style.cursor = 'grab';
    div.style.whiteSpace = 'nowrap';
    div.style.display = titleObj.visible || titleObj.areaVisible ? 'block' : 'none';

    let inputName = document.createElement('input');
    inputName.type = "text";
    inputName.classList.add("titleTool_input");    

    let spanText = document.createElement('span');
    spanText.style.visibility = "hidden";
    spanText.style.position = "absolute";

    if(!titleObj.visible) inputName.style.display = spanText.style.display = 'none';

    let areaText = document.createElement('span');
    areaText.style.position = "absolute";
    areaText.style.top = "100%";
    areaText.style.left = "50%";
    areaText.style.transform = "translateX(-50%)";

    if(!titleObj.areaVisible) areaText.style.display = 'none';

    spanText.style.fontSize = inputName.style.fontSize = '13px';
    areaText.style.fontSize = '11px';

    inputName.value = spanText.innerHTML = titleObj.text;

    areaText.innerHTML = R2D.DimensionSystem.squareToString(constrObj.area);

    inputName.style.textShadow = areaText.style.textShadow = '-1px 0px 0px #fff, 1px 0px 0px #fff, 0px -1px 0px #fff, 0px 1px 0px #fff';

    div.append(inputName);
    div.append(spanText);
    div.append(areaText);

    inputName.style.background = "transparent";
    inputName.style.border = "none";
    inputName.style.pointerEvents = "none";

    let pr = new THREE.Vector3();
    me.scrX = 0;
    me.scrY = 0;

    me.id = constrObj.id;

    me.getInputElement = () => inputName;

    me.getSpanElement = () => spanText;

    me.getDomElement = function()
    {
        return div;
    };

    me.select = function() {   
        inputName.style.pointerEvents = "auto";
        inputName.focus();
    };

    me.updatePosition = function() {        

        let {x, y} = WC.wallsEditor.realToView({x: titleObj.x, y: titleObj.y});
        
        me.scrX = x;
        me.scrY = y;

        div.style.display = titleObj.visible || titleObj.areaVisible ? 'block' : 'none';
        inputName.style.display = spanText.style.display = titleObj.visible ? 'block' : 'none';
        areaText.style.display = titleObj.areaVisible ? 'block' : 'none';

        let bound = div.getBoundingClientRect();
        div.style.left = Math.round(me.scrX - bound.width / 2) + "px";
        div.style.top = Math.round(me.scrY - bound.height / 2) + "px";
    };

    me.repositionByScreen = function() {

        let {x, y} = WC.wallsEditor.viewToReal({x: me.scrX, y: me.scrY});

        titleObj.x = x;
        titleObj.y = y;

        me.updatePosition();
    };

    me.moveDiv = function()
    {
        let bound = div.getBoundingClientRect();

        div.style.left = Math.round(me.scrX - bound.width / 2) + "px";
        div.style.top = Math.round(me.scrY - bound.height / 2) + "px";
    };

    me.updateValue = function(newWidth)
    {
        spanText.innerHTML = inputName.value = titleObj.text;
        newWidth = spanText.offsetWidth != 0 ? spanText.offsetWidth : newWidth;
        inputName.style.width = newWidth + "px";
    }
};

WC.BaseState = function()
{
    var me = this;

    me.setParams = function(params)
    {
        for (var k in params)
        {
            me[k] = params[k];
        }
    };

    me.start = function()
    {

    };

    me.stop = function()
    {

    };

    me.pause = function()
    {

    };

    me.restore = function()
    {

    };

	me.cancel = function()
	{

	};

    me.afterRebuild = function()
    {

    };

    me.mouseRDown = function()
    {
        if (! WC.wallsEditor.rightEnabled) return;

        WC.wallsEditor.stateDraggingCanvas.dragX = WC.viewPos.x;
        WC.wallsEditor.stateDraggingCanvas.dragY = WC.viewPos.y;

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));

        WC.wallsEditor.pushState(WC.wallsEditor.stateDraggingCanvas);
        me.draw();
    };

    me.mouseRMove = function()
    {

    };

    me.mouseRUp = function()
    {

    };

    me.mouseWheel = function()
    {
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));

        for (var i = 0; i < WC.wallsEditor.rulers.length; i++)
        {
            WC.wallsEditor.rulers[i].calcDragPoints();
        }
    };

    me.findSnap = function()
    {
        var snapRes = WC.snapTool.getSnapPoint(WC.realPos, [], WC.SNAP_DIST / WC.wallsEditor.scale, []);
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    me.undo = function()
    {
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        WC.wallsCommander.undo();
    };

    me.redo = function()
    {
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        WC.wallsCommander.redo();
    };

    me.canUndo = function()
    {
        return WC.wallsCommander.canUndo();
    };

    me.canRedo = function()
    {
        return WC.wallsCommander.canRedo();
    };

    me.drawSize = function(A, B, k, anyway)
    {
        if (WC.SFK.selectedSizeData && WC.SFK.selectedSizeData.A == A && WC.SFK.selectedSizeData.B == B) return;

        if (WC.SFK.selectedPoint && (WC.SFK.selectedPoint == A || WC.SFK.selectedPoint == B)) return;

        anyway = typeof anyway !== 'undefined' ? anyway : true;
        var minLen = 30;

        if (WC.wallsEditor.scale != WC.wallsEditor.maxScale && TR.euclDistP(A, B) * WC.wallsEditor.scale < minLen) return;
        
        var txt = R2D.DimensionSystem.toString(TR.euclDistP(A, B).toFixed(1));
        // if (R2D.DimensionSystem.isMetric()) txt = txt + ' ' + R2D.DimensionSystem.getName();

        var vA = WC.wallsEditor.realToView(A);
        var vB = WC.wallsEditor.realToView(B);

        if (anyway)
        {
            var X1 = TR.lineIntersectLine(vA, vB, new TR.Point(0, 0), new TR.Point(WC.canvasWidth, 0), true);
            var X2 = TR.lineIntersectLine(vA, vB, new TR.Point(WC.canvasWidth, 0), new TR.Point(WC.canvasWidth, WC.canvasHeight), true);
            var X3 = TR.lineIntersectLine(vA, vB, new TR.Point(WC.canvasWidth, WC.canvasHeight), new TR.Point(0, WC.canvasHeight), true);
            var X4 = TR.lineIntersectLine(vA, vB, new TR.Point(0, WC.canvasHeight), new TR.Point(0, 0), true);

            if (X1)
            {
                if (vB.y < X1.y) vB = X1; else vA = X1;
            }
            if (X2)
            {
                if (vB.x > X2.x) vB = X2; else vA = X2;
            }
            if (X3)
            {
                if (vB.y > X3.y) vB = X3; else vA = X3;
            }
            if (X4)
            {
                if (vB.x < X4.x) vB = X4; else vA = X4;
            }
        }

        var px = (vA.x + vB.x) / 2;
        var py = (vA.y + vB.y) / 2;

        //  ,    
        // if (px < 0 || py < 0 || px > WC.canvasWidth || py > WC.canvasHeight) return; 

        var dx = vB.x - vA.x;
        var dy = vB.y - vA.y;

        var r = Math.sqrt(dx * dx + dy * dy);
        var ang = Math.atan2(dy, dx);

        if (ang > Math.PI / 2 - TR.B_EPS) ang = ang - Math.PI;
        if (ang < -Math.PI / 2) ang = ang + Math.PI;

        dx = dx / r * 10 * k;
        dy = dy / r * 10 * k;

        WC.context.textAlign = "center";
        WC.context.textBaseline = "middle";
        WC.context.font = "10pt Arial";
        WC.context.strokeStyle = '#000000';
        WC.context.fillStyle = '#000000';

        if (WC.wallsEditor.scale != WC.wallsEditor.maxScale && TR.euclDistP(vA, vB) < WC.context.measureText(txt).width + 30) return;

        if (WC.SFK.curSizeData && WC.SFK.curSizeData.A == A && WC.SFK.curSizeData.B == B) {
            WC.SFK.addBackgroundToActiveSize();
        } 

        WC.context.save();
        WC.context.translate(px + dy, py - dx);
        WC.context.rotate(ang);
        WC.context.fillText(txt, 0, 0);
        WC.context.restore();

        // -------------------
        WC.SFK.addSizeData({
            txtWidth: WC.context.measureText(txt).width,
            txtHeight: parseFloat(WC.context.font),
            ang,
            txt,
            center: { x: px + dy, y: py - dx },
            vA,
            vB,
            inputCenter: { x: px + 1.5 * dy, y: py - 1.5 * dx },
            A,
            B,
            k,
        });
    };

    me.drawRoom = function(room)
    {
        if (room?.outer)
        {
            WC.context.fillStyle = WC.MEAT_FILL_STYLE;
            WC.context.strokeStyle = WC.MEAT_STROKE_STYLE;

            for (var i = 0; i < room.triangles.length; i++)
            {
                var pt1 = room.triangles[i][0];
                var pt2 = room.triangles[i][1];
                var pt3 = room.triangles[i][2];
                me.drawTri(pt1[0], pt1[1], pt2[0], pt2[1], pt3[0], pt3[1])
            }
        }

        if (room.points.length <= 1) return;

        if (room.selected)
        {
            WC.context.strokeStyle = '#bae51f';
            WC.context.lineWidth = 3;
        }
        else
        {
            WC.context.strokeStyle = '#7c7c7c';
            WC.context.lineWidth = 1;
        }

        WC.context.fillStyle = "rgba(0, 0, 0, 0)"; //'#d4d6d7';

        me.drawPolygon(room.points);
    };

    me.drawCover = function(cover)
    {
        if (cover.points.length <= 1) return;

        WC.context.strokeStyle = "rgba(0, 0, 0, 0)";

        if (cover?.outer)
        {
            if (cover.selected)
            {
                WC.context.fillStyle = WC.context.createPattern(WC.imgSelectedFloor, "repeat");
            }
            else
            {
                WC.context.fillStyle = WC.context.createPattern(WC.imgFloor, "repeat");
            }

            for (var i = 0; i < cover.triangles.length; i++)
            {
                var pt1 = cover.triangles[i][0];
                var pt2 = cover.triangles[i][1];
                var pt3 = cover.triangles[i][2];
                me.drawTri(pt1[0], pt1[1], pt2[0], pt2[1], pt3[0], pt3[1])
            }
        }

        WC.context.fillStyle = "rgba(0, 0, 0, 0)";

        WC.context.strokeStyle = '#7c7c7c';
        WC.context.lineWidth = 1;

        me.drawPolygon(cover.points);
    };

    me.drawArea = function(area)
    {
        if (area.points.length <= 1) return;

        if (area.selected)
        {
            WC.context.fillStyle = WC.SELECTED_AREA_FILL_STYLE;
        }
        else
        {
            WC.context.fillStyle = WC.AREA_FILL_STYLE;
        }

        WC.context.strokeStyle = "rgba(0, 0, 0, 0)";
        WC.context.lineWidth = 0;

        for (var i = 0; i < area.triangles.length; i++)
        {
            var pt1 = area.triangles[i][0];
            var pt2 = area.triangles[i][1];
            var pt3 = area.triangles[i][2];
            me.drawTri(pt1[0], pt1[1], pt2[0], pt2[1], pt3[0], pt3[1])
        }
    };

    me.drawTri = function(ax, ay, bx, by, cx, cy)
    {
        WC.context.beginPath();

        var A = WC.wallsEditor.realToView(new TR.Point(ax, ay));
        var B = WC.wallsEditor.realToView(new TR.Point(bx, by));
        var C = WC.wallsEditor.realToView(new TR.Point(cx, cy));

        WC.context.moveTo(A.x + 0.5, A.y + 0.5);
        WC.context.lineTo(B.x + 0.5, B.y + 0.5);
        WC.context.lineTo(C.x + 0.5, C.y + 0.5);
        WC.context.lineTo(A.x + 0.5, A.y + 0.5);

        WC.context.fill();
        WC.context.stroke();
        WC.context.closePath();
    };

    me.drawPolygonSizes = function(room, anyway, reverse)
    {
        if(!room) return;
        var pts = room.points;
        var k = 1;
        if (room?.outer) k = -1;
        if (reverse) k = -k;

        WC.context.fillStyle = "rgba(0, 0, 0, 1)";

        if (WC.wallsEditor.sizesVisible)
        {
            for (var i = 0; i < pts.length - 1; i++)
            {
                me.drawSize(pts[i], pts[i + 1], k, anyway)
            }
            me.drawSize(pts[pts.length - 1], pts[0], k, anyway);
        }
    };

    me.drawPolygon = function(pts)
    {
        WC.context.beginPath();

        var viewCoord = WC.wallsEditor.realToView(pts[pts.length - 1]);

        WC.context.moveTo(viewCoord.x + 0.5, viewCoord.y + 0.5);

        for (var i = 0; i < pts.length; i++)
        {
            viewCoord = WC.wallsEditor.realToView(pts[i]);
            WC.context.lineTo(viewCoord.x + 0.5, viewCoord.y + 0.5);
        }

        WC.context.fill();
        WC.context.stroke();
        WC.context.closePath();
    };

    me.drawPoint = function(point)
    {
        var viewCoord = WC.wallsEditor.realToView(point);

        if (viewCoord.x < 0 || viewCoord.y < 0 || viewCoord.x > WC.canvasWidth || viewCoord.y > WC.canvasHeight) return;

        var r = 5;

        if (point.state == WC.UP)
        {
            if (point.type == WC.ROOM_POINT)
            {
                WC.context.drawImage(WC.imgPoint, viewCoord.x - r + 1, viewCoord.y - r + 1);
            }
            else
            {
                WC.context.drawImage(WC.imgCoverPoint, viewCoord.x - r + 1, viewCoord.y - r + 1);
            }
        }
        else
        {
            if (point.state == WC.OVER)
            {
                if (point.type == WC.ROOM_POINT)
                {
                    WC.context.fillStyle = '#bae51f';
                }
                else
                {
                    WC.context.fillStyle = '#FFDD66';
                }

                WC.context.strokeStyle = '#444444';
                r = 7;
            }
            else
            {
                if (point.type == WC.ROOM_POINT)
                {
                    WC.context.fillStyle = '#bae51f';
                }
                else
                {
                    WC.context.fillStyle = '#FFDD66';
                }

                WC.context.strokeStyle = '#444444';
                r = 3;
            }

            WC.context.beginPath();
            WC.context.arc(viewCoord.x + 1, viewCoord.y + 1, r, 0, Math.PI * 2);
            WC.context.stroke();
            WC.context.fill();
            WC.context.closePath();
        }


    };

    me.dblClick = function()
    {

    };

    me.drawAligner = function()
    {
        if (! WC.aligners) return;

        var locSnapPos = WC.wallsEditor.realToView(WC.snapPos);

        WC.context.strokeStyle = '#00aa00';
        WC.context.lineWidth = 1;
        WC.context.setLineDash([2, 4]);

        WC.context.beginPath();

        for (var i = 0; i < 3; i++)
        {
            if (WC.aligners[i])
            {
                var locAligner = WC.wallsEditor.realToView(WC.aligners[i]);
                WC.context.moveTo(locSnapPos.x, locSnapPos.y);
                WC.context.lineTo(locAligner.x, locAligner.y);
            }
        }

        WC.context.stroke();
        WC.context.closePath();
        WC.context.setLineDash([]);
    };

    me.drawBG = function(opacity)
    {
        if (!WC.wallsEditor.imgDrawing) return;
        
        var viewCoord = WC.wallsEditor.realToView(new TR.Point(0, 0));

        WC.context.globalAlpha = opacity;
        WC.context.translate(viewCoord.x, viewCoord.y);
        WC.context.rotate(WC.wallsEditor.drawingRotation);
        WC.context.scale(WC.wallsEditor.scale * WC.wallsEditor.drawingScale, WC.wallsEditor.scale * WC.wallsEditor.drawingScale);
        WC.context.translate(WC.wallsEditor.drawingX, WC.wallsEditor.drawingY);

        if(WC.wallsEditor.imgDrawing.complete && WC.wallsEditor.imgDrawing.naturalHeight !== 0 && WC.wallsEditor.imgDrawing.naturalWidth !== 0) WC.context.drawImage(WC.wallsEditor.imgDrawing, 0, 0);

        WC.context.translate(-WC.wallsEditor.drawingX, -WC.wallsEditor.drawingY);
        WC.context.scale(1 / WC.wallsEditor.scale / WC.wallsEditor.drawingScale, 1 / WC.wallsEditor.scale / WC.wallsEditor.drawingScale);
        WC.context.rotate(-WC.wallsEditor.drawingRotation);
        WC.context.translate(-viewCoord.x, -viewCoord.y);
        WC.context.globalAlpha = 1;
    };

    me.drawCross = function()
    {
        var crossSize = 10;
        var P = WC.wallsEditor.realToView(WC.snapPos);

        WC.context.strokeStyle = '#000000';
        WC.context.lineWidth = 1;
        WC.context.beginPath();
        WC.context.moveTo(P.x - 10 + 0.5, P.y + 0.5);
        WC.context.lineTo(P.x + 10 + 0.5, P.y + 0.5);
        WC.context.moveTo(P.x + 0.5, P.y - 10 + 0.5);
        WC.context.lineTo(P.x + 0.5, P.y + 10 + 0.5);
        WC.context.stroke();
        WC.context.closePath();
    };

    me.drawObjects = function()
    {
        WC.context.drawImage(WC.wallsEditor.objCanvas, 0, 0);
    };

    me.drawRuler = function(ruler)
    {
        if (! WC.imgAlignerIconUp) return;

        var A = WC.wallsEditor.realToView(ruler.aligner1.center);
        var B = WC.wallsEditor.realToView(ruler.aligner2.center);

        WC.context.strokeStyle = '#ffffff';
        WC.context.fillStyle = '#ffffff';
        WC.context.lineWidth = 3;

        WC.context.beginPath();
        WC.context.moveTo(A.x, A.y);
        WC.context.lineTo(B.x, B.y);
        WC.context.stroke();
        WC.context.closePath();

        WC.context.strokeStyle = '#dd0066';
        WC.context.fillStyle = '#dd0066';
        WC.context.lineWidth = 1;

        WC.context.beginPath();
        WC.context.setLineDash([5]);
        WC.context.moveTo(A.x, A.y);
        WC.context.lineTo(B.x, B.y);
        WC.context.stroke();
        WC.context.closePath();

        var dw = WC.imgAlignerIconUp?.width / 2;
        var dh = WC.imgAlignerIconUp?.height;
        if (ruler.aligner1.state == 'up')
        {
            WC.context.drawImage(WC.imgAlignerIconUp, A.x - dw, A.y - dh);
        }
        else
        {
            WC.context.drawImage(WC.imgAlignerIconOver, A.x - dw, A.y - dh);
        }

        if (ruler.aligner2.state == 'up')
        {
            WC.context.drawImage(WC.imgAlignerIconUp, B.x - dw, B.y - dh);
        }
        else
        {
            WC.context.drawImage(WC.imgAlignerIconOver, B.x - dw, B.y - dh);
        }
    };

    me.drawRulerLabel = function(ruler)
    {
        if (! WC.imgAlignerIconUp) return;

        var dist = TR.euclDistP(ruler.aligner1.center, ruler.aligner2.center);

        var A = WC.wallsEditor.realToView(ruler.aligner1.center);
        var B = WC.wallsEditor.realToView(ruler.aligner2.center);

        var textX = Math.round((A.x + B.x) / 2) + 0.5;
        var textY = Math.round((A.y + B.y) / 2) + 0.5;

        WC.context.textAlign = "center";
        WC.context.textBaseline = "middle";
        WC.context.font = "10pt Arial";

        WC.context.strokeStyle = 'white';
        WC.context.lineWidth = 6;

        var text = R2D.DimensionSystem.toString(dist);
        if (R2D.DimensionSystem.isMetric()) text = text + ' ' + R2D.DimensionSystem.getName();
        var tWidth = WC.context.measureText(text).width + 10;
        var tHeight = 20;
        var tWidth2 = Math.round((WC.context.measureText(text).width + 10) / 2);
        var tHeight2 = tHeight / 2;
        tWidth = Math.round(tWidth);

        WC.context.strokeStyle = '#dd0066';
        WC.context.fillStyle = '#ffffff';
        WC.context.lineWidth = 1;
        WC.context.setLineDash([]);
        WC.context.fillRect(Math.round(textX - tWidth2) + 0.5, Math.round(textY - tHeight2 - 1) + 0.5, tWidth, tHeight);
        WC.context.strokeRect(Math.round(textX - tWidth2) + 0.5, Math.round(textY - tHeight2 - 1) + 0.5, tWidth, tHeight);

        WC.context.fillStyle = '#000000';
        WC.context.fillText(text, textX, textY);
    };

    me.drawRulers = function()
    {
        for (var i = 0; i < WC.wallsEditor.rulers.length; i++) me.drawRuler(WC.wallsEditor.rulers[i]);
        for (i = 0; i < WC.wallsEditor.rulers.length; i++) me.drawRulerLabel(WC.wallsEditor.rulers[i]);

    };

    me.drawModels = function()
    {
        if (! WC.wallsEditor.imgModels) return;

        var viewCoord = WC.wallsEditor.realToView(new TR.Point(0, 0));

        WC.context.globalAlpha = 0.3;
        WC.context.translate(viewCoord.x, viewCoord.y);
        WC.context.scale(WC.wallsEditor.scale, WC.wallsEditor.scale);
        WC.context.translate(WC.wallsEditor.modelsX, WC.wallsEditor.modelsY);

        WC.context.drawImage(WC.wallsEditor.imgModels, 0, 0, WC.wallsEditor.imgModels.width / 2, WC.wallsEditor.imgModels.height / 2);

        WC.context.translate(-WC.wallsEditor.modelsX, -WC.wallsEditor.modelsY);
        WC.context.scale(1 / WC.wallsEditor.scale, 1 / WC.wallsEditor.scale);
        WC.context.translate(-viewCoord.x, -viewCoord.y);
        WC.context.globalAlpha = 1;
    };


    me.draw = function()
    {
        WC.SFK.sizesData = [];

        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_BELOW) me.drawBG(0.3);

        me.drawModels();

        for (var i = 0; i < WC.core.arrCovers.length; i++) me.drawCover(WC.core.arrCovers[i]);
        for (i = 0; i < WC.core.arrRooms.length; i++) me.drawRoom(WC.core.arrRooms[i]);
        for (i = 0; i < WC.core.arrRooms.length; i++) me.drawPolygonSizes(WC.core.arrRooms[i]);

        for (i = 0; i < WC.core.arrAreas.length; i++) me.drawArea(WC.core.arrAreas[i]);
        for (i = 0; i < WC.core.roomPoints.length; i++) me.drawPoint(WC.core.roomPoints[i]);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_ABOVE) me.drawBG(0.5);

        if (!R2D.view2d || R2D.Viewers.getCurrentViewerType() !== "constructor") return;

        for (const planeViewer of R2D.view2d.getObjectsViewers3dPlanes().values()) {
            planeViewer.updateObject();
            planeViewer.makeCanvasLighter();

            const viewCoord = WC.wallsEditor.realToView(
                new TR.Point(planeViewer.sceneObject.x, planeViewer.sceneObject.z)
            );
            const width = planeViewer.canvasWidth * WC.wallsEditor.scale;
            const height = planeViewer.canvasHeight * WC.wallsEditor.scale;

            WC.context.save();
            WC.context.translate(viewCoord.x, viewCoord.y);
            WC.context.rotate(-(planeViewer.sceneObject.rotationY * Math.PI) / 180);
            WC.context.scale(planeViewer.flipX, planeViewer.flipZ);
            WC.context.drawImage(planeViewer.canvas, -width / 2, -height / 2, width, height);
            WC.context.restore();
        }
    };

    me.setElementName = function(name)
    {

    };

    me.getElementName = function()
    {

    };
};
WC.StateDraggingCanvas = function(api)
{
    let me = this;
    WC.BaseState.call(this);
    me.name = 'stateDraggingCanvas';

    me.dragX = 0;
    me.dragY = 0;
    me.startShX = 0;
    me.startShY = 0;

    me.start = function()
    {
        me.startShX = WC.wallsEditor.shiftX;
        me.startShY = WC.wallsEditor.shiftY;
        

        me.draw();
    };

    me.stop = function()
    {
        WC.framePointLT = WC.wallsEditor.viewToReal(new TR.Point(0, 0));
        WC.framePointRB = WC.wallsEditor.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));
    };

    me.mouseRUp = function(viewX, viewY)
    {
        me.stop()
        WC.wallsEditor.popState();
    };

    me.mouseRDown = function(viewX, viewY)
    {

    };

    me.mouseMove = function(viewX, viewY)
    {
        WC.framePointLT = WC.wallsEditor.viewToReal(new TR.Point(0, 0));
        WC.framePointRB = WC.wallsEditor.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));
    };

    me.mouseRMove = function(viewX, viewY)
    {
        let dx = viewX - me.dragX;
        let dy = viewY - me.dragY;

        WC.wallsEditor.shiftX = me.startShX - dx;
        WC.wallsEditor.shiftY = me.startShY - dy;

        WC.wallsEditor.drawObjLayer();
        WC.wallsEditor.pushedStateDraw();
        WC.SFK.state.updateInputsAfterDraggingCanvasOrZoom();
        WC.wallsEditor.titlesTool.viewUpdate();
    };

    me.findSnap = function()
    {

    }
};

WC.StateDraggingCanvas.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingCanvas.prototype.constructor = WC.StateDraggingCanvas;


WC.StateDraggingCoverPoint = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateDraggingCoverPoint';

    me.covers = [];
    me.currentPt = null;

    me.start = function()
    {
        WC.wallsEditor.dispatchEvent(new Event(WC.SHOW_COVER_PAGE, WC.wallsEditor));
        WC.wallsEditor.hideCursor();

        for (var i = 0; i < me.covers.length; i++)
        {
            me.covers[i].selected = true;
        }
        me.draw();
    };

    me.stop = function()
    {
        for (var i = 0; i < me.covers.length; i++) me.covers[i].selected = false;
        me.covers = [];

        WC.core.findCoverHoles();
        WC.core.findAllCoverTriangles();
        WC.wallsEditor.titlesTool.hide();
        WC.wallsEditor.titlesTool.show(false);
        WC.wallsEditor.save();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {
        if (! me.currentPt) return;

        //    var snapedPos = WC.snapData[0];

        me.currentPt.x = WC.snapPos.x;
        me.currentPt.y = WC.snapPos.y;

        me.draw();
    };

    me.mouseUp = function()
    {
        me.currentPt = null;
        WC.wallsEditor.stateSelectedCover.covers = me.covers;
        WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedCover);
    };

    me.dblClick = function()
    {

    };

    me.findSnap = function()
    {
        if(!me.currentPt) return;
        var snapRes = WC.snapTool.getSnapPoint(WC.realPos, [me.currentPt], WC.SNAP_DIST / WC.wallsEditor.scale, me.currentPt.contour.points);
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    me.draw = function()
    {
        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_BELOW) me.drawBG(0.3);
        
        for (i = 0; i < WC.core.arrCovers.length; i++) me.drawCover(WC.core.arrCovers[i]);
        for (var i = 0; i < WC.core.arrRooms.length; i++) me.drawRoom(WC.core.arrRooms[i]);

        me.drawObjects();

        for (i = 0; i < me.covers.length; i++)
        {
            var cover = me.covers[i];
            for (var j = 0; j < cover.points.length; j++)
            {
                me.drawPoint(cover.points[j]);
            }
            me.drawPolygonSizes(me.covers[i], true, true);
        }

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_ABOVE) me.drawBG(0.5);

        me.drawRulers();
        me.drawAligner();
    };
};

WC.StateDraggingCoverPoint.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingCoverPoint.prototype.constructor = WC.StateDraggingCoverPoint;

WC.StateDraggingPoint = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateDraggingPoint';

    me.currentPt = null;
    me.currentRoom = null;
    me.exceptPts = [];

    me.start = function()
    {
        if(!me.currentPt || !me.currentPt.children) return;
        WC.wallsEditor.hideCursor();
        me.exceptPts = me.currentPt.children.concat(me.currentPt);
        for (var i = 0; i < WC.core.arrRooms.length; i++)
        {
            if (WC.core.arrRooms[i].points.includes(me.currentPt)) me.currentRoom = WC.core.arrRooms[i];
        }
        me.draw();
    };

    me.stop = function()
    {
        WC.core.rebuildWallsAndCovers();
        WC.core.findAllCoverTriangles();
        WC.wallsEditor.titlesTool.updateComponents();
        WC.wallsEditor.save();
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {
        if (! me.currentPt) return;

        me.currentPt.move(WC.snapPos.x, WC.snapPos.y);

        me.draw();
    };

    me.mouseUp = function()
    {
        me.currentPt = null;
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);

        me.draw();
    };

    me.dblClick = function()
    {

    };

    me.findSnap = function()
    {
        if(!me.currentPt) return;
        var snapRes = WC.snapTool.getSnapPoint(WC.realPos, me.exceptPts, WC.SNAP_DIST / WC.wallsEditor.scale, me.currentPt.contour.points);
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    //var superDraw = me.draw;

    me.draw = function()
    {
        //superDraw();
        //me.drawRulers();
        //me.drawAligner();

        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_BELOW) me.drawBG(0.3);

        me.drawModels();

        for (var i = 0; i < WC.core.arrCovers.length; i++) me.drawCover(WC.core.arrCovers[i]);
        for (i = 0; i < WC.core.arrRooms.length; i++) me.drawRoom(WC.core.arrRooms[i]);
        for (i = 0; i < WC.core.arrAreas.length; i++) me.drawArea(WC.core.arrAreas[i]);
        for (i = 0; i < WC.core.roomPoints.length; i++) me.drawPoint(WC.core.roomPoints[i]);

        for (i = 0; i < WC.core.arrRooms.length; i++)
        {
            if (WC.core.arrRooms[i] != me.currentRoom) me.drawPolygonSizes(WC.core.arrRooms[i]);
        }
        me.drawPolygonSizes(me.currentRoom, true);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_ABOVE) me.drawBG(0.5);

        me.drawRulers();
        me.drawAligner();
    }
};

WC.StateDraggingPoint.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingPoint.prototype.constructor = WC.StateDraggingPoint;

WC.StateDraggingRoom = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateDraggingRoom';

    me.room = null;
    me.innerPoints = [];

    me.exceptPts = [];

    var dxDrag = 0;
    var dyDrag = 0;

    me.start = function()
    {
        dxDrag = me.room?.points[0].x - WC.realPos.x;
        dyDrag = me.room?.points[0].y - WC.realPos.y;

        me.exceptPts = [].concat(me.room?.points);
        for (var i = 0; i < me.room?.points.length; i++)
        {
            me.exceptPts = me.exceptPts.concat(me.room?.points[i].children);
        }

        me.draw();
    };

    me.stop = function()
    {
        WC.core.rebuildWallsAndCovers();
        WC.wallsEditor.save();
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {
        if (! me.room) return;

        var testPos0 = new TR.Point(WC.realPos.x + dxDrag, WC.realPos.y + dyDrag);

    //    var snapRes = WC.snapTool.getSnapPoint(testPos0, me.exceptPts, WC.SNAP_DIST / WC.wallsEditor.scale, []);
    //    WC.snapPos = snapRes[0];
    //    WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];

        var dx = testPos0.x - me.room.points[0].x;
        var dy = testPos0.y - me.room.points[0].y;

        for (var i = 0; i < me.room.points.length; i++)
        {
            var P = me.room.points[i];
            if(P && P.move) P.move(P.x + dx, P.y + dy);
        }

        for (i = 0; i < me.innerPoints.length; i++)
        {
            P = me.innerPoints[i];
            P.move(P.x + dx, P.y + dy);
        }

        me.draw();
    };

    me.mouseUp = function()
    {
        WC.wallsEditor.stateSelectedRoom.room = me.room;
        WC.wallsEditor.titlesTool.updateComponents();
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);

        me.draw();
    };

    me.dblClick = function()
    {

    };

    me.findSnap = function()
    {

    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        me.drawRulers();
    }
};

WC.StateDraggingRoom.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingRoom.prototype.constructor = WC.StateDraggingRoom;

WC.StateDraggingWall = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateDraggingWall';

    me.dragPtA = null;
    me.dragPtB = null;
    me.parallelPt = null;
    me.exceptPts = [];

    var startPosA = null;
    var startPosB = null;
    var snapPosA = null;
    var startDragPt = null;
    var ptDir1 = null;
    var ptDir2 = null;

    me.start = function()
    {
        if(!me.dragPtA || !me.dragPtB) return;
        startDragPt = WC.realPos.clone();
        startPosA = me.dragPtA.clone();
        startPosB = me.dragPtB.clone();

        me.exceptPts = [me.dragPtA, me.dragPtB].concat(me.dragPtA.children).concat(me.dragPtB.children);
        me.draw();

        ptDir1 = startPosA;
        ptDir2 = TR.perpendicularPoint(startPosA, startPosB, 100);
    };

    me.stop = function()
    {
        WC.core.rebuildWallsAndCovers();
        WC.core.findAllCoverTriangles();
        WC.wallsEditor.titlesTool.updateComponents();
        WC.wallsEditor.save();
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {
        if (!me.dragPtA || !me.dragPtB || !startPosA || !me.dragPtA.move || !me.dragPtB.move) return;

        var dx = WC.realPos.x - startDragPt.x;
        var dy = WC.realPos.y - startDragPt.y;
        var testPosA = new TR.Point(startPosA.x + dx, startPosA.y + dy);

        // + Projection on line perpendicular to wall

        var snapRes = WC.snapTool.getSnapPoint(testPosA, me.exceptPts, WC.SNAP_DIST / WC.wallsEditor.scale, []);

        WC.snapPos = TR.projectionPointOnLine(snapRes[0], ptDir1, ptDir2, false);
        WC.aligners = [null, null, null];

        dx = WC.snapPos.x - startPosA.x;
        dy = WC.snapPos.y - startPosA.y;

        me.dragPtA.move(WC.snapPos.x, WC.snapPos.y);
        me.dragPtB.move(startPosB.x + dx, startPosB.y + dy);

        me.draw();
    };

    me.mouseUp = function()
    {
        if(!me.dragPtA) return;
        var room = me.dragPtA.contour;

        me.dragPtA = null;
        me.dragPtB = null;
        me.parallelPt = null;

        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);

        me.draw();
    };

    me.dblClick = function()
    {

    };

    me.findSnap = function()
    {

    };

    function drawWallWidth()
    {
        if (! me.parallelPt) return;

        var ptOnDragWall = TR.projectionPointOnLine(me.parallelPt, me.dragPtA, me.dragPtB);

        if (! ptOnDragWall) return;

        WC.drawTool.drawWallSize(ptOnDragWall, me.parallelPt)
    }

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        me.drawRulers();
        drawWallWidth();
    }
};

WC.StateDraggingWall.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingWall.prototype.constructor = WC.StateDraggingWall;
WC.StateDraggingCoverSide = function () {
    var me = this;
    WC.BaseState.call(this);
    me.name = "stateDraggingCoverSide";

    me.dragPtA = null;
    me.dragPtB = null;
    me.covers = null;
    me.exceptPts = [];

    var startPosA = null;
    var startPosB = null;
    var startDragPt = null;
    var ptDir1 = null;
    var ptDir2 = null;

    me.start = function () {
        startDragPt = WC.realPos.clone();
        startPosA = me.dragPtA.clone();
        startPosB = me.dragPtB.clone();

        me.exceptPts = [me.dragPtA, me.dragPtB]
            .concat(me.dragPtA.children)
            .concat(me.dragPtB.children);

        for (var i = 0; i < me.covers.length; i++) {
            me.covers[i].selected = true;
        }
        me.draw();

        ptDir1 = startPosA;
        ptDir2 = TR.perpendicularPoint(startPosA, startPosB, 100);
        
    };

    me.stop = function () {
        WC.core.findAllCoverTriangles();
        WC.wallsEditor.titlesTool.hide();
        WC.wallsEditor.titlesTool.show(false);
        WC.wallsEditor.save();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
    };

    me.mouseDown = function () {};

    me.mouseMove = function () {
        if (!me.dragPtA || !me.dragPtB || !startPosA) return;

        var dx = WC.realPos.x - startDragPt.x;
        var dy = WC.realPos.y - startDragPt.y;
        var testPosA = new TR.Point(startPosA.x + dx, startPosA.y + dy);

        // + Projection on line perpendicular to wall

        var snapRes = WC.snapTool.getSnapPoint(
            testPosA,
            me.exceptPts,
            WC.SNAP_DIST / WC.wallsEditor.scale,
            []
        );

        WC.snapPos = TR.projectionPointOnLine(snapRes[0], ptDir1, ptDir2, false);
        WC.aligners = [null, null, null];

        dx = WC.snapPos.x - startPosA.x;
        dy = WC.snapPos.y - startPosA.y;

        me.dragPtA.move(WC.snapPos.x, WC.snapPos.y);
        me.dragPtB.move(startPosB.x + dx, startPosB.y + dy);

        me.draw();
    };

    me.mouseUp = function () {
        if (!me.dragPtA) return;
        var room = me.dragPtA.contour;

        me.dragPtA = null;
        me.dragPtB = null;

        WC.wallsEditor.stateSelectedCover.covers = me.covers;
        WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedCover);

        me.draw();
    };

    me.dblClick = function () {};
    me.findSnap = function () {};

    me.draw = function () {
        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_BELOW) me.drawBG(1.0);

        for (i = 0; i < WC.core.arrCovers.length; i++) me.drawCover(WC.core.arrCovers[i]);
        for (var i = 0; i < WC.core.arrRooms.length; i++) me.drawRoom(WC.core.arrRooms[i]);

        me.drawObjects();

        for (i = 0; i < me.covers.length; i++) {
            var cover = me.covers[i];
            for (var j = 0; j < cover.points.length; j++) {
                me.drawPoint(cover.points[j]);
            }
            me.drawPolygonSizes(me.covers[i], true, true);
        }

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_ABOVE) me.drawBG(0.3);

        me.drawRulers();
        me.drawAligner();
    };
};

WC.StateDraggingCoverSide.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingCoverSide.prototype.constructor = WC.StateDraggingCoverSide;

WC.StateEditing = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateEditing';

    var pointOver = null;
    var sideOverCont = null;
    var sideOverIndA = -1;
    var sideOverIndB = -1;
    var sideOverData = null;

    var areaOver = null;
    var overMeat = false;
    var lastClickOnMeat = false;

    var pointDown = false;
    var sideDown = false;
    var downCoord = null;

    var sideCenter = null;
    var rulerAligner = null;

    me.isCtrl = false;

    function findCurrentSideAndCenter()
    {
        if (pointOver) pointOver.state = WC.UP;
        if (! WC.realPos) return;

        pointOver = WC.snapTool.findNearest(WC.realPos, WC.core.roomPoints, WC.POINT_SIZE / WC.wallsEditor.scale);
        if (pointOver) pointOver.state = WC.OVER;

        sideOverCont = null;
        sideOverIndA = -1;
        sideOverIndB = -1;
        if (! pointOver)
        {
            sideOverData = getSideByPoint(WC.realPos);
            if (sideOverData)
            {
                sideOverCont = sideOverData.room;
                sideOverIndA = sideOverData.i1;
                sideOverIndB = sideOverData.i2;
            }
        }

        sideCenter = null;
        if (sideOverCont)
        {
            var A = sideOverCont.points[sideOverIndA];
            var B = sideOverCont.points[sideOverIndB];
            sideCenter = new TR.Point((A?.x + B?.x) / 2, (A?.y + B?.y) / 2);
        }
    }

    function findCurrentRulerAligner()
    {
        if (rulerAligner) rulerAligner.state = 'up';
        if (! WC.realPos) return;

        var minDist = Number.POSITIVE_INFINITY;

        for (var i = 0; i < WC.wallsEditor.rulers.length; i++)
        {
            var ruler = WC.wallsEditor.rulers[i];
            ruler.aligner1.state = 'up';
            ruler.aligner2.state = 'up';

            var d = TR.euclDistP(WC.realPos, ruler.aligner1.dragPt);
            if (d < minDist)
            {
                minDist = d;
                rulerAligner = ruler.aligner1;
            }
            d = TR.euclDistP(WC.realPos, ruler.aligner2.dragPt);
            if (d < minDist)
            {
                minDist = d;
                rulerAligner = ruler.aligner2;
            }
        }

        if (minDist > WC.SNAP_DIST * 1.5 / WC.wallsEditor.scale)
        {
            rulerAligner = null;
        }

        if (rulerAligner) rulerAligner.state = 'over';
    }

    function getSideByPoint(P)
    {
        var accuracy = WC.SNAP_DIST / 2 / WC.wallsEditor.scale;

        for (var i = 0; i < parallelData.length; i++)
        {
            if (TR.pointOnLine(P, parallelData[i].P1, parallelData[i].P2, accuracy))
                return parallelData[i];
        }
    }

    function getWidthPoints()
    {
        if (! sideOverData) return null;

        var ptOnCurrWall = TR.projectionPointOnLine(new TR.Point(WC.realPos.x, WC.realPos.y), sideOverData.P1, sideOverData.P2);
        if (! ptOnCurrWall) return null;

        var ptOnOtherWall = null;
        var minDist = Number.MAX_VALUE;

        for (var i = 0; i < sideOverData.parallel.length; i++)
        {
            var otherLineData = sideOverData.parallel[i];
            var proj = TR.projectionPointOnLine(ptOnCurrWall, otherLineData.P1, otherLineData.P2);
            if (! proj) continue;
            var d = TR.euclDistP(proj, ptOnCurrWall);
            if (d < minDist)
            {
                minDist = d;
                ptOnOtherWall = proj;
            }
        }

        if (ptOnOtherWall) return [ptOnCurrWall, ptOnOtherWall];
        return null;
    }

    function getWidthPointsFromCurSide(curSideData) {
        if (! curSideData) return null;

        const ptOnCurrWall = TR.projectionPointOnLine(new TR.Point(WC.realPos.x, WC.realPos.y), curSideData.P1, curSideData.P2);
        if (! ptOnCurrWall) return null;

        let ptOnOtherWall = null;
        let minDist = Number.MAX_VALUE;

        for (let i = 0; i < curSideData.parallel.length; i++)
        {
            const otherLineData = curSideData.parallel[i];
            const proj = TR.projectionPointOnLine(ptOnCurrWall, otherLineData.P1, otherLineData.P2);
            if (! proj) continue;
            const d = TR.euclDistP(proj, ptOnCurrWall);
            if (d < minDist)
            {
                minDist = d;
                ptOnOtherWall = proj;
            }
        }

        if (ptOnOtherWall) return [ptOnCurrWall, ptOnOtherWall];
        return null;
    }

    var parallelData = [];

    function findParallelSides()
    {
        parallelData = [];

        for (var i = 0; i < WC.core.arrRooms.length; i++)
        {
            //WC.core.arrRooms[i].MARKED = "Marked";

            for (var j = 0; j < WC.core.arrRooms[i].points.length; j++)
            {
                var P1 = WC.core.arrRooms[i].points[j];
                var P2 = WC.core.arrRooms[i].points[j + 1];
                if (j == WC.core.arrRooms[i].points.length - 1) P2 = WC.core.arrRooms[i].points[0];

                var i2 = j + 1;
                if (j == WC.core.arrRooms[i].points.length - 1) i2 = 0;
                var lineData = {P1: P1, P2: P2, room: WC.core.arrRooms[i], i1: j, i2: i2, parallel:[]};

                for (var ii = 0; ii < WC.core.arrRooms.length; ii++)
                {
                    for (var jj = 0; jj < WC.core.arrRooms[ii].points.length; jj++)
                    {
                        if (i == ii && j == jj) continue;

                        var Q1 = WC.core.arrRooms[ii].points[jj];
                        var Q2 = WC.core.arrRooms[ii].points[jj + 1];
                        if (jj == WC.core.arrRooms[ii].points.length - 1) Q2 = WC.core.arrRooms[ii].points[0];

                        var dist = TR.euclDistP(P1, TR.projectionPointOnLine(P1, Q1, Q2, false, true));
                        if (dist > 100) continue;

                        if (TR.parallelLines(P1, P2, Q1, Q2))
                        {
                            i2 = jj + 1;
                            if (jj == WC.core.arrRooms[ii].points.length - 1) i2 = 0;
                            lineData.parallel.push({P1: Q1, P2: Q2});
                        }
                    }
                }

                parallelData.push(lineData);
            }
        }
    }

    function splitCurrentSide()
    {
        var A = sideOverCont.points[sideOverIndA];
        var B = sideOverCont.points[sideOverIndB];

        var rp = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.ROOM_POINT);
        WC.core.addRoomPoints([rp]);
        sideOverCont.addPointAt(rp, sideOverIndB);

        for (var i = 0; i < WC.core.walls.length; i++)
        {
            var w = WC.core.walls[i];
            if ((w.point1.match(A) && w.point2.match(B)) ||
                (w.point2.match(A) && w.point1.match(B)))
            {
                // Create two walls
                //    var wall = new WC.CWall(dictPoints[w.point1.id], dictPoints[w.point2.id], w);
                WC.core.walls.push(new WC.CWall(w.point1, rp, w.data));
                WC.core.walls.push(new WC.CWall(w.point2, rp, w.data));
            }
        }

        for (i = 0; i < A.areas.length; i++)
        {
            for (var j = 0; j < B.areas.length; j++)
            {
                if (A.areas[i] != B.areas[j]) continue;

                var area = A.areas[i];

                var indA = area.points.indexOf(A);
                var indB = area.points.indexOf(B);

                if (Math.abs(indA - indB) > 1)
                {
                    if (! (indA == 0 && indB == area.points.length - 1) && !
                            ((indA == area.points.length - 1 && indB == 0))) continue;
                }

                var insTo = Math.max(indA, indB);
                if (Math.abs(indA - indB) > 1) insTo = 0;
                area.addPointAt(rp, insTo);

            }
        }

        for (i = 0; i < A.children.length; i++)     // split cover sides
        {
            for (j = 0; j < B.children.length; j++)
            {
                if (A.children[i].contour != B.children[j].contour) continue;

                var cover = A.children[i].contour;
                indA = cover.points.indexOf(A.children[i]);
                indB = cover.points.indexOf(B.children[j]);

                if (Math.abs(indA - indB) > 1)
                {
                    if (! (indA == 0 && indB == cover.points.length - 1) && !
                         ((indA == cover.points.length - 1 && indB == 0))) continue;
                }

                insTo = Math.max(indA, indB);
                if (Math.abs(indA - indB) > 1) insTo = 0;

                var cp = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.COVER_POINT);
                WC.core.addCoverPoints([cp]);
                cover.addPointAt(cp, insTo);
            }
        }

        WC.core.connectAllPoints(); // TODO: one point?

        return rp;
    }

    me.start = function()
    {
        findParallelSides();

        WC.wallsEditor.showCursor();
        me.mouseMove();

        areaOver = null;
        overMeat = false;
    };

    me.stop = function()
    {
        if (lastClickOnMeat)
        {
           WC.wallsEditor.dispatchEvent(new Event(WC.HIDE_MEAT_PAGE, WC.wallsEditor));
           lastClickOnMeat = false;
        }
    };

    me.afterRebuild = function()
    {
        findParallelSides();
    };

    me.mouseDown = function()
    {
        downCoord = WC.viewPos.clone();

        if (rulerAligner)
        {
            WC.wallsEditor.stateDraggingRuler.currentAligner = rulerAligner;
            WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingRuler);
            return;
        }

        if (pointOver)
        {
            pointDown = true;
        }
        else if (sideOverCont)
        {
            if (TR.euclDist(sideCenter.x, sideCenter.y, WC.realPos.x, WC.realPos.y) < WC.CENTER_SIZE / WC.wallsEditor.scale)
            {
                WC.wallsEditor.stateDraggingPoint.currentPt = splitCurrentSide();
                WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingPoint);
                WC.snapTool.reset();
            }
            else
            {
                sideDown = true;
            }
        }

        if (! pointOver && ! sideOverCont)
        {
            areaOver = WC.core.getAreaByPoint(WC.realPos);
            if (! areaOver) overMeat = WC.core.pointInMeat(WC.realPos);
        }

        WC.SFK.state.hideInputs();
    };

    me.mouseMove = function()
    {
        if (WC.SFK.state.name === "stateSelectedWall") return;

        if (pointDown)
        {
            if (TR.euclDist(downCoord.x, downCoord.y, WC.viewPos.x, WC.viewPos.y) > WC.POINT_SIZE / 2)
            {
                pointDown = false;
                WC.wallsEditor.stateDraggingPoint.currentPt = pointOver;
                WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingPoint);
            }

            return;
        }
        else if (sideDown)
        {
            if (TR.euclDist(downCoord.x, downCoord.y, WC.viewPos.x, WC.viewPos.y) > WC.POINT_SIZE / 2)
            {
                sideDown = false;
                WC.wallsEditor.stateDraggingWall.dragPtA = sideOverCont.points[sideOverIndA];
                WC.wallsEditor.stateDraggingWall.dragPtB = sideOverCont.points[sideOverIndB];

                var wpts = getWidthPoints();
                if (wpts)
                {
                    WC.wallsEditor.stateDraggingWall.parallelPt = wpts[1];
                }

                WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingWall);
            }

            return;
        }

        findCurrentSideAndCenter();

        findCurrentRulerAligner();

        getWidthPoints();

        WC.SFK.checkHoverSize();

        me.draw();
    };

    me.keyboardHelper = function () {
        //  selectedSizeData
        const A = WC.SFK.selectedSizeData.A;
        const B = WC.SFK.selectedSizeData.B;
        const C = new TR.Point((A.x + B.x) / 2, (A.y + B.y) / 2);

        const curSideData = getSideByPoint(C);

        if (!curSideData) return;

        WC.SFK.findSizeDataBySide(
            curSideData.room.points[curSideData.i1],
            curSideData.room.points[curSideData.i2]
        );

        if (!WC.SFK.selectedSizeData) {
            WC.SFK.selectedSizeData = {
                A: curSideData.room.points[curSideData.i1],
                B: curSideData.room.points[curSideData.i2],
            }
        }
    };

    me.mouseUp = function()
    {
        if (! downCoord) return;

        if (WC.SFK.curSizeData) {
            WC.SFK.selectedSizeData = {...WC.SFK.curSizeData};
            WC.SFK.curSizeData = null;
            WC.SFK.state = WC.SFK.stateSelectedWall;
            WC.SFK.state.showInputs();
            WC.SFK.state.makeInputSelected(WC.SFK.inputDomEl1.input);

            return;
        }

        pointDown = false;
        sideDown = false;

        var draged = TR.euclDist(downCoord.x, downCoord.y, WC.viewPos.x, WC.viewPos.y) > WC.POINT_SIZE / 2;
        var clickedArea = WC.core.getAreaByPoint(WC.realPos);

        if (! draged && clickedArea)
        {
            /*
            WC.wallsEditor.selectedAreas = [clickedArea];
            for (var i = 0; i < WC.core.arrAreas.length; i++) WC.core.arrAreas[i].selected = false;
            for (i = 0; i < WC.wallsEditor.selectedAreas.length; i++) WC.wallsEditor.selectedAreas[i].selected = true;

            WC.wallsEditor.dispatchEvent(new Event(WC.SHOW_AREA_PAGE, WC.wallsEditor));
            
            me.draw();
            */
            WC.wallsEditor.stateSelectedArea.areas = [clickedArea];
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedArea);
            return {state: "stateSelectedArea"};
        }

        //if (! draged && ! clickedArea)
        //{
        //    WC.wallsEditor.unselectAllAreas();
        //    me.draw();
        //}

        if (pointOver)
        {
            WC.wallsEditor.stateSelectedPoint.point = pointOver;
            pointOver = false;
            sideOverData = null;
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedPoint);
            
            return { state: "stateSelectedPoint", quickPanel: {x: WC.viewPos.x, y: WC.viewPos.y - 30} }
        }

        if (sideOverCont) {
            if (me.isCtrl) {
                WC.wallsEditor.stateSelectedRoom.room = sideOverCont;
                WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedRoom);
                return { state: "stateSelectedRoom", quickPanel: {x: WC.viewPos.x, y: WC.viewPos.y - 30} }
            } else {
                me.draw();
                WC.SFK.findSizeDataBySide(
                    sideOverCont.points[sideOverIndA],
                    sideOverCont.points[sideOverIndB]
                );

                WC.SFK.state = WC.SFK.stateSelectedWall;

                if (WC.SFK.selectedSizeData) {
                    WC.SFK.setWidthData({
                        wpts: getWidthPoints(),
                        sideOverData,
                    });
                
                    sideOverData = null;
                    sideOverCont = null;
                    sideCenter = null;
                    WC.SFK.state.showInputs();
                } else {
                    WC.SFK.selectedSizeData = {
                        A: sideOverData.P1,
                        B: sideOverData.P2,
                    };
                    WC.SFK.state.formatActivePoints(WC.SFK.selectedSizeData.A, WC.SFK.selectedSizeData.B);
                    sideOverData = null;
                    sideOverCont = null;
                    sideCenter = null;
                    me.draw();
                }

                //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_SHOW, {isMetric: R2D.DimensionSystem.isMetric()}));

                return;
            }
        }

        var selectedCovers = WC.core.getCoversByPoint(WC.realPos);
        if (selectedCovers.length > 0)
        {
            WC.wallsEditor.stateSelectedCover.covers = selectedCovers;
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedCover);
            WC.SFK.state.hideInputs();
            return {state: "stateSelectedCover", quickPanel: { x: WC.viewPos.x, y: WC.viewPos.y - 30 }}
        }

        if (overMeat) {
            WC.wallsEditor.stateSelectedRoom.room = overMeat;
            WC.wallsEditor.stateSelectedRoom.isClickOnMeat = true;
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedRoom);
            return {
                state: "stateSelectedRoom",
                quickPanel: { x: WC.viewPos.x, y: WC.viewPos.y - 30 },
            };
        }
        
        areaOver = null;
        overMeat = false;
    };

    me.dblClick = function()
    {
        if (WC.wallsEditor.dblClickToDel)
        {
            var nearestPt = WC.snapTool.findNearest(WC.realPos, WC.core.roomPoints, WC.POINT_SIZE / WC.wallsEditor.scale);
            if (! nearestPt) return;

            WC.core.delPoint(nearestPt);
            WC.core.rebuildWallsAndCovers();
            findParallelSides();
            WC.wallsEditor.save();
            WC.snapTool.reset();
            me.draw();
        }
        else
        {
            WC.wallsEditor.dblClickToDel = true;
        }
    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

        if (WC.SFK.state.name === "stateSelectedWall") {
            const A = WC.wallsEditor.realToView(WC.SFK.selectedSizeData.A);
            const B = WC.wallsEditor.realToView(WC.SFK.selectedSizeData.B);

            if (WC.SFK.widthData) {
                WC.drawTool.drawWallSize(WC.SFK.widthData.M, WC.SFK.widthData.N, false)
            };
            
            WC.context.strokeStyle = '#bae51f'; // FFDD66
            WC.context.lineWidth = 3;
            WC.context.beginPath();
            WC.context.moveTo(A.x + 0.5, A.y + 0.5);
            WC.context.lineTo(B.x + 0.5, B.y + 0.5);
            WC.context.fill();
            WC.context.stroke();
            WC.context.closePath();
        }
        else if (sideOverCont)
        {
            var A = WC.wallsEditor.realToView(sideOverCont.points[sideOverIndA]);
            var B = WC.wallsEditor.realToView(sideOverCont.points[sideOverIndB]);

            WC.context.strokeStyle = '#bae51f'; // FFDD66
            WC.context.lineWidth = 3;
            WC.context.beginPath();
            WC.context.moveTo(A.x + 0.5, A.y + 0.5);
            WC.context.lineTo(B.x + 0.5, B.y + 0.5);
            WC.context.fill();
            WC.context.stroke();
            WC.context.closePath();
        }

        if (sideCenter)
        {
            var C = WC.wallsEditor.realToView(sideCenter);

            WC.context.fillStyle = '#FFFFFF';
            WC.context.strokeStyle = '#444444';
            WC.context.lineWidth = 1;
            var r = 3;
            WC.context.beginPath();
            WC.context.arc(C.x + 1, C.y + 1, r, 0, Math.PI * 2);
            WC.context.stroke();
            WC.context.fill();
            WC.context.closePath();
        }

        var wpts = getWidthPoints();
        if (wpts && ! pointOver) WC.drawTool.drawWallSize(wpts[0], wpts[1]);

        me.drawRulers();
    };

    var superUndo = me.undo;
    var superRedo = me.redo;

    me.undo = function()
    {
        superUndo();
        findParallelSides();
    };

    me.redo = function()
    {
        superRedo();
        findParallelSides();
    };
};

WC.StateEditing.prototype = Object.create(WC.BaseState.prototype);
WC.StateEditing.prototype.constructor = WC.StateEditing;
WC.StateMakingArea = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateMakingArea';

    var currentPt = null;

    let needInputShow = true;

    me.start = function()
    {
        WC.wallsEditor.hideCursor();

        WC.core.rawCont = new WC.CRawContour();
        // prepare snap

        currentPt = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.ROOM_POINT);

        WC.core.rawCont.addPoint(currentPt);

        me.draw();

        WC.SFK.state.hideInputs();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
        WC.SFK.state = WC.SFK.stateMakingArea;

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_MAKING_LOW_AREA, {}));
    };

    me.stop = function()
    {
        WC.SFK.state.hideInputs();
		WC.SFK.state = WC.SFK.baseState;
        me.order = [];

		if (! WC.core.rawCont || WC.core.rawCont.points.length < 4 || ! TR.contourValid(WC.core.rawCont.points))
		{
			WC.core.rawCont = null;
			WC.wallsEditor.dblClickToDel = false;
			return;
		}

        WC.core.rawCont.points.pop();

        for (var i = 0; i < WC.core.arrAreas.length; i++)
        {
            var comp = TR.compareContours(WC.core.arrAreas[i].points, WC.core.rawCont.points);
            if (comp != TR.OUTSIDE && comp != TR.CONTACT)
            {
                WC.core.rawCont = null;
                WC.wallsEditor.dblClickToDel = false;
                return;
            }
        }

        var pts = WC.core.rawCont.points;
        var pairs = [];
        for (i = 0; i < pts.length - 1; i++)
        {
            pairs.push([pts[i], pts[i + 1]]);
        }
        pairs.push([pts[pts.length - 1], pts[0]]);

        WC.core.rebuildWalls(pairs);

        // ---

        var areaTrs = [];

        for (i = 0; i < TR.fillGroups.length; i++)
        {
            if (TR.fillGroups[i].length == 0) continue;
            var tri = TR.fillGroups[i][0];
            var center = TR.triangleCenter( TR.points[tri.pointIndices[0]][0], TR.points[tri.pointIndices[0]][1],
                                            TR.points[tri.pointIndices[1]][0], TR.points[tri.pointIndices[1]][1],
                                            TR.points[tri.pointIndices[2]][0], TR.points[tri.pointIndices[2]][1]);

            if (TR.pointInContour(center, pts))
            {
                areaTrs = areaTrs.concat(TR.fillGroups[i]);
            }
        }

        var areaGroups = TR.groupTriangles(areaTrs, false);  //TR.mergeGroups([areaTrs]);
        var contoursForAreas = [];

        for (i = 0; i < areaGroups.length; i++)
        {
            var outline = TR.contoursFromGroup(areaGroups[i])[0];

            if (! outline) continue;

            pts = [];
            for (var j = 0; j < outline.length; j++)
            {
                var P = WC.snapTool.findNearest(new TR.Point(TR.points[outline[j]][0], TR.points[outline[j]][1]), WC.core.roomPoints, TR.B_EPS);
                if (P) pts.push(P);
            }

            if (pts.length >= 3) contoursForAreas.push(pts);
        }

        for (i = 0; i < contoursForAreas.length - 1; i++)
        {
            if (! contoursForAreas[i]) continue;
            for (j = i + 1; j < contoursForAreas.length; j++)
            {
                if (! contoursForAreas[j]) continue;

                var res = TR.compareContoursOnePoint(contoursForAreas[i], contoursForAreas[j]);
                if (res == TR.BELONG)
                {
                    contoursForAreas[i] = null;
                    areaGroups[j] = areaGroups[j].concat(areaGroups[i]);
                }
                else if (res == TR.CONTAIN)
                {
                    contoursForAreas[j] = null;
                    areaGroups[i] = areaGroups[i].concat(areaGroups[j]);
                }
            }
        }

        for (i = 0; i < contoursForAreas.length; i++)
        {
            if (! contoursForAreas[i]) continue;
            pts = contoursForAreas[i];

            var area = new WC.CArea();
            area.points = pts;
            area.data.ceiling.height = WC.core.wallsHeight;

            for (var k = 0; k < pts.length; k++)
            {
                pts[k].areas.push(area);
            }

            WC.core.arrAreas.push(area);
            var trs = areaGroups[i];

            area.triangles = new Array(trs.length);
            for (j = 0; j < trs.length; j++)
            {
                var pt1 = TR.points[trs[j].pointIndices[0]];
                var pt2 = TR.points[trs[j].pointIndices[1]];
                var pt3 = TR.points[trs[j].pointIndices[2]];
                area.triangles[j] = [pt1, pt2, pt3];
            }

            WC.wallsEditor.stateSelectedArea.areas.push(area);
            WC.wallsEditor.dispatchEvent(new Event(WC.ASK_AREA_HEIGHT, WC.wallsEditor));
        }

        WC.core.rawCont = null;

        WC.wallsEditor.dblClickToDel = false;

        WC.snapTool.reset();
        WC.wallsEditor.save();
    };

    me.findSnap = function()
    {
        var snapRes = WC.snapTool.getSnapPoint(WC.realPos, [currentPt], WC.SNAP_DIST / WC.wallsEditor.scale, currentPt.contour?.points);
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    var undoPoints = [];
    me.order = [];

    me.undo = function()
    {
        if (WC.core.rawCont?.points.length >= 2) {
            const lastOrder = me.order.pop();
            if (lastOrder === "end") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(WC.core.rawCont.points.length - 2, 1)
                );
            } else if (lastOrder === "start") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(0, 1)
                );
            }
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.redo = function()
    {
        if (undoPoints.length > 0)
        {
            WC.core.rawCont?.addPointAt(undoPoints.pop(), WC.core.rawCont.points.length - 1);
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.canUndo = function()
    {
        return WC.core.rawCont && (WC.core.rawCont.points.length >= 2);
    };

    me.canRedo = function()
    {
        return undoPoints.length > 0;
    };

    me.mouseDown = function()
    {

    };

    let timer;

    me.mouseMove = function()
    {
        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;

        me.draw();

        clearTimeout(timer)
    	timer = setTimeout(() => WC.wallsEditor.updateTip(WC.SFK.selectedSizeData?.inputCenter, 2), 25);
        
    };

    me.mouseUp = function()
    {
        WC.SFK.state.hideInputs();
		needInputShow = false;

        if(!WC.core.rawCont) return;
        var eps = 0.1;
        if (WC.core.rawCont && WC.core.rawCont.points.length >= 2)
        {
            var firstPt = WC.core.rawCont.points[0];
            var lastPt = WC.core.rawCont.points[WC.core.rawCont.points.length - 2];

            if (TR.manhDist(lastPt.x, lastPt.y, currentPt.x, currentPt.y) <= eps || TR.manhDist(firstPt.x, firstPt.y, currentPt.x, currentPt.y) <= eps)
            {
                WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
                return {state: "stateSetWallHeight"};
            }
        }

        currentPt = new WC.CPoint(WC.snapPos.x, WC.snapPos.y, WC.ROOM_POINT);
        WC.core.rawCont.addPoint(currentPt);
        WC.wallsEditor.state.order?.push("end");
        WC.snapTool.reset();
        WC.wallsEditor.dispatchHistoryState();
        me.draw();
    };

    me.setCurrentPt = function(P) {
		currentPt = P;
	}

    me.dblClick = function()
    {

    };

    function drawRawArea()
    {
        if (! WC.core.rawCont || WC.core.rawCont.points.length <= 1) return;

        WC.context.strokeStyle = "rgba(0, 255, 0, 1)";
        WC.context.lineWidth = 1;
        WC.context.fillStyle = "rgba(0, 255, 0, 0.1)";

        me.drawPolygon(WC.core.rawCont.points);

        // if (WC.core.rawCont?.points.length >= 2) {
        //     me.drawSize(pts[pts.length - 2], pts[pts.length - 1], 1, true);
        // }
        // if (WC.core.rawCont.points.length >= 3) {
        //     me.drawSize(pts[pts.length - 1], pts[0], 1, true);
        // }

        if (WC.core.rawCont.points) {
            let pts = WC.core.rawCont.points;
            const minLen = 45;

            if (
                TR.euclDistP(pts[pts.length - 2], pts[pts.length - 1]) * WC.wallsEditor.scale <
                    minLen ||
                TR.euclDistP(pts[pts.length - 1], pts[0]) * WC.wallsEditor.scale < minLen
            ) {
                WC.SFK.state.hideInputs();
                needInputShow = true;
                return;
            }

            if (!needInputShow) return;

            WC.SFK.selectedSizeData1 = {
                A: pts[pts.length - 2],
                B: pts[pts.length - 1],
                k: 1,
            };
            WC.SFK.selectedSizeData2 = {
                A: pts[pts.length - 1],
                B: pts[0],
                k: 1,
            };

            WC.SFK.state.updateSizesData();

            if (!WC.SFK.activeInput?.parentNode) {
                WC.SFK.state.showInputs();
            }

            WC.SFK.findNewSelectedSizeDataByInput(WC.SFK.activeInput);
            
            WC.SFK.activeInput.select();
            WC.SFK.validInputValue = WC.SFK.activeInput.value;
            WC.SFK.activeInput.parentNode.style.transform = "rotate(0rad)";
        }
    }

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

        drawRawArea();

        me.drawRulers();

        me.drawAligner();

        me.drawCross();
    }
};

WC.StateMakingArea.prototype = Object.create(WC.BaseState.prototype);
WC.StateMakingArea.prototype.constructor = WC.StateMakingArea;
WC.MAKING_RECT_START = 'makingRectFinish';
WC.MAKING_RECT_FINISH = 'makingRectFinish';

WC.StateMakingRect = function()
{
	var me = this;
	WC.BaseState.call(this);
	me.name = 'stateMakingRect';

	me.startPt = null;
	me.endPt = null;
	me.cursPt = null;

	me.wallsWidth = 10;

	me.mouseMovingX = true;
	me.mouseMovingY = true;
	let areInputsShown = false;

	me.start = function()
	{
		WC.SFK.state.hideInputs();
		WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
		WC.SFK.state = WC.SFK.stateMakingRect;

		WC.wallsEditor.hideCursor();

		me.startPt = null;
		me.endPt = null;
		me.cursPt = new WC.CPoint(WC.realPos.x, WC.realPos.y);

		me.draw();

		WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_MAKING_ROOM, {}));
	};

	me.stop = function()
	{
		WC.SFK.state.hideInputs();
		WC.SFK.state = WC.SFK.baseState;
		
		me.mouseMovingX = true;
		me.mouseMovingY = true;
		
		if (! me.startPt || ! me.endPt)
		{
			me.startPt = null;
			me.endPt = null;
			WC.wallsEditor.titlesTool.updateComponents();
			return;
		}
		var points = findBoxes(me.startPt, me.endPt);
		
		var room = new WC.CRoom(true);
		room.points = points.slice(0, 4);
		for (var i = 0; i < room.points.length; i++) room.points[i].contour = room;
		WC.core.arrRooms.push(room);
		WC.core.addRoomPoints(room.points);

		if (points.length == 8)
		{
			room = new WC.CRoom(false);
			room.points = points.slice(4);
			for (i = 0; i < room.points.length; i++) room.points[i].contour = room;
			WC.core.arrRooms.push(room);
			WC.core.addRoomPoints(room.points);
		}

		WC.core.rebuildWallsAndCovers();
		WC.wallsEditor.titlesTool.updateComponents();
		WC.wallsEditor.save();

		me.startPt = null;
		me.endPt = null;
		me.draw();

		WC.wallsEditor.dispatchEvent(new Event(WC.MAKING_RECT_FINISH));
	};

	var undoPt = null;

	me.undo = function()
	{
		if (! me.startPt) return;

		undoPt = me.startPt;
		me.startPt = null;

		WC.snapTool.reset();
		me.findSnap();
		me.draw();
	};

	me.redo = function()
	{
		if (me.startPt || ! undoPt) return;

		me.startPt = undoPt;
		undoPt = null;

		WC.snapTool.reset();
		me.findSnap();
		me.draw();
	};

	me.canUndo = function()
	{
		return Boolean(me.startPt);
	};

	me.canRedo = function()
	{
		return Boolean(undoPt);
	};

	me.mouseDown = function()
	{

	};

	let timer;

	me.mouseMove = function()
	{
        if (me.mouseMovingX) {
            me.cursPt.x = WC.snapPos.x;
        }
        if (me.mouseMovingY) {
            me.cursPt.y = WC.snapPos.y;
        }

        me.draw();

		clearTimeout(timer)
    	timer = setTimeout(() => WC.wallsEditor.updateTip(WC.SFK.selectedSizeData1?.inputCenter, 1, WC.SFK.selectedSizeData3?.inputCenter), 25);
        
    };

	me.mouseUp = function()
	{
		if (! me.startPt)
		{
			me.startPt = me.cursPt.clone();
		}
		else if (! me.endPt)
		{
			me.endPt = me.cursPt.clone();
			WC.SFK.state.hideInputs();
			WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
			return {state: "stateEditing"}; 
		}

		// + add startPt to snap
		WC.snapTool.reset();
		WC.wallsEditor.dispatchHistoryState();
		me.draw();
	};

	function findBoxes(A, B, scale)
	{
		var k = 1;
		if (scale) k = WC.wallsEditor.scale;

		var minX = Math.min(A.x, B.x);
		var maxX = Math.max(A.x, B.x);
		var minY = Math.min(A.y, B.y);
		var maxY = Math.max(A.y, B.y);

		var pts = [
			new WC.CPoint(minX, minY, WC.ROOM_POINT),
			new WC.CPoint(maxX, minY, WC.ROOM_POINT),
			new WC.CPoint(maxX, maxY, WC.ROOM_POINT),
			new WC.CPoint(minX, maxY, WC.ROOM_POINT)];

		if (maxX - minX > 2 * me.wallsWidth && maxY - minY > 2 * me.wallsWidth)
		{
			pts = pts.concat([
				new WC.CPoint(minX + me.wallsWidth * k, minY + me.wallsWidth * k, WC.ROOM_POINT),
				new WC.CPoint(maxX - me.wallsWidth * k, minY + me.wallsWidth * k, WC.ROOM_POINT),
				new WC.CPoint(maxX - me.wallsWidth * k, maxY - me.wallsWidth * k, WC.ROOM_POINT),
				new WC.CPoint(minX + me.wallsWidth * k, maxY - me.wallsWidth * k, WC.ROOM_POINT)]);
		}

		return pts;
	}

	function drawTempRect()
	{
		if (! me.startPt) return;

		var viewPoints = findBoxes(WC.wallsEditor.realToView(me.startPt), WC.wallsEditor.realToView(me.cursPt), true);
		var realPoints = findBoxes(me.startPt, me.cursPt, false);

		WC.context.lineWidth = 1;
		WC.context.strokeStyle = '#aaaaaa';
		WC.context.beginPath();

		WC.context.moveTo(viewPoints[0].x + 0.5, viewPoints[0].y + 0.5);
		WC.context.lineTo(viewPoints[1].x + 0.5, viewPoints[1].y + 0.5);
		WC.context.lineTo(viewPoints[2].x + 0.5, viewPoints[2].y + 0.5);
		WC.context.lineTo(viewPoints[3].x + 0.5, viewPoints[3].y + 0.5);
		WC.context.lineTo(viewPoints[0].x + 0.5, viewPoints[0].y + 0.5);

		if (viewPoints.length == 8)
		{
			WC.context.moveTo(viewPoints[4].x + 0.5, viewPoints[4].y + 0.5);
			WC.context.lineTo(viewPoints[5].x + 0.5, viewPoints[5].y + 0.5);
			WC.context.lineTo(viewPoints[6].x + 0.5, viewPoints[6].y + 0.5);
			WC.context.lineTo(viewPoints[7].x + 0.5, viewPoints[7].y + 0.5);
			WC.context.lineTo(viewPoints[4].x + 0.5, viewPoints[4].y + 0.5);
		}

		WC.context.stroke();

		// me.drawSize(realPoints[0], realPoints[1], 1, true);
		// me.drawSize(realPoints[1], realPoints[2], 1, true);

		const minLen = 70;

        if (
            realPoints.length !== 8 ||
            TR.euclDistP(realPoints[0], realPoints[1]) * WC.wallsEditor.scale < minLen ||
            TR.euclDistP(realPoints[1], realPoints[2]) * WC.wallsEditor.scale < minLen
        ) {
            WC.SFK.state.hideInputs();
            areInputsShown = false;
            return;
        } else {
            WC.SFK.selectedSizeData1 = {
                A: realPoints[0],
                B: realPoints[1],
                k: 1,
            };
            WC.SFK.selectedSizeData2 = {
                A: realPoints[1],
                B: realPoints[2],
                k: 1,
            };
            WC.SFK.selectedSizeData3 = {
                A: realPoints[4],
                B: realPoints[5],
                k: -1,
            };
            WC.SFK.selectedSizeData4 = {
                A: realPoints[5],
                B: realPoints[6],
                k: -1,
            };

            WC.SFK.state.updateSizesData();

            if (!areInputsShown) {
                areInputsShown = true;
                WC.SFK.state.showInputs();
            } else {
                if (!WC.SFK.activeInput?.parentNode) return;

				WC.SFK.state.updateSizesData();
                WC.SFK.findNewSelectedSizeDataByInput(WC.SFK.activeInput);

                WC.SFK.activeInput.parentNode.style.transform = "rotate(0rad)";
                WC.SFK.activeInput.select();
				WC.SFK.validInputValue = WC.SFK.activeInput.value;
                WC.SFK.animation.stop();
            }
        }
		
		// if (realPoints.length == 8)
		// {
		// 	me.drawSize(realPoints[4], realPoints[5], -1, true);
		// 	me.drawSize(realPoints[5], realPoints[6], -1, true);
		// }
	}

	var superDraw = me.draw;

	me.draw = function()
	{
		superDraw();

		me.drawRulers();
		drawTempRect();
		me.drawAligner();
		me.drawCross();
	}
};

WC.StateMakingRect.prototype = Object.create(WC.BaseState.prototype);
WC.StateMakingRect.prototype.constructor = WC.StateMakingRect;
WC.StateMakingWalls = function()
{
	var me = this;
	WC.BaseState.call(this);
	me.name = 'stateMakingWalls';

	var currentPt = null;
	var signSide = 1;  // 1/-1

	me.wallsWidth = 10;

	let needInputShow = true;

    me.getSignSide = function () {
        return signSide;
    };

    me.setSignSide = function (sign) {
        signSide = sign;
    };

	me.start = function()
	{
		WC.wallsEditor.hideCursor();

		WC.core.rawCont = new WC.CRawContour();
		// prepare snap

		currentPt = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.ROOM_POINT);

		WC.core.rawCont.addPoint(currentPt);

		me.draw();

		WC.SFK.state.hideInputs();
		WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
		WC.SFK.state = WC.SFK.stateMakingWalls;

		WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_MAKING_WALL, {}));
	};

	me.stop = function()
	{
		
		WC.wallsEditor.dblClickToDel = false;

		if (WC.core.rawCont && WC.core.rawCont.points.length >= 1)
		{
			var pts = WC.core.rawCont.points;
			if (! pts[0].match(pts[pts.length - 1])) WC.core.rawCont.points.pop();
		}

		WC.SFK.activeBlock = null;
		WC.SFK.state.hideInputs();
		WC.SFK.state = WC.SFK.baseState;

		if (! WC.core.rawCont || WC.core.rawCont.points.length < 2)
		{
			WC.core.rawCont = null;
			me.draw();
			WC.wallsEditor.titlesTool.updateComponents();
			return;
		}

		var blocks = WC.drawTool.blocksFromContour(WC.core.rawCont.points, signSide * me.wallsWidth, startNeighbSeg);

		startNeighbSeg = null;
		fixedStart = false;

		for (var i = 0; i < blocks.length; i++)
		{
			var room = new WC.CRoom(true);
			room.points = blocks[i];
			for (var j = 0; j < room.points.length; j++) room.points[j].contour = room;
			WC.core.arrRooms.push(room);
			WC.core.addRoomPoints(WC.core.rawCont.points);
		}

		WC.core.rebuildWallsAndCovers();
		WC.wallsEditor.titlesTool.updateComponents();
		WC.wallsEditor.save();

		WC.core.rawCont = null;
		me.draw();
	};

	me.findSnap = function()
	{
		var snapRes = WC.snapTool.getSnapPoint(WC.realPos, [currentPt], WC.SNAP_DIST / WC.wallsEditor.scale, currentPt.contour?.points);
		WC.snapPos = snapRes[0];
		WC.aligners = [snapRes[1], snapRes[2], snapRes[3], snapRes[4], snapRes[5]];
	};

	var undoPoints = [];

	me.undo = function()
	{
		if (WC.core.rawCont?.points?.length >= 2)
		{
			undoPoints = undoPoints.concat(WC.core.rawCont.points.splice(WC.core.rawCont.points.length - 2, 1));
		}

		WC.snapTool.reset();
		me.findSnap();

		currentPt.x = WC.snapPos.x;
		currentPt.y = WC.snapPos.y;

		if (WC.core.rawCont?.points.length == 1)
		{
			startNeighbSeg = null;
			fixedStart = false;
		}
	};

	me.redo = function()
	{
		if (undoPoints.length > 0)
		{
			WC.core.rawCont?.addPointAt(undoPoints.pop(), WC.core.rawCont.points.length - 1);
		}

		WC.snapTool.reset();
		me.findSnap();

		currentPt.x = WC.snapPos.x;
		currentPt.y = WC.snapPos.y;
	};

	me.canUndo = function()
	{
		if(WC.core.rawCont) return WC.core.rawCont.points.length >= 2;
	};

	me.canRedo = function()
	{
		return undoPoints.length > 0;
	};

	me.mouseDown = function()
	{
		
	};

	let timer;

	me.mouseMove = function()
	{
		currentPt.x = WC.snapPos.x;
		currentPt.y = WC.snapPos.y;

		if (! fixedStart) calcStart();

		me.draw();
		
		clearTimeout(timer)
    	timer = setTimeout(() => WC.wallsEditor.updateTip(WC.SFK.selectedSizeData?.inputCenter, 1, WC.SFK.selectedSizeData2?.inputCenter), 25);

	};

	var startNeighbSeg = null;
	var fixedStart = false;
	function calcStart()
	{
		if(!WC.core.rawCont) return;
		startNeighbSeg = WC.snapTool.findNearSegments(WC.core.rawCont.points[0]);

		if (! startNeighbSeg || startNeighbSeg.length == 0 || WC.core.rawCont.points.length < 2) return;

		var p1 = WC.core.rawCont.points[0];
		var p2 = WC.core.rawCont.points[1];
		if (TR.manhDist(p1.x, p1.y, p2.x, p2.y) < 5) return;
		var pl = startNeighbSeg[0];
		var pr = startNeighbSeg[1];
		var ang1 = Math.abs(TR.angleBetweenLines(p1.x, p1.y, p2.x, p2.y, p1.x, p1.y, pl.x, pl.y));
		var ang2 = Math.abs(TR.angleBetweenLines(p1.x, p1.y, pr.x, pr.y, p1.x, p1.y, p2.x, p2.y));

		if (ang1 < ang2 + TR.B_EPS)
		{
			signSide = 1;
		}
		else
		{
			signSide = -1;
		}
	}

	me.mouseUp = function()
	{
		WC.SFK.state.hideInputs();
		needInputShow = false;

		if(!WC.core.rawCont) return;
		if (WC.core.rawCont.points.length == 3) fixedStart = true;

		var eps = 0.1;
		if (WC.core.rawCont && WC.core.rawCont.points.length >= 2)
		{
			var firstPt = WC.core.rawCont.points[0];
			var lastPt = WC.core.rawCont.points[WC.core.rawCont.points.length - 2];

			if (TR.euclDist(lastPt.x, lastPt.y, currentPt.x, currentPt.y) <= me.wallsWidth ||
				TR.euclDist(firstPt.x, firstPt.y, currentPt.x, currentPt.y) <= eps)
			{
				WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
				return {state: "stateEditing"};
			}
		}

		currentPt = new WC.CPoint(WC.snapPos.x, WC.snapPos.y, WC.ROOM_POINT);
		WC.core.rawCont.addPoint(currentPt);
		WC.snapTool.reset();
		WC.wallsEditor.dispatchHistoryState();
		me.draw();
	};

	me.setCurrentPt = function(P) {
		currentPt = P;
	}

	me.dblClick = function()
	{

	};

	me.drawAligner = function()
	{
		if (! WC.aligners) return;

		var locSnapPos = WC.wallsEditor.realToView(WC.snapPos);

		WC.context.strokeStyle = '#00aa00';
		WC.context.setLineDash([2, 4]);
		//  WC.context.lineDashOffset = 0;

		WC.context.beginPath();

		for (var i = 0; i < 3; i++)
		{
			if (WC.aligners[i])
			{
				var locAligner = WC.wallsEditor.realToView(WC.aligners[i]);
				drawLineAB(locSnapPos, locAligner);
			}
		}

		// --

		var lastPt = null;
		if (WC.core.rawCont && WC.core.rawCont.points.length >= 2)
		{
			lastPt = WC.core.rawCont.points[WC.core.rawCont.points.length - 2];
		}

		var alignersX = WC.aligners[3];
		var alignersY = WC.aligners[4];

		var coincideWithAligner = (alignersX && alignersX[0] && TR.manhDistP(alignersX[0], WC.snapPos) < TR.B_EPS) ||
								  (alignersX && alignersX[1] && TR.manhDistP(alignersX[1], WC.snapPos) < TR.B_EPS) ||
								  (alignersY && alignersY[0] && TR.manhDistP(alignersY[0], WC.snapPos) < TR.B_EPS) ||
								  (alignersY && alignersY[1] && TR.manhDistP(alignersY[1], WC.snapPos) < TR.B_EPS);

		if (! coincideWithAligner)
		{
			for (i = 0; i < WC.core.arrRooms.length; i++)
			{
				var broken = false;
				for (var j = 0; j < WC.core.arrRooms[i].points.length; j++)
				{
					var p1 = WC.core.arrRooms[i].points[j];
					var p2 = WC.core.arrRooms[i].points[j + 1];
					if (!p2) p2 = WC.core.arrRooms[i].points[0];

					if (TR.pointOnLine(WC.snapPos, p1, p2))
					{
						coincideWithAligner = true;
						broken = true;
						break;
					}
				}
				if (broken) break;
			}
		}

		var recalcAng = Math.PI * 0.75;

		//var ang = TR.angleBetweenLines(P0.x, P0.y, P1.x, P1.y, P1.x, P1.y, P2.x, P2.y);
		//if (ang > recalcAng && ang < 2 * Math.PI - recalcAng && ! TR.pointInBounds(C, D, L2))

		if (! coincideWithAligner && alignersX && alignersX[0] && lastPt && lastPt.x != alignersX[0].x)
		{
			var ang = TR.angleBetweenLines(lastPt.x, lastPt.y, WC.snapPos.x, WC.snapPos.y, WC.snapPos.x, WC.snapPos.y, alignersX[0].x, alignersX[0].y);

			if (ang < recalcAng || ang > 2 * Math.PI - recalcAng)
			{
				locAligner = WC.wallsEditor.realToView(alignersX[0]);
				drawLineAB(locSnapPos, locAligner);

				var sideSnapPos = TR.perpendicularPoint(locSnapPos, locAligner, -signSide * me.wallsWidth * WC.wallsEditor.scale);
				var sideAligner = TR.perpendicularPoint(locAligner, locSnapPos, signSide * me.wallsWidth * WC.wallsEditor.scale);
				drawLineAB(sideSnapPos, sideAligner);
			}
		}
		if (! coincideWithAligner && alignersX && alignersX[1] && lastPt && lastPt.x != alignersX[1].x)
		{
			ang = TR.angleBetweenLines(lastPt.x, lastPt.y, WC.snapPos.x, WC.snapPos.y, WC.snapPos.x, WC.snapPos.y, alignersX[1].x, alignersX[1].y);

			if (ang < recalcAng || ang > 2 * Math.PI - recalcAng)
			{
				locAligner = WC.wallsEditor.realToView(alignersX[1]);
				drawLineAB(locSnapPos, locAligner);

				sideSnapPos = TR.perpendicularPoint(locSnapPos, locAligner, -signSide * me.wallsWidth * WC.wallsEditor.scale);
				sideAligner = TR.perpendicularPoint(locAligner, locSnapPos, signSide * me.wallsWidth * WC.wallsEditor.scale);
				drawLineAB(sideSnapPos, sideAligner);
			}
		}
		if (! coincideWithAligner && alignersY && alignersY[0] && lastPt && lastPt.y != alignersY[0].y)
		{
			ang = TR.angleBetweenLines(lastPt.x, lastPt.y, WC.snapPos.x, WC.snapPos.y, WC.snapPos.x, WC.snapPos.y, alignersY[0].x, alignersY[0].y);

			if (ang < recalcAng || ang > 2 * Math.PI - recalcAng)
			{
				locAligner = WC.wallsEditor.realToView(alignersY[0]);
				drawLineAB(locSnapPos, locAligner);

				sideSnapPos = TR.perpendicularPoint(locSnapPos, locAligner, -signSide * me.wallsWidth * WC.wallsEditor.scale);
				sideAligner = TR.perpendicularPoint(locAligner, locSnapPos, signSide * me.wallsWidth * WC.wallsEditor.scale);
				drawLineAB(sideSnapPos, sideAligner);
			}
		}
		if (! coincideWithAligner && alignersY && alignersY[1] && lastPt && lastPt.y != alignersY[1].y)
		{
			ang = TR.angleBetweenLines(lastPt.x, lastPt.y, WC.snapPos.x, WC.snapPos.y, WC.snapPos.x, WC.snapPos.y, alignersY[1].x, alignersY[1].y);

			if (ang < recalcAng || ang > 2 * Math.PI - recalcAng)
			{
				locAligner = WC.wallsEditor.realToView(alignersY[1]);
				drawLineAB(locSnapPos, locAligner);

				sideSnapPos = TR.perpendicularPoint(locSnapPos, locAligner, -signSide * me.wallsWidth * WC.wallsEditor.scale);
				sideAligner = TR.perpendicularPoint(locAligner, locSnapPos, signSide * me.wallsWidth * WC.wallsEditor.scale);
				drawLineAB(sideSnapPos, sideAligner);
			}
		}

		WC.context.stroke();
		WC.context.closePath();
		WC.context.setLineDash([]);
	};

	function drawLineAB(A, B)
	{
		WC.context.moveTo(A.x, A.y);
		WC.context.lineTo(B.x, B.y);
	}

	function drawBlocks()
	{
		if (! WC.core.rawCont || WC.core.rawCont.points.length <= 1) return;

		WC.context.strokeStyle = '#888888';
		WC.context.lineWidth = 1;
		WC.context.fillStyle = "rgba(255, 255, 255, 0)";

		var pts = WC.core.rawCont.points;
		var blocks;
		
		blocks = WC.drawTool.blocksFromContour(pts, signSide * me.wallsWidth, startNeighbSeg);

		for (var i = 0; i < blocks.length; i++)
		{
			me.drawPolygon(blocks[i]);
		}

		WC.context.fillStyle = "rgba(0, 0, 0, 1)";

        for (i = 0; i < blocks.length - 1; i++) {
            var b = blocks[i];
            me.drawSize(b[0], b[1], -signSide, true);
            me.drawSize(b[3], b[2], signSide, true);
        }

        if (blocks.length == 0 || WC.SFK.state.name != "stateMakingWalls") return;

        const lastBlock = blocks[blocks.length - 1];
        const minLen = 45;


        if (
            WC.wallsEditor.scale != WC.wallsEditor.maxScale &&
            (TR.euclDistP(lastBlock[0], lastBlock[1]) * WC.wallsEditor.scale < minLen ||
                TR.euclDistP(lastBlock[3], lastBlock[2]) * WC.wallsEditor.scale < minLen ||
                Math.abs(TR.euclDistP(lastBlock[0], lastBlock[1]) - me.wallsWidth) < 0.4 ||
                Math.abs(TR.euclDistP(lastBlock[0], lastBlock[1]) - 2 * me.wallsWidth) < 0.4)
        ) {
            WC.SFK.state.hideInputs();
            needInputShow = true;
            return;
        } 

		if (!needInputShow) return;

		WC.SFK.selectedSizeData1 = {
			A: lastBlock[3],
			B: lastBlock[2],
			k: signSide,
		};

		WC.SFK.selectedSizeData2 = {
			A: lastBlock[0],
			B: lastBlock[1],
			k: -signSide,
		};

		WC.SFK.state.updateSizesData();

		if (!WC.SFK.activeInput?.parentNode) {
			WC.SFK.state.showInputs();
		}

		WC.SFK.findNewSelectedSizeDataByInput(WC.SFK.activeInput)

		WC.SFK.activeInput.select();
		WC.SFK.validInputValue = WC.SFK.activeInput.value;
        WC.SFK.activeInput.parentNode.style.transform = "rotate(0rad)";

        if (lastBlock !== WC.SFK.activeBlock) {
            WC.SFK.activeBlock = lastBlock;
        }
    }

	var superDraw = me.draw;

	me.draw = function()
	{
		superDraw();
		drawBlocks();
		me.drawRulers();
		me.drawAligner();
		me.drawCross();
	}
};

WC.StateMakingWalls.prototype = Object.create(WC.BaseState.prototype);
WC.StateMakingWalls.prototype.constructor = WC.StateMakingWalls;

WC.StateMakingCover = function()
{
    let me = this;
    WC.BaseState.call(this);
    me.name = 'stateMakingCover';

    let currentPt = null;
    me.makingOuter = true;

    let needInputShow = true;

    me.start = function()
    {
        WC.wallsEditor.hideCursor();

        WC.core.rawCont = new WC.CRawContour();
        // prepare snap

        currentPt = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.COVER_POINT);

        WC.core.rawCont.addPoint(currentPt);

        me.draw();

        WC.SFK.state.hideInputs();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
        WC.SFK.state = WC.SFK.stateMakingCover;

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_MAKING_COVER, {}));
    };

    me.stop = function()
    {
        WC.SFK.state.hideInputs();
		WC.SFK.state = WC.SFK.baseState;
        me.order = [];

        WC.wallsEditor.dblClickToDel = false;

        

        if (! WC.core.rawCont || WC.core.rawCont.points.length < 4 || ! TR.contourValid(WC.core.rawCont.points))
        {
            WC.core.rawCont = null;
            me.draw();
            WC.wallsEditor.titlesTool.updateComponents();
            return;
        }
        WC.core.rawCont.points.pop();

        if (TR.contourArea(WC.core.rawCont.points) < 0) WC.core.rawCont.points.reverse();

        let cover = new WC.CCover(me.makingOuter);
        cover.data.ceiling.height = WC.core.wallsHeight;
        cover.points = WC.core.rawCont.points;
        for (let i = 0; i < cover.points.length; i++) cover.points[i].contour = cover;
        WC.core.arrCovers.push(cover);
        WC.core.addCoverPoints(WC.core.rawCont.points);
        WC.core.connectAllPoints();
        WC.core.findCoverHoles();
        WC.core.findAllCoverTriangles();

        let relatedCoversRes = WC.core.findRelatedCovers(cover);
        if (relatedCoversRes[0])
        {
            WC.core.rebuildRelatedCovers(! cover.outer);
            WC.core.findCoverHoles();
        }
        else if (relatedCoversRes[1])
        {
            WC.wallsEditor.dispatchEvent(new Event(WC.ASK_MERGE_COVERS, WC.wallsEditor));
        }
        
        WC.wallsEditor.titlesTool.updateComponents();
        WC.wallsEditor.save();

        WC.core.rawCont = null;
        
        me.draw();
        return relatedCoversRes[1] ? {state: "stateMergeCovers"} : null;
    };

    me.findSnap = function()
    {
        if(!currentPt.contour) return;
        let snapRes = WC.snapTool.getSnapPoint(WC.realPos, [currentPt], WC.SNAP_DIST / WC.wallsEditor.scale, currentPt.contour.points);
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    let undoPoints = [];
	me.order = [];

    me.undo = function()
    {
        if (WC.core.rawCont?.points.length >= 2) {
            const lastOrder = me.order.pop();
            if (lastOrder === "end") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(WC.core.rawCont.points.length - 2, 1)
                );
            } else if (lastOrder === "start") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(0, 1)
                );
            }
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.redo = function()
    {
        if (undoPoints.length > 0)
        {
            WC.core.rawCont?.addPointAt(undoPoints.pop(), WC.core.rawCont.points.length - 1);
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.canUndo = function()
    {
        if(WC.core.rawCont) return WC.core.rawCont.points.length >= 2;
        
    };

    me.canRedo = function()
    {
        return undoPoints.length > 0;
    };

    me.mouseDown = function()
    {
        
    };

    let timer;

    me.mouseMove = function()
    {
        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;

        me.draw();

        clearTimeout(timer)
    	timer = setTimeout(() => WC.wallsEditor.updateTip(WC.SFK.selectedSizeData?.inputCenter, 2), 25);
    };

    me.mouseUp = function()
    {
        WC.SFK.state.hideInputs();
		needInputShow = false;

        let eps = 0.1;
        if (WC.core.rawCont && WC.core.rawCont.points.length >= 2)
        {
            let firstPt = WC.core.rawCont.points[0];
            let lastPt = WC.core.rawCont.points[WC.core.rawCont.points.length - 2];

            if (TR.manhDist(lastPt.x, lastPt.y, currentPt.x, currentPt.y) <= eps || TR.manhDist(firstPt.x, firstPt.y, currentPt.x, currentPt.y) <= eps)
            {
                let result = WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
                if(result && result.state == "stateMergeCovers") return {state: "stateMergeCovers"}
                else return {state: "stateEditing"}
                
            }
        }

        currentPt = new WC.CPoint(WC.snapPos.x, WC.snapPos.y, WC.COVER_POINT);
        if (WC.core.rawCont) {
            WC.core.rawCont.addPoint(currentPt);
            WC.wallsEditor.state.order?.push("end");
        }
        WC.snapTool.reset();
        WC.wallsEditor.dispatchHistoryState();
        me.draw();
    };

    me.setCurrentPt = function(P) {
		currentPt = P;
	}

    me.dblClick = function()
    {

    };

    function drawRawCover()
    {
        if (! WC.core.rawCont || WC.core.rawCont.points.length <= 1) return;

        WC.context.strokeStyle = '#000000';
        WC.context.lineWidth = 1;
        WC.context.fillStyle = me.cut
            ? "rgba(255, 255, 255, 0)"
            : WC.context.createPattern(WC.imgFloor, "repeat");

        me.drawPolygon(WC.core.rawCont.points);
    }

    let superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        drawRawCover();

        if (! WC.core.rawCont) return;

        // WC.context.fillStyle = "rgba(0, 0, 0, 1)";
        // if (WC.core.rawCont.points.length >= 2)
        // {
        //     me.drawSize(pts[pts.length - 2], pts[pts.length - 1], 1, true);
        // }
        // if (WC.core.rawCont.points.length >= 3)
        // {
        //     me.drawSize(pts[pts.length - 1], pts[0], 1, true);
        // }

        if(WC.core.rawCont.points && WC.core.rawCont.points.length > 1) {
            let pts = WC.core.rawCont.points;
            const minLen = 45;

            if (
                TR.euclDistP(pts[pts.length - 2], pts[pts.length - 1]) * WC.wallsEditor.scale <
                    minLen ||
                TR.euclDistP(pts[pts.length - 1], pts[0]) * WC.wallsEditor.scale < minLen
            ) {
                WC.SFK.state.hideInputs();
                needInputShow = true;
                return;
            }

            if (!needInputShow) return;

            WC.SFK.selectedSizeData1 = {
                A: pts[pts.length - 2],
                B: pts[pts.length - 1],
                k: 1,
            };
            WC.SFK.selectedSizeData2 = {
                A: pts[pts.length - 1],
                B: pts[0],
                k: 1,
            };

            WC.SFK.state.updateSizesData();

            if (!WC.SFK.activeInput?.parentNode) {
                WC.SFK.state.showInputs();
            }

            WC.SFK.findNewSelectedSizeDataByInput(WC.SFK.activeInput);
            
            WC.SFK.activeInput.select();
            WC.SFK.validInputValue = WC.SFK.activeInput.value;
            WC.SFK.activeInput.parentNode.style.transform = "rotate(0rad)";
        }
        

        me.drawRulers();
        me.drawAligner();
        me.drawCross();
    }
};

WC.StateMakingCover.prototype = Object.create(WC.BaseState.prototype);
WC.StateMakingCover.prototype.constructor = WC.StateMakingCover;
WC.StateMakingRoom = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateMakingRoom';

    var currentPt = null;
    me.makingOuter = true;

    let needInputShow = true;

    me.start = function()
    {
        WC.wallsEditor.hideCursor();

        WC.core.rawCont = new WC.CRawContour();
        // prepare snap

        currentPt = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.ROOM_POINT);

        WC.core.rawCont.addPoint(currentPt);

        me.draw();

        WC.SFK.state.hideInputs();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
        WC.SFK.state = WC.SFK.stateMakingRoom;

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_MAKING_WALL_SHAPE, {}));
    };

    me.stop = function()
    {
        WC.SFK.state.hideInputs();
		WC.SFK.state = WC.SFK.baseState;
        me.order = [];

        WC.wallsEditor.dblClickToDel = false;

        if (! WC.core.rawCont || WC.core.rawCont.points.length < 4 || ! TR.contourValid(WC.core.rawCont.points))
        {
            WC.core.rawCont = null;
            WC.wallsEditor.titlesTool.updateComponents();
            me.draw();
            return;
        }

        WC.core.rawCont.points.pop();

        var room = new WC.CRoom(me.makingOuter);
        room.points = WC.core.rawCont.points;
        for (var i = 0; i < room.points.length; i++) room.points[i].contour = room;
        WC.core.arrRooms.push(room);
        WC.core.addRoomPoints(WC.core.rawCont.points);

        WC.core.rebuildWallsAndCovers();
        WC.wallsEditor.titlesTool.updateComponents();
        WC.wallsEditor.save();

        WC.core.rawCont = null;
        me.draw();
    };

    me.findSnap = function()
    {
        var snapRes = WC.snapTool.getSnapPoint(WC.realPos, [currentPt], WC.SNAP_DIST / WC.wallsEditor.scale, currentPt.contour?.points);
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    var undoPoints = [];
	me.order = [];

    me.undo = function()
    {
        if (WC.core.rawCont?.points.length >= 2) {
            const lastOrder = me.order.pop();
            if (lastOrder === "end") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(WC.core.rawCont.points.length - 2, 1)
                );
            } else if (lastOrder === "start") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(0, 1)
                );
            }
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.redo = function()
    {
        if (undoPoints.length > 0)
        {
            WC.core.rawCont?.addPointAt(undoPoints.pop(), WC.core.rawCont.points.length - 1);
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.canUndo = function()
    {
        if(WC.core.rawCont) return WC.core.rawCont.points.length >= 2;
    };

    me.canRedo = function()
    {
        return undoPoints.length > 0;
    };

    me.mouseDown = function()
    {
        
    };

    let timer;

    me.mouseMove = function()
    {
        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;

        me.draw();

        clearTimeout(timer)
    	timer = setTimeout(() => WC.wallsEditor.updateTip(WC.SFK.selectedSizeData?.inputCenter, 2), 25);
    };

    me.mouseUp = function()
    {
        WC.SFK.state.hideInputs();
		needInputShow = false;

        if(!WC.core.rawCont) return;
        var eps = 0.1;
        if (WC.core.rawCont && WC.core.rawCont.points.length >= 2)
        {
            var firstPt = WC.core.rawCont.points[0];
            var lastPt = WC.core.rawCont.points[WC.core.rawCont.points.length - 2];

            if (TR.manhDist(lastPt.x, lastPt.y, currentPt.x, currentPt.y) <= eps || TR.manhDist(firstPt.x, firstPt.y, currentPt.x, currentPt.y) <= eps)
            {
                WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
                return {state: "stateEditing"};
            }
        }

        currentPt = new WC.CPoint(WC.snapPos.x, WC.snapPos.y, WC.ROOM_POINT);
        WC.core.rawCont.addPoint(currentPt);
        WC.wallsEditor.state.order?.push("end");
        WC.snapTool.reset();
        WC.wallsEditor.dispatchHistoryState();
        me.draw();
    };

    me.setCurrentPt = function(P) {
		currentPt = P;
	}

    me.dblClick = function()
    {

    };

    function drawRawRoom()
    {
        if (! WC.core.rawCont || WC.core.rawCont.points.length <= 1) return;

        WC.context.strokeStyle = '#000000';
        WC.context.lineWidth = 1;
        WC.context.fillStyle = me.cut
            ? "rgba(255, 255, 255, 0)"
            : WC.MEAT_FILL_STYLE;

        me.drawPolygon(WC.core.rawCont.points);

        if (WC.core.rawCont.points) {
            let pts = WC.core.rawCont.points;
            const minLen = 45;

            if (
                TR.euclDistP(pts[pts.length - 2], pts[pts.length - 1]) * WC.wallsEditor.scale <
                    minLen ||
                TR.euclDistP(pts[pts.length - 1], pts[0]) * WC.wallsEditor.scale < minLen
            ) {
                WC.SFK.state.hideInputs();
                needInputShow = true;
                return;
            }

            if (!needInputShow) return;

            WC.SFK.selectedSizeData1 = {
                A: pts[pts.length - 2],
                B: pts[pts.length - 1],
                k: 1,
            };
            WC.SFK.selectedSizeData2 = {
                A: pts[pts.length - 1],
                B: pts[0],
                k: 1,
            };

            WC.SFK.state.updateSizesData();

            if (!WC.SFK.activeInput?.parentNode) {
                WC.SFK.state.showInputs();
            }

            WC.SFK.findNewSelectedSizeDataByInput(WC.SFK.activeInput);
            
            WC.SFK.activeInput.select();
            WC.SFK.validInputValue = WC.SFK.activeInput.value;
            WC.SFK.activeInput.parentNode.style.transform = "rotate(0rad)";
        }
    }

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

        drawRawRoom();

        me.drawRulers();

        me.drawAligner();

        me.drawCross();
    }
};

WC.StateMakingRoom.prototype = Object.create(WC.BaseState.prototype);
WC.StateMakingRoom.prototype.constructor = WC.StateMakingRoom;
WC.StateSelectedCover = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateSelectedCover';

    var pointOver = null;
    var visiblePoints = [];
    me.covers = [];
    var pointDown = false;
    var downCoord = null;

    var sideOverCont = null;
    var sideOverIndA = -1;
    var sideOverIndB = -1;
    var sideCenter = null;

    let draggingCover = false;
    let sideDown = false;
    let dxDrag = 0;
    let dyDrag = 0;
    me.allPoints = [];

    me.keyboardHelper = function() {};

    function findCurrentSideAndCenter()
    {
        if (pointOver) pointOver.state = WC.UP;
        pointOver = WC.snapTool.findNearest(WC.realPos, visiblePoints, WC.POINT_SIZE / WC.wallsEditor.scale);

        if (pointOver) pointOver.state = WC.OVER;

        sideOverCont = null;
        sideOverIndA = -1;
        sideOverIndB = -1;
        if (! pointOver)
        {
            var w = WC.core.getSideByPoint(WC.realPos, me.covers);
            if (w)
            {
                sideOverCont = w[0];
                sideOverIndA = w[1];
                sideOverIndB = w[2];
            }
        }

        sideCenter = null;
        if (! sideOverCont) return;

        var A = sideOverCont.points[sideOverIndA];
        var B = sideOverCont.points[sideOverIndB];
        sideCenter = new TR.Point((A?.x + B?.x) / 2, (A?.y + B?.y) / 2);
    }

    function splitCurrentSide()
    {
        var A = sideOverCont.points[sideOverIndA];
        var B = sideOverCont.points[sideOverIndB];

        var cp = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.COVER_POINT);
        WC.core.addCoverPoints([cp]);
        sideOverCont.addPointAt(cp, sideOverIndB);

        return cp;
    }

    me.start = function(restart = false)
    {
        WC.wallsEditor.showCursor();

        visiblePoints = [];
        var L = me.covers.length;
        for (var i = 0; i < me.covers.length; i++)
        {
            if (WC.core.arrCovers.indexOf(me.covers[i]) == -1)
            {
                me.covers.splice(i, 1);
                i--;
                L--;
                continue;
            }

            me.covers[i].selected = true;
            visiblePoints = visiblePoints.concat(me.covers[i].points);
        }

        findCurrentSideAndCenter();
        
        me.draw();

        me.allPoints = me.covers.flatMap(cover => cover.points);
        WC.SFK.stateSelectedCover.allPoints = me.allPoints;

        if (restart || WC.wallsEditor.prevState == WC.wallsEditor.stateEditing || WC.wallsEditor.prevState == WC.wallsEditor.stateSelectedCover)
        {
            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_SELECTED_COVER, {pos: {x: WC.viewPos.x, y: WC.viewPos.y}}));
        }
        else
        {
            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_SELECTED_COVER, {}));
        }
    };

    me.stop = function()
    {
        for (var i = 0; i < me.covers.length; i++) me.covers[i].selected = false;
        me.covers = [];
        WC.core.connectAllPoints();
        pointDown = false;
        WC.wallsEditor.save();
    };

    me.delCover = function(cover)
    {
        var i = me.covers.indexOf(cover);
        if (i >= 0)
        {
            me.covers.splice(i, 1);
        }

        WC.wallsEditor.save();
        WC.snapTool.reset();

        if (me.covers.length == 0)
        {
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        }
    };

    me.delSelectedCovers = function()
    {
        var coversToDel = [].concat(me.covers);
        for (var i = 0; i < coversToDel.length; i++)
        {
            WC.core.delCover(coversToDel[i]);
        }

        coversToDel = [];
        me.covers = [];
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
    };

    me.setCeilingVisible = function (v)
    {
        for (var i = 0; i < me.covers.length; i++)
        {
            me.covers[i].setCeilingVisible(v);
        }
    };

    me.setCeilingHeight = function (h)
    {
        for (var i = 0; i < me.covers.length; i++)
        {
            me.covers[i].setCeilingHeight(h);
        }
    };

    me.mouseDown = function()
    {
        WC.SFK.state.hideInputs();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));

        downCoord = WC.viewPos.clone();

        if (pointOver) {
            pointDown = true;
        } else if (sideCenter) {
            if (
                TR.euclDist(sideCenter.x, sideCenter.y, WC.realPos.x, WC.realPos.y) <
                WC.CENTER_SIZE / WC.wallsEditor.scale
            ) {
                sideCenter = null;
                //    sideOverCont = null;
                WC.wallsEditor.stateDraggingCoverPoint.currentPt = splitCurrentSide();
                WC.wallsEditor.stateDraggingCoverPoint.covers = me.covers;
                WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingCoverPoint);
                WC.snapTool.reset();
            } else {
                sideDown = true;
            }
        } else if (TR.pointInContour(WC.realPos, me.covers[0]?.points) && !WC.SFK.curSizeData) {
            me.allPoints = me.covers.flatMap(cover => cover.points);
            draggingCover = true;
            dxDrag = me.allPoints[0].x - WC.realPos.x;
            dyDrag = me.allPoints[0].y - WC.realPos.y;
        }
    };

    me.mouseMove = function()
    {
        if (pointDown)
        {
            if (TR.euclDist(downCoord.x, downCoord.y, WC.viewPos.x, WC.viewPos.y) > WC.POINT_SIZE / 2)
            {
                pointDown = false;
                WC.wallsEditor.stateDraggingCoverPoint.currentPt = pointOver;
                WC.wallsEditor.stateDraggingCoverPoint.covers = me.covers;
                WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingCoverPoint);
                WC.snapTool.reset();
            }

            return;
        }

        if (sideDown) {
            sideDown = false;
            WC.wallsEditor.stateDraggingCoverSide.dragPtA = sideOverCont?.points[sideOverIndA];
            WC.wallsEditor.stateDraggingCoverSide.dragPtB = sideOverCont?.points[sideOverIndB];
            WC.wallsEditor.stateDraggingCoverSide.covers = me.covers;
            WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingCoverSide);

            return;
        }

        if (draggingCover) {
            let testPos0 = new TR.Point(WC.realPos.x + dxDrag, WC.realPos.y + dyDrag);
            let dx = testPos0.x - me.allPoints[0].x;
            let dy = testPos0.y - me.allPoints[0].y;

            for (let i = 0; i < me.allPoints.length; i++) {
                const P = me.allPoints[i];
                P.move(P.x + dx, P.y + dy);
            }

            WC.core.findCoverHoles();
            WC.core.findAllCoverTriangles();
            me.draw();

            return;
        }

        if (WC.SFK.state.name !=="stateSelectedWall") findCurrentSideAndCenter();

        WC.SFK.checkHoverSize();
        
        me.draw();
    };

    me.mouseUp = function()
    {
        if (draggingCover) {
            draggingCover = false;
            WC.core.findCoverHoles();
            WC.core.findAllCoverTriangles();
            WC.wallsEditor.titlesTool.hide();
            WC.wallsEditor.titlesTool.show(false);
            WC.wallsEditor.save();

            WC.SFK.stateSelectedCover.allPoints = me.allPoints;

            return;
        }

        if (WC.SFK.curSizeData) {
            WC.SFK.selectedSizeData = {...WC.SFK.curSizeData};
            WC.SFK.state = WC.SFK.stateSelectedWall;
            WC.SFK.state.showInputs();
            WC.SFK.state.makeInputSelected(WC.SFK.inputDomEl1.input);

            return;
        }

        sideDown = false;

        findCurrentSideAndCenter();
        if (sideCenter) {
            me.draw();
            WC.SFK.findSizeDataBySide(
                sideOverCont.points[sideOverIndA],
                sideOverCont.points[sideOverIndB]
            );

            WC.SFK.state = WC.SFK.stateSelectedWall;

            if (WC.SFK.selectedSizeData) {
                sideOverCont = null;
                sideCenter = null;
                WC.SFK.state.showInputs();
            } else {
                WC.SFK.selectedSizeData ={
                    A: sideOverCont.points[sideOverIndA],
                    B: sideOverCont.points[sideOverIndB],
                }
                WC.SFK.state.formatActivePoints(
                    WC.SFK.selectedSizeData.A,
                    WC.SFK.selectedSizeData.B
                )
                sideOverCont = null;
                sideCenter = null;
                me.draw();
            }

            return;
        }

    //    if (pointDown)
    //    {
    //        pointDown = false;
    //        return;
    //    }

        if (pointOver)
        {
            WC.wallsEditor.stateSelectedPoint.point = pointOver;
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedPoint);
            return { state: "stateSelectedPoint", quickPanel: {x: WC.viewPos.x, y: WC.viewPos.y - 30} }
        }

        var selectedCovers = WC.core.getCoversByPoint(WC.realPos);
        if (selectedCovers.length > 0)
        {
            for (var i = 0; i < me.covers.length; i++) me.covers[i].selected = false;
            me.covers = selectedCovers;

            me.start(true);

            WC.SFK.state.hideInputs();

            me.draw();
            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.SELECTED_COVER_AGAIN, {key: Math.random()}));
            return {state: "stateSelectedCover", quickPanel: { x: WC.viewPos.x, y: WC.viewPos.y - 30 }}
            return;
        }

        for (i = 0; i < me.covers.length; i++) me.covers[i].selected = false;
        me.covers = [];
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        return {state: "stateEditing"};
    };

    me.dblClick = function()
    {
        
        
        if (WC.wallsEditor.dblClickToDel)
        {
            var pointOver = WC.snapTool.findNearest(WC.realPos, visiblePoints, WC.POINT_SIZE / WC.wallsEditor.scale);
            if (! pointOver) return;

            WC.core.delPoint(pointOver);
            WC.core.findAllCoverTriangles();
            WC.wallsEditor.save();
            WC.snapTool.reset();
            me.draw();
            pointDown = false;
            pointOver = null;
        }
        else
        {
            WC.wallsEditor.dblClickToDel = true;
        }
    };

    function drawActiveWall(A, B) {
        const prevLineWidth = WC.context.lineWidth;
        WC.context.strokeStyle = '#FFDD66'; 
        WC.context.lineWidth = 3;
        WC.context.beginPath();
        WC.context.moveTo(A.x + 0.5, A.y + 0.5);
        WC.context.lineTo(B.x + 0.5, B.y + 0.5);
        WC.context.stroke();
        WC.context.closePath();
        WC.context.lineWidth = prevLineWidth;
    }

    me.draw = function()
    {
        WC.SFK.sizesData = [];

        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_BELOW) me.drawBG(0.3);

        me.drawModels();

        for (var i = 0; i < WC.core.arrCovers.length; i++) me.drawCover(WC.core.arrCovers[i]);
        for (i = 0; i < WC.core.arrRooms.length; i++) me.drawRoom(WC.core.arrRooms[i]);
        for (i = 0; i < me.covers.length; i++) me.drawPolygonSizes(me.covers[i], true, true);
        for (i = 0; i < WC.core.arrAreas.length; i++) me.drawArea(WC.core.arrAreas[i]);

        //me.drawObjects();

        if (WC.SFK.state.name === "stateSelectedWall") {
            const A = WC.wallsEditor.realToView(WC.SFK.selectedSizeData.A);
            const B = WC.wallsEditor.realToView(WC.SFK.selectedSizeData.B);
            drawActiveWall(A, B)
        }

        if (sideOverCont) {
            const A = WC.wallsEditor.realToView(sideOverCont.points[sideOverIndA]);
            const B = WC.wallsEditor.realToView(sideOverCont.points[sideOverIndB]);
            drawActiveWall(A, B)
        }

        for (i = 0; i < me.covers.length; i++)
        {
            var cover = me.covers[i];
            for (var j = 0; j < cover.points.length; j++)
            {
                me.drawPoint(cover.points[j]);
            }
        }

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_ABOVE) me.drawBG(0.5);

        if (sideCenter)
        {
            
            var C = WC.wallsEditor.realToView(sideCenter);

            WC.context.fillStyle = '#FFFFFF';
            WC.context.strokeStyle = '#004400';
            WC.context.lineWidth = 1;
            var r = 3;
            WC.context.beginPath();
            WC.context.arc(C.x + 1, C.y + 1, r, 0, Math.PI * 2);
            WC.context.stroke();
            WC.context.fill();
            WC.context.closePath();
        }

        me.drawRulers();
    };
};

WC.StateSelectedCover.prototype = Object.create(WC.BaseState.prototype);
WC.StateSelectedCover.prototype.constructor = WC.StateSelectedCover;
WC.StateSelectedRoom = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateSelectedRoom';

    me.room = null;
    me.isClickOnMeat = false;
    var innerPoints = [];
    var innerRooms = [];
    var innerCovers = [];

    me.start = function()
    {
        WC.wallsEditor.showCursor();

        me.room.selected = true;

        if (me.isClickOnMeat) {
            findInnerStuf();
            innerRooms.forEach(room => room.selected = true);
        };

        me.draw();


        WC.SFK.state = WC.SFK.stateSelectedRoom;
        WC.SFK.state.room = me.room;
        WC.SFK.state.innerPoints = innerPoints;
        WC.SFK.state.roomIndex = WC.core.arrRooms.indexOf(me.room);

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_SELECTED_ROOM, {pos: {x: WC.viewPos.x, y: WC.viewPos.y}}));

        //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_SHOW, {isMetric: R2D.DimensionSystem.isMetric()}));
    };

    me.stop = function()
    {
		WC.SFK.state = WC.SFK.baseState;
        me.isClickOnMeat = false;
        if (me.room) me.room.selected = false;
        innerRooms.forEach(room => room.selected = false);
    };

    me.mouseDown = function()
    {
        var w = WC.core.getSideByPoint(WC.realPos, [me.room]);
        if (w || me.isClickOnMeat)
        {
            WC.wallsEditor.stateDraggingRoom.room = me.room;
            WC.wallsEditor.stateDraggingRoom.innerPoints = innerPoints;
            WC.wallsEditor.changeState(WC.wallsEditor.stateDraggingRoom);

            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
        }
    };

    me.mouseMove = function()
    {

    };

    me.keyboardHelper = function() {
        me.room = WC.core.arrRooms[WC.SFK.state.roomIndex];
        if (me.isClickOnMeat) {
            findInnerStuf();
            innerRooms.forEach(room => room.selected = true);
        };
        if(me.room) {
            me.room.selected = true;
            WC.SFK.state.room = me.room;
            WC.SFK.state.innerPoints = innerPoints;
        }
    }

    me.mouseUp = function()
    {
        if (WC.wallsEditor.fastUp)
        {
            if (me.room) me.room.selected = false;
            innerRooms.forEach(room => room.selected = false);
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            return {state: "stateEditing"}
            
        }
    };

    me.delSelectedRoom = function()
    {
        WC.core.delRoom(me.room);
        me.room = null;

        for (var i = 0; i < innerRooms.length; i++) WC.core.delRoom(innerRooms[i]);

        for (i = 0; i < innerCovers.length; i++) WC.core.delCover(innerCovers[i]);

        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        
    };

    function findInnerStuf()
    {
        innerPoints = [];
        innerRooms = [];
        innerCovers = [];
        
        for (var i = 0; i < WC.core.arrRooms.length; i++)
        {
            if (WC.core.arrRooms[i] == me.room) continue;
            var comp = TR.compareContours(me.room?.points, WC.core.arrRooms[i]?.points);
            if (comp == TR.CONTAIN || comp == TR.CONTACT_CONTAIN || comp == TR.COINCIDE)
            {
                innerRooms.push(WC.core.arrRooms[i]);
                innerPoints = innerPoints.concat(WC.core.arrRooms[i]?.points);
            }
        }

        for (i = 0; i < WC.core.arrCovers.length; i++)
        {
            comp = TR.compareContours(me.room?.points, WC.core.arrCovers[i]?.points);
            if (comp == TR.CONTAIN || comp == TR.CONTACT_CONTAIN || comp == TR.COINCIDE)
            {
                innerCovers.push(WC.core.arrCovers[i]);
                for (var j = 0; j < WC.core.arrCovers[i]?.points.length; j++)
                {
                    if (! WC.core.arrCovers[i]?.points[j].parent)
                    {
                        innerPoints.push(WC.core.arrCovers[i]?.points[j]);
                    }
                }
            //    innerPoints = innerPoints.concat(WC.core.arrCovers[i].points);
            }
        }
    }

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        me.drawRulers();
    };
};

WC.StateSelectedRoom.prototype = Object.create(WC.BaseState.prototype);
WC.StateSelectedRoom.prototype.constructor = WC.StateSelectedRoom;

WC.StateSelectedPoint = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateSelectedPoint';

    me.point = null;
    me.cover = null;

    me.start = function()
    {
        WC.wallsEditor.showCursor();

        me.point.state = WC.OVER;

        if (me.point.type == WC.COVER_POINT)
        {
            me.cover = me.point.contour;
            me.cover.selected = true;
        }

        me.draw();
        WC.SFK.selectedPoint = me.point;
        WC.SFK.state = WC.SFK.stateSelectedPoint;
        WC.SFK.findSizeDataBySelectedPoint();
        WC.SFK.state.showInputs();

        me.draw();

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_SELECTED_POINT, {pos: {x: WC.viewPos.x, y: WC.viewPos.y}}));

        // setTimeout(() => {
        //     WC.wallsEditor.api.dispatchEvent(
        //         new Event(WC.wallsEditor.api.KEYBOARD_HELPER_SHOW, {
        //             isMetric: R2D.DimensionSystem.isMetric(),
        //         })
        //     );
        // }, 0);
    };

    me.stop = function()
    {
        me.cover = null;
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {

    };

    me.mouseUp = function()
    {
        me.point.state = WC.UP;
        if (me.point.type == WC.COVER_POINT)
        {
            var selectedCovers = WC.core.getCoversByPoint(WC.realPos);
            if (selectedCovers.length > 0)
            {
                WC.wallsEditor.stateSelectedCover.covers = selectedCovers;
                WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedCover);
                WC.SFK.state.hideInputs();
                //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_HIDE, {}));
                WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
                return {state: "selectedCover"};
            }
            else
            {
                me.cover.selected = false;

                //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_HIDE, {}));

                WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
                WC.SFK.state.hideInputs();
                return {state: "stateEditing"};
            }
        }
        else
        {
            //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_HIDE, {}));
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            WC.SFK.state.hideInputs();
            return {state: "stateEditing"};
            
        }
    };

    me.delSelectedPoint = function()
    {
        if (me.cover && me.cover.points.length > 3)
        {
            WC.core.delPoint(me.point);
            me.point = null;
            WC.wallsEditor.stateSelectedCover.covers = [me.cover];
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedCover);
        }
        else if (me.cover && me.cover.points.length <= 3)
        {
            me.cover.selected = false;
            WC.core.delPoint(me.point);
            me.point = null;
            //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_HIDE, {}));
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            
        }
        else
        {
            WC.core.delPoint(me.point);
            me.point = null;

            //    WC.core.rebuildWallsAndCovers();
            //    WC.wallsEditor.save();
            //    WC.snapTool.reset();
            //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.KEYBOARD_HELPER_HIDE, {}));
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            
        }

            //me.point.contour.selected = false;
    };

    me.draw = function()
    {
        WC.SFK.sizesData = [];
        let A = null;
        let B = null;

        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);
        if (WC.wallsEditor.drawingPosition == WC.DRAWING_BELOW) me.drawBG(0.3);

        me.drawModels();

        for (var i = 0; i < WC.core.arrCovers.length; i++) me.drawCover(WC.core.arrCovers[i]);
        for (i = 0; i < WC.core.arrRooms.length; i++) me.drawRoom(WC.core.arrRooms[i]);
        //for (i = 0; i < WC.core.arrRooms.length; i++) me.drawPolygonSizes(WC.core.arrRooms[i]);
        for (i = 0; i < WC.core.arrAreas.length; i++) me.drawArea(WC.core.arrAreas[i]);
        for (i = 0; i < WC.core.roomPoints.length; i++) me.drawPoint(WC.core.roomPoints[i]);

        if (WC.SFK.selectedSizeData1) {
            if (me.point.type == WC.COVER_POINT) {
                WC.context.strokeStyle = '#FFDD66';
            } else {
                WC.context.strokeStyle = '#bae51f';
            }
            
            WC.context.lineWidth = 3;
            A = WC.wallsEditor.realToView(WC.SFK.selectedSizeData1.A);
            B = WC.wallsEditor.realToView(WC.SFK.selectedSizeData1.B);
            
            WC.context.beginPath();
            WC.context.moveTo(A.x + 0.5, A.y + 0.5);
            WC.context.lineTo(B.x + 0.5, B.y + 0.5);
            WC.context.closePath();
            WC.context.stroke();
        }

        if (WC.SFK.selectedSizeData2) {
            A = WC.wallsEditor.realToView(WC.SFK.selectedSizeData2.A);
            B = WC.wallsEditor.realToView(WC.SFK.selectedSizeData2.B);

            WC.context.beginPath();
            WC.context.moveTo(A.x + 0.5, A.y + 0.5);
            WC.context.lineTo(B.x + 0.5, B.y + 0.5);
            WC.context.closePath();
            WC.context.stroke();

            WC.context.lineWidth = 1;
        }

        if (me.point.type == WC.COVER_POINT)
        {
            var cover = me.point.contour;

            for (var j = 0; j < cover.points.length; j++)
            {
                me.drawPoint(cover.points[j]);
            }
                me.drawPolygonSizes(me.cover, false, true);
        } else {
            for (i = 0; i < WC.core.arrRooms.length; i++) me.drawPolygonSizes(WC.core.arrRooms[i]);
        }

        if (WC.wallsEditor.drawingPosition == WC.DRAWING_ABOVE) me.drawBG(0.5);

        me.drawRulers();
    }
};

WC.StateSelectedPoint.prototype = Object.create(WC.BaseState.prototype);
WC.StateSelectedPoint.prototype.constructor = WC.StateSelectedPoint;
WC.StateSelectedArea = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateSelectedArea';

    me.areas = [];

    me.start = function()
    {
        WC.wallsEditor.showCursor();
        for (let ar of me.areas) ar.selected = true;
        me.draw();

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_SELECTED_LOW_AREA, {pos: {x: WC.viewPos.x, y: WC.viewPos.y}}));
    };

    me.stop = function()
    {
        for (let ar of me.areas) ar.selected = false;
        me.areas = []
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {

    };

    me.mouseUp = function()
    {
        if (WC.wallsEditor.fastUp)
        {
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            return {state: "stateEditing"};
        }
    };

    var superDraw = me.draw;
    me.draw = function()
    {
        superDraw();
    }
};

WC.StateSelectedArea.prototype = Object.create(WC.BaseState.prototype);
WC.StateSelectedArea.prototype.constructor = WC.StateSelectedArea;

// constructor

WC.StateAlignDrawing = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateAlignDrawing';

    me.rotateDrawing = false;
    me.newDrawing = false;

    var alignerH1 = {center: new TR.Point(50, 0),   dragPt: new TR.Point(0, 0), angle: 0, state: 'up'};
    var alignerH2 = {center: new TR.Point(150, 0),  dragPt: new TR.Point(0, 0), angle: 0, state: 'up'};

    var distanceV, distanceH;

    var aligners = [alignerH1, alignerH2];

    var dragShiftX = 0;
    var dragShiftY = 0;
    var dragAligner = null;
    var otherAligner = null;
    var overAligner = null;
    var overH = false;
    var overV = false;
    var changeV = false;
    var changeH = false;

    me.setSizeFirstTime = true;

    me.start = function()
    {
        recalcDragPts();

        me.draw();

        

        if (me.newDrawing)
        {
            
            me.newDrawing = false;
            return {state: "stateAlignDrawing"};
        }
        
    };

    me.stop = function()
    {
        me.scaleDrawing();
        WC.wallsEditor.dispatchDrawingChanged();
    };

    me.restore = function()
    {
        recalcDragPts();
    };

    me.initValues = function()
    {
        alignerH1.center = new TR.Point(50, 0);
        alignerH1.dragPt = new TR.Point(0, 0);
        alignerH2.center = new TR.Point(250, 0);
        alignerH2.dragPt = new TR.Point(0, 0);

        distanceV = 0;
        distanceH = 0;
    };

    me.initValues();

    me.mouseDown = function()
    {
        if (! overAligner) return;
        dragAligner = overAligner;
        overAligner = null;

        //    dragShiftX = dragAligner.center.x - WC.realPos.x;
        //    dragShiftY = dragAligner.center.y - WC.realPos.y;
        dragShiftX = dragAligner.dragPt.x - WC.realPos.x;   // add scale
        dragShiftY = dragAligner.dragPt.y - WC.realPos.y;

        if (dragAligner == alignerH1)
        {
            otherAligner = alignerH2;
        }
        else if (dragAligner == alignerH2)
        {
            otherAligner = alignerH1;
        }

        WC.wallsEditor.wheelEnabled = false;
        WC.wallsEditor.rightEnabled = false;

        WC.wallsEditor.hideCursor();

        me.draw();
    };

    me.mouseMove = function()
    {
        if (dragAligner)
        {
            var pivotPt = otherAligner.center;
            var otherDrag = otherAligner.dragPt;
            var dragPt = new TR.Point(WC.realPos.x + dragShiftX, WC.realPos.y + dragShiftY);
            var diag = Math.sqrt(Math.pow(dragPt.x - pivotPt.x, 2) + Math.pow(dragPt.y - pivotPt.y, 2));
            var h = 22 / WC.wallsEditor.scale;
            var L = Math.sqrt(Math.pow(diag, 2) - Math.pow(h, 2));
            var a = Math.asin(h / diag);
            var sign = Math.sign((otherDrag.y - dragPt.y) * (pivotPt.x - dragPt.x) - (otherDrag.x - dragPt.x) * (pivotPt.y - dragPt.y));

            if (isNaN(L)) L = 1;
            if (isNaN(a)) a = 1;
            if (isNaN(sign)) sign = 1;

            var P = TR.pointAtAngle(pivotPt, dragPt, sign * a, L);

            dragAligner.center.x = P.x;
            dragAligner.center.y = P.y;

            recalcDragPts();

            me.draw();
        }
        else
        {
            findUnderMouse();

            if (overH || overV)
            {
                WC.wallsEditor.cursorPointer();
            }
            else
            {
                WC.wallsEditor.showCursor();
            }
        }

        me.draw();
    };

    me.mouseUp = function()
    {
        WC.wallsEditor.showCursor();
        WC.wallsEditor.wheelEnabled = true;
        WC.wallsEditor.rightEnabled = true;

        if (dragAligner)
        {
            dragAligner = null;
        }
        me.mouseMove();
        if (overH)
        {
            changeH = true;
            //WC.wallsEditor.dispatchEvent(new Event(WC.ASK_ALIGNER_SIZE, WC.wallsEditor));
            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.ALIGN_PLAN_ASK_LENGTH, {}));
            return {state: "stateAlignDrawing", action: "alignerWidthSet"};
        }
        else if (overV)
        {
            console.log("overVoverV")
            changeV = true;
            //WC.wallsEditor.dispatchEvent(new Event(WC.ASK_ALIGNER_SIZE, WC.wallsEditor));
            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.ALIGN_PLAN_ASK_LENGTH, {}));
        }

        
    };

    me.mouseWheel = function()
    {
        recalcDragPts();
    };

    var findUnderMouse = function()
    {
        var aligner = null;
        var minDist = Number.POSITIVE_INFINITY;

        for (var i = 0; i < 2; i++)
        {
            var d = TR.euclDistP(WC.realPos, aligners[i].dragPt);
            if (d < minDist)
            {
                minDist = d;
                aligner = aligners[i];
            }
        }

        if (minDist < WC.SNAP_DIST * 1.5 / WC.wallsEditor.scale)
        {
            overAligner = aligner;
        }
        else
        {
            overAligner = null;
        }

        var valHPosX = (alignerH1.center.x + alignerH2.center.x) / 2;
        var valHPosY = (alignerH1.center.y + alignerH2.center.y) / 2;

        overH = (TR.euclDist(WC.realPos.x, WC.realPos.y, valHPosX, valHPosY) < WC.SNAP_DIST * 2 / WC.wallsEditor.scale);
    };

    var recalcDragPts = function()
    {
        var dx = alignerH2.center.x - alignerH1.center.x;
        var dy = alignerH2.center.y - alignerH1.center.y;
        var ang = Math.atan2(dy, dx);
        alignerH1.angle = ang;
        alignerH2.angle = ang;

        //---

        for (var i = 0; i < 2; i++)
        {
            var aligner = aligners[i];

            var pos = new TR.Point(aligner.center.x, aligner.center.y);
            var h = 22 / WC.wallsEditor.scale;
            pos.x = pos.x + h * Math.sin(aligner.angle);
            pos.y = pos.y - h * Math.cos(aligner.angle);

            aligner.dragPt = pos;
        }
    };

    me.getAlignerValue = function()
    {
        if (changeV) return distanceV;
        if (changeH) return distanceH;
        return NaN;
    };

    me.setAlignerValue = function(val)
    {
        if (parseInt(val) >= 0)
        {
            if (changeV) distanceV = val;
            if (changeH) distanceH = val;
        }

        changeV = false;
        changeH = false;
        me.draw();
    };

    var drawAligners = function()
    {
        var rcH1 = WC.wallsEditor.realToView(alignerH1.center);
        var rcH2 = WC.wallsEditor.realToView(alignerH2.center);

        WC.context.strokeStyle = '#ffffff';
        WC.context.fillStyle = '#ffffff';
        WC.context.lineWidth = 3;

        WC.context.beginPath();
        WC.context.moveTo(rcH1.x, rcH1.y);
        WC.context.lineTo(rcH2.x, rcH2.y);
        WC.context.stroke();
        WC.context.closePath();

        WC.context.strokeStyle = '#dd0066';
        WC.context.fillStyle = '#dd0066';
        WC.context.lineWidth = 1;

        var r = 6;

        for (var i = 0; i < 2; i++)
        {
            var aligner = aligners[i];

            var pos = WC.wallsEditor.realToView(aligner.center);
            var w = WC.imgAlignerIconUp?.width / 2;
            var h = WC.imgAlignerIconUp?.height;
            pos.x = pos.x - w * Math.cos(aligner.angle) + h * Math.sin(aligner.angle);
            pos.y = pos.y - w * Math.sin(aligner.angle) - h * Math.cos(aligner.angle);

            WC.context.save();
            WC.context.translate(pos.x, pos.y);
            WC.context.rotate(aligner.angle);

            if (aligner == overAligner)
            {
                WC.context.drawImage(WC.imgAlignerIconOver, 0, 0);
            }
            else if (aligner == dragAligner)
            {
                WC.context.drawImage(WC.imgAlignerIconDown, 0, 0);
            }
            else
            {
                WC.context.drawImage(WC.imgAlignerIconUp, 0, 0);
            }

            WC.context.restore();
        }

        WC.context.beginPath();
        WC.context.moveTo(rcH1.x, rcH1.y);
        WC.context.lineTo(rcH2.x, rcH2.y);
        WC.context.stroke();
        WC.context.closePath();

        //

        drawSize(rcH1, rcH2, distanceH);

        function drawSize(P1, P2, val)
        {
            var px = (P1.x + P2.x) / 2;
            var py = (P1.y + P2.y) / 2;

            var dx = P2.x - P1.x;
            var dy = P2.y - P1.y;

            r = Math.sqrt(dx * dx + dy * dy);
            var ang = Math.atan2(dy, dx);

            if (ang > Math.PI / 2 - TR.B_EPS) ang = ang - Math.PI;
            if (ang < -Math.PI / 2) ang = ang + Math.PI;

            WC.context.save();
            WC.context.translate(px, py);
            WC.context.rotate(ang);
            WC.context.textAlign = "center";
            WC.context.textBaseline = "middle";
            WC.context.font = "12pt Arial";

            var txt = R2D.DimensionSystem.toString(val);
            if (R2D.DimensionSystem.isMetric()) txt = txt + ' ' + R2D.DimensionSystem.getName();

            WC.context.strokeStyle = 'white';
            WC.context.lineWidth = 6;
            WC.context.strokeText(txt, 0, 0);

            WC.context.fillStyle = '#dd0066';
            WC.context.fillText(txt, 0, 0);
            WC.context.restore();
        }
    };

    me.scaleDrawing = function()
    {
        if (distanceH == 0) return;

        var addScale = distanceH / TR.euclDistP(alignerH1.center, alignerH2.center);

        WC.wallsEditor.drawingScale *= addScale;

        for (var i = 0; i < 2; i++)
        {
            aligners[i].center.x *= addScale;
            aligners[i].center.y *= addScale;
        }

        if (me.rotateDrawing)
        {
            var ang = (Math.atan2(alignerH2.center.x - alignerH1.center.x, alignerH2.center.y - alignerH1.center.y) - Math.PI / 2)

            WC.wallsEditor.drawingRotation += ang;

            for (i = 0; i < 2; i++)
            {
                var nx = aligners[i].center.x * Math.cos(ang) - aligners[i].center.y * Math.sin(ang);
                var ny = aligners[i].center.x * Math.sin(ang) + aligners[i].center.y * Math.cos(ang);
                aligners[i].center.x = nx;
                aligners[i].center.y = ny;
            }
        }

        recalcDragPts();
    };

    me.draw = function()
    {
        WC.context.clearRect(0, 0, WC.canvasWidth, WC.canvasHeight);

        me.drawBG(1);
        drawAligners();
    };

    me.getRulersData = function(data)
    {
        return {
            horizontal:{
                size: distanceH,
                ax: alignerH1.center.x,
                ay: alignerH1.center.y,
                bx: alignerH2.center.x,
                by: alignerH2.center.y
            },
            vertical:{
                size: 0,
                ax: 0,
                ay: 0,
                bx: 0,
                by: 0
            }
        }
    };

    me.setRulersData = function(data)
    {
        distanceH = parseFloat(data.horizontal.size);
        alignerH1.center.x = parseFloat(data.horizontal.ax);
        alignerH1.center.y = parseFloat(data.horizontal.ay);
        alignerH2.center.x = parseFloat(data.horizontal.bx);
        alignerH2.center.y = parseFloat(data.horizontal.by);

        me.scaleDrawing();

        recalcDragPts();
    };

    me.drawingCorrect = function()
    {
        return distanceH > 0 || WC.wallsEditor.drawingScale > 1;
    };

    //me.alignError
};

WC.StateAlignDrawing.prototype = Object.create(WC.BaseState.prototype);
WC.StateAlignDrawing.prototype.constructor = WC.StateAlignDrawing;
// constructor

WC.StateAlignDrawingByArea = function () {
    const me = this;
    WC.BaseState.call(this);
    me.name = "stateAlignDrawingByArea";

    let currentPt = null;
    let areaValue = 0;
    let stopDrawing = false;
    let undoPoints = [];

    me.order = [];

    me.start = function () {
        WC.wallsEditor.hideCursor();
        WC.core.rawCont = new WC.CRawContour();
        // prepare snap

        currentPt = new WC.CPoint(WC.realPos.x, WC.realPos.y, WC.ROOM_POINT);
        WC.core.rawCont.addPoint(currentPt);
        me.draw();
    };

    me.stop = function () {
        if (
            !WC.core.rawCont ||
            WC.core.rawCont.points.length < 4 ||
            !TR.contourValid(WC.core.rawCont.points)
        ) {
            WC.core.rawCont = null;
            me.draw();
            return;
        }

        WC.core.rawCont.points.pop();
        me.scaleDrawing();
        WC.wallsEditor.dispatchDrawingChanged();
        printRes();
        WC.core.rawCont = null;
    };

    me.findSnap = function () {
        const snapRes = WC.snapTool.getSnapPoint(
            WC.realPos,
            [currentPt],
            WC.SNAP_DIST / WC.wallsEditor.scale,
            currentPt.contour.points
        );
        WC.snapPos = snapRes[0];
        WC.aligners = [snapRes[1], snapRes[2], snapRes[3]];
    };

    me.restore = function () {};

    me.undo = function () {
        if (WC.core.rawCont?.points.length >= 2) {
            const lastOrder = me.order.pop();
            if (lastOrder === "end") {
                undoPoints = undoPoints.concat(
                    WC.core.rawCont.points.splice(WC.core.rawCont.points.length - 2, 1)
                );
            } else if (lastOrder === "start") {
                undoPoints = undoPoints.concat(WC.core.rawCont.points.splice(0, 1));
            }
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.redo = function () {
        if (undoPoints.length > 0) {
            WC.core.rawCont?.addPointAt(undoPoints.pop(), WC.core.rawCont.points.length - 1);
        }

        WC.snapTool.reset();
        me.findSnap();

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;
    };

    me.mouseDown = function () {};

    me.mouseMove = function () {
        if (stopDrawing) return;

        currentPt.x = WC.snapPos.x;
        currentPt.y = WC.snapPos.y;

        me.draw();
    };

    me.mouseUp = function () {
        if (!WC.core.rawCont) return;
        const eps = 0.1;

        if (WC.core.rawCont && WC.core.rawCont.points.length >= 2) {
            const firstPt = WC.core.rawCont.points[0];
            const lastPt = WC.core.rawCont.points[WC.core.rawCont.points.length - 2];

            if (
                TR.manhDist(lastPt.x, lastPt.y, currentPt.x, currentPt.y) <= eps ||
                TR.manhDist(firstPt.x, firstPt.y, currentPt.x, currentPt.y) <= eps
            ) {
                WC.wallsEditor.api.dispatchEvent(
                    new Event(WC.wallsEditor.api.SET_AREA_IMAG_PLAN_POPUP, {})
                );

                stopDrawing = true;
                WC.wallsEditor.showCursor();
                me.draw();

                return;
            }
        }

        currentPt = new WC.CPoint(WC.snapPos.x, WC.snapPos.y, WC.ROOM_POINT);
        WC.core.rawCont.addPoint(currentPt);
        me.order.push("end");
        WC.snapTool.reset();
        WC.wallsEditor.dispatchHistoryState();
        me.draw();
    };

    me.mouseWheel = function () {};

    me.getAlignerValue = function () {
        return -1;
    };

    me.setAlignerValue = function (val) {
        if (parseFloat(val) >= 0) {
            areaValue = parseFloat(val);
        }
    };

    me.scaleDrawing = function () {
        const a = Math.abs(TR.contourArea(WC.core.rawCont.points));
        const addScale = Math.sqrt(areaValue / a);
        WC.wallsEditor.drawingScale *= addScale;
    };

    function printRes(scale) {
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;

        for (let i = 0; i < WC.core.rawCont.points.length; i++) {
            const p = WC.core.rawCont.points[i];
            if (p.x < minX) minX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.x > maxX) maxX = p.x;
            if (p.y > maxY) maxY = p.y;
        }

        console.log("Max width: " + parseInt((maxX - minX) * WC.wallsEditor.drawingScale) + " cm");
        console.log("Max height: " + parseInt((maxY - minY) * WC.wallsEditor.drawingScale) + " cm");
    }

    const superDraw = me.draw;

    me.draw = function () {
        superDraw();

        WC.context.strokeStyle = "rgba(0, 255, 0, 1)";
        WC.context.lineWidth = 1;
        WC.context.fillStyle = "rgba(0, 255, 0, 0.1)";

        if (!WC.core.rawCont) return;

        me.drawPolygon(WC.core.rawCont.points);
        if (!stopDrawing) me.drawAligner();
        if (!stopDrawing) me.drawCross();
    };

    me.getRulersData = function () {
        return {
            horizontal: {
                size: 0,
                ax: 0,
                ay: 0,
                bx: 0,
                by: 0,
            },
            vertical: {
                size: 0,
                ax: 0,
                ay: 0,
                bx: 0,
                by: 0,
            },
        };
    };

    me.setRulersData = function (data) {};

    me.drawingCorrect = function () {
        return { scale: true, angle: true };
    };
};

WC.StateAlignDrawingByArea.prototype = Object.create(WC.BaseState.prototype);
WC.StateAlignDrawingByArea.prototype.constructor = WC.StateAlignDrawingByArea;

WC.StateMakingRuler = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateMakingRuler';

    var startPoint = null;

    me.start = function()
    {
        WC.wallsEditor.hideCursor();
        startPoint = null;
        //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_MAKING_RULER, {}));
    };

    me.stop = function()
    {

    };

    me.undo = function()
    {

    };

    me.redo = function()
    {

    };

    me.canUndo = function()
    {
        return false;
    };

    me.canRedo = function()
    {
        return false;
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {

        me.draw();
    };

    me.mouseUp = function()
    {
        if (! startPoint)
        {
            startPoint = new TR.Point(WC.realPos.x, WC.realPos.y);
        }
        else
        {
            var endPoint = new TR.Point(WC.realPos.x, WC.realPos.y);
            WC.wallsEditor.rulers.push(new WC.Ruler(startPoint, endPoint));
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        }
    };

    me.dblClick = function()
    {

    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        me.drawRulers();

        var endPoint = new TR.Point(WC.realPos.x, WC.realPos.y);
        if (! startPoint)
        {
            var dw = WC.imgAlignerIconUp?.width / 2;
            var dh = WC.imgAlignerIconUp?.height;
            var P = WC.wallsEditor.realToView(endPoint);
            WC.context.drawImage(WC.imgAlignerIconUp, P.x - dw, P.y - dh);
        }
        else
        {
            me.drawRuler(new WC.Ruler(startPoint, endPoint));
            me.drawRulerLabel(new WC.Ruler(startPoint, endPoint));
        }
    }
};

WC.StateMakingRuler.prototype = Object.create(WC.BaseState.prototype);
WC.StateMakingRuler.prototype.constructor = WC.StateMakingRuler;

WC.StateDraggingRuler = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateDraggingRuler';

    me.currentAligner = null;

    var dx = 0;
    var dy = 0;
    var moved = false;

    me.start = function()
    {
        dx = me.currentAligner.center.x - WC.realPos.x;
        dy = me.currentAligner.center.y - WC.realPos.y;
        moved = false;
    };

    me.stop = function()
    {
        for (var i = 0; i < WC.wallsEditor.rulers.length; i++)
        {
            WC.wallsEditor.rulers[i].calcDragPoints();
        }
    };

    me.undo = function()
    {

    };

    me.redo = function()
    {

    };

    me.canUndo = function()
    {
        return false;
    };

    me.canRedo = function()
    {
        return false;
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {
        moved = true;
        me.currentAligner.center.x = WC.realPos.x + dx;
        me.currentAligner.center.y = WC.realPos.y + dy;

        me.draw();
    };

    me.mouseUp = function()
    {
        let result = null;
        if (moved)
        {
            me.currentAligner = null;
            WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            result = {state: 'stateEditing'}
        }
        else
        {
            
            WC.wallsEditor.stateSelectedRuler.currentAligner = me.currentAligner;
            WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedRuler);
            result = {state: 'stateSelectedRuler', quickPanel: {x: WC.viewPos.x, y: WC.viewPos.y - 30}}
        }

        me.draw();
        return result;
    };

    me.dblClick = function()
    {

    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        me.drawRulers();
    }
};

WC.StateDraggingRuler.prototype = Object.create(WC.BaseState.prototype);
WC.StateDraggingRuler.prototype.constructor = WC.StateDraggingRuler;

WC.StateSelectedRuler = function()
{
    var me = this;
    WC.BaseState.call(this);
    me.name = 'stateSelectedRuler';

    me.currentAligner = null;

    me.start = function()
    {
        WC.wallsEditor.showCursor();
        //WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_SELECTED_RULER, {pos: {x: WC.viewPos.x, y: WC.viewPos.y}}));
    };

    me.stop = function()
    {

    };

    me.undo = function()
    {

    };

    me.redo = function()
    {

    };

    me.canUndo = function()
    {
        return false;
    };

    me.canRedo = function()
    {
        return false;
    };

    me.mouseDown = function()
    {

    };

    me.mouseMove = function()
    {

        me.draw();
    };

    me.mouseUp = function()
    {
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        return {state: 'stateEditing'};
    };

    me.dblClick = function()
    {

    };

    me.delSelectedRuler = function()
    {
        for (var i = 0; i < WC.wallsEditor.rulers.length; i++)
        {
            if (WC.wallsEditor.rulers[i].aligner1 == me.currentAligner || WC.wallsEditor.rulers[i].aligner2 == me.currentAligner)
            {
                WC.wallsEditor.rulers.splice(i, 1);
                WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
                return;
            }
        }
    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        me.drawRulers();
    }
};

WC.StateSelectedRuler.prototype = Object.create(WC.BaseState.prototype);
WC.StateSelectedRuler.prototype.constructor = WC.StateSelectedRuler;

function ContoursRenderTool()
{
    var me = this;

    var filter = new ContoursFilter();
    filter.setInsideColor(0.6, 0.6, 0.6, 0.5);
    filter.setOutsideColor(1.0, 1.0, 1.0, 0.0);
    filter.setStrokeColor(0.5, 0.5, 0.5, 1.0);

    me.getRender = function()
    {
        var bbox = new THREE.Box3().setFromObject(R2D.commonSceneObject.productObjects);
        if (bbox.min.x == Infinity || bbox.min.y == Infinity ||
            bbox.max.x == -Infinity || bbox.max.y == -Infinity) return null;
        var minX = bbox.min.x - 10;
        var maxX = bbox.max.x + 10;
        var minY = bbox.min.z - 10;
        var maxY = bbox.max.z + 10;

        var camera = new THREE.OrthographicCamera(minX, maxX, -minY, -maxY, 1, 1000);
        camera.position.set(0, 500, 0);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        camera.rotation.z = 0;

        var canvas = document.createElement('canvas');
        canvas.width = 2 * Math.abs(maxX - minX);
        canvas.height = 2 * Math.abs(maxY - minY);

        var renderer = new THREE.WebGLRenderer({
            antialias:true,
            alpha:true,
            preserveDrawingBuffer:true,
            canvas:canvas
        });

        var sceneContours = new THREE.Scene();
        var prodContainer = R2D.commonSceneObject.productObjects;
        var oldParent = prodContainer.parent;
        
        // deleting wall objects from render
        const wallObjects3d = [];
        const sceneObjectsForWall = R2D.scene.getSceneObjectsForWall();
        sceneObjectsForWall.forEach((sceneObject) => {
            const viewer3d = R2D.commonSceneHelper.productHelper.findObjectView3dBySceneObject(sceneObject);
            if(viewer3d) {
                wallObjects3d.push(viewer3d.object3d);
                viewer3d.object3d.removeFromParent();
            }
        });

        sceneContours.add(prodContainer);

        filter.setComponents(sceneContours, camera, renderer);
        filter.setSize(Math.abs(maxX - minX), Math.abs(maxY - minY));
        filter.render();

        // adding wall objects back
        wallObjects3d.forEach((object3d) => {
            prodContainer.add(object3d);
        });

        oldParent.add(prodContainer);

    //    filter.setComponents(R2D.commonSceneObject.productObjects, camera, renderer);


        return {src: canvas.toDataURL("image/png"), x: minX, y: minY};
    }
}

R2D.CopyPaste = {};

R2D.CopyPaste.clear = function()
{
    R2D.Storage.clear('r2d_clipboard');
    R2D.CopyPaste._dispatcher.dispatchEvent(new Event(R2D.CopyPaste.CHANGE));
};

R2D.CopyPaste.objToClipboard = function(obj)
{
    var str = JSON.stringify(obj);
    R2D.Storage.save('r2d_clipboard', str);
    R2D.CopyPaste._dispatcher.dispatchEvent(new Event(R2D.CopyPaste.CHANGE));
};

R2D.CopyPaste.objFromClipboard = function()
{
    try
    {
        var str = R2D.Storage.load('r2d_clipboard');
        if (! str) return null;

        return JSON.parse(str);
    }
    catch (e)
    {
        return null;
    }
};

R2D.CopyPaste.copyMaterial = function(val)
{
    R2D.CopyPaste.objToClipboard({type: 'material', value: val});
};

R2D.CopyPaste.pasteMaterial = function()
{
    var pasteData = R2D.CopyPaste.objFromClipboard();
    if (! pasteData) return;
    if (pasteData.type == 'material')
    {
        return pasteData.value;
    }
    else if (pasteData.type == 'constr')
    {
        return pasteData.value.m;
    }
};

R2D.CopyPaste.copyConstruction = function(dataConstr, partNum)
{
    var obj = {m:  dataConstr.materialID,
               mr: dataConstr.materialRotation,
               mx: dataConstr.materialX,
               my: dataConstr.materialY};

    if (dataConstr.type == 'wall' && dataConstr.configData)
    {
        obj.m = dataConstr.getMaterial(partNum);
        obj.conf = dataConstr.configData.toData();
    }

    R2D.CopyPaste.objToClipboard({type: 'constr', value: obj});
};

R2D.CopyPaste.pasteConstructionTo = function(target, partNum)
{
    var pasteObj = R2D.CopyPaste.objFromClipboard();
    if (! pasteObj) return;

    if (pasteObj.type == 'constr')
    {
        target.materialID = pasteObj.value.m;
        target.addMaterialID = pasteObj.value.addM;
        target.materialRotation = pasteObj.value.mr;
        target.materialX = pasteObj.value.mx;
        target.materialY = pasteObj.value.my;

        if (target.type == 'wall')
        {
            if (pasteObj.value.conf)
            {
                target.configData = new TConf.Field();
                target.configData.fromData(pasteObj.value.conf);
            }
            else
            {
                target.configData = null;
            }
        }

        target.changed = true;
        target.build3D();
        target.dispatchUpdate();
    }
    else if (pasteObj.type == 'material')
    {
        target.setMaterial(pasteObj.value, partNum);
        target.changed = true;
        target.build3D();
        target.dispatchUpdate();
    }
};

R2D.CopyPaste.copyModel = function(sceneObject)
{
    var dataModel = R2D.Scene.makeSceneObjectData(sceneObject);
    R2D.CopyPaste.objToClipboard({type: 'model', value: dataModel});
};

R2D.CopyPaste.pasteModel = async function()
{
    var pasteObj = R2D.CopyPaste.objFromClipboard();
    if (! pasteObj) return;

    let raycaster = new THREE.Raycaster();
    let point = R2D.Renderer3D.getMousePointForPicker(R2D.mouseInteractionHelper._currentCanvas, R2D.mouseInteractionHelper.mouseX, R2D.mouseInteractionHelper.mouseY);
    raycaster.setFromCamera(new THREE.Vector2(point.x, point.y), R2D.mouseInteractionHelper._currentCamera);
    data = raycaster.intersectObjects(R2D.mouseInteractionHelper._commonSceneObject.interactiveObjects.children, true);

    if (pasteObj.type == 'model')
    {   
        var models = await R2D.Creator.makeFromLoadedData([pasteObj.value]);
        return models[0];
    }
    else if(pasteObj.type == 'group') {
        let groupObjects = [];
        for(let i = 0; i < pasteObj.value.objectsData.length; i++) {
            var models = await R2D.Creator.makeFromLoadedData([pasteObj.value.objectsData[i]]);
            groupObjects.push(models[0]);
        }
        return groupObjects;
    }
    
};

R2D.CopyPaste.copyGroup = async group => {
    var dataGroup = R2D.Scene.makeSceneGroupData(group);
    R2D.CopyPaste.objToClipboard({type: 'group', value: dataGroup});
}

R2D.CopyPaste.modelToData = function(sceneObject) {
    var data = {
        id:sceneObject.getProductId(),
        type:sceneObject.getType(),
        x:sceneObject.x,
        y:sceneObject.y,
        z:sceneObject.z,
        sx:sceneObject.scaleX,
        sy:sceneObject.scaleY,
        sz:sceneObject.scaleZ,
        rx:sceneObject.rotationX,
        ry:sceneObject.rotationY,
        rz:sceneObject.rotationZ
    };

    if ( data.type == R2D.ProductType.MODEL ) {
        data['fx'] = sceneObject.flipX ? 1 : 0;
        data['fy'] = sceneObject.flipY ? 1 : 0;
        data['fz'] = sceneObject.flipZ ? 1 : 0;
        data['materials'] = sceneObject.getMaterials();

        if ( sceneObject.forWall ) {
            data['mf'] = sceneObject.getMaterialFrame();
            data['mfr'] = sceneObject.getMaterialFrameRotation();
            data['mfx'] = sceneObject.getMaterialFrameX();
            data['mfy'] = sceneObject.getMaterialFrameY();
            data['mb'] = sceneObject.getMaterialBottom();
            data['mbr'] = sceneObject.getMaterialBottomRotation();
            data['mbx'] = sceneObject.getMaterialBottomX();
            data['mby'] = sceneObject.getMaterialBottomY();
        }
    }

    return data;
};

R2D.CopyPaste.dataToModel = function(data)
{

};

R2D.CopyPaste._dispatcher = new EventDispatcher();

R2D.CopyPaste.addEventListener = function(evt, list)
{
    R2D.CopyPaste._dispatcher.addEventListener(evt, list)
};

R2D.CopyPaste.CHANGE = 'copyPasteChange';

R2D.CopyPaste.checkGlobalClipboard = async function () {
    if (R2D.Viewers._instance.getCurrentViewerType() == "constructor") return;
    
    try {
        const text = await navigator.clipboard.readText();
        const obj = JSON.parse(text);
        if (obj.action === "copy_to_clipboard") {
            console.log("Found model in clipboard.");
            await navigator.clipboard.writeText("");
            R2D.CopyPaste.objToClipboard({ type: "model", value: obj.model });
            return true;
        }
    } catch (error) {
        console.log("Failed to read clipboard.");
        return null;
    }
};

class ArrowAnimation {
    constructor() {
        this.canvas = document.createElement("canvas");
        this.canvas.style.position = "absolute";
        this.canvas.width = 200;
        this.canvas.height = 200;

        this.ctx = this.canvas.getContext("2d");
        this.startPoint = {};
        this.ctx.lineWidth = 3;
        this.ctx.lineCap = "round";
        this.ctx.lineJoin = "round";

        this.intervalId = null;
        this.interval = 20;
        this.arrowSize = 8;
        this.distBetweenArrows = this.arrowSize + 15;
        this.distFromStart = 15;
        this.pointer = 0;
        this.angle = 0;
        this.isAnimateRunning = false;

        this.canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });

        this.canvas.addEventListener("wheel", (e) => {
            if (WC.wallsEditor.wheelEnabled) {
                let x = e.offsetX == undefined ? e.layerX : e.offsetX;
                let y = e.offsetY == undefined ? e.layerY : e.offsetY;

                WC.wallsEditor.api.dispatchEvent(
                    new Event(WC.wallsEditor.api.WHEEL_ZOOM, {
                        x, y, delta: -e.deltaY || -e.detail || e.wheelDelta,
                    })
                );
            }

            WC.wallsEditor.state.mouseWheel();
        });

    }

    start() {
        if (this.isAnimateRunning) return;

        this.isAnimateRunning = true;

        this.intervalId = setInterval(this.animate.bind(this), this.interval);

        this.canvas.style.top = `${this.startPoint.y}px`;
        this.canvas.style.left = `${this.startPoint.x}px`;
        this.canvas.style.transform = "translate(-50%, -50%)";
        setTimeout(() => {
            document.body.appendChild(this.canvas);
        }, 100);
    }

    stop() {
        if (!this.isAnimateRunning) return;

        this.isAnimateRunning = false;
        if (this.canvas.parentNode) {
            document.body.removeChild(this.canvas);
        }
        clearInterval(this.intervalId);
    }

    setStartPoint(realPoint) {
        this.startPoint = WC.wallsEditor.realToView(realPoint);
    }

    setLineWidth(width) {
        this.ctx.lineWidth = width;
    }

    animate() {
        const ctx = this.ctx;
        const len = this.distBetweenArrows;
        let tr = 0;
        let k = (0.33 * (this.distBetweenArrows - this.pointer)) / this.distBetweenArrows;

        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        ctx.save();
        ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
        ctx.rotate(this.angle);

        tr = 0.66 + k;
        drawArrow.call(this, 0);

        tr = 0.33 + k;
        drawArrow.call(this, 1);

        tr = k;
        drawArrow.call(this, 2);

        ctx.restore();

        this.pointer += 1;

        if (this.pointer === len) {
            this.pointer = 0;
        }

        function drawArrow(num) {
            ctx.strokeStyle = `rgba(256, 256, 256, ${tr})`;
            ctx.lineWidth += 2;
            ctx.beginPath();
            ctx.moveTo(num * this.distBetweenArrows + this.pointer, -this.arrowSize);
            ctx.lineTo(this.arrowSize + num * this.distBetweenArrows + this.pointer, 0);
            ctx.lineTo(num * this.distBetweenArrows + this.pointer, this.arrowSize);
            ctx.stroke();

            ctx.strokeStyle =
                WC.SFK.activeInput == WC.SFK.inputDOMWidth.input
                    ? `rgba(221, 0, 102, ${tr})`
                    : `rgba(187, 230, 34, ${tr})`;
            ctx.lineWidth -= 2;
            ctx.beginPath();
            ctx.moveTo(num * this.distBetweenArrows + this.pointer, -this.arrowSize);
            ctx.lineTo(this.arrowSize + num * this.distBetweenArrows + this.pointer, 0);
            ctx.lineTo(num * this.distBetweenArrows + this.pointer, this.arrowSize);
            ctx.stroke();
        }
    }

    updateAnimation() {
        clearInterval(this.intervalId);
        this.canvas.style.top = `${this.startPoint.y}px`;
        this.canvas.style.left = `${this.startPoint.x}px`;
        this.canvas.style.transform = "translate(-50%, -50%)";
        this.intervalId = setInterval(this.animate.bind(this), this.interval);
    }
}
class CreateInput {
    constructor(sfk, params) {
        this.sfk = sfk;
        this.params = params;
        this.cont = this.createContainer();
        this.input = this.createInput();
        this.dimension = this.createDimension();

        this.cont.append(this.input);
        this.cont.append(this.dimension);

        this.input.addEventListener("keydown", (e) => this.keydownListener.call(this.sfk, e));
        this.input.addEventListener("mouseup", (e) => this.mousedownListener.call(this.sfk, e));

        if (this.params.type == "standard") {
            this.input.addEventListener("input", (e) =>
                this.inputStandardListener.call(this.sfk, e)
            );
        } else if (this.params.type == "width") {
            this.input.addEventListener("input", (e) => this.inputWidthListener.call(this.sfk, e));
        }
    }

    createContainer() {
        const container = document.createElement("div");
        container.style.position = "absolute";
        container.style.display = "flex";
        container.style.zIndex = "100";
        container.style.justifyContent = "center";
        container.style.alignItems = "center";
        container.style.width = "70px";
        container.style.height = "20px";

        return container;
    }

    createInput() {
        const input = document.createElement("input");
        input.type = "text";
        input.style.height = "20px";
        input.style.textAlign = "center";
        input.style.outline = "none";
        input.style.border = "1px solid " + this.params.borderColor;
        input.style.fontSize = "12px";

        return input;
    }

    createDimension() {
        const dimension = document.createElement("div");
        dimension.style.height = "20px";
        dimension.style.marginLeft = "4px";
        dimension.style.fontFamily = "sans-serif";
        dimension.style.fontSize = "14px";
        dimension.style.paddingTop = "2px";

        return dimension;
    }

    keydownListener(e) {
        const validImperial =
            /^[+-]?[0-9]+((\'(($)|( [0-9]+((((\'{2})|(\"))$)|( [0-9]+\/[0-9]+((\'{2})|(\"))$)|(\/[0-9]+((\'{2})|(\"))$)))))|(((\'{2})|(\"))$)|( [0-9]+\/[0-9]+((\'{2})|(\"))$)|(\/[0-9]+((\'{2})|(\"))$))/;

        if (e.code === "Enter") {
            if (R2D.DimensionSystem.isMetric()) {
                if (
                    e.currentTarget.value == "" ||
                    e.currentTarget.value == "+" ||
                    e.currentTarget.value == "-"
                )
                    return;

                e.currentTarget.value = e.currentTarget.value.replace(",", ".");
            } else {
                if (!validImperial.test(e.currentTarget.value)) {
                    return;
                }
            }

            this.state.updateConstruction(e.target);
            this.state.afterUpdateConstruction();

            if (this.state.name != "stateMakingRect") {
                this.state.hideInputs();
            }

            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.CHANGE_AREA_VALUE, {}));
        }
    }

    mousedownListener(e) {
        if (e.target == this.activeInput) return;

        e.preventDefault();
        this.state.makeInputSelected(e.target);
    }

    inputStandardListener(e) {
        const validNumber = /^[+-]?[0-9]+([,.]?[0-9]*)?$/;

        if (R2D.DimensionSystem.isMetric()) {
            if (
                !validNumber.test(e.currentTarget.value) &&
                e.currentTarget.value != "-" &&
                e.currentTarget.value != "+" &&
                e.currentTarget.value != ""
            ) {
                e.currentTarget.value = this.validInputValue;
                return;
            }
        }

        this.validInputValue = e.currentTarget.value;

        e.target.style.width = (e.currentTarget.value.length + 1) * 8 + "px";

        const curValueStr = e.currentTarget.value;

        this.state.updateAnimationData(curValueStr);

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }

    inputWidthListener(e) {
        const validNumber = /^[+-]?[0-9]+([,.]?[0-9]*)?$/;

        if (R2D.DimensionSystem.isMetric()) {
            if (
                !validNumber.test(e.currentTarget.value) &&
                e.currentTarget.value != "-" &&
                e.currentTarget.value != "+" &&
                e.currentTarget.value != ""
            ) {
                e.currentTarget.value = this.validInputValue;
                return;
            }
        }

        this.validInputValue = e.currentTarget.value;

        e.target.style.width = (e.currentTarget.value.length + 1) * 8 + "px";

        const prevValue = R2D.DimensionSystem.fromString(this.widthData?.value);
        const curValueStr = e.currentTarget.value;
        const curValue =
            curValueStr[0] === "+" || curValueStr[0] === "-"
                ? R2D.DimensionSystem.fromString(curValueStr.slice(1))
                : R2D.DimensionSystem.fromString(curValueStr);
        const angle = Math.atan2(
            this.widthData?.N?.y - this.widthData?.M?.y,
            this.widthData?.N?.x - this.widthData?.M?.x
        );

        if (!curValue) return;

        if (curValueStr[0] === "+" || (curValueStr[0] != "-" && curValue > prevValue)) {
            this.animation.angle = angle + Math.PI;
        } else if (curValueStr[0] === "-" || (curValueStr[0] != "+" && curValue < prevValue)) {
            this.animation.angle = angle;
        } else if (curValue == prevValue) {
            this.animation.stop();
            return;
        }

        const dx =
            (this.animation.distFromStart / WC.wallsEditor.scale) * Math.cos(this.animation.angle);
        const dy =
            (this.animation.distFromStart / WC.wallsEditor.scale) * Math.sin(this.animation.angle);

        this.animation.setStartPoint({
            x: this.widthData.M.x + dx,
            y: this.widthData.M.y + dy,
        });

        if (this.animation.isAnimateRunning) {
            this.animation.updateAnimation();
        } else {
            this.animation.start();
        }

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }
}

class BaseState {
    constructor(sfk) {
        this.core = sfk;

        this.name = "baseState";
    }

    updateAnimationData() {}

    moveElement(dir, dist) {
        if (WC.wallsEditor.state.name == "stateSelectedCover") {
            this.core.stateSelectedCover.moveElement(dir, dist);
        };
    }

    afterUpdateConstruction() {}

    formatActivePoints(point1, point2) {
        point1.state = WC.OVER;
        if (point2) point2.state = WC.OVER;
    }

    unsetActivePoints(point1, point2) {
        if (point1) point1.state = WC.UP;
        if (point2) point2.state = WC.UP;
    }

    updateSizesData(data, input) {
        if (!data) return;

        const { A, B, k } = data;
        const minLen = 30;

        if (
            WC.wallsEditor.scale != WC.wallsEditor.maxScale &&
            TR.euclDistP(A, B) * WC.wallsEditor.scale < minLen
        )
            return;

        const txt = R2D.DimensionSystem.toString(TR.euclDistP(A, B).toFixed(1));

        let vA = WC.wallsEditor.realToView(A);
        let vB = WC.wallsEditor.realToView(B);

        const X1 = TR.lineIntersectLine(
            vA,
            vB,
            new TR.Point(0, 0),
            new TR.Point(WC.canvasWidth, 0),
            true
        );
        const X2 = TR.lineIntersectLine(
            vA,
            vB,
            new TR.Point(WC.canvasWidth, 0),
            new TR.Point(WC.canvasWidth, WC.canvasHeight),
            true
        );
        const X3 = TR.lineIntersectLine(
            vA,
            vB,
            new TR.Point(WC.canvasWidth, WC.canvasHeight),
            new TR.Point(0, WC.canvasHeight),
            true
        );
        const X4 = TR.lineIntersectLine(
            vA,
            vB,
            new TR.Point(0, WC.canvasHeight),
            new TR.Point(0, 0),
            true
        );

        if (X1) {
            if (vB.y < X1.y) vB = X1;
            else vA = X1;
        }
        if (X2) {
            if (vB.x > X2.x) vB = X2;
            else vA = X2;
        }
        if (X3) {
            if (vB.y > X3.y) vB = X3;
            else vA = X3;
        }
        if (X4) {
            if (vB.x < X4.x) vB = X4;
            else vA = X4;
        }

        const px = (vA.x + vB.x) / 2;
        const py = (vA.y + vB.y) / 2;

        let dx = vB.x - vA.x;
        let dy = vB.y - vA.y;

        const r = Math.sqrt(dx * dx + dy * dy);
        let ang = Math.atan2(dy, dx);

        if (ang > Math.PI / 2 - TR.B_EPS) ang = ang - Math.PI;
        if (ang < -Math.PI / 2) ang = ang + Math.PI;

        dx = (dx / r) * 10 * k;
        dy = (dy / r) * 10 * k;

        data.value = txt;
        data.txtWidth = WC.context.measureText(txt).width;
        data.txtHeight = parseFloat(WC.context.font);
        data.ang = ang;
        data.center = { x: px + dy, y: py - dx };
        data.inputCenter = { x: px + 1.5 * dy, y: py - 1.5 * dx };

        this.core.state.updateInput(data, input);
    }

    showInputs() {
        // use for states: MakingRoom, MakingArea, MakingCover

        this.updateInput(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.addDimension(this.core.inputDomEl1);
        this.addInputInDOM(this.core.inputDomEl1);

        if (WC.core.rawCont.points.length > 2) {
            this.updateInput(this.core.selectedSizeData2, this.core.inputDomEl2);
            this.addDimension(this.core.inputDomEl2);
            this.addInputInDOM(this.core.inputDomEl2);
        }

        this.core.activeInput = this.core.inputDomEl1.input;
        this.core.selectedSizeData = this.core.selectedSizeData1;
    }

    updateConstruction(target) {
        // use for states: MakingRoom, MakingArea, MakingCover

        if (!this.core.selectedSizeData) return;

        const pointType = this.core.state.name == "stateMakingCover" ? WC.COVER_POINT : WC.ROOM_POINT; 

        const newSize = target.value;
        let delta = 0;
        let angle = this.core.selectedSizeData.ang;
        let value = this.core.selectedSizeData.value;

        if (newSize[0] === "+" || newSize[0] === "-") {
            const k = newSize[0] === "+" ? 1 : -1;
            delta = k * R2D.DimensionSystem.fromString(newSize.slice(1));
        } else {
            delta = R2D.DimensionSystem.fromString(newSize) - R2D.DimensionSystem.fromString(value);
        }

        // -------------------------------

        if (target == this.core.inputDomEl1.input) {
            const prevPoint = WC.core.rawCont?.points[WC.core.rawCont?.points.length - 2];
            const curPoint = WC.core.rawCont?.points[WC.core.rawCont?.points.length - 1];
            angle = Math.atan2(curPoint?.y - prevPoint?.y, curPoint?.x - prevPoint?.x);
            delta = R2D.DimensionSystem.fromString(newSize);
            const nextPoint = new WC.CPoint(
                prevPoint?.x + delta * Math.cos(angle),
                prevPoint?.y + delta * Math.sin(angle),
                pointType
            );

            WC.core.rawCont?.points.pop();
            WC.core.rawCont?.addPoint(nextPoint.clone());

            WC.core.rawCont?.addPoint(nextPoint);
            WC.wallsEditor.state.order?.push("end");
            WC.wallsEditor.state.setCurrentPt && WC.wallsEditor.state.setCurrentPt(nextPoint);
            WC.snapTool.reset();
        } else if (target == this.core.inputDomEl2.input) {
            const prevPoint = WC.core.rawCont?.points[0];
            const curPoint = WC.core.rawCont?.points[WC.core.rawCont?.points.length - 1];
            angle = Math.atan2(curPoint?.y - prevPoint?.y, curPoint?.x - prevPoint?.x);
            delta = R2D.DimensionSystem.fromString(newSize);
            const nextPoint = new WC.CPoint(
                prevPoint?.x + delta * Math.cos(angle),
                prevPoint?.y + delta * Math.sin(angle),
                pointType
            );
            WC.core.rawCont.addPointAt(nextPoint, 0);
            WC.wallsEditor.state.order.push("start");
            WC.snapTool.reset();
        }
    }

    updateInput(data, inputDomEl, addParams) {
        if (!data?.inputCenter) return;

        let styleLeft = data.inputCenter.x - parseInt(inputDomEl.cont.style.width) / 2;
        let styleTop = data.inputCenter.y - parseInt(inputDomEl.cont.style.height) / 2;

        if (this.core.widthData && addParams) {
            styleLeft = addParams.styleLeft;
            styleTop = addParams.styleTop;
        }

        inputDomEl.cont.style.left = `${styleLeft}px`;
        inputDomEl.cont.style.top = `${styleTop}px`;
        const angle = this.core.widthData ? this.core.selectedSizeData.ang : data.ang;
        inputDomEl.cont.style.transform = `rotate(${angle}rad)`;
        inputDomEl.input.value = data.value;
        inputDomEl.input.style.width = (inputDomEl.input.value.length + 1) * 8 + "px";
    }

    hideInputs() {
        this.core.animation.stop();
        this.core.animation2.stop();

        this.core.tabIndex = 0;
        this.core.tabElements = [];
        this.core.sizesData = [];
        this.core.selectedSizeData = null;
        this.core.selectedSizeData1 = null;
        this.core.selectedSizeData2 = null;
        this.core.selectedPoint = null;
        this.core.widthData = null;
        this.core.activeInput = null;
    }

    makeNextInputSelected() {
        this.core.tabIndex = (this.core.tabIndex + 1) % this.core.tabElements.length;
        this.makeInputSelected(this.core.tabElements[this.core.tabIndex]);
    }

    makeInputSelected(target) {
        if (!target) return;
        
        target.select();
        WC.SFK.validInputValue = target.value;

        this.resetDOM(this.core.activeInput, this.core.selectedSizeData);
        this.core.findNewSelectedSizeDataByInput(target);

        this.core.activeInput = target;
        this.core.activeInput.parentNode.style.transform = "rotate(0rad)";

        this.core.animation.stop();
        this.core.animation2.stop();

        this.core.tabIndex = this.core.tabElements.indexOf(target);

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }

    resetDOM(dom, data) {
        if (!dom) return;

        if (data?.value) dom.value = data.value;
        dom.style.width = (dom.value.length + 1) * 8 + "px";
        if (this.core.selectedSizeData) {
            dom.parentNode.style.transform = `rotate(${this.core.selectedSizeData.ang}rad)`;
        } else if (this.core.state.name == "stateMakingWall") {
            dom.parentNode.style.transform = `rotate(${data.ang}rad)`;
        }
    }

    updateInputsAfterDraggingCanvasOrZoom() {
        if (this.core.activeInput) this.core.activeInput.select();

        this.core.animation.stop();
        this.core.animation2.stop();
    }

    addDimension(domEl) {
        if (R2D.DimensionSystem.isMetric()) {
            domEl.dimension.textContent = R2D.DimensionSystem.getName();
        } else {
            domEl.dimension.textContent = "";
        }
    }

    addInputInDOM(domEl) {
        document.body.appendChild(domEl.cont);
        this.core.tabElements.push(domEl.input);
    }
}

class SelectedWall extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateSelectedWall";
        this.superHideInputs = core.baseState.hideInputs;
        this.superUpdateInputsAfterDraggingCanvasOrZoom =
            core.baseState.updateInputsAfterDraggingCanvasOrZoom;
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDOMWidth.cont.parentNode) {
            document.body.removeChild(this.core.inputDOMWidth.cont);
        }

        if (this.core.selectedSizeData) {
            this.core.selectedSizeData.A.state = WC.UP;
            this.core.selectedSizeData.B.state = WC.UP;

            this.superHideInputs();

            this.core.state = this.core.baseState;

            WC.wallsEditor.state.draw();

            // if (WC.wallsEditor.state.name == "stateEditing") {
            //     setTimeout(() => {
            //         WC.wallsEditor.api.dispatchEvent(
            //             new Event(WC.wallsEditor.api.KEYBOARD_HELPER_HIDE, {})
            //         );
            //     }, 0);
            // }
        }
    }

    showInputs() {
        if (!this.core.selectedSizeData) return;

        this.updateInput(this.core.selectedSizeData, this.core.inputDomEl1);
        this.addDimension(this.core.inputDomEl1);
        this.addInputInDOM(this.core.inputDomEl1);

        this.formatActivePoints(this.core.selectedSizeData.A, this.core.selectedSizeData.B);

        this.showWidthInput();

        WC.wallsEditor.state.draw();
    }

    showWidthInput() {
        if (!this.core.widthData) return;

        this.updateInput(this.core.widthData, this.core.inputDOMWidth);
        this.addDimension(this.core.inputDOMWidth);
        this.addInputInDOM(this.core.inputDOMWidth);
    }

    updateConstruction(target) {
        if (!this.core.selectedSizeData) return;

        const newSize = target.value;
        let delta = 0;
        let dx = 0;
        let dy = 0;
        let angle = 0;
        let value = 0;
        let sSD = this.core.selectedSizeData;

        if (target == this.core.inputDOMWidth.input) {
            angle = Math.atan2(
                this.core.widthData.N?.y - this.core.widthData.M?.y,
                this.core.widthData.N?.x - this.core.widthData.M?.x
            );
            value = this.core.widthData.value;
        } else {
            angle = sSD.ang;
            value = sSD.value;
        }

        if (newSize[0] === "+" || newSize[0] === "-") {
            const k = newSize[0] === "+" ? 1 : -1;
            delta = k * R2D.DimensionSystem.fromString(newSize.slice(1));
        } else {
            delta = R2D.DimensionSystem.fromString(newSize) - R2D.DimensionSystem.fromString(value);
        }

        dx = delta * Math.cos(angle);
        dy = delta * Math.sin(angle);

        // -------------------------------

        if (target == this.core.inputDOMWidth.input) {
            sSD.A.move(sSD.A.x - dx, sSD.A.y - dy);
            sSD.B.move(sSD.B.x - dx, sSD.B.y - dy);
        } else if (target == this.core.inputDomEl1.input) {
            sSD.pointAtStart?.move(sSD.pointAtStart.x - dx / 2, sSD.pointAtStart.y - dy / 2);
            sSD.pointAtEnd?.move(sSD.pointAtEnd.x + dx / 2, sSD.pointAtEnd.y + dy / 2);
        }
    }

    afterUpdateConstruction() {
        if (WC.wallsEditor.state.name == "stateEditing") {
            WC.core.rebuildWallsAndCovers();
            WC.core.findAllCoverTriangles();
            WC.wallsEditor.stateEditing.afterRebuild();
        } else if (WC.wallsEditor.state.name == "stateSelectedCover") {
            WC.core.findCoverHoles();
            WC.core.findAllCoverTriangles();
        }

        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }

    updateAnimationData(curValueStr) {
        if (!this.core.selectedSizeData) return;
        
        const prevValue = R2D.DimensionSystem.fromString(this.core.selectedSizeData?.value);
        const curValue =
            curValueStr[0] === "+" || curValueStr[0] === "-"
                ? R2D.DimensionSystem.fromString(curValueStr.slice(1))
                : R2D.DimensionSystem.fromString(curValueStr);
        const angle = this.core.selectedSizeData.ang;

        if (!curValue) return;

        if (curValueStr[0] === "+" || (curValueStr[0] != "-" && curValue > prevValue)) {
            this.core.animation.angle = angle > 0 ? angle + Math.PI : angle - Math.PI;
            this.core.animation2.angle = angle;
        } else if (curValueStr[0] === "-" || (curValueStr[0] != "+" && curValue < prevValue)) {
            this.core.animation.angle = angle;
            this.core.animation2.angle = angle > 0 ? angle + Math.PI : angle - Math.PI;
        } else if (curValue == prevValue) {
            this.core.animation.stop();
            this.core.animation2.stop();
            return;
        }

        const dx =
            (this.core.animation.distFromStart / WC.wallsEditor.scale) *
            Math.cos(this.core.animation.angle);
        const dy =
            (this.core.animation.distFromStart / WC.wallsEditor.scale) *
            Math.sin(this.core.animation.angle);

        this.core.animation.setStartPoint({
            x: this.core.selectedSizeData.pointAtStart?.x + dx,
            y: this.core.selectedSizeData.pointAtStart?.y + dy,
        });

        this.core.animation2.setStartPoint({
            x: this.core.selectedSizeData.pointAtEnd?.x - dx,
            y: this.core.selectedSizeData.pointAtEnd?.y - dy,
        });

        if (this.core.animation.isAnimateRunning) {
            this.core.animation.updateAnimation();
            this.core.animation2.updateAnimation();
        } else {
            this.core.animation.start();
            this.core.animation2.start();
        }
    }

    makeInputSelected(target) {
        if (!target) return;

        target.select();
        WC.SFK.validInputValue = target.value;

        if (this.core.widthData) {
            if (target == this.core.inputDomEl1.input) {
                this.resetDOM(this.core.inputDOMWidth.input, this.core.widthData);
            } else if (target == this.core.inputDOMWidth.input) {
                this.resetDOM(this.core.inputDomEl1.input, this.core.selectedSizeData);
            }
        }

        this.core.activeInput = target;
        this.core.activeInput.parentNode.style.transform = "rotate(0rad)";

        this.core.animation.stop();
        this.core.animation2.stop();

        this.core.tabIndex = this.core.tabElements.indexOf(target);

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }

    updateInputsAfterDraggingCanvasOrZoom() {
        this.updateSizesData(this.core.selectedSizeData, this.core.inputDomEl1);
        if (this.core.widthData) this.updateWidthEl();

        this.superUpdateInputsAfterDraggingCanvasOrZoom();
    }

    updateWidthEl() {
        if (!this.core.widthData.M || !this.core.widthData.N) return;

        let dx =
            WC.wallsEditor.realToView(this.core.selectedSizeData.B).x -
            WC.wallsEditor.realToView(this.core.selectedSizeData.A).x;
        let dy =
            WC.wallsEditor.realToView(this.core.selectedSizeData.B).y -
            WC.wallsEditor.realToView(this.core.selectedSizeData.A).y;
        const r = Math.sqrt(dx * dx + dy * dy);

        dx = (dx / r) * 10 * this.core.selectedSizeData.k;
        dy = (dy / r) * 10 * this.core.selectedSizeData.k;

        const M = this.core.widthData.M;
        const N = this.core.widthData.N;
        const newValue = R2D.DimensionSystem.toString(TR.euclDistP(M, N).toFixed(1));
        this.core.widthData.value = newValue;
        const newInputCenter = WC.wallsEditor.realToView(this.core.widthData.realPos);
        const addParams = {
            styleLeft:
                newInputCenter.x +
                1.5 * dy -
                parseInt(this.core.inputDOMWidth.cont.style.width) / 2,
            styleTop:
                newInputCenter.y -
                1.5 * dx -
                parseInt(this.core.inputDOMWidth.cont.style.height) / 2,
        };

        this.updateInput(this.core.widthData, this.core.inputDOMWidth, addParams);
    }

    moveElement(dir, dist) {
        let sSD = this.core.selectedSizeData;

        if (dir == this.core.LEFT) {
            sSD.A.move(sSD.A.x - dist, sSD.A.y);
            sSD.B.move(sSD.B.x - dist, sSD.B.y);
        } else if (dir == this.core.RIGHT) {
            sSD.A.move(sSD.A.x + dist, sSD.A.y);
            sSD.B.move(sSD.B.x + dist, sSD.B.y);
        } else if (dir == this.core.UP) {
            sSD.A.move(sSD.A.x, sSD.A.y - dist);
            sSD.B.move(sSD.B.x, sSD.B.y - dist);
        } else if (dir == this.core.DOWN) {
            sSD.A.move(sSD.A.x, sSD.A.y + dist);
            sSD.B.move(sSD.B.x, sSD.B.y + dist);
        }

        this.afterUpdateConstruction();
        WC.wallsEditor.state?.keyboardHelper && WC.wallsEditor.state?.keyboardHelper();
        this.formatActivePoints(this.core.selectedSizeData.A, this.core.selectedSizeData.B);
        this.updateSizesData(sSD, this.core.inputDomEl1);

        if (this.core.widthData) {
            this.core.widthData.M = TR.projectionPointOnLine(this.core.widthData.N, sSD.A, sSD.B);

            if (dir == this.core.LEFT) {
                this.core.widthData.realPos.x -= dist;
            } else if (dir == this.core.RIGHT) {
                this.core.widthData.realPos.x += dist;
            } else if (dir == this.core.UP) {
                this.core.widthData.realPos.y -= dist;
            } else if (dir == this.core.DOWN) {
                this.core.widthData.realPos.y += dist;
            }

            this.updateWidthEl();
        }

        WC.wallsEditor.state.draw();
    }
}

class SelectedPoint extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateSelectedPoint";
        this.superHideInputs = core.baseState.hideInputs;
        this.superUpdateInputsAfterDraggingCanvasOrZoom =
            core.baseState.updateInputsAfterDraggingCanvasOrZoom;
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }

        if (this.core.selectedPoint) this.core.selectedPoint.state = WC.UP;
        if (WC.wallsEditor.state.name == "stateSelectedPoint") {
            if (WC.wallsEditor.stateSelectedPoint.point.type == WC.ROOM_POINT) {
                WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
            } else {
                WC.wallsEditor.stateSelectedCover.covers.push(
                    WC.wallsEditor.stateSelectedPoint.cover
                );
                WC.wallsEditor.changeState(WC.wallsEditor.stateSelectedCover);
            }
        }

        this.superHideInputs();

        this.core.state = this.core.baseState;

        WC.wallsEditor.state.draw();
    }

    showInputs() {
        if (this.core.selectedSizeData1) {
            this.updateInput(this.core.selectedSizeData1, this.core.inputDomEl1);
            this.addDimension(this.core.inputDomEl1);
            this.addInputInDOM(this.core.inputDomEl1);
        }

        if (this.core.selectedSizeData2) {
            this.updateInput(this.core.selectedSizeData2, this.core.inputDomEl2);
            this.addDimension(this.core.inputDomEl2);
            this.addInputInDOM(this.core.inputDomEl2);
        }
    }

    updateConstruction(target) {
        if (!this.core.selectedSizeData) return;

        const newSize = target.value;
        let sSD = this.core.selectedSizeData;
        let delta = 0;
        let dx = 0;
        let dy = 0;
        let angle = sSD.ang;
        let value = sSD.value;

        if (newSize[0] === "+" || newSize[0] === "-") {
            const k = newSize[0] === "+" ? 1 : -1;
            delta = k * R2D.DimensionSystem.fromString(newSize.slice(1));
        } else {
            delta = R2D.DimensionSystem.fromString(newSize) - R2D.DimensionSystem.fromString(value);
        }

        dx = delta * Math.cos(angle);
        dy = delta * Math.sin(angle);

        // -------------------------------

        if (this.core.selectedPoint == sSD.pointAtStart) {
            sSD.pointAtStart.move(sSD.pointAtStart.x - dx, sSD.pointAtStart.y - dy);
        } else {
            sSD.pointAtEnd.move(sSD.pointAtEnd.x + dx, sSD.pointAtEnd.y + dy);
        }
    }

    afterUpdateConstruction() {
        if (this.core.selectedPoint.type == WC.ROOM_POINT) {
            WC.core.rebuildWallsAndCovers();
            WC.wallsEditor.stateEditing.afterRebuild();
        } else {
            WC.core.findCoverHoles();
            WC.core.findAllCoverTriangles();
        }
        this.core.selectedPoint = null;
        this.core.tabIndex = 0;
        this.core.tabElements = [];
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }

        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }

    updateAnimationData(curValueStr) {
        if (!this.core.selectedSizeData) return;
        
        const prevValue = R2D.DimensionSystem.fromString(this.core.selectedSizeData?.value);
        const curValue =
            curValueStr[0] === "+" || curValueStr[0] === "-"
                ? R2D.DimensionSystem.fromString(curValueStr.slice(1))
                : R2D.DimensionSystem.fromString(curValueStr);
        const angle = this.core.selectedSizeData.ang;

        if (!curValue) return;

        const core = this.core;

        if (curValueStr[0] === "+" || (curValueStr[0] != "-" && curValue > prevValue)) {
            if (core.selectedPoint == core.selectedSizeData.pointAtStart) {
                core.animation.angle = angle > 0 ? angle + Math.PI : angle - Math.PI;
            } else if (core.selectedPoint == core.selectedSizeData.pointAtEnd) {
                core.animation.angle = angle;
            }
        } else if (curValueStr[0] === "-" || (curValueStr[0] != "+" && curValue < prevValue)) {
            if (core.selectedPoint == core.selectedSizeData.pointAtStart) {
                core.animation.angle = angle;
            } else if (core.selectedPoint == core.selectedSizeData.pointAtEnd) {
                core.animation.angle = angle > 0 ? angle + Math.PI : angle - Math.PI;
            }
        } else if (curValue == prevValue) {
            core.animation.stop();
            return;
        }

        const dx =
            (core.animation.distFromStart / WC.wallsEditor.scale) * Math.cos(core.animation.angle);
        const dy =
            (core.animation.distFromStart / WC.wallsEditor.scale) * Math.sin(core.animation.angle);

        core.animation.setStartPoint({
            x: core.selectedPoint.x + dx,
            y: core.selectedPoint.y + dy,
        });

        if (core.animation.isAnimateRunning) {
            core.animation.updateAnimation();
        } else {
            core.animation.start();
        }
    }

    updateInputsAfterDraggingCanvasOrZoom() {
        this.updateSizesData(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.updateSizesData(this.core.selectedSizeData2, this.core.inputDomEl2);

        this.superUpdateInputsAfterDraggingCanvasOrZoom();
    }

    moveElement(dir, dist) {
        let sSD1 = this.core.selectedSizeData1;
        let sSD2 = this.core.selectedSizeData2;

        if (!this.core.selectedPoint) return;

        if (dir == this.core.LEFT) {
            this.core.selectedPoint.move(
                this.core.selectedPoint.x - dist,
                this.core.selectedPoint.y
            );
        } else if (dir == this.core.RIGHT) {
            this.core.selectedPoint.move(
                this.core.selectedPoint.x + dist,
                this.core.selectedPoint.y
            );
        } else if (dir == this.core.UP) {
            this.core.selectedPoint.move(
                this.core.selectedPoint.x,
                this.core.selectedPoint.y - dist
            );
        } else if (dir == this.core.DOWN) {
            this.core.selectedPoint.move(
                this.core.selectedPoint.x,
                this.core.selectedPoint.y + dist
            );
        }

        const point = this.core.selectedPoint;

        this.afterUpdateConstruction();

        const dataArr = this.core.sizesData.filter(
            (size) => size.A.match(point) || size.B.match(point)
        );
        this.core.selectedSizeData1 = dataArr[0];
        this.core.selectedSizeData2 = dataArr[1];
        sSD1 = this.core.selectedSizeData1;
        sSD2 = this.core.selectedSizeData2;

        const arrPoints = point.type == WC.ROOM_POINT ? WC.core.roomPoints : WC.core.coverPoints;
        this.core.selectedPoint = arrPoints.find((p) => p.match(point));
        if (this.core.selectedPoint) this.formatActivePoints(this.core.selectedPoint);

        if (sSD1) this.updateSizesData(sSD1, this.core.inputDomEl1);
        if (sSD2) this.updateSizesData(sSD2, this.core.inputDomEl2);

        this.showInputs();

        WC.wallsEditor.state.draw();

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }
}

class SelectedRoom extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateSelectedRoom";

        this.room = null;
        this.innerPoints = [];
    }

    hideInputs() {
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
        WC.wallsEditor.state.draw();
    }

    afterUpdateConstruction() {
        WC.core.rebuildWallsAndCovers();
        WC.core.findAllCoverTriangles();
        WC.wallsEditor.save();
    }

    moveElement(dir, dist) {
        let distX = 0;
        let distY = 0;
        let P = null;

        if (dir == this.core.LEFT) {
            distX = -dist;
        } else if (dir == this.core.RIGHT) {
            distX = dist;
        } else if (dir == this.core.UP) {
            distY = -dist;
        } else if (dir == this.core.DOWN) {
            distY = dist;
        }

        for (let i = 0; i < this.room.points.length; i++) {
            P = this.room.points[i];
            P.move(P.x + distX, P.y + distY);
        }

        for (let i = 0; i < this.innerPoints.length; i++) {
            P = this.innerPoints[i];
            P.move(P.x + distX, P.y + distY);
        }

        this.afterUpdateConstruction();
        WC.wallsEditor.state?.keyboardHelper && WC.wallsEditor.state?.keyboardHelper();

        WC.wallsEditor.state.draw();

        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }
}

class SelectedCover extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateSelectedCover";

        this.allPoints = [];
    }

    afterUpdateConstruction() {
        WC.core.findCoverHoles();
        WC.core.findAllCoverTriangles();
        WC.wallsEditor.save();
        WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.QUICK_PANELS_HIDE, {}));
    }

    hideInputs() {
        R2D.scene.api.dispatchEvent(
            new Event(R2D.scene.api.HISTORY_UNDO_REDO, {
                removeQuickPanel: true,
                clearRightPanel: true,
            })
        );
        WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
    }

    moveElement(dir, dist) {
        let distX = 0;
        let distY = 0;
        let P = null;

        if (dir == this.core.LEFT) {
            distX = -dist;
        } else if (dir == this.core.RIGHT) {
            distX = dist;
        } else if (dir == this.core.UP) {
            distY = -dist;
        } else if (dir == this.core.DOWN) {
            distY = dist;
        }

        for (let i = 0; i < this.allPoints.length; i++) {
            P = this.allPoints[i];
            P.move(P.x + distX, P.y + distY);
        }

        this.afterUpdateConstruction();
        WC.wallsEditor.state.draw();
    }
}

class MakingWalls extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateMakingWalls";
        this.superHideInputs = core.baseState.hideInputs;
        this.superUpdateSizesData = core.baseState.updateSizesData;
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }

        this.superHideInputs();
    }

    showInputs() {
        this.updateInput(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.addDimension(this.core.inputDomEl1);
        this.addInputInDOM(this.core.inputDomEl1);

        this.updateInput(this.core.selectedSizeData2, this.core.inputDomEl2);
        this.addDimension(this.core.inputDomEl2);
        this.addInputInDOM(this.core.inputDomEl2);

        this.core.activeInput = this.core.inputDomEl1.input;
        this.core.selectedSizeData = this.core.selectedSizeData1;
    }

    updateConstruction(target) {
        if (!this.core.selectedSizeData) return;

        const newSize = target.value;
        let delta = 0;
        let angle = this.core.selectedSizeData.ang;
        let value = this.core.selectedSizeData.value;

        if (newSize[0] === "+" || newSize[0] === "-") {
            const k = newSize[0] === "+" ? 1 : -1;
            delta = k * R2D.DimensionSystem.fromString(newSize.slice(1));
        } else {
            delta = R2D.DimensionSystem.fromString(newSize) - R2D.DimensionSystem.fromString(value);
        }

        // -------------------------------

        const prevPoint = WC.core.rawCont?.points[WC.core.rawCont?.points.length - 2];
        const curPoint = WC.core.rawCont?.points[WC.core.rawCont?.points.length - 1];
        angle = Math.atan2(curPoint?.y - prevPoint?.y, curPoint?.x - prevPoint?.x);
        delta = R2D.DimensionSystem.fromString(newSize);
        const nextPoint = new WC.CPoint(
            prevPoint?.x + delta * Math.cos(angle),
            prevPoint?.y + delta * Math.sin(angle),
            WC.ROOM_POINT
        );

        WC.core.rawCont?.points.pop();
        WC.core.rawCont?.addPoint(nextPoint.clone());

        if (WC.core.rawCont && WC.core.rawCont?.points.length >= 2) {
            const firstPt = WC.core.rawCont?.points[0];
            const lastPt = WC.core.rawCont?.points[WC.core.rawCont?.points.length - 2];

            if (
                TR.euclDist(lastPt.x, lastPt.y, nextPoint.x, nextPoint.y) <=
                    WC.wallsEditor.state.wallsWidth ||
                TR.euclDist(firstPt.x, firstPt.y, nextPoint.x, nextPoint.y) <= 0.1
            ) {
                WC.wallsEditor.changeState(WC.wallsEditor.stateEditing);
                WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_CONSTR_STOP, {state: "stateEditing"}));
                return;
            }
        }

        WC.core.rawCont?.addPoint(nextPoint);
        WC.wallsEditor.state.setCurrentPt && WC.wallsEditor.state.setCurrentPt(nextPoint);
        WC.snapTool.reset();

        // -------------------------------

        this.hideInputs();
    }

    afterUpdateConstruction() {
        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }

    makeNextInputSelected() {
        this.makeInputSelected(this.core.tabElements[this.core.tabIndex]);

        const sign = WC.wallsEditor.state.getSignSide && WC.wallsEditor.state.getSignSide(); 
        WC.wallsEditor.state.setSignSide(-sign);
        WC.wallsEditor.state.draw();
    }

    updateSizesData() {
        this.superUpdateSizesData(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.superUpdateSizesData(this.core.selectedSizeData2, this.core.inputDomEl2);
    }
}

class MakingRect extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateMakingRect";
        this.superUpdateSizesData = core.baseState.updateSizesData;
        this.superHideInputs = core.baseState.hideInputs;
    }

    updateSizesData() {
        this.superUpdateSizesData(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.superUpdateSizesData(this.core.selectedSizeData2, this.core.inputDomEl2);
        this.superUpdateSizesData(this.core.selectedSizeData3, this.core.inputDomEl3);
        this.superUpdateSizesData(this.core.selectedSizeData4, this.core.inputDomEl4);
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }
        if (this.core.inputDomEl3.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl3.cont);
        }
        if (this.core.inputDomEl4.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl4.cont);
        }

        this.superHideInputs();
    }

    showInputs() {
        this.updateInput(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.addDimension(this.core.inputDomEl1);
        this.addInputInDOM(this.core.inputDomEl1);

        this.updateInput(this.core.selectedSizeData3, this.core.inputDomEl3);
        this.addDimension(this.core.inputDomEl3);
        this.addInputInDOM(this.core.inputDomEl3);

        this.updateInput(this.core.selectedSizeData2, this.core.inputDomEl2);
        this.addDimension(this.core.inputDomEl2);
        this.addInputInDOM(this.core.inputDomEl2);

        this.updateInput(this.core.selectedSizeData4, this.core.inputDomEl4);
        this.addDimension(this.core.inputDomEl4);
        this.addInputInDOM(this.core.inputDomEl4);

        this.core.activeInput = this.core.inputDomEl1.input;
        this.core.selectedSizeData = this.core.selectedSizeData1;
    }

    updateConstruction(target) {
        if (!this.core.selectedSizeData) return;

        const newSize = target.value;
        let delta = 0;
        let value = this.core.selectedSizeData.value;

        if (newSize[0] === "+" || newSize[0] === "-") {
            const k = newSize[0] === "+" ? 1 : -1;
            delta = k * R2D.DimensionSystem.fromString(newSize.slice(1));
        } else {
            delta = R2D.DimensionSystem.fromString(newSize) - R2D.DimensionSystem.fromString(value);
        }

        // -------------------------------

        const curPt = WC.wallsEditor.state.cursPt;
        const startPt = WC.wallsEditor.state.startPt;

        if (target == this.core.inputDomEl1.input || target == this.core.inputDomEl3.input) {
            if (curPt?.x < startPt?.x) delta *= -1;
            curPt?.move(curPt?.x + delta, curPt?.y);
        } else if (target == this.core.inputDomEl2.input || target == this.core.inputDomEl4.input) {
            if (curPt?.y < startPt?.y) delta *= -1;
            curPt?.move(curPt?.x, curPt?.y + delta);
        }

        // -------------------------------

        if (target == this.core.inputDomEl1.input || target == this.core.inputDomEl3.input) {
            WC.wallsEditor.state.mouseMovingX = false;
            this.makeInputSelected(this.core.inputDomEl2.input);
        } else if (target == this.core.inputDomEl2.input || target == this.core.inputDomEl4.input) {
            WC.wallsEditor.state.mouseMovingY = false;
            this.makeInputSelected(this.core.inputDomEl1.input);
        }

        if (
            WC.wallsEditor.state.mouseMovingX == false &&
            WC.wallsEditor.state.mouseMovingY == false
        ) {
            WC.wallsEditor.state.mouseUp();
            WC.wallsEditor.api.dispatchEvent(new Event(WC.wallsEditor.api.STATE_CONSTR_STOP, {state: "stateEditing"}));
        }
    }

    afterUpdateConstruction() {
        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }

    updateAnimationData(curValueStr) {
        if (!this.core.selectedSizeData) return;
        
        const prevValue = R2D.DimensionSystem.fromString(this.core.selectedSizeData?.value);
        const curValue =
            curValueStr[0] === "+" || curValueStr[0] === "-"
                ? R2D.DimensionSystem.fromString(curValueStr.slice(1))
                : R2D.DimensionSystem.fromString(curValueStr);
        const angle = this.core.selectedSizeData.ang;

        if (!curValue) return;

        const core = this.core;

        const curPt = WC.wallsEditor.state.cursPt;
        const startPt = WC.wallsEditor.state.startPt;

        let kx = curPt?.x < startPt?.x ? -1 : 1;
        let ky = curPt?.y < startPt?.y ? -1 : 1;

        if (curValueStr[0] === "+" || (curValueStr[0] != "-" && curValue > prevValue)) {
            //
        } else if (curValueStr[0] === "-" || (curValueStr[0] != "+" && curValue < prevValue)) {
            kx *= -1;
            ky *= -1;
        } else if (curValue == prevValue) {
            core.animation.stop();
            return;
        }

        const dx = (core.animation.distFromStart / WC.wallsEditor.scale) * kx;
        const dy = (core.animation.distFromStart / WC.wallsEditor.scale) * ky;

        if (angle == 0) {
            core.animation.angle = kx < 0 ? -Math.PI : angle;
            core.animation.setStartPoint({
                x: curPt?.x + dx,
                y: (startPt?.y + curPt?.y) / 2,
            });
        } else if (angle == -Math.PI / 2) {
            core.animation.angle = ky < 0 ? angle : Math.PI / 2;
            core.animation.setStartPoint({
                x: (startPt?.x + curPt?.x) / 2,
                y: curPt?.y + dy,
            });
        }

        if (core.animation.isAnimateRunning) {
            core.animation.updateAnimation();
        } else {
            core.animation.start();
        }
    }
}

class MakingRoom extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateMakingRoom";
        this.superUpdateSizesData = core.baseState.updateSizesData;
        this.superHideInputs = core.baseState.hideInputs;
    }

    updateSizesData() {
        this.superUpdateSizesData(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.superUpdateSizesData(this.core.selectedSizeData2, this.core.inputDomEl2);
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }

        this.superHideInputs();
    }

    afterUpdateConstruction() {
        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }
}

class MakingCover extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateMakingCover";
        this.superUpdateSizesData = core.baseState.updateSizesData;
        this.superHideInputs = core.baseState.hideInputs;
    }

    updateSizesData() {
        this.superUpdateSizesData(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.superUpdateSizesData(this.core.selectedSizeData2, this.core.inputDomEl2);
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }

        this.superHideInputs();
    }

    afterUpdateConstruction() {
        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }
}

class MakingArea extends BaseState {
    constructor(core) {
        super(core);

        this.name = "stateMakingArea";
        this.superUpdateSizesData = core.baseState.updateSizesData;
        this.superHideInputs = core.baseState.hideInputs;
    }

    updateSizesData() {
        this.superUpdateSizesData(this.core.selectedSizeData1, this.core.inputDomEl1);
        this.superUpdateSizesData(this.core.selectedSizeData2, this.core.inputDomEl2);
    }

    hideInputs() {
        if (this.core.inputDomEl1.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl1.cont);
        }
        if (this.core.inputDomEl2.cont.parentNode) {
            document.body.removeChild(this.core.inputDomEl2.cont);
        }

        this.superHideInputs();
    }

    afterUpdateConstruction() {
        WC.wallsEditor.state.draw();
        WC.wallsEditor.save();
    }
}

class SizesFromKeyboard {
    constructor() {
        this.colors = {
            lightGrey: "#cdcdcd",
            black: "#000000",
            red: "#dd0066",
            // gray: "#6b6b6b",
            // green: "#BBE622",
        };

        const standardInputParams = {
            borderColor: this.colors.black,
            type: "standard",
        };

        const widthInputParams = {
            borderColor: this.colors.red,
            type: "width",
        };

        this.sizesData = [];
        this.curSizeData = null;
        this.widthData = null;
        this.selectedSizeData = null;
        this.selectedSizeData1 = null;
        this.selectedSizeData2 = null;
        this.selectedSizeData3 = null;
        this.selectedSizeData4 = null;
        this.selectedPoint = null;
        this.tabIndex = 0;
        this.tabElements = [];
        this.activeBlock = null;
        this.validInputValue = "";

        this.inputDomEl1 = new CreateInput(this, standardInputParams);
        this.inputDomEl2 = new CreateInput(this, standardInputParams);
        this.inputDomEl3 = new CreateInput(this, standardInputParams);
        this.inputDomEl4 = new CreateInput(this, standardInputParams);
        this.inputDOMWidth = new CreateInput(this, widthInputParams);
        this.activeInput = null;

        this.animation = new ArrowAnimation();
        this.animation2 = new ArrowAnimation();

        this.LEFT = "left";
        this.RIGHT = "right";
        this.UP = "up";
        this.DOWN = "down";

        this.baseState = new BaseState(this);
        this.stateSelectedWall = new SelectedWall(this);
        this.stateSelectedPoint = new SelectedPoint(this);
        this.stateMakingRect = new MakingRect(this);
        this.stateMakingWalls = new MakingWalls(this);
        this.stateMakingRoom = new MakingRoom(this);
        this.stateMakingCover = new MakingCover(this);
        this.stateMakingArea = new MakingArea(this);
        this.stateSelectedRoom = new SelectedRoom(this);
        this.stateSelectedCover = new SelectedCover(this);

        this.state = this.baseState;
    }

    addSizeData(sizeData) {
        const ang = sizeData.ang;
        const x = sizeData.center.x;
        const y = sizeData.center.y;
        const w2 = sizeData.txtWidth / 2;
        const h2 = sizeData.txtHeight / 2;

        const startPoint = { x: x - w2 * Math.cos(ang), y: y - w2 * Math.sin(ang) };
        const endPoint = { x: x + w2 * Math.cos(ang), y: y + w2 * Math.sin(ang) };

        const distStartPointToA = +TR.euclDistP(startPoint, sizeData.vA);
        const distStartPointToB = +TR.euclDistP(startPoint, sizeData.vB);

        const boundsObj = {
            leftTop: {
                x: +(startPoint.x + h2 * Math.sin(ang)).toFixed(1),
                y: +(startPoint.y - h2 * Math.cos(ang)).toFixed(1),
            },
            rightTop: {
                x: +(endPoint.x + h2 * Math.sin(ang)).toFixed(1),
                y: +(endPoint.y - h2 * Math.cos(ang)).toFixed(1),
            },
            rightBottom: {
                x: +(endPoint.x - h2 * Math.sin(ang)).toFixed(1),
                y: +(endPoint.y + h2 * Math.cos(ang)).toFixed(1),
            },
            leftBottom: {
                x: +(startPoint.x - h2 * Math.sin(ang)).toFixed(1),
                y: +(startPoint.y + h2 * Math.cos(ang)).toFixed(1),
            },
        };

        const bounds = [
            boundsObj.leftTop,
            boundsObj.rightTop,
            boundsObj.rightBottom,
            boundsObj.leftBottom,
        ];

        this.sizesData.push({
            k: sizeData.k,
            ang,
            value: sizeData.txt,
            bounds,
            center: { x, y },
            inputCenter: { ...sizeData.inputCenter },
            A: sizeData.A,
            B: sizeData.B,
            pointAtStart: distStartPointToA < distStartPointToB ? sizeData.A : sizeData.B,
            pointAtEnd: distStartPointToA < distStartPointToB ? sizeData.B : sizeData.A,
        });
    }

    setWidthData(widthData) {
        if (!widthData.wpts) return;

        let M = widthData.wpts[0];
        let N = widthData.wpts[1];
        let C = {
            x: (this.selectedSizeData.A.x + this.selectedSizeData.B.x) / 2,
            y: (this.selectedSizeData.A.y + this.selectedSizeData.B.y) / 2,
        };

        let parallelC = this.movePointOnLineInDirAToB(M, N, C, TR.euclDistP(M, N));

        let movedM = { ...M };
        let movedN = { ...N };

        const distToStartPoint = TR.euclDistP(M, this.selectedSizeData.pointAtStart);
        const distToEndPoint = TR.euclDistP(M, this.selectedSizeData.pointAtEnd);
        const distToCenterPoint = TR.euclDistP(M, C);

        let moveDist = 100 / WC.wallsEditor.scale;
        let inputPos = null;

        if (distToStartPoint < distToEndPoint) {
            if (distToCenterPoint < 50 / WC.wallsEditor.scale) {
                movedM = this.movePointOnLineInDirAToB(
                    this.selectedSizeData.pointAtEnd,
                    this.selectedSizeData.pointAtStart,
                    C,
                    moveDist * 0.55
                );
                movedN = this.movePointOnLineInDirAToB(
                    this.selectedSizeData.pointAtEnd,
                    this.selectedSizeData.pointAtStart,
                    parallelC,
                    moveDist * 0.55
                );
            }

            inputPos = this.movePointOnLineInDirAToB(
                this.selectedSizeData.pointAtEnd,
                this.selectedSizeData.pointAtStart,
                movedM,
                moveDist * 0.25
            );
        } else {
            if (distToCenterPoint < 50 / WC.wallsEditor.scale) {
                movedM = this.movePointOnLineInDirAToB(
                    this.selectedSizeData.pointAtStart,
                    this.selectedSizeData.pointAtEnd,
                    C,
                    moveDist * 0.55
                );
                movedN = this.movePointOnLineInDirAToB(
                    this.selectedSizeData.pointAtStart,
                    this.selectedSizeData.pointAtEnd,
                    parallelC,
                    moveDist * 0.55
                );
            }

            inputPos = this.movePointOnLineInDirAToB(
                this.selectedSizeData.pointAtStart,
                this.selectedSizeData.pointAtEnd,
                movedM,
                moveDist * 0.25
            );
        }

        inputPos = WC.wallsEditor.realToView(inputPos);

        let dx =
            WC.wallsEditor.realToView(this.selectedSizeData.B).x -
            WC.wallsEditor.realToView(this.selectedSizeData.A).x;
        let dy =
            WC.wallsEditor.realToView(this.selectedSizeData.B).y -
            WC.wallsEditor.realToView(this.selectedSizeData.A).y;
        const r = Math.sqrt(dx * dx + dy * dy);

        dx = (dx / r) * 10 * this.selectedSizeData.k;
        dy = (dy / r) * 10 * this.selectedSizeData.k;

        this.widthData = {
            value: R2D.DimensionSystem.toString(TR.euclDistP(M, N).toFixed(1)),
            M: movedM,
            N: movedN,
            realPos: WC.wallsEditor.viewToReal(inputPos),
            inputCenter: {
                x: inputPos.x + 1.5 * dy,
                y: inputPos.y - 1.5 * dx,
            },
        };
    }

    movePointOnLineInDirAToB(A, B, P, dist) {
        let dx = A.x - B.x;
        let dy = B.y - A.y;
        let angle = Math.atan2(dy, dx);
        dy = dist * Math.sin(angle);
        dx = dist * Math.cos(angle);
        return { x: P.x - dx, y: P.y + dy };
    }

    checkHoverSize() {
        if (!WC.viewPos) return;

        this.curSizeData = this.sizesData.find((size) =>
            TR.pointInContour(WC.viewPos, Object.values(size.bounds))
        );
    }

    isEqualPoints(P1, P2) {
        return P1.x === P2.x && P1.y === P2.y;
    }

    findSizeDataBySide(A, B) {
        this.selectedSizeData = this.sizesData.find((size) => size.A === A && size.B === B);
    }

    findSizeDataBySelectedPoint() {
        const P = this.selectedPoint;
        const dataArr = this.sizesData.filter((size) => size.A === P || size.B === P);
        this.selectedSizeData1 = dataArr[0];
        this.selectedSizeData2 = dataArr[1];
    }

    findNewSelectedSizeDataByInput(target) {
        if (target === this.inputDomEl1.input) {
            this.selectedSizeData = this.selectedSizeData1;
        } else if (target === this.inputDomEl2.input) {
            this.selectedSizeData = this.selectedSizeData2;
        } else if (target === this.inputDomEl3.input) {
            this.selectedSizeData = this.selectedSizeData3;
        } else if (target === this.inputDomEl4.input) {
            this.selectedSizeData = this.selectedSizeData4;
        }
    }

    addBackgroundToActiveSize() {
        const boundsObj = this.curSizeData.bounds;
        WC.context.save();
        WC.context.beginPath();
        WC.context.moveTo(boundsObj[0].x, boundsObj[0].y);
        WC.context.lineTo(boundsObj[1].x, boundsObj[1].y);
        WC.context.lineTo(boundsObj[2].x, boundsObj[2].y);
        WC.context.lineTo(boundsObj[3].x, boundsObj[3].y);
        WC.context.closePath();
        WC.context.fillStyle = this.colors.lightGrey;
        WC.context.fill();
        WC.context.restore();
    }
}

WC.SFK = new SizesFromKeyboard();

//creator

R2D.ProductPackageCreator = function() {
    //-
};
//creator

R2D.ProductPackageCreator.Material = function() {
    EventDispatcher.call(this);

    var scope = this;
    var byteArray = null;
    var materialPackage = null;

    Object.defineProperties(scope, {
        'package':{
            get() {
                return materialPackage;
            }
        }
    });

    scope.getPackage = function () {
        return materialPackage;
    };
    scope.create = function(data) {
        byteArray = new ByteArray();
        materialPackage = new ByteArray();

        materialPackage.setInt32(10);
        materialPackage.setInt32(data.originalWidth);
        materialPackage.setInt32(11);
        materialPackage.setInt32(data.originalHeight);
        materialPackage.setInt32(12);
        materialPackage.setInt32(data.currentWidth);
        materialPackage.setInt32(13);
        materialPackage.setInt32(data.currentHeight);
        materialPackage.setInt32(14);
        materialPackage.setFloat32(data.scaleX);
        materialPackage.setInt32(15);
        materialPackage.setFloat32(data.scaleY);
        materialPackage.setInt32(20);
        materialPackage.setInt8(data.realSize ? 1 : 0);
        materialPackage.setInt32(21);
        materialPackage.setInt8(data.transparent ? 1 : 0);
        materialPackage.setInt32(60);
        materialPackage.setInt32(data.materialType);
        materialPackage.setInt32(61);
        materialPackage.setFloat32(data.materialReflectivity);

        if ( data.diffuse ) {
            materialPackage.setInt32(50);
            materialPackage.setInt32(data.diffuse.length);
            materialPackage.writeUint8Array(data.diffuse);
        }
        if ( data.specular ) {
            materialPackage.setInt32(51);
            materialPackage.setInt32(data.specular.length);
            materialPackage.writeUint8Array(data.specular);
        }
        if ( data.normal ) {
            materialPackage.setInt32(52);
            materialPackage.setInt32(data.normal.length);
            materialPackage.writeUint8Array(data.normal);
        }

        //marker
        byteArray.setUint8('R'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('M'.charCodeAt(0));
        byteArray.setUint8('T'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('D'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));

        byteArray.setInt32(1); //type
        byteArray.setInt32(2); //version
        byteArray.writeUint8Array(materialPackage.getUint8Array()); //package

        scope.dispatchComplete(byteArray);
    };
};

R2D.extend(R2D.ProductPackageCreator.Material, EventDispatcher);
//creator

R2D.ProductPackageCreator.Model = function() {
    EventDispatcher.call(this);

    var scope = this;
    var byteArray = null;
    var modelPackage = null;

    Object.defineProperties(scope, {
        'package':{
            get() {
                return modelPackage;
            }
        }
    });

    scope.getPackage = function () {
        return modelPackage;
    };

    scope.create = function(data) {
        var geometriesLength = data.length;

        byteArray = new ByteArray();
        modelPackage = new ByteArray();

        modelPackage.setInt32(10);
        modelPackage.setInt32(geometriesLength);

        data.forEach(function(element) {
            var geometry = element.geometry;
            var indices = geometry.indices;
            var vertices = geometry.vertices;
            var uvs = geometry.uvs || [];
            var normals = geometry.normals;
            var md5 = geometry.md5;
            var index, length;

            modelPackage.setUint8('B'.charCodeAt(0));
            modelPackage.setUint8('E'.charCodeAt(0));
            modelPackage.setUint8('G'.charCodeAt(0));
            modelPackage.setUint8('I'.charCodeAt(0));
            modelPackage.setUint8('N'.charCodeAt(0));

            if ( vertices ) {
                modelPackage.setInt32(20);
                modelPackage.setInt32(vertices.length / 3);

                for ( index = 0, length = vertices.length; index < length; index += 3 ) {
                    modelPackage.setFloat32(vertices[index]);
                    modelPackage.setFloat32(vertices[index + 1]);
                    modelPackage.setFloat32(vertices[index + 2]);
                }
            } else {
                console.warn("Model has no vertices!");
            }

            if ( uvs ) {
                modelPackage.setInt32(21);
                modelPackage.setInt32(uvs.length / 2);

                for ( index = 0, length = uvs.length; index < length; index += 2 ) {
                    modelPackage.setFloat32(uvs[index]);
                    modelPackage.setFloat32(uvs[index + 1]);
                }
            } else {
                console.warn("Model has no uvs!");
            }

            if ( normals ) {
                modelPackage.setInt32(22);
                modelPackage.setInt32(normals.length / 3);

                for ( index = 0, length = normals.length; index < length; index += 3 ) {
                    modelPackage.setFloat32(normals[index]);
                    modelPackage.setFloat32(normals[index + 1]);
                    modelPackage.setFloat32(normals[index + 2]);
                }
            } else {
                console.warn("Model has no normals!");
            }

            if ( indices ) {
                modelPackage.setInt32(23);
                modelPackage.setInt32(indices.length);

                for ( index = 0, length = indices.length; index < length; index += 1 ) {
                    modelPackage.setUint32(indices[index]);
                }
            } else {
                console.warn("Model has no indices!");
            }

            //write md5
            modelPackage.setInt32(30);

            for ( let i = 0, l = md5.length; i < l; i++ ) {
                modelPackage.setUint8(md5.charCodeAt(i));
            }

            modelPackage.setUint8('E'.charCodeAt(0));
            modelPackage.setUint8('N'.charCodeAt(0));
            modelPackage.setUint8('D'.charCodeAt(0));
        });

        //marker
        byteArray.setUint8('R'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('M'.charCodeAt(0));
        byteArray.setUint8('T'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('D'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));

        byteArray.setInt32(2); //type
        byteArray.setInt32(3); //version
        byteArray.writeUint8Array(modelPackage.getUint8Array()); //package

        scope.dispatchComplete(byteArray);
    };
};

R2D.extend(R2D.ProductPackageCreator.Model, EventDispatcher);
//creator

R2D.ProductPackageCreator.Carpet = function() {
    EventDispatcher.call(this);

    var scope = this;
    var byteArray = null;//new ByteArray();
    var carpetPackage = null;//new ByteArray();

    Object.defineProperties(scope, {
        'package':{
            get() {
                return carpetPackage;
            }
        }
    });

    scope.getPackage = function () {
        return carpetPackage;
    };
    scope.create = function(data) {
        byteArray = new ByteArray();
        carpetPackage = new ByteArray();

        //write form of shape
        carpetPackage.setInt32(20);

        switch ( data.carpetType ) {
            case 2:
                carpetPackage.setInt32(2);
                break;

            case 1:
            default:
                carpetPackage.setInt32(1);
        }

        //write material data
        carpetPackage.setInt32(10);
        carpetPackage.setInt32(data.material.byteLength);
        carpetPackage.setBytes(data.material);

        //marker
        byteArray.setUint8('R'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('M'.charCodeAt(0));
        byteArray.setUint8('T'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('D'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));

        byteArray.setInt32(4); //type
        byteArray.setInt32(1); //version
        byteArray.writeUint8Array(carpetPackage.getUint8Array()); //package

        scope.dispatchComplete(byteArray);
    };
};

R2D.extend(R2D.ProductPackageCreator.Carpet, EventDispatcher);
//creator

R2D.ProductPackageCreator.Poster = function() {
    EventDispatcher.call(this);

    var scope = this;
    var byteArray = null;//new ByteArray();
    var carpetPackage = null;//new ByteArray();

    Object.defineProperties(scope, {
        'package':{
            get() {
                return carpetPackage;
            }
        }
    });

    scope.getPackage = function () {
        return carpetPackage;
    };
    scope.create = function(data) {
        byteArray = new ByteArray();
        carpetPackage = new ByteArray();

        //write material data
        carpetPackage.setInt32(10);
        carpetPackage.setInt32(data.material.byteLength);
        carpetPackage.setBytes(data.material);

        //marker
        byteArray.setUint8('R'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('M'.charCodeAt(0));
        byteArray.setUint8('T'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));
        byteArray.setUint8('D'.charCodeAt(0));
        byteArray.setUint8('O'.charCodeAt(0));

        byteArray.setInt32(3); //type
        byteArray.setInt32(1); //version
        byteArray.writeUint8Array(carpetPackage.getUint8Array()); //package

        scope.dispatchComplete(byteArray);
    };
};

R2D.extend(R2D.ProductPackageCreator.Poster, EventDispatcher);
// creator

R2D.MaterialCreator = function() {
    R2D.DomElement.call(this);

    var scope = this;
    var pixelsPerMeter = 512;
    var superSetWidth = scope.setWidth;
    var superSetHeight = scope.setHeight;
    var superSetSize = scope.setSize;
    var body = scope.getDomElement();
    var materialSetting = new R2D.MaterialCreator.MaterialSetting();
    var widthCM = null;
    var heightCM = null;
    var materialTexturesManager = new R2D.MaterialCreator.MaterialTexturesManager(materialSetting, pixelsPerMeter, widthCM, heightCM);
    var materialMaker = new R2D.MaterialCreator.MaterialMaker(materialSetting);
    var materialScene = new R2D.MaterialCreator.MaterialScene(materialMaker);
    var packageCreator = new R2D.ProductPackageCreator.Material();
    var isCreatingPackage = false;

    scope.setMaterialSizeCM = function(width, height)
    {
        widthCM = width;
        heightCM = height;
        materialTexturesManager.setSizeCM(width, height)
    };

    function setPackage(pack) {
        var matData = R2D.ProductPackageParser.parseMaterial(pack);

        materialTexturesManager.fromMaterialData(matData);
    }

    //package creator
    function packageCreatorCompleteEvent(event) {
        isCreatingPackage = false;

        scope.dispatchEvent(new Event(R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE, {
            "sizes":{
                "width":materialSetting.originalWidth,
                "height":materialSetting.originalHeight,
            },
            "package":new Blob([event.data.getBytesRange()], {type:'application/octet-stream'})
        }));
    }
    //end package creator

    //material textures manager
    function materialTexturesManagerEventHandler(event) {
        switch ( event.type ) {
            case Event.UPDATE:
                scope.dispatchEvent(new Event(Event.UPDATE, scope));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE:
                scope.dispatchEvent(new Event(Event.ERROR, R2D.MaterialCreator.ErrorNeedsDiffuse));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES:
                scope.dispatchEvent(new Event(Event.ERROR, R2D.MaterialCreator.ErrorTexturesDifferentSizes));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED:
                scope.dispatchEvent(new Event(R2D.MaterialCreator.PACKAGE_UPDATE, scope));
                break;
        }
    }
    //end material textures manager

    function resize() {
        materialScene.setSize(scope.getWidth(), scope.getHeight());
    }

    Object.defineProperties(scope, {
        "info":{
            get() {
                return {
                    originalWidth:materialSetting.originalWidth,
                    originalHeight:materialSetting.originalHeight,
                    currentWidth:materialSetting.currentWidth,
                    currentHeight:materialSetting.currentHeight,
                    scaleX:materialSetting.scaleX,
                    scaleY:materialSetting.scaleY,
                    pixelsPerMeter:pixelsPerMeter,
                    cmWidth:materialSetting.originalWidth / pixelsPerMeter * 100,
                    cmHeight:materialSetting.originalHeight / pixelsPerMeter * 100
                }
            }
        },
        "diffuse":{
            get() { return materialTexturesManager.diffuseFile; },
            set(file) {
                materialTexturesManager.diffuseFile = file;
            }
        },
        "specular":{
            get() { return materialTexturesManager.specularFile; },
            set(file) {
                materialTexturesManager.specularFile = file;
            }
        },
        "normal":{
            get() { return materialTexturesManager.normalFile; },
            set(file) {
                materialTexturesManager.normalFile = file;
            }
        },
        "realSize":{
            get() { return materialSetting.realSize; },
            set(value) {
                materialSetting.realSize = value;
                materialSetting.update();
            }
        },
        "transparent":{
            get() { return materialSetting.transparent; },
            set(value) {
                materialSetting.transparent = value;
                materialSetting.update();
            }
        },
        "materialReflectivity":{
            get() { return materialSetting.materialReflectivity; },
            set(value) {
                materialSetting.materialReflectivity = value;
                materialSetting.update();
            }
        },
        "materialType":{
            get() { return materialSetting.materialType; },
            set(value) {
                materialSetting.materialType = parseInt(value);
                materialSetting.update();
            }
        },
        "allMaterialTypes":{
            get() {
                return [
                    {
                        name:"Simple",
                        id:R2D.EnvironmentBase.NONE,
                        reflectivity:false
                    },
                    {
                        name:"Gloss",
                        id:R2D.EnvironmentBase.GLOSS,
                        reflectivity:true
                    },
                    {
                        name:"Metal",
                        id:R2D.EnvironmentBase.METAL,
                        reflectivity:true
                    }
                ];
            }
        },
        "geometryShape":{
            get() { return materialScene.geometry; },
            set(value) {
                materialScene.geometry = value;
            }
        },
        "allGeometryShapes":{
            get() {
                return [
                    {
                        name:'Sphere',
                        id:'sphere'
                    },
                    {
                        name:'Torus Knot',
                        id:'torusKnot'
                    },
                    {
                        name:'Box',
                        id:'box'
                    },
                    {
                        name:'Tile',
                        id:'tile'
                    }
                ];
            }
        }
    });

    scope.setWidth = function(value) {
        superSetWidth(value);
        resize();
    };
    scope.setHeight = function(value) {
        superSetHeight(value);
        resize();
    };
    scope.setSize = function(width, height) {
        superSetSize(width, height);
        resize();
    };
    scope.setData = function(data) {
        FILE.loadFileAsArrayBuffer(data.package, function(pack) {
            setPackage(pack);
        });
    };
    scope.createData = function() {
        if ( isCreatingPackage ) {
            console.error("Creating in process.");
            scope.dispatchEvent(new Event(R2D.MaterialCreator.ERROR_CREATING_IN_PROCESS));
            return;
        }
        if ( !materialSetting.diffuse && !materialSetting.specular && !materialSetting.normal ) {
            console.error("Empty material!");
            scope.dispatchEvent(new Event(R2D.MaterialCreator.ERROR_EMPTY_MATERIAL));
            return;
        }

        isCreatingPackage = true;

        scope.dispatchEvent(new Event(R2D.MaterialCreator.PACKAGE_CREATE_START, scope));
        packageCreator.create(materialSetting);
    };

    materialTexturesManager.addEventListener(Event.UPDATE, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED, materialTexturesManagerEventHandler);
    packageCreator.addEventListener(Event.COMPLETE, packageCreatorCompleteEvent);

    body.setAttribute('class', 'creator-material-body');
    body.appendChild(materialScene.domElement);

    setTimeout(function () {
        scope.dispatchEvent(new Event(Event.READY, scope));
    }, 100);
};

R2D.extend(R2D.MaterialCreator, R2D.DomElement);

R2D.MaterialCreator.PACKAGE_UPDATE = 'packageUpdate';
R2D.MaterialCreator.PACKAGE_CREATE_START = 'packageCreateStart';
R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE = 'packageCreateComplete';
R2D.MaterialCreator.ERROR_CREATING_IN_PROCESS = 'errorCreatingInProcess';
R2D.MaterialCreator.ERROR_EMPTY_MATERIAL = 'errorEmptyMaterial';

R2D.MaterialCreator.ErrorNeedsDiffuse = {
    "code":1000,
    "message":"Needs diffuse texture!"
};
R2D.MaterialCreator.ErrorTexturesDifferentSizes = {
    "code":1001,
    "message":"Textures have different sizes!"
};
//creator

R2D.MaterialCreator.MaterialMaker = function(materialSetting) {
    EventDispatcher.call(this);

    var scope = this;
    var material = null;

    function updateComplete() {
        material.needsUpdate = true;

        scope.dispatchUpdate();
    }

    function setEnvironment() {
        switch ( materialSetting.materialType ) {
            case R2D.EnvironmentBase.GLOSS:
                material.envMap = R2D.EnvironmentGloss.getTexture();
                material.reflectivity = R2D.EnvironmentGloss.getReflectivity(materialSetting.materialReflectivity);
                break;

            case R2D.EnvironmentBase.METAL:
                material.envMap = R2D.EnvironmentMetal.getTexture();
                material.reflectivity = R2D.EnvironmentMetal.getReflectivity(materialSetting.materialReflectivity);
                break;

            case R2D.EnvironmentBase.NONE:
                material.envMap = null;
                material.reflectivity = 1;
                break;

            default:
                material.envMap = null;
                material.reflectivity = 1;
                console.warn('Unknown type of environment map!');
        }

        updateComplete();
    }

    function texturesComplete() {
        setEnvironment();
    }

    function makeTexture(src, targetProperty, nextFunction) {
        var img = document.createElement('img');

        img.addEventListener('load', function(event) {
            var texture = new THREE.Texture();
            var rx = materialSetting.realSize ? materialSetting.scaleX : 1;
            var ry = materialSetting.realSize ? materialSetting.scaleY : 1;

            texture.image = img;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.flipY = false;
            texture.repeat.set(rx, ry);
            texture.needsUpdate = true;

            material[targetProperty] = texture;

            nextFunction();
        });
        img.setAttribute('src', src);
    }

    function loadSpecular() {
        if ( materialSetting.specular ) {
            FILE.loadFileAsDataURL(
                FILE.readArrayAsFile(materialSetting.specular),
                function(dataURL) {
                    makeTexture(dataURL, 'specularMap', texturesComplete);
                }
            );
        } else {
            texturesComplete();
        }
    }
    function loadNormal() {
        if ( materialSetting.normal ) {
            FILE.loadFileAsDataURL(
                FILE.readArrayAsFile(materialSetting.normal),
                function(dataURL) {
                    makeTexture(dataURL, 'normalMap', loadSpecular);
                }
            );
        } else {
            loadSpecular();
        }
    }
    function loadDiffuse() {
        if ( materialSetting.diffuse ) {
            FILE.loadFileAsDataURL(
                FILE.readArrayAsFile(materialSetting.diffuse),
                function(dataURL) {
                    makeTexture(dataURL, 'map', loadNormal);
                }
            );
        } else {
            loadNormal();
        }
    }
    function updateTextures() {
        loadDiffuse();
    }

    function materialSettingUpdateEventHandler(event) {
        material = new THREE.MeshPhongMaterial();

        material.transparent = materialSetting.transparent;
        // material.side = THREE.DoubleSide;

        updateTextures();
    }

    Object.defineProperties(scope, {
        'material':{
            get() {
                return material;
            }
        },
        'materialSettings':{
            get() {
                return materialSetting;
            }
        }
    });

    materialSetting.onUpdate(materialSettingUpdateEventHandler);
};

R2D.extend(R2D.MaterialCreator.MaterialMaker, EventDispatcher);
R2D.MaterialCreator.MaterialSetting = function() {
    EventDispatcher.call(this);

    var scope = this;
    var diffuse = null;
    var normal = null;
    var specular = null;
    var realSize = true;
    var transparent = false;
    var materialType = 0;
    var materialReflectivity = 0.5;
    var originalWidth = 0;
    var originalHeight = 0;
    var currentWidth = 0;
    var currentHeight = 0;
    var scaleX = 1;
    var scaleY = 1;

    function update() {
        scope.dispatchUpdate(scope);
    }

    Object.defineProperties(scope, {
        'diffuse':{
            get() {
                return diffuse;
            },
            set(file) {
                diffuse = file;
            }
        },
        'normal': {
            get() {
                return normal;
            },
            set(file) {
                normal = file;
            }
        },
        'specular':{
            get() {
                return specular;
            },
            set(file) {
                specular = file;
            }
        },
        'realSize': {
            get() {
                return realSize;
            },
            set(value) {
                realSize = value;
            }
        },
        'transparent':{
            get() {
                return transparent;
            },
            set(value) {
                transparent = value;
            }
        },
        'materialType':{
            get() {
                return materialType;
            },
            set(value) {
                materialType = value;
            }
        },
        'materialReflectivity':{
            get() {
                return materialReflectivity;
            },
            set(value) {
                materialReflectivity = Math.min(Math.max(value, 0), 1);
            }
        },
        'originalWidth':{
            get() {
                return originalWidth;
            },
            set(value) {
                originalWidth = value;
            }
        },
        'originalHeight':{
            get() {
                return originalHeight;
            },
            set(value) {
                originalHeight = value;
            }
        },
        'currentWidth':{
            get() {
                return currentWidth;
            },
            set(value) {
                currentWidth = value;
            }
        },
        'currentHeight':{
            get() {
                return currentHeight;
            },
            set(value) {
                currentHeight = value;
            }
        },
        'scaleX':{
            get() {
                return scaleX;
            },
            set(value) {
                scaleX = value;
            }
        },
        'scaleY':{
            get() {
                return scaleY;
            },
            set(value) {
                scaleY = value;
            }
        }
    });

    scope.update = function() {
        update();
    };
    scope.fromData = function(materialData) {
        scope.diffuse = materialData.diffuseData ? new Uint8Array(materialData.diffuseData) : null;
        scope.normal = materialData.normalData ? new Uint8Array(materialData.normalData) : null;
        scope.specular = materialData.specularData ? new Uint8Array(materialData.specularData) : null;
        scope.realSize = materialData.scalability;
        scope.transparent = materialData.transparent;
        scope.originalWidth = materialData.defaultWidth;
        scope.originalHeight = materialData.defaultHeight;
        scope.currentWidth = materialData.currentWidth;
        scope.currentHeight = materialData.currentHeight;
        scope.scaleX = materialData.scaleX;
        scope.scaleY = materialData.scaleY;

        if ( materialData.version == 2 ) {
            scope.materialType = materialData.materialType;
            scope.materialReflectivity = materialData.materialReflectivity;
        } else {
            if ( materialData.metal ) {
                scope.materialType = R2D.EnvironmentBase.METAL;
                scope.materialReflectivity = materialData.intensityMetal;
            } else if ( materialData.gloss ) {
                scope.materialType = R2D.EnvironmentBase.GLOSS;
                scope.materialReflectivity = materialData.intensityGloss;
            }
        }
    };
    scope.clear = function() {
        scope.diffuse = null;
        scope.specular = null;
        scope.normal = null;
        scope.originalWidth = 1;
        scope.originalHeight = 1;
        scope.currentWidth = 1;
        scope.currentHeight = 1;
        scope.scaleX = 1;
        scope.scaleY = 1;
    };
};

R2D.extend(R2D.MaterialCreator.MaterialSetting, EventDispatcher);

R2D.MaterialCreator.MaterialSetting.TextureData = function(pixelsPerMeter, widthCM, heightCM) {
    EventDispatcher.call(this);

    var scope = this;
    var isProcess = false;
    var isReady = false;
    var originalFile = null;
    var originalFileBytes = null;
    var originalImage = null;
    var currentFile = null;
    var currentFileBytes = null;
    var currentImage = null;
    var scaleX = 1;
    var scaleY = 1;
    var originalWidth = 0;
    var originalHeight = 0;
    var currentWidth = 0;
    var currentHeight = 0;

    if ( !pixelsPerMeter ) throw "Error! Set pixels per meter!";

    function fileReaderCurrentBytesEventHandler(event) {
        var fileReader = event.currentTarget;

        fileReader.removeEventListener('load', fileReaderCurrentBytesEventHandler);
        fileReader.removeEventListener('error', fileReaderCurrentBytesEventHandler);

        currentFileBytes = new Uint8Array(fileReader.result);
        isProcess = false;
        isReady = true;

        scope.dispatchComplete(scope);
    }
    function loadCurrentBytes() {
        var fileReader = new FileReader();

        fileReader.addEventListener('load', fileReaderCurrentBytesEventHandler);
        fileReader.addEventListener('error', fileReaderCurrentBytesEventHandler);
        fileReader.readAsArrayBuffer(currentFile);
    }
    function currentImageEventHandler(event) {
        currentImage.removeEventListener('load', currentImageEventHandler);
        currentImage.removeEventListener('error', currentImageEventHandler);

        loadCurrentBytes();
    }
    function makeImageTexture() {
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');

        canvas.width = currentWidth;
        canvas.height = currentHeight;

        context.drawImage(originalImage, 0, 0, currentWidth, currentHeight);

        canvas.toBlob(function(blob) {
            currentFile = blob;
            currentImage = document.createElement('img');

            currentImage.addEventListener('load', currentImageEventHandler);
            currentImage.addEventListener('error', currentImageEventHandler);
            currentImage.setAttribute('src', canvas.toDataURL('image/png'));
        }, 'image/png');
    }
    function makeTextureData() {
        var baseEdge, nearPower, nearEdge;

        originalWidth = originalImage.width;
        originalHeight = originalImage.height;

        if (widthCM && heightCM)
        {
            scaleX = 100 / widthCM;
            scaleY = 100 / heightCM;

            baseEdge = Math.max(512 / 100 * widthCM, 512 / 100 * heightCM);
        }
        else
        {
            scaleX = pixelsPerMeter / originalWidth;
            scaleY = pixelsPerMeter / originalHeight;

            baseEdge = Math.max(originalWidth, originalHeight);
        }

        nearPower = Math.round(Math.log(baseEdge) / Math.log(2));
        nearEdge = Math.min(Math.pow(2, nearPower), 2048);

        currentWidth = nearEdge;
        currentHeight = nearEdge;
    }
    function fileReaderOriginalBytesEventHandler(event) {
        var fileReader = event.currentTarget;

        fileReader.removeEventListener('load', fileReaderOriginalBytesEventHandler);
        fileReader.removeEventListener('error', fileReaderOriginalBytesEventHandler);

        originalFileBytes = new Uint8Array(fileReader.result);

        makeTextureData();
        makeImageTexture();
    }
    function loadOriginalBytes() {
        var fileReader = new FileReader();

        fileReader.addEventListener('load', fileReaderOriginalBytesEventHandler);
        fileReader.addEventListener('error', fileReaderOriginalBytesEventHandler);
        fileReader.readAsArrayBuffer(originalFile);
    }
    function originalImageEventHandler(event) {
        originalImage.removeEventListener('load', originalImageEventHandler);
        originalImage.removeEventListener('error', originalImageEventHandler);

        loadOriginalBytes();
    }
    function fileReaderOriginalDataURLEventHandler(event) {
        var fileReader = event.currentTarget;

        fileReader.removeEventListener('load', fileReaderOriginalDataURLEventHandler);
        fileReader.removeEventListener('error', fileReaderOriginalDataURLEventHandler);

        originalImage = document.createElement('img');

        originalImage.addEventListener('load', originalImageEventHandler);
        originalImage.addEventListener('error', originalImageEventHandler);
        originalImage.setAttribute('src', fileReader.result);
    }
    function loadFile() {
        var fileReader = new FileReader();

        fileReader.addEventListener('load', fileReaderOriginalDataURLEventHandler);
        fileReader.addEventListener('error', fileReaderOriginalDataURLEventHandler);
        fileReader.readAsDataURL(originalFile);
    }

    Object.defineProperties(scope, {
        'isProcess':{
            get() {
                return isProcess;
            }
        },
        'isReady':{
            get() {
                return isReady;
            }
        },
        'originalFile':{
            get() {
                return originalFile;
            }
        },
        'currentFile':{
            get() {
                return currentFile;
            }
        },
        'originalImage':{
            get() {
                return originalImage;
            }
        },
        'currentImage':{
            get() {
                return currentImage;
            }
        },
        'originalBytes':{
            get() {
                return originalFileBytes;
            }
        },
        'currentBytes':{
            get() {
                return currentFileBytes;
            }
        },
        'originalWidth':{
            get() {
                return originalWidth;
            }
        },
        'originalHeight':{
            get() {
                return originalHeight;
            }
        },
        'currentWidth':{
            get() {
                return currentWidth;
            }
        },
        'currentHeight':{
            get() {
                return currentHeight;
            }
        },
        'scaleX':{
            get() {
                return scaleX;
            }
        },
        'scaleY':{
            get() {
                return scaleY;
            }
        }
    });

    scope.setData = function(textureData, widthOriginal, heightOriginal, widthCurrent, heightCurrent, xScale, yScale) {
        if ( isProcess ) throw "Error!";
        if ( isReady ) throw "Error!";

        currentFileBytes = textureData;
        scaleX = xScale;
        scaleY = yScale;
        originalWidth = widthOriginal;
        originalHeight = heightOriginal;
        currentWidth = widthCurrent;
        currentHeight = heightCurrent;
    };
    scope.loadFile = function(file) {
        if ( isProcess ) throw "Error!";

        isProcess = true;
        isReady = false;
        originalFile = file;

        loadFile();
    };
    scope.clear = function() {
        scope.removeAllListeners();
        //TODO
    };
};

R2D.extend(R2D.MaterialCreator.MaterialSetting.TextureData, EventDispatcher);
// viewers

R2D.MaterialCreator.MaterialTexturesManager = function(materialSetting, pixelsPerMeter) {
    EventDispatcher.call(this);

    var scope = this;
    var diffuseFile, normalFile, specularFile;
    var diffuseData, normalData, specularData;
    var widthCM = null;
    var heightCM = null;

    scope.setSizeCM = function(width, height)
    {
        widthCM = width;
        heightCM = height;
    };

    Object.defineProperties(scope, {
        "diffuseFile":{
            get() { return diffuseFile; },
            set(file) {
                scope.clear();

                diffuseFile = file;

                if ( diffuseFile ) {
                    diffuseData = new R2D.MaterialCreator.MaterialSetting.TextureData(pixelsPerMeter, widthCM, heightCM);

                    diffuseData.onComplete((event) => {
                        materialSetting.diffuse = diffuseData.currentBytes;
                        materialSetting.specular = null;
                        materialSetting.normal = null;
                        materialSetting.originalWidth = diffuseData.originalWidth;
                        materialSetting.originalHeight = diffuseData.originalHeight;
                        materialSetting.currentWidth = diffuseData.currentWidth;
                        materialSetting.currentHeight = diffuseData.currentHeight;
                        materialSetting.scaleX = diffuseData.scaleX;
                        materialSetting.scaleY = diffuseData.scaleY;

                        materialSetting.update();
                        scope.dispatchUpdate(scope);
                    });
                    diffuseData.loadFile(diffuseFile);
                } else {
                    materialSetting.clear();
                    materialSetting.update();
                    scope.dispatchUpdate(scope);
                }
            }
        },
        "diffuseData":{
            get() { return diffuseData; }
        },
        "normalFile":{
            get() { return normalFile; },
            set(file) {
                if ( !diffuseData ) {
                    scope.dispatchEvent(new Event(R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE, scope));
                    return;
                }
                if ( normalData ) normalData.clear();

                normalFile = file;

                if ( normalFile ) {
                    normalData = new R2D.MaterialCreator.MaterialSetting.TextureData(pixelsPerMeter, widthCM, heightCM);

                    normalData.onComplete((event) => {
                        if ( normalData.originalWidth != diffuseData.originalWidth || normalData.originalHeight != diffuseData.originalHeight ) {
                            scope.dispatchEvent(new Event(R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES, scope));
                            return;
                        }

                        materialSetting.normal = normalData.currentBytes;

                        materialSetting.update();
                        scope.dispatchUpdate(scope);
                    });
                    normalData.loadFile(normalFile);
                } else {
                    materialSetting.normal = null;

                    materialSetting.update();
                    scope.dispatchUpdate(scope);
                }
            }
        },
        "normalData":{
            get() { return normalData; }
        },
        "specularFile":{
            get() { return specularFile; },
            set(file) {
                if ( !diffuseData ) {
                    scope.dispatchEvent(new Event(R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE, scope));
                    return;
                }
                if ( specularData ) specularData.clear();

                specularFile = file;

                if ( specularFile ) {
                    specularData = new R2D.MaterialCreator.MaterialSetting.TextureData(pixelsPerMeter, widthCM, heightCM);

                    specularData.onComplete((event) => {
                        if ( specularData.originalWidth != diffuseData.originalWidth || specularData.originalHeight != diffuseData.originalHeight ) {
                            scope.dispatchEvent(new Event(R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES, scope));
                            return;
                        }

                        materialSetting.specular = specularData.currentBytes;

                        materialSetting.update();
                        scope.dispatchUpdate(scope);
                    });
                    specularData.loadFile(specularFile);
                } else {
                    materialSetting.specular = null;

                    materialSetting.update();
                    scope.dispatchUpdate(scope);
                }
            }
        },
        "specularData":{
            get() { return specularData; }
        }
    });

    scope.fromMaterialData = function(mData) {
        if ( diffuseData ) diffuseData.clear();
        if ( specularData ) specularData.clear();
        if ( normalData ) normalData.clear();

        diffuseData = null;
        specularData = null;
        normalData = null;

        if ( !mData.diffuseData ) {
            throw "Material data has no diffuse data!";
        }

        function setup() {
            diffuseData = new R2D.MaterialCreator.MaterialSetting.TextureData(pixelsPerMeter, widthCM, heightCM);
            diffuseData.setData(
                diffuseFile,
                mData.defaultWidth,
                mData.defaultHeight,
                mData.currentWidth,
                mData.currentHeight,
                mData.scaleX,
                mData.scaleY
            );

            materialSetting.fromData(mData);
            materialSetting.update();

            scope.dispatchEvent(new Event(R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED));
        }
        function makeOriginalImage(file, width, height, callback) {
            FILE.loadFileAsDataURL(file, function(data) {
                IMAGE.loadImage(data, function(image) {
                    IMAGE.fillImageInSizes(image, width, height, function(image, blob, base64) {
                        callback(blob);
                    });
                });
            });
        }
        function makeOriginalNormal() {
            if ( mData.normalData ) {
                makeOriginalImage(
                    FILE.readArrayAsFile(mData.normalData),
                    mData.defaultWidth,
                    mData.defaultHeight,
                    function (file) {
                        normalFile = file;

                        setup();
                    }
                )
            } else {
                setup();
            }
        }
        function makeOriginalSpecular() {
            if ( mData.specularData ) {
                makeOriginalImage(
                    FILE.readArrayAsFile(mData.specularData),
                    mData.defaultWidth,
                    mData.defaultHeight,
                    function (file) {
                        specularFile = file;

                        makeOriginalNormal();
                    }
                )
            } else {
                makeOriginalNormal();
            }
        }
        function makeOriginalDiffuse() {
            if ( mData.diffuseData ) {
                makeOriginalImage(
                    FILE.readArrayAsFile(mData.diffuseData),
                    mData.defaultWidth,
                    mData.defaultHeight,
                    function (file) {
                        diffuseFile = file;

                        makeOriginalSpecular();
                    }
                )
            } else {
                makeOriginalSpecular();
            }
        }

        makeOriginalDiffuse();
    };
    scope.clear = function() {
        if ( diffuseData ) diffuseData.clear();
        if ( normalData ) normalData.clear();
        if ( specularData ) specularData.clear();

        diffuseFile = null;
        normalFile = null;
        specularFile = null;
        diffuseData = null;
        normalData = null;
        specularData = null;
    };
};

extend(R2D.MaterialCreator.MaterialTexturesManager, EventDispatcher);

R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED = "rextureDataUpdated";
R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE = "errorMissingDiffuse";
R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES = "errorDifferentSizes";
//creator

R2D.MaterialCreator.MaterialScene = function(materialMaker) {
    R2D.DomElement.call(this);

    var scope = this;
    var superSetWidth = scope.setWidth;
    var superSetHeight = scope.setHeight;
    var superSetSize = scope.setSize;
    var body = scope.getDomElement();
    var camera3d = new THREE.PerspectiveCamera(55, 1, 0.1, 5000);
    var scene3d = new R2D.Scene3D();
    var renderer3d = new R2D.Renderer3D(scene3d);
    var perspectiveRenderer = new R2D.Renderer3DPerspective(renderer3d, camera3d);
    var canvas = renderer3d.domElement;
    var rendererMouseController = new R2D.Renderer3DMouseController(canvas, perspectiveRenderer);

    var materialTile = new THREE.MeshPhongMaterial();
    var material = new THREE.MeshPhongMaterial();

    var geometryTile = R2D.MaterialCreator.MaterialScene._makePlane(512, 512);
    var geometryBox = new THREE.BoxGeometry(512, 512, 512);
    var geometrySphere = new THREE.SphereGeometry(256, 100, 100);
    var geometryTorusKnot = new THREE.TorusKnotGeometry(256, 64, 100, 50);
    var currentGeometry = geometryTile;

    var mesh = new THREE.Mesh(currentGeometry, material);

    var tileScaleX = 1;
    var tileScaleY = 1;

    function resize() {
        perspectiveRenderer.setSize(scope.getWidth(), scope.getHeight());
        perspectiveRenderer.update();
    }
    function cloneMaterial(material) {
        var newMaterial = material.clone();

        function cloneMap(map) {
            var newMap = map.clone(map);

            newMap.repeat.set(1, 1);

            newMap.needsUpdate = true;

            return newMap;
        }

        if ( newMaterial.map ) newMaterial.map = cloneMap(newMaterial.map);
        if ( newMaterial.normalMap ) newMaterial.normalMap = cloneMap(newMaterial.normalMap);
        if ( newMaterial.specularMap ) newMaterial.specularMap = cloneMap(newMaterial.specularMap);

        return newMaterial;
    }
    function materialMakerUpdateHandler(event) {
        var sx = Math.max(materialMaker.materialSettings.originalWidth, 1) / 512;
        var sy = Math.max(materialMaker.materialSettings.originalHeight, 1) / 512;
        // var uvAttribute = geometryTile.getAttribute('uv');
        // var uvArray = uvAttribute.array;

        geometryTile.scale(1 / tileScaleX * sx, 1 / tileScaleY * sy, 1);

        tileScaleX = sx;
        tileScaleY = sy;

        material = materialMaker.material;
        materialTile = cloneMaterial(material);

        if ( currentGeometry == geometryTile ) {
            mesh.material = materialTile;
        } else {
            mesh.material = material;
        }

        perspectiveRenderer.update();
    }

    Object.defineProperties(scope, {
        'geometry':{
            get() {
                switch ( currentGeometry ) {
                    case geometrySphere:
                        return 'sphere';

                    case geometryTorusKnot:
                        return 'torusKnot';

                    case geometryBox:
                        return 'box';

                    case geometryTile:
                    default:
                        return 'tile';
                }
            },
            set(value) {
                switch ( value ) {
                    case 'sphere':
                        currentGeometry = geometrySphere;
                        break;

                    case 'torusKnot':
                        currentGeometry = geometryTorusKnot;
                        break;

                    case 'box':
                        currentGeometry = geometryBox;
                        break;

                    case 'tile':
                    default:
                        currentGeometry = geometryTile;
                }

                if ( currentGeometry == geometryTile ) {
                    mesh.material = materialTile;
                } else {
                    mesh.material = material;
                }

                mesh.geometry = currentGeometry;
                mesh.needsUpdate = true;

                perspectiveRenderer.update();
            }
        }
    });

    scope.setWidth = function(value) {
        superSetWidth(value);
        resize();
    };
    scope.setHeight = function(value) {
        superSetHeight(value);
        resize();
    };
    scope.setSize = function(width, height) {
        superSetSize(width, height);
        resize();
    };

    scene3d.add(mesh);

    canvas.setAttribute("class", "material-scene-canvas");
    body.setAttribute('class', 'material-scene-body');
    body.appendChild(canvas);

    perspectiveRenderer.setupRendererData();
    perspectiveRenderer.enable();

    materialMaker.onUpdate(materialMakerUpdateHandler);
};

R2D.extend(R2D.MaterialCreator.MaterialScene, R2D.DomElement);

R2D.MaterialCreator.MaterialScene._makePlane = function(width, height) {
    var vertices = [
        -width / 2,  height / 2, 0,
         width / 2,  height / 2, 0,
         width / 2, -height / 2, 0,
        -width / 2, -height / 2, 0
    ];
    var normals = [
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1
    ];
    var uvs = [
        0, 0,
        1, 0,
        1, 1,
        0, 1
    ];
    var indices = [
        0, 3, 1,
        1, 3, 2
    ];
    var geometry = new THREE.BufferGeometry();

    geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));

    // geometry.computeFaceNormals();
    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();

    return geometry;
};
// creator

R2D.CarpetCreator = function() {
    EventDispatcher.call(this);

    var scope = this;
    var pixelsPerMeter = 256;
    var camera3d = new THREE.PerspectiveCamera(55, 1, 0.1, 2000);
    var scene3d = new R2D.Scene3D();
    var renderer3d = new R2D.Renderer3D(scene3d);
    var perspectiveRenderer = new R2D.Renderer3DPerspective(renderer3d, camera3d);
    var rendererMouseController = new R2D.Renderer3DMouseController(renderer3d.domElement, perspectiveRenderer);
    var materialSetting = new R2D.MaterialCreator.MaterialSetting();
    var materialTexturesManager = new R2D.MaterialCreator.MaterialTexturesManager(materialSetting, pixelsPerMeter);
    var materialMaker = new R2D.MaterialCreator.MaterialMaker(materialSetting);
    var body = HGen.fromModel({
        "type":"container",
        "attributes":{
            "class":"carpet-creator-body"
        }
    });

    var canvas = renderer3d.canvas;

    var materialCarpet = new THREE.MeshPhongMaterial({ color:0x444444 });

    // var squareGeometries = R2D.ObjectViewer3DCarpet.getSquareGeometry();
    var squareGeometryFace = R2D.ObjectViewer3DCarpet.__geometryFaceSquare(250, 1, 250);
    var squareGeometryBox = R2D.ObjectViewer3DCarpet.__geometryBoxSquare(250, 1, 250);

    var roundGeometries = R2D.ObjectViewer3DCarpet.getRoundGeometry();

    // var meshSquareFace = new THREE.Mesh(squareGeometries[0], materialCarpet);
    // var meshSquareBox = new THREE.Mesh(squareGeometries[1], materialCarpet);

    var meshSquareFace = new THREE.Mesh(squareGeometryFace, materialCarpet);
    var meshSquareBox = new THREE.Mesh(squareGeometryBox, materialCarpet);

    var meshRoundFace = new THREE.Mesh(roundGeometries[0], materialCarpet);
    var meshRoundBox = new THREE.Mesh(roundGeometries[1], materialCarpet);

    var materialPackageCreator = new R2D.ProductPackageCreator.Material();
    var carpetPackageCreator = new R2D.ProductPackageCreator.Carpet();
    var isCreatingPackage = false;

    var carpetType = 1;
    var carpetWidth = 0;
    var carpetDepth = 0;

    var widthCM = null;
    var heightCM = null;
    scope.setMaterialSizeCM = function(width, height)
    {
        widthCM = width;
        heightCM = height;
        materialTexturesManager.setSizeCM(width, height);
    };

    function updateCarpet() {
        switch ( parseInt(carpetType) ) {
            case 2:
                if ( meshSquareFace.parent ) scene3d.remove(meshSquareFace);
                if ( meshSquareBox.parent ) scene3d.remove(meshSquareBox);

                if ( !meshRoundFace.parent ) scene3d.add(meshRoundFace);
                if ( !meshRoundBox.parent ) scene3d.add(meshRoundBox);
                break;

            case 1:
            default:
                if ( meshRoundFace.parent ) scene3d.remove(meshRoundFace);
                if ( meshRoundBox.parent ) scene3d.remove(meshRoundBox);

                if ( !meshSquareFace.parent ) scene3d.add(meshSquareFace);
                if ( !meshSquareBox.parent ) scene3d.add(meshSquareBox);
        }

        perspectiveRenderer.update();
    }
    function materialMakerUpdate(event) {
        var materialWidth = materialMaker.materialSettings.originalWidth;
        var materialDepth = materialMaker.materialSettings.originalHeight;

        var scaleSquareX, scaleSquareY, scaleSquareZ;
        var scaleRoundX, scaleRoundY, scaleRoundZ;

        carpetWidth = Math.round(materialWidth / 256 * 100);
        carpetDepth = Math.round(materialDepth / 256 * 100);

        scaleSquareX = carpetWidth / R2D.ObjectViewer3DCarpet.__squareWidth;
        scaleSquareY = 1;
        scaleSquareZ = carpetDepth / R2D.ObjectViewer3DCarpet.__squareDepth;

        scaleRoundX = carpetWidth / R2D.ObjectViewer3DCarpet.__roundWidth;
        scaleRoundY = 1;
        scaleRoundZ = carpetDepth / R2D.ObjectViewer3DCarpet.__roundDepth;

        scaleSquareX = Math.max(scaleSquareX, 0.01);
        scaleSquareY = Math.max(scaleSquareY, 0.01);
        scaleSquareZ = Math.max(scaleSquareZ, 0.01);

        scaleRoundX = Math.max(scaleRoundX, 0.01);
        scaleRoundY = Math.max(scaleRoundY, 0.01);
        scaleRoundZ = Math.max(scaleRoundZ, 0.01);

        materialCarpet = materialMaker.material;

        if (materialCarpet.map) {
            materialCarpet.map.repeat.x = 1;
            materialCarpet.map.repeat.y = 1;
        }

        meshSquareFace.material = materialCarpet;
        meshSquareBox.material = materialCarpet;

        meshRoundFace.material = materialCarpet;
        meshRoundBox.material = materialCarpet;

        meshSquareFace.scale.set(scaleSquareX, scaleSquareY, scaleSquareZ);
        meshSquareBox.scale.set(scaleSquareX, scaleSquareY, scaleSquareZ);

        meshRoundFace.scale.set(scaleRoundX, scaleRoundY, scaleRoundZ);
        meshRoundBox.scale.set(scaleRoundX, scaleRoundY, scaleRoundZ);

        perspectiveRenderer.update();
    }

    //material textures manager
    function materialTexturesManagerEventHandler(event) {
        switch ( event.type ) {
            case Event.UPDATE:
                scope.dispatchEvent(new Event(Event.UPDATE, scope));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE:
                scope.dispatchEvent(new Event(Event.ERROR, R2D.MaterialCreator.ErrorNeedsDiffuse));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES:
                scope.dispatchEvent(new Event(Event.ERROR, R2D.MaterialCreator.ErrorTexturesDifferentSizes));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED:
                scope.dispatchEvent(new Event(R2D.CarpetCreator.PACKAGE_UPDATE, scope));
                break;
        }
    }
    //end material textures manager

    function carpetPackageCreateComplete(event) {
        isCreatingPackage = false;

        scope.dispatchEvent(new Event(R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE, {
            "sizes":{
                "width":carpetWidth,
                "height":carpetType == 2 ? R2D.ObjectViewer3DCarpet.__roundHeight : R2D.ObjectViewer3DCarpet.__squareHeight,
                "depth":carpetDepth,
            },
            "package":new Blob([event.data.getBytesRange()], {type:'application/octet-stream'})
        }));
    }
    function materialPackageCreateComplete(event) {
        carpetPackageCreator.create({
            "carpetType":carpetType,
            "material":event.data.getBytesRange()
        });
    }

    Object.defineProperties(scope, {
        "hgenElement":{
            get() { return body; }
        },
        "domElement":{
            get() { return body.domElement; }
        },
        "info":{
            get() {
                return {
                    originalWidth:materialSetting.originalWidth,
                    originalHeight:materialSetting.originalHeight,
                    currentWidth:materialSetting.currentWidth,
                    currentHeight:materialSetting.currentHeight,
                    scaleX:materialSetting.scaleX,
                    scaleY:materialSetting.scaleY,
                    pixelsPerMeter:pixelsPerMeter,
                    cmWidth:materialSetting.originalWidth / pixelsPerMeter * 100,
                    cmHeight:materialSetting.originalHeight / pixelsPerMeter * 100
                }
            }
        },
        "diffuse":{
            get() { return materialTexturesManager.diffuseFile; },
            set(file) { materialTexturesManager.diffuseFile = file; }
        },
        "specular":{
            get() { return materialTexturesManager.specularFile; },
            set(file) { materialTexturesManager.specularFile = file; }
        },
        "normal":{
            get() { return materialTexturesManager.normalFile; },
            set(file) { materialTexturesManager.normalFile = file; }
        },
        "carpetShape":{
            get() { return carpetType },
            set(value) {
                switch ( parseInt(value) ) {
                    case 2:
                        carpetType = 2;
                        break;

                    case 1:
                    default:
                        carpetType = 1;
                }

                updateCarpet();
            }
        },
        "allCarpetShapes":{
            get() {
                return [
                    {
                        name:'Square',
                        id:1
                    },
                    {
                        name:'Round',
                        id:2
                    }
                ];
            }
        }
    });

    scope.setData = function(data) {
        FILE.loadFileAsArrayBuffer(data.package, function(pack) {
            var result = R2D.ProductPackageParser.parseCarpet(pack);
            var matData = result.materialData;

            carpetType = result.carpetType;
            materialSetting.realSize = false;

            materialTexturesManager.fromMaterialData(matData);

            updateCarpet();
        });
    };
    scope.createData = function() {
        if ( isCreatingPackage ) {
            console.error("Creating in process.");
            scope.dispatchEvent(new Event(R2D.CarpetCreator.ERROR_CREATING_IN_PROCESS));
            return;
        }
        if ( !materialSetting.diffuse && !materialSetting.specular && !materialSetting.normal ) {
            console.error("Empty carpet!");
            scope.dispatchEvent(new Event(R2D.CarpetCreator.ERROR_EMPTY_CARPET));
            return;
        }

        isCreatingPackage = true;

        scope.dispatchEvent(new Event(R2D.MaterialCreator.PACKAGE_CREATE_START, scope));
        materialPackageCreator.create(materialSetting);
    };
    scope.setSize = function(w, h) {
        camera3d.aspect = w / h;

        camera3d.updateProjectionMatrix();
        perspectiveRenderer.setSize(w, h);
    };

    materialSetting.realSize = false;

    body.add(canvas);

    scene3d.add(meshSquareFace);
    scene3d.add(meshSquareBox);

    materialTexturesManager.addEventListener(Event.UPDATE, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED, materialTexturesManagerEventHandler);
    materialMaker.addEventListener(Event.UPDATE, materialMakerUpdate);
    carpetPackageCreator.addEventListener(Event.COMPLETE, carpetPackageCreateComplete);
    materialPackageCreator.addEventListener(Event.COMPLETE, materialPackageCreateComplete);

    perspectiveRenderer.setupRendererData();
    perspectiveRenderer.enable();

    setTimeout(function () {
        scope.dispatchEvent(new Event(Event.READY, scope));
    }, 100);
};

R2D.extend(R2D.CarpetCreator, EventDispatcher);

R2D.CarpetCreator.PACKAGE_UPDATE = 'packageUpdate';
R2D.CarpetCreator.PACKAGE_CREATE_START = 'packageCreateStart';
R2D.CarpetCreator.PACKAGE_CREATE_COMPLETE = 'packageCreateComplete';
R2D.CarpetCreator.ERROR_CREATING_IN_PROCESS = 'errorCreatingInProcess';
R2D.CarpetCreator.ERROR_EMPTY_CARPET = 'errorEmptyCarpet';
// creator

R2D.PosterCreator = function() {
    EventDispatcher.call(this);

    var scope = this;
    var pixelsPerMeter = 512;
    var camera3d = new THREE.PerspectiveCamera(55, 1, 0.1, 2000);
    var scene3d = new R2D.Scene3D();
    var renderer3d = new R2D.Renderer3D(scene3d);
    var perspectiveRenderer = new R2D.Renderer3DPerspective(renderer3d, camera3d);
    var rendererMouseController = new R2D.Renderer3DMouseController(renderer3d.domElement, perspectiveRenderer);
    var materialSetting = new R2D.MaterialCreator.MaterialSetting();
    var materialTexturesManager = new R2D.MaterialCreator.MaterialTexturesManager(materialSetting, pixelsPerMeter);
    var materialMaker = new R2D.MaterialCreator.MaterialMaker(materialSetting);
    var body = HGen.fromModel({
        "type":"container",
        "attributes":{
            "class":"poster-creator-body"
        }
    });

    var canvas = renderer3d.canvas;

    var materialPoster = new THREE.MeshPhongMaterial({ color:0x444444 });

    var geometryFace = R2D.ObjectViewer3DPoster.__geometryFace(512, 512, 2);
    var geometryBox = R2D.ObjectViewer3DPoster.__geometryBox(512, 512, 2);

    var meshFace = new THREE.Mesh(geometryFace, materialPoster);
    var meshBox = new THREE.Mesh(geometryBox, materialPoster);

    var materialPackageCreator = new R2D.ProductPackageCreator.Material();
    var posterPackageCreator = new R2D.ProductPackageCreator.Poster();
    var isCreatingPackage = false;

    var posterWidth = 0;
    var posterHeight = 0;

    var widthCM = null;
    var heightCM = null;

    scope.setMaterialSizeCM = function(width, height)
    {
        widthCM = width;
        heightCM = height;
        materialTexturesManager.setSizeCM(width, height)
    };

    //material textures manager
    function materialTexturesManagerEventHandler(event) {
        switch ( event.type ) {
            case Event.UPDATE:
                scope.dispatchEvent(new Event(Event.UPDATE, scope));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE:
                scope.dispatchEvent(new Event(Event.ERROR, R2D.MaterialCreator.ErrorNeedsDiffuse));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES:
                scope.dispatchEvent(new Event(Event.ERROR, R2D.MaterialCreator.ErrorTexturesDifferentSizes));
                break;

            case R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED:
                scope.dispatchEvent(new Event(R2D.PosterCreator.PACKAGE_UPDATE, scope));
                break;
        }
    }
    //end material textures manager

    function posterPackageCreateComplete(event) {
        isCreatingPackage = false;

        scope.dispatchEvent(new Event(R2D.MaterialCreator.PACKAGE_CREATE_COMPLETE, {
            "sizes":{
                "width":posterWidth,
                "height":posterHeight,
                "depth":2
            },
            "package":new Blob([event.data.getBytesRange()], {type:'application/octet-stream'})
        }));
    }
    function materialPackageCreateComplete(event) {
        posterPackageCreator.create({
            "material":event.data.getBytesRange()
        });
    }

    function materialMakerUpdate(event) {
        var materialWidth = materialMaker.materialSettings.originalWidth;
        var materialHeight = materialMaker.materialSettings.originalHeight;
        var scaleX, scaleY, scaleZ;

        posterWidth = Math.round(materialWidth / 512 * 100);
        posterHeight = Math.round(materialHeight / 512 * 100);

        scaleX = Math.max(posterWidth / 512, 0.01);
        scaleY = Math.max(posterHeight / 512, 0.01);
        scaleZ = 1;

        materialPoster = materialMaker.material;

        meshFace.material = materialPoster;
        meshBox.material = materialPoster;

        meshFace.scale.set(scaleX, scaleY, scaleZ);
        meshBox.scale.set(scaleX, scaleY, scaleZ);

        perspectiveRenderer.updateCameraAnchor(0, posterWidth / 2, 0);
        perspectiveRenderer.update();
    }

    Object.defineProperties(scope, {
        "hgenElement":{
            get() { return body; }
        },
        "domElement":{
            get() { return body.domElement; }
        },
        "info":{
            get() {
                return {
                    originalWidth:materialSetting.originalWidth,
                    originalHeight:materialSetting.originalHeight,
                    currentWidth:materialSetting.currentWidth,
                    currentHeight:materialSetting.currentHeight,
                    scaleX:materialSetting.scaleX,
                    scaleY:materialSetting.scaleY,
                    pixelsPerMeter:pixelsPerMeter,
                    cmWidth:materialSetting.originalWidth / pixelsPerMeter * 100,
                    cmHeight:materialSetting.originalHeight / pixelsPerMeter * 100
                }
            }
        },
        "diffuse":{
            get() { return materialTexturesManager.diffuseFile; },
            set(file) { materialTexturesManager.diffuseFile = file; }
        },
        "specular":{
            get() { return materialTexturesManager.specularFile; },
            set(file) { materialTexturesManager.specularFile = file; }
        },
        "normal":{
            get() { return materialTexturesManager.normalFile; },
            set(file) { materialTexturesManager.normalFile = file; }
        }
    });

    scope.setData = function(data) {
        FILE.loadFileAsArrayBuffer(data.package, function(pack) {
            var result = R2D.ProductPackageParser.parsePoster(pack);
            var matData = result.materialData;

            materialTexturesManager.fromMaterialData(matData);
        });
    };
    scope.createData = function() {
        if ( isCreatingPackage ) {
            console.error("Creating in process.");
            scope.dispatchEvent(new Event(R2D.PosterCreator.ERROR_CREATING_IN_PROCESS));
            return;
        }
        if ( !materialSetting.diffuse && !materialSetting.specular && !materialSetting.normal ) {
            console.error("Empty poster!");
            scope.dispatchEvent(new Event(R2D.PosterCreator.ERROR_EMPTY_POSTER));
            return;
        }

        isCreatingPackage = true;

        scope.dispatchEvent(new Event(R2D.PosterCreator.PACKAGE_CREATE_START, scope));
        materialPackageCreator.create(materialSetting);
    };
    scope.setSize = function(w, h) {
        camera3d.aspect = w / h;

        camera3d.updateProjectionMatrix();
        perspectiveRenderer.setSize(w, h);
    };

    materialSetting.realSize = false;

    body.add(canvas);

    scene3d.add(meshFace);
    scene3d.add(meshBox);

    materialTexturesManager.addEventListener(Event.UPDATE, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.ERROR_MISSING_DIFFUSE, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.ERROR_DIFFERENT_SIZES, materialTexturesManagerEventHandler);
    materialTexturesManager.addEventListener(R2D.MaterialCreator.MaterialTexturesManager.TEXTURE_DATA_UPDATED, materialTexturesManagerEventHandler);
    materialMaker.addEventListener(Event.UPDATE, materialMakerUpdate);
    posterPackageCreator.addEventListener(Event.COMPLETE, posterPackageCreateComplete);
    materialPackageCreator.addEventListener(Event.COMPLETE, materialPackageCreateComplete);

    perspectiveRenderer.setupRendererData();
    perspectiveRenderer.enable();

    setTimeout(function () {
        scope.dispatchEvent(new Event(Event.READY, scope));
    }, 100);
};

R2D.extend(R2D.PosterCreator, EventDispatcher);

R2D.PosterCreator.PACKAGE_UPDATE = 'packageUpdate';
R2D.PosterCreator.PACKAGE_CREATE_START = 'packageCreateStart';
R2D.PosterCreator.PACKAGE_CREATE_COMPLETE = 'packageCreateComplete';
R2D.PosterCreator.ERROR_CREATING_IN_PROCESS = 'errorCreatingInProcess';
R2D.PosterCreator.ERROR_EMPTY_POSTER = 'errorEmptyPoster';
var WCT = {};

WCT.AXIS_X = 'axisX';
WCT.AXIS_Y = 'axisY';
WCT.AXIS_Z = 'axisZ';

WCT.CANVAS_WIDTH = 300;
WCT.CANVAS_HEIGHT = 300;

WCT.makeContour = function(models, axis)
{
    WCT.renderer = new THREE.CanvasRenderer();
    WCT.renderer.setClearColor(0xffffff);
    WCT.renderer.setSize(WCT.CANVAS_WIDTH, WCT.CANVAS_HEIGHT);

    var scene = new THREE.Scene();
    var modelData = mergeModels(models);
    var mesh = buildMesh(modelData.vertices, modelData.indices);
    scene.add(mesh);

    var maxCoord = findMaxCoord(modelData.vertices);
    var camera = new THREE.OrthographicCamera(-maxCoord, maxCoord, -maxCoord, maxCoord);

    if (axis == WCT.AXIS_X)
    {
        camera.position.set(maxCoord + 100, 0, 0);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }
    else if (axis == WCT.AXIS_Y)
    {
        camera.position.set(0, maxCoord + 100, 0);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }
    else
    {
        camera.position.set(0, 0, maxCoord + 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    WCT.renderer.render(scene, camera);

    var M = WCT.getDataFromCanvas();

    M = WCT.delSmallClusters(M);

    if (! M) return [];

    var contour = contourFromPixels(M, WCT.CANVAS_WIDTH, WCT.CANVAS_HEIGHT, 1);

    contour.push(contour[0]);
    contour = WCT.removePointsOnLine(contour, 0.5);
    contour = WCT.removePointsOnLine(contour, 2);
    contour.pop();

    for (var i = 0; i < contour.length; i++)
    {
        contour[i][0] = (contour[i][0] * 2 / WCT.CANVAS_WIDTH - 1) * maxCoord;
        contour[i][1] = (contour[i][1] * 2 / WCT.CANVAS_HEIGHT - 1) * maxCoord;
    }

    scene.remove(mesh);
    scene = null;
    camera = null;
    WCT.renderer = null;
    mesh = null;

    return contour;

    function mergeModels(models)
    {
        var vLen = 0;
        var iLen = 0;
        for (var i = 0; i < models.length; i++)
        {
            vLen += models[i].vertices.length;
            iLen += models[i].indices.length;
        }

        var vertices = new Float32Array(vLen);
        var indices = new Uint32Array(iLen);
        var vStart = 0;
        var iStart = 0;

        for (i = 0; i < models.length; i++)
        {
            for (var j = 0; j < models[i].vertices.length; j++)
            {
                vertices[vStart + j] = models[i].vertices[j];
            }

            for (j = 0; j < models[i].indices.length; j++)
            {
                indices[iStart + j] = models[i].indices[j] + vStart / 3;
            }

            vStart += models[i].vertices.length;
            iStart += models[i].indices.length;
        }

        return {vertices: vertices, indices: indices}
    }

    function buildMesh(vertices, indices)
    {
        var buffGeom = new THREE.BufferGeometry();
        var bufferIndices = new Uint32Array(indices);
        var bufferVertices = new Float32Array(vertices);

        buffGeom.setIndex(new THREE.BufferAttribute(bufferIndices, 1));
        buffGeom.setAttribute("position", new THREE.BufferAttribute(bufferVertices, 3));

        buffGeom.computeVertexNormals();
        buffGeom.computeBoundingBox();
        buffGeom.computeBoundingSphere();

        return new THREE.Mesh(buffGeom, new THREE.MeshBasicMaterial({color:0x000000}));
    }

    function findMaxCoord(vertices)
    {
        var maxCoord = -Number.MAX_VALUE;

        for (var i = 0; i < vertices.length / 3; i++)
        {
            var vx = Math.abs(vertices[i * 3]);
            var vy = Math.abs(vertices[i * 3 + 1]);
            var vz = Math.abs(vertices[i * 3 + 2]);

            if (vx > maxCoord) maxCoord = vx;
            if (vy > maxCoord) maxCoord = vy;
            if (vz > maxCoord) maxCoord = vz;
        }

        return maxCoord + 10;
    }

    function contourFromPixels(data, width, height, num)
    {
        var M = data;

        var iMin = -1, jMin = -1;
        for (var j = 1; j < width - 1; j++)
        {
            for (var i = 1; i < height - 1; i++)
            {
                if (M[i][j] >= 1)
                {
                    iMin = i;
                    jMin = j;
                    break;
                }
            }
            if (iMin >= 0 && jMin >= 0) break;
        }

        var contour = [];
        var iCur = iMin;
        var jCur = jMin;
        var iPrev = iCur;
        var jPrev = jCur - 1;

        var ctx = WCT.renderer.domElement.getContext('2d');
        ctx.fillStyle="red";

        do {
            contour.push([iCur, jCur]);
            var ijNext = next(M, iPrev, jPrev, iCur, jCur, width, num);

            if (! ijNext) return [];

            iPrev = iCur;
            jPrev = jCur;
            iCur = ijNext[0];
            jCur = ijNext[1];

            ctx.fillRect(iCur, jCur, 1, 1);

        } while ((iCur != iMin) || (jCur != jMin));

        return contour;

        function next(M, iPrev, jPrev, iCur, jCur, w, n)
        {
            var order;
            if (iPrev == iCur && jPrev == jCur - 1) order = [[1, 0], [0, 1], [-1, 0], [0, -1]];
            if (iPrev == iCur + 1 && jPrev == jCur) order = [[0, 1], [-1, 0], [0, -1], [1, 0]];
            if (iPrev == iCur && jPrev == jCur + 1) order = [[-1, 0], [0, -1], [1, 0], [0, 1]];
            if (iPrev == iCur - 1 && jPrev == jCur) order = [[0, -1], [1, 0], [0, 1], [-1, 0]];

            for (var k = 0; k < 4; k++)
            {
                var ip = order[k][0];
                var jp = order[k][1];
                if (M[iCur + ip][jCur + jp] >= 1) return [iCur + ip, jCur + jp];
            }
        }
    }
};

WCT.getDataFromCanvas = function()
{
    var pixelData = WCT.renderer.getContext('2d').getImageData(0, 0, WCT.CANVAS_WIDTH, WCT.CANVAS_HEIGHT).data;

    var M = [];
    for (var i = 0; i < WCT.CANVAS_WIDTH; i++)
    {
        M.push(new Uint32Array(WCT.CANVAS_HEIGHT))
    }

    for (i = 0; i < WCT.CANVAS_WIDTH; i++)
    {
        for (var j = 0; j < WCT.CANVAS_HEIGHT; j++)
        {
            if (getAt(pixelData, i, j, WCT.CANVAS_WIDTH, 4) > 250)
            {
                M[i][j] = 0
            }
            else
            {
                M[i][j] = 1
            }
        }
    }

    for (i = 0; i < WCT.CANVAS_WIDTH; i++)
    {
        M[i][0] = 0;
        M[i][WCT.CANVAS_HEIGHT - 1] = 0;
    }

    for (j = 0; j < WCT.CANVAS_HEIGHT; j++)
    {
        M[0][j] = 0;
        M[WCT.CANVAS_WIDTH - 1][j] = 0;
    }
    
    return M;

    function getAt(M, i, j, w, n)
    {
        return M[(w * j + i) * n]
    }
};

WCT.removePointsOnLine = function(arr, accuracy)
{
    var array = [].concat(arr);
    if (array.length <= 3) return array;

    array.push(array[array.length - 1]);

    var arrRemovePoints = [];

    var pointA;
    var pointB;

    var indexA = 0;
    pointA = array[indexA];

    for (var i = 2; i < array.length; i++)
    {
        pointB = array[i];
        var outOfRange = false;

        for (var j = indexA + 1; j < i; j++)
        {
            var dist = Math.abs(distancePointToLine(array[j], pointA, pointB));
            if (dist > accuracy) {
                outOfRange = true;
            }
        }

        if (outOfRange || i == array.length - 1)
        {
            for (j = indexA + 1; j < i - 1; j++) {
                arrRemovePoints.push(array[j]);
            }
            indexA = i - 1;
            pointA = array[indexA];
        }
    }

    //--
    while (arrRemovePoints.length > 0)
    {
        for (i = 0; i < array.length; i++)
        {
            if (arrRemovePoints[0] == array[i])
            {
                arrRemovePoints.splice(0, 1);
                array.splice(i, 1);
                break;
            }
        }
    }

    array.pop();
    return array;

    function distancePointToLine(point, pointLineA, pointLineB)
    {
        var a = pointLineB[1] - pointLineA[1];
        var b = pointLineA[0] - pointLineB[0];
        var c = pointLineB[0] * pointLineA[1] - pointLineA[0] * pointLineB[1];

        //console.log(((a * point[0]) + (b * point[1]) + c) / Math.pow((Math.pow(a, 2) + Math.pow(b, 2)), .5));

        return ((a * point[0]) + (b * point[1]) + c) / Math.pow((Math.pow(a, 2) + Math.pow(b, 2)), .5);
    }
};

WCT.delSmallClusters = function(pixelData)
{
    //var pixelData = WCT.getDataFromCanvas();

    var M = [];
    for (var i = 0; i < WCT.CANVAS_WIDTH; i++)
    {
        M.push(new Uint32Array(WCT.CANVAS_HEIGHT))
    }

    var n = 2;
    for (var j = 1; j < WCT.CANVAS_HEIGHT - 1; j++)
    {
        for (i = 1; i < WCT.CANVAS_WIDTH - 1; i++)
        {
            if (pixelData[i][j] == 0) continue;

            if (M[i - 1][j] > 0)
            {
                M[i][j] = M[i - 1][j];
            }
            else if (M[i][j - 1] > 0)
            {
                M[i][j] = M[i][j - 1];
            }
            else
            {
                M[i][j] = n;
                n += 1;
            }
        }
    }

    var nearNumbers = [];

    for (j = 1; j < WCT.CANVAS_HEIGHT - 1; j++)
    {
        for (i = 1; i < WCT.CANVAS_WIDTH - 1; i++)
        {
            var v = M[i][j];
            if (v == 0) continue;
            var neighbours = [];
            if (M[i - 1][j] > 0 && M[i - 1][j] != v) neighbours.push(M[i - 1][j]);
            if (M[i][j - 1] > 0 && M[i][j - 1] != v) neighbours.push(M[i][j - 1]);
            if (M[i + 1][j] > 0 && M[i + 1][j] != v) neighbours.push(M[i + 1][j]);
            if (M[i][j + 1] > 0 && M[i][j + 1] != v) neighbours.push(M[i][j + 1]);

            var vns = [];
            for (var k = 0; k < nearNumbers.length; k++)
            {
                if (nearNumbers[k].indexOf(v) >= 0)
                {
                    vns = nearNumbers[k];
                    break;
                }
            }
            if (vns.length == 0)
            {
                vns.push(v);
                nearNumbers.push(vns);
            }

            for (k = 0; k < neighbours.length; k++)
            {
                if (vns.indexOf(neighbours[k]) == -1) vns.push(neighbours[k])
            }
        }
    }

    var newNearNumbers = [];

    while (nearNumbers.length > 0)
    {
        newNearNumbers.push(nearNumbers.shift());

        var L = nearNumbers.length;
        for (i = 0; i < L; i++)
        {
            if (arraysIntersect(newNearNumbers[newNearNumbers.length - 1], nearNumbers[i]))
            {
                newNearNumbers[newNearNumbers.length - 1] = newNearNumbers[newNearNumbers.length - 1].concat(nearNumbers[i]);
                nearNumbers.splice(i, 1);
                i = -1;
                L--;
            }
        }
    }

    nearNumbers = newNearNumbers;

    var numberDict = {};
    for (i = 0; i < nearNumbers.length; i++)
    {
        for (j = 0; j < nearNumbers[i].length; j++)
        {
            numberDict[nearNumbers[i][j]] = nearNumbers[i][0];
        }
    }

    for (j = 1; j < WCT.CANVAS_HEIGHT - 1; j++)
    {
        for (i = 1; i < WCT.CANVAS_WIDTH - 1; i++)
        {
            M[i][j] = numberDict[M[i][j]];
        }
    }

    var clusterArea = {};

    for (j = 1; j < WCT.CANVAS_HEIGHT - 1; j++)
    {
        for (i = 1; i < WCT.CANVAS_WIDTH - 1; i++)
        {
            v = M[i][j];
            if (v == 0) continue;
            if (v in clusterArea)
            {
                clusterArea[v] += 1;
            }
            else
            {
                clusterArea[v] = 1;
            }
        }
    }

    var maxClusterNum = 0;
    var maxClusterArea = 0;

    for (var key in clusterArea)
    {
        if (clusterArea[key] > maxClusterArea)
        {
            maxClusterNum = key;
            maxClusterArea = clusterArea[key];
        }
    }

    if (maxClusterArea == 0) return null;

    for (j = 0; j < WCT.CANVAS_HEIGHT; j++)
    {
        for (i = 0; i < WCT.CANVAS_WIDTH; i++)
        {
            if (M[i][j] != maxClusterNum)
            {
                M[i][j] = 0;
            }
            else
            {
                M[i][j] = 1;
            }
        }
    }

    return M;

    //draw();

    function arraysIntersect(A, B)
    {
        for (var i = 0; i < A.length; i++)
        {
            if (B.indexOf(A[i]) >= 0) return true;
        }
        return false;
    }

    function draw()
    {
        var values = [];
        for (var j = 1; j < WCT.CANVAS_HEIGHT - 1; j++)
        {
            for (i = 1; i < WCT.CANVAS_WIDTH - 1; i++)
            {
                if (M[i][j] > 0 && values.indexOf(M[i][j]) == -1) values.push(M[i][j])
            }
        }

        colors = {};
        for (i = 0; i < values.length; i++)
        {
            colors[values[i]] = {r: Math.round(Math.random() * 255),
                                 g: Math.round(Math.random() * 255),
                                 b: Math.round(Math.random() * 255)};
        }

        var ctx = WCT.renderer.domElement.getContext('2d');

        for (j = 1; j < WCT.CANVAS_HEIGHT - 1; j++) 
        {
            for (i = 1; i < WCT.CANVAS_WIDTH - 1; i++) 
            {
                if (M[i][j] != 0)
                {
                    var c = colors[M[i][j]];
                    ctx.fillStyle = 'rgba(' + c.r + ', ' + c.g + ', ' + c.b + ', 255)';
                }
                else
                {
                    ctx.fillStyle = 'rgba(255, 255, 255, 255)';
                }

                ctx.fillRect(i, j, 1, 1);
            }
        }

    }
};



//creator

R2D.ModelCreator = function() {
    EventDispatcher.call(this);

    var scope = this;
    var modelSetting = new R2D.ModelCreator.Setting();
    var modelScene = new R2D.ModelCreator.Scene(modelSetting);

    var body = HGen.fromModel({
        "type":"container",
        "tagName":"div",
        "attributes":{
            "class":"creator-model-view-body"
        }
    });
    var isCreatingData = false;

    Object.defineProperties(scope, {
        "domElement":{
            get() { return body.domElement; }
        }
    });

    scope.getInfo = function () {
        return modelSetting.getInfo();
    };
    scope.getElementInfo = function(index) {
        return modelSetting.getElementInfo(index);
    };
    scope.isVisible = function (index) {
        return modelScene.isVisible(index);
    };
    scope.setVisibility = function(index, value) {
        modelScene.setVisibility(index, value);
    };
    scope.isActive = function (index) {
        return modelScene.isActive(index);
    };
    scope.setActive = function(index, value) {
        modelScene.setActive(index, value);
    };
    scope.setMaterial = function (index, materialId) {
        modelSetting.setMaterial(index, materialId);
    };
    scope.removeElement = function (index) {
        modelSetting.removeElement(index);
    };
    scope.setSize = function(width, heigth) {
        modelScene.setSize(width, heigth);

        body.style.width = width + "px";
        body.style.heigth = heigth + "px";
    };
    scope.browseOBJ = function () {
        modelSetting.browseOBJ();
    };
    scope.loadOBJ = function(fileOBJ, index) {
        modelSetting.loadOBJ(fileOBJ, index);
    };
    scope.parseOBJ = function(stringOBJ, index) {
        modelSetting.parseOBJ(stringOBJ, index);
    };
    scope.setData = function(object) {
        FILE.loadFileAsArrayBuffer(object.package, function(arrayBuffer) {
            let raw = R2D.ProductPackageParser.parseModel(arrayBuffer);
            let elements = new Array(raw.geometries.length);

            if ( elements.length != object.materials.length ) {
                throw "Received materials length is not equal to geometries length!";
            }

            for ( let i = 0, l = raw.geometries.length; i < l; i++ ) {
                elements[i] = {
                    materialId:object.materials[i].materialId,
                    addMaterialId:object.materials[i].addMaterialId,
                    geometry:raw.geometries[i]
                };
            }

            modelSetting.setElements(elements);
            scope.dispatchEvent(new Event(R2D.ModelCreator.PACKAGE_UPDATE, scope));
        });
    };
    scope.createData = function() {
        if ( isCreatingData ) {
            console.error("Creating in process.");
            scope.dispatchEvent(new Event(R2D.ModelCreator.ERROR_CREATING_IN_PROCESS));
            return;
        }
        if ( modelSetting.elements.length == 0 ) {
            console.error("Empty model!");
            scope.dispatchEvent(new Event(R2D.ModelCreator.ERROR_EMPTY_MODEL));
            return;
        }

        let preview = null;
        let modelData = null;

        isCreatingData = true;

        modelScene.makePreview(blob => {
            preview = blob;

            function makeGeometriesData() {
                let geometries = [];
                let elements = modelSetting.elements;

                for ( let i = 0, l = elements.length; i < l; i++ ) {
                    geometries.push({
                        md5:elements[i].geometry.md5
                    });
                }

                return geometries;
            }
            function makeResultData() {
                var resultData = {
                    contourTop:modelData.contourTop,
                    contourCut:modelData.contourCut,
                    sizes:modelData.sizes,
                    package:new Blob([modelData.package], {type:'application/octet-stream'}),
                    geometries:makeGeometriesData(),
                    preview:preview
                };

                isCreatingData = false;

                scope.dispatchEvent(new Event(R2D.ModelCreator.PACKAGE_CREATE_COMPLETE, resultData));
            }
            function createComplete(event) {
                modelData = event.data;

                modelSetting.removeEventListener(Event.COMPLETE, createComplete);

                makeResultData();
            }

            scope.dispatchEvent(new Event(R2D.ModelCreator.PACKAGE_CREATE_START, scope));

            modelSetting.addEventListener(Event.COMPLETE, createComplete);
            modelSetting.prepare();
            modelSetting.createData();
        });
    };

    body.add(modelScene.canvas);

    modelSetting.addEventListener(R2D.ModelCreator.Setting.OBJ_LOADED, function (event) {
        scope.dispatchEvent(new Event(R2D.ModelCreator.OBJ_LOADED));
    });
    modelSetting.addEventListener(R2D.ModelCreator.Setting.OBJ_PARSED, function (event) {
        scope.dispatchEvent(new Event(R2D.ModelCreator.OBJ_PARSED));
    });
    modelSetting.addEventListener(R2D.ModelCreator.Setting.UPDATE_ELEMENT, function(event) {
        scope.dispatchEvent(new Event(R2D.ModelCreator.GEOMETRY_UPDATE));
    });
    modelSetting.addEventListener(R2D.ModelCreator.Setting.UPDATE, function(event) {
        scope.dispatchEvent(new Event(R2D.ModelCreator.GEOMETRY_UPDATE));
    });
    modelSetting.addEventListener(R2D.ModelCreator.Setting.ELEMENT_EXIST, function(event) {
        scope.dispatchEvent(new Event(R2D.ModelCreator.GEOMETRY_EXIST, event.data));
    });

    setTimeout(function() {
        scope.dispatchEvent(new Event(Event.READY, scope));
    }, 1000);
};

R2D.extend(R2D.ModelCreator, EventDispatcher);

R2D.ModelCreator.PACKAGE_UPDATE = 'packageUpdate';
R2D.ModelCreator.PACKAGE_CREATE_START = 'packageCreateStart';
R2D.ModelCreator.PACKAGE_CREATE_COMPLETE = 'packageCreateComplete';
R2D.ModelCreator.OBJ_LOADED = 'objLoaded';
R2D.ModelCreator.OBJ_PARSED = 'objParsed';
R2D.ModelCreator.GEOMETRY_UPDATE = 'geometryUpdate';
R2D.ModelCreator.GEOMETRY_EXIST = 'geometryExist';
R2D.ModelCreator.ERROR_CREATING_IN_PROCESS = 'errorCreatingInProcess';
R2D.ModelCreator.ERROR_EMPTY_MODEL = 'errorEmptyModel';
// creator

R2D.ModelCreator.Setting = function() {
    EventDispatcher.call(this);

    var scope = this;
    var elements = [];
    var isCreatingData = false;
    var packageCreator = new R2D.ProductPackageCreator.Model();
    var packageData = null;
    var contourTop = null;
    var contourCut = null;

    function makeData() {
        var bounds = scope.bounds;
        var geometries = [];

        elements.forEach(function(element) {
            geometries.push({
                name:element.name,
                materialId:element.materialId,
                addMaterialId:element.addMaterialId,
                materialInput:element.materialInput
            });
        });

        isCreatingData = false;

        scope.dispatchComplete({
            geometries:geometries,
            contourTop:contourTop,
            contourCut:contourCut,
            sizes:{
                width:bounds.width,
                height:bounds.height,
                depth:bounds.depth
            },
            package:packageData
        });
    }
    function makeContours() {
        var geometries = [];

        function makeNumber(number) {
            return parseFloat(number.toFixed(2));
        }
        function makeString(contour) {
            if ( contour.length == 0 ) return;

            var last = contour.length - 1;
            var string = "";

            for ( var i = 0; i < last; i++ ) {
                string += makeNumber(contour[i][0]) + "," + makeNumber(-contour[i][1]) + ",";
            }

            return string + makeNumber(contour[last][0]) + "," + makeNumber(-contour[last][1]);
        }

        elements.forEach(function(element) {
            geometries.push({
                indices:element.geometry.indices,
                vertices:element.geometry.vertices
            });
        });

        contourTop = makeString(WCT.makeContour(geometries, WCT.AXIS_Y));
        contourCut = makeString(WCT.makeContour(geometries, WCT.AXIS_Z));
    }

    //package creator
    function packageCreatorCompleteEventHandler(event) {
        packageData = event.data.getBytesRange();

        makeContours();
        makeData();
    }
    //end package creator


    Object.defineProperties(scope, {
        "elements":{
            get() { return elements; }
        },
        "bounds":{
            get() {
                var minX = Infinity, maxX = -Infinity;
                var minY = Infinity, maxY = -Infinity;
                var minZ = Infinity, maxZ = -Infinity;
                var width, height, depth;
                var centerX, centerY, centerZ;
                var radius;

                if ( elements.length > 0 ) {
                    elements.forEach(function(element) {
                        if ( element.geometry.bounds.minX < minX ) minX = element.geometry.bounds.minX;
                        if ( element.geometry.bounds.maxX > maxX ) maxX = element.geometry.bounds.maxX;
                        if ( element.geometry.bounds.minY < minY ) minY = element.geometry.bounds.minY;
                        if ( element.geometry.bounds.maxY > maxY ) maxY = element.geometry.bounds.maxY;
                        if ( element.geometry.bounds.minZ < minZ ) minZ = element.geometry.bounds.minZ;
                        if ( element.geometry.bounds.maxZ > maxZ ) maxZ = element.geometry.bounds.maxZ;
                    });
                } else {
                    minX = 0;
                    maxX = 0;
                    minY = 0;
                    maxY = 0;
                    minZ = 0;
                    maxZ = 0;
                }

                width = maxX - minX;
                height = maxY - minY;
                depth = maxZ - minZ;
                centerX = width / 2 + minX;
                centerY = height / 2 + minY;
                centerZ = depth / 2 + minZ;
                radius = Math.sqrt((width / 2) * (width / 2) + (height / 2) * (height / 2) + (depth / 2) * (depth / 2));

                return {
                    minX:minX, maxX:maxX,
                    minY:minY, maxY:maxY,
                    minZ:minZ, maxZ:maxZ,
                    width:width,
                    height:height,
                    depth:depth,
                    centerX:centerX,
                    centerY:centerY,
                    centerZ:centerZ,
                    radius:radius
                }
            }
        },
        "info":{
            get() {
                var indices = 0;
                var vertices = 0;
                var triangles = 0;

                elements.forEach(function(element) {
                    indices += element.geometry.indices.length;
                    vertices += element.geometry.vertices.length;
                    triangles += element.geometry.totalTriangles;
                });

                return {
                    totalGeometries:elements.length,
                    indices:indices,
                    vertices:vertices,
                    triangles:triangles,
                    bounds:scope.bounds
                }
            }
        }
    });

    scope.getInfo = function () {
        return scope.info;
    };
    scope.getElementInfo = function (index) {
        if ( index === undefined ) throw "Needs index!";
        if ( !Number.isInteger(index) ) throw "Value is not integer!";
        if ( index < 0 || index >= elements.length ) throw "Out of range!";

        var element = elements[index];

        return {
            indices:element.geometry.indices.length,
            vertices:element.geometry.vertices.length,
            triangles:element.geometry.totalTriangles,
            bounds:Object.assign({}, element.geometry.bounds),
            md5:element.geometry.md5
        }
    };
    scope.update = function() {
        scope.dispatchUpdate(scope);
    };
    scope.removeElement = function(index) {
        if ( index === undefined ) throw "Needs index!";
        if ( !Number.isInteger(index) ) throw "Value is not integer!";
        if ( index < 0 || index >= elements.length ) throw "Out of range!";

        elements.splice(index, 1);
        scope.dispatchUpdate(scope);
    };
    scope.parseOBJ = function(string, index) {
        if ( index !== undefined ) {
            if ( !Number.isInteger(index) ) {
                throw "Received index of element but value is not integer!";
            }
            if ( index < 0 || index >= elements.length ) {
                throw "Received index of element but index out of range!";
            }
        }

        let parser = new R2D.OBJParser();

        function onComplete(event) {
            parser.removeOnComplete(onComplete);
            parser.removeOnError(onError);

            for ( let i = 0, l = elements.length; i < l; i++ ) {
                if ( elements[i]["geometry"]["md5"] == parser.geometry.md5 ) {
                    console.error("The element have been added!");
                    scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.ELEMENT_EXIST, "The element have been added!"));
                    return;
                }
            }

            if ( index !== undefined ) {
                elements[index].geometry = parser.geometry;

                scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.UPDATE_ELEMENT, index));
            } else {
                elements.push({
                    materialId:0,
                    addMaterialId:"",
                    geometry:parser.geometry
                });

                scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.OBJ_PARSED, scope));
                scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.UPDATE));
            }
        }
        function onError(event) {
            parser.removeOnComplete(onComplete);
            parser.removeOnError(onError);

            scope.dispatchError(scope);
        }

        parser.onComplete(onComplete);
        parser.onError(onError);
        parser.parse(string);
    };
    scope.loadOBJ = function(file, index) {
        if ( index !== undefined ) {
            if ( !Number.isInteger(index) ) {
                throw "Received index of element but value is not integer!";
            }
            if ( index < 0 || index >= elements.length ) {
                throw "Received index of element but index out of range!";
            }
        }

        FILE.loadFileAsBinaryString(file, function(string) {
            scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.OBJ_LOADED, scope));
            scope.parseOBJ(string, index);
        });
    };
    scope.browseOBJ = function() {
        FILE.openFile(function(files) {
            for ( var i = 0, l = files.length; i < l; i++ ) {
                scope.loadOBJ(files[i]);
            }
        }, '.obj', true);
    };
    scope.setMaterial = function (index, materialId) {
        if ( index === undefined ) throw "Needs index!";
        if ( !Number.isInteger(index) ) throw "Value is not integer!";
        if ( index < 0 || index >= elements.length ) throw "Out of range!";

        elements[index].materialId = materialId;

        scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.UPDATE_MATERIAL, index));
    };
    scope.setAddMaterial = function (index, addMaterialId) {
        if ( index === undefined ) throw "Needs index!";
        if ( !Number.isInteger(index) ) throw "Value is not integer!";
        if ( index < 0 || index >= elements.length ) throw "Out of range!";

        elements[index].addMaterialId = addMaterialId;

        scope.dispatchEvent(new Event(R2D.ModelCreator.Setting.UPDATE_MATERIAL, index));
    };
    scope.setElements = function(newElements) {
        elements = newElements;

        elements.forEach(function(element) {
            element.geometry.totalTriangles = element.geometry.indices.length / 3;
            element.geometry.bounds = R2D.Tool.getGeometryBounds(element.geometry.vertices);
            element.sizes = {
                width:element.geometry.bounds.maxX - element.geometry.bounds.minX,
                height:element.geometry.bounds.maxY - element.geometry.bounds.minY,
                depth:element.geometry.bounds.maxZ - element.geometry.bounds.minZ
            };
        });

        scope.dispatchUpdate(scope);
    };
    scope.prepare = function() {
        var bounds = scope.bounds;
        var sx = Math.floor(bounds.width) / bounds.width;
        var sy = Math.floor(bounds.height) / bounds.height;
        var sz = Math.floor(bounds.depth) / bounds.depth;
        var tx, ty, tz;

        elements.forEach(function(element) {
            element.geometry.vertices = R2D.Tool.scaleVertices(element.geometry.vertices, sx, sy, sz);
            element.geometry.bounds = R2D.Tool.getGeometryBounds(element.geometry.vertices);
        });

        bounds = scope.bounds;
        tx = -bounds.centerX;
        ty = -bounds.minY;
        tz = -bounds.centerZ;

        elements.forEach(function(element) {
            element.geometry.vertices = R2D.Tool.translateVertices(element.geometry.vertices, tx, ty, tz);
            element.geometry.bounds = R2D.Tool.getGeometryBounds(element.geometry.vertices);
        });

        scope.dispatchUpdate(scope);
    };
    scope.createData = function() {
        if ( isCreatingData ) throw "Error! Creating data!";

        isCreatingData = true;

        packageCreator.addEventListener(Event.COMPLETE, packageCreatorCompleteEventHandler);
        packageCreator.create(elements);
    };
};

R2D.extend(R2D.ModelCreator.Setting, EventDispatcher);

R2D.ModelCreator.Setting.UPDATE = "update";
R2D.ModelCreator.Setting.UPDATE_ELEMENT = "updateElement";
R2D.ModelCreator.Setting.UPDATE_MATERIAL = "updateMaterial";
R2D.ModelCreator.Setting.OBJ_LOADED = "objLoaded";
R2D.ModelCreator.Setting.OBJ_PARSED = "objParsed";
R2D.ModelCreator.Setting.ELEMENT_EXIST = "elementExist";
// creator

R2D.ModelCreator.Scene = function(modelSetting) {
    EventDispatcher.call(this);

    var scope = this;
    var scene3d = new R2D.Scene3D();
    var FOV = 45;
    var camera3d = new THREE.PerspectiveCamera(FOV, 1, 5, 5000);
    var renderer3d = new R2D.Renderer3D(scene3d);
    var renderer3dPerspective = new R2D.Renderer3DPerspective(renderer3d, camera3d);
    var rendererMouseController = new R2D.Renderer3DMouseController(renderer3d.canvas, renderer3dPerspective);
    var elements = [];
    var elementsVisibility = [];
    var elementsActive = [];
    var elementsActiveVisibility = [];
    var materials = [];

    var meshModelBoundsGood = new THREE.Line(R2D.Tool.makeGeometryLinesBox(0, 0, 0, 1, 1, 1), new THREE.LineBasicMaterial({color:0x21af47, transparent:true, opacity:0.7}));
    var meshModelBoundsPoor = new THREE.Line(R2D.Tool.makeGeometryLinesBox(0, 0, 0, 1, 1, 1), new THREE.LineBasicMaterial({color:0xc11313, transparent:true, opacity:0.5}));
    var meshModelBox = new THREE.Mesh(R2D.Tool.makeGeometryBox(0, 0, 0, 1, 1, 1), new THREE.MeshBasicMaterial({color:0x961b1b, transparent:true, opacity:0.1}));

    function materialUpdateEventHandler(event) {
        renderer3dPerspective.update();
    }
    function updateCameraPosition() {
        var bounds = modelSetting.bounds;

        renderer3dPerspective.setCameraDistanceBounds(bounds.radius, bounds.radius * 5);
        renderer3dPerspective.updateCameraAnchor(0, bounds.height / 2, 0);
    }
    function checkBoundsPosition() {
        var limit = 2;
        var info = modelSetting.info;
        var bounds = info.bounds;

        if ( Math.abs(bounds.centerX) > limit || Math.abs(Math.abs(bounds.centerY) - Math.abs(bounds.height / 2)) > limit || Math.abs(bounds.centerZ) > limit ) {
            // meshModelBox.geometry = R2D.Tool.makeGeometryBox(bounds.centerX, bounds.centerY, bounds.centerZ, bounds.width, bounds.height, bounds.depth);
            meshModelBoundsPoor.geometry = R2D.Tool.makeGeometryLinesBox(bounds.centerX, bounds.centerY, bounds.centerZ, bounds.width, bounds.height, bounds.depth);
            meshModelBoundsGood.geometry = R2D.Tool.makeGeometryLinesBox(0, bounds.height / 2, 0, bounds.width, bounds.height, bounds.depth);

            // if ( !meshModelBox.parent ) scene3d.add(meshModelBox, "b");
            if ( !meshModelBoundsPoor.parent ) scene3d.add(meshModelBoundsPoor, R2D.Scene3D.TOP);
            if ( !meshModelBoundsGood.parent ) scene3d.add(meshModelBoundsGood,  R2D.Scene3D.TOP);
        } else {
            // if ( meshModelBox.parent ) scene3d.remove(meshModelBox, "b");
            if ( meshModelBoundsPoor.parent ) scene3d.remove(meshModelBoundsPoor,  R2D.Scene3D.TOP);
            if ( meshModelBoundsGood.parent ) scene3d.remove(meshModelBoundsGood,  R2D.Scene3D.TOP);
        }
    }
    function modelSettingUpdateMaterialEvent(event) {
        let index = event.data;
        let newMaterialId = modelSetting.elements[index].materialId;
        let materialObject = materials[index];
        let currentMaterialId = materialObject ? materialObject.getProductId() : null;

        if ( newMaterialId == currentMaterialId ) return;

        if ( materialObject ) {
            materialObject.removeEventListener(Event.UPDATE, materialUpdateEventHandler);
        }

        materialObject = R2D.PoolMaterials.getMaterial(newMaterialId);

        elements[index].material = materialObject ? materialObject.getMaterial() : R2D.ModelCreator.Scene.__defaultMaterial;
        materials[index] = materialObject;

        if ( materialObject ) {
            materialObject.addEventListener(Event.UPDATE, materialUpdateEventHandler);
        }

        renderer3dPerspective.update();
    }
    function modelSettingUpdateElementEvent(event) {
        let index = event.data;
        let geometryData = modelSetting.elements[index].geometry;
        let geometry = R2D.Tool.makeBufferGeometry(geometryData.indices, geometryData.vertices, geometryData.uvs, geometryData.normals);
        let mesh = elements[index];
        let meshActive = elementsActive[index];

        mesh.geometry = geometry;
        meshActive.geometry = geometry;

        checkBoundsPosition();
        updateCameraPosition();

        renderer3dPerspective.update();
    }
    function modelSettingUpdateEvent(event) {
        elements.forEach(mesh => {
            scene3d.remove(mesh);
        });
        elementsActive.forEach(mesh => {
            scene3d.remove(mesh, R2D.Scene3D.TOP);
        });
        materials.forEach(materialObject => {
            if ( !materialObject ) return;

            materialObject.removeEventListener(Event.UPDATE, materialUpdateEventHandler);
        });

        elements = [];
        elementsVisibility = [];
        elementsActive = [];
        elementsActiveVisibility = [];
        materials = [];

        for ( let i = 0, l = modelSetting.elements.length; i < l; i++ ) {
            let element = modelSetting.elements[i];
            let geometryData = element.geometry;
            let geometry = R2D.Tool.makeBufferGeometry(geometryData.indices, geometryData.vertices, geometryData.uvs, geometryData.normals);
            let material = R2D.PoolMaterials.getMaterial(element.materialId);
            let mesh = new THREE.Mesh(geometry, material ? material.getMaterial() : R2D.ModelCreator.Scene.__defaultMaterial);
            let meshActive = new THREE.Mesh(geometry, R2D.ModelCreator.Scene.__defaultMaterialActive);

            meshActive.visible = false;

            if ( material ) {
                material.addEventListener(Event.UPDATE, materialUpdateEventHandler);
            }

            scene3d.add(mesh);
            scene3d.add(meshActive, R2D.Scene3D.TOP);
            elements.push(mesh);
            elementsVisibility.push(true);
            elementsActive.push(meshActive);
            elementsActiveVisibility.push(false);
            materials.push(material);
        }

        checkBoundsPosition();
        updateCameraPosition();

        renderer3dPerspective.update();
    }

    Object.defineProperties(scope, {
        "canvas":{
            get() { return renderer3d.canvas; }
        },
        "domElement":{
            get() { return renderer3d.canvas.domElement; }
        }
    });

    scope.isActive = function (index) {
        return elementsActiveVisibility[index];
    };
    scope.setActive = function (index, value) {
        if ( elementsActiveVisibility[index] == value ) return;

        elementsActive[index].visible = value;
        elementsActiveVisibility[index] = value;

        renderer3dPerspective.update();
    };
    scope.isVisible = function (index) {
        return elementsVisibility[index];
    };
    scope.setVisibility = function (index, value) {
        if ( elementsVisibility[index] == value ) return;

        elements[index].visible = value;
        elementsVisibility[index] = value;

        renderer3dPerspective.update();
    };
    scope.setSize = function(width, height) {
        camera3d.aspect = width / height;

        camera3d.updateProjectionMatrix();
        renderer3dPerspective.setSize(width, height);
    };
    scope.makePreview = function(callback) {
        var size = 500;
        var oldWidth = renderer3d.width;
        var oldHeight = renderer3d.height;
        var screenshot = null;
        var oldFOV = camera3d.fov;
        var oldFar = camera3d.far;
        var previewFOV = 12;
        var oldMaxDistance = renderer3dPerspective.getCameraDistanceMax();
        var oldDistance = renderer3dPerspective.getCameraDistance();

        var bounds = modelSetting.bounds;
        var radius = bounds.radius;
        var angle = previewFOV / 2 * Math.PI / 180;
        var distance = radius / Math.sin(angle) * Math.cos(angle) + radius;

        camera3d.fov = previewFOV;
        camera3d.far = distance + 1000;

        renderer3dPerspective.setCameraDistanceBounds(renderer3dPerspective.getCameraDistanceMin(), distance + 500);
        renderer3dPerspective.updateCameraViewPosition(0, bounds.centerY, 0, distance, 30 * Math.PI / 180, 15 * Math.PI / 180);

        scope.setSize(size, size);

        renderer3d.getScreenshot(function(blob) {
            function imageResized(blob, url) {
                callback(blob, url);
            }
            function imageCropped(blob, url, w, h) {
                var s = 250 / Math.max(w, h);

                IMAGE.resizeImage(url, s, s, imageResized);
            }
            function screenshotLoaded(data) {
                IMAGE.cropBorders(data, imageCropped);
            }

            camera3d.fov = oldFOV;
            camera3d.far = oldFar;

            renderer3dPerspective.setCameraDistanceBounds(renderer3dPerspective.getCameraDistanceMin(), oldMaxDistance);
            renderer3dPerspective.updateCameraDistance(oldDistance);

            scope.setSize(oldWidth, oldHeight);

            FILE.loadFileAsDataURL(blob, screenshotLoaded);
        });
    };

    renderer3dPerspective.setupRendererData();
    renderer3dPerspective.enable();

    modelSetting.addEventListener(R2D.ModelCreator.Setting.UPDATE, modelSettingUpdateEvent);
    modelSetting.addEventListener(R2D.ModelCreator.Setting.UPDATE_ELEMENT, modelSettingUpdateElementEvent);
    modelSetting.addEventListener(R2D.ModelCreator.Setting.UPDATE_MATERIAL, modelSettingUpdateMaterialEvent);
};

R2D.extend(R2D.ModelCreator.Scene, EventDispatcher);

R2D.ModelCreator.Scene.__defaultMaterial = new THREE.MeshPhongMaterial({color:0x999999});
R2D.ModelCreator.Scene.__defaultMaterialActive = new THREE.MeshPhongMaterial({color:0xff0000, transparent:true, opacity:0.5});
//ssao

function DepthPass()
{
    var me = this;

    /*
    var depthShader = THREE.ShaderLib["depthRGBA"];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    var depthMaterial = new THREE.ShaderMaterial({fragmentShader: depthShader.fragmentShader,
        vertexShader: depthShader.vertexShader,
        uniforms: depthUniforms,
        blending: THREE.NoBlending,
        side: THREE.DoubleSide});
    */

    var depthMaterial = new THREE.MeshDepthMaterial( {
        depthPacking: THREE.RGBADepthPacking
    } );

    me.render = function(target)
    {
        //var rendColor = me.renderer.getClearColor();
        //var rendAlpha = me.renderer.getClearAlpha();

        me.renderer.setClearColor(0xffffff);
        me.renderer.setClearAlpha(1);

        me.objScene.overrideMaterial = depthMaterial;
        var gl = me.renderer.getContext();

        gl.disable(gl.CULL_FACE);

        if (typeof target !== 'undefined')
        {
            me.renderer.setRenderTarget(target);
            me.renderer.clear();
            me.renderer.render(me.objScene, me.objCamera);
            me.renderer.setRenderTarget(null);
        }
        else
        {
            me.renderer.render(me.objScene, me.objCamera);
        }

        me.objScene.overrideMaterial = null;
        gl.enable(gl.CULL_FACE);

        //me.renderer.setClearColor(rendColor);
        //me.renderer.setClearAlpha(rendAlpha);
    };

    me.setComponents = function(scene, camera, renderer)
    {
        me.renderer = renderer;
        me.objScene = scene;
        me.objCamera = camera;
    }
}
function OverlayPass(source)
{
    var me = this;

    me.effectScene = new THREE.Scene();

    me.effectCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
    me.effectCamera.position.set(0, 0, 1);
    me.effectCamera.lookAt(new THREE.Vector3(0, 0, 0));

    var screenGeom = new THREE.PlaneBufferGeometry(2, 2);

    me.vertShader =
        ' varying vec2 vUV;                             ' +

        ' void main()                                   ' +
        ' {                                             ' +
        '     vUV = uv;                                 ' +
        '     gl_Position = vec4(position, 1.0);        ' +
        ' } ';

    me.fragShader =
        ' varying vec2 vUV;                             ' +
        ' uniform sampler2D textureInput;               ' +
        ' uniform float opacity;                        ' +

        ' void main()                                   ' +
        ' {                                             ' +
        '     vec4 c = texture2D(textureInput, vUV);    ' +

        '     gl_FragColor = vec4(c.x, c.y, c.z, c.w); ' +
        ' } ';

    var multiplyMaterial = new THREE.ShaderMaterial({
        uniforms:
        {
            textureInput: {type: 't', value: source},
            opacity:      {type: 'f', value: 1.0}
        },
        vertexShader: me.vertShader,
        fragmentShader: me.fragShader
    });
    multiplyMaterial.transparent = true;

    var screenMesh = new THREE.Mesh(screenGeom, multiplyMaterial);
    me.effectScene.add(screenMesh);

    me.render = function(target)
    {
        me.effectScene.overrideMaterial = multiplyMaterial;

        if (typeof target !== 'undefined')
        {
            me.renderer.render(me.effectScene, me.effectCamera, target, false);
        }
        else
        {
            me.renderer.render(me.effectScene, me.effectCamera);
        }

        me.effectScene.overrideMaterial = null;
    };

    me.setSource = function(src)
    {
        multiplyMaterial.uniforms.textureInput.value = src;
    };

//    me.setOpacity = function(opacity)
//    {
//        multiplyMaterial.uniforms.opacity.value = opacity;
//    };

    me.setSize = function(w, h)
    {
        //    multiplyMaterial.uniforms.stepX.value = 1 / w;
        //    multiplyMaterial.uniforms.stepY.value = 1 / h;
    };
}
//ssao

function BGFilter(rend)
{
    var me = this;

    var renderer = rend;
    me.effectScene = new THREE.Scene();

    me.effectCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
    me.effectCamera.position.set(0, 0, 1);
    me.effectCamera.lookAt(new THREE.Vector3(0, 0, 0));

    var screenGeom = new THREE.PlaneBufferGeometry(2, 2);

    me.vertShader =
        ' varying vec2 vUV;                             ' +

        ' void main()                                   ' +
        ' {                                             ' +
        '     vUV = uv;                                 ' +
        '     gl_Position = vec4(position, 1.0);        ' +
        ' } ';

    me.fragShader =
        ' varying vec2 vUV;                             ' +
    //    ' uniform sampler2D textureInput;               ' +
    //    ' uniform float opacity;                        ' +

        ' void main()                                   ' +
        ' {                                             ' +
    //    '     vec4 c = texture2D(textureInput, vUV);    ' +

        '     float k = (vUV.y - 0.5) / 0.5; ' +
        '     float r = 0.80; ' +
        '     float g = 0.90; ' +
        '     gl_FragColor = vec4(k * (1.0 - r) + r, k * (1.0 - g) + g, 1.0, 1.0);  ' +
        ' } ';

    var multiplyMaterial = new THREE.ShaderMaterial({
        uniforms:
        {
            //textureInput: {type: 't', value: source},
            //opacity:      {type: 'f', value: 1}
        },
        vertexShader: me.vertShader,
        fragmentShader: me.fragShader
    });

    var screenMesh = new THREE.Mesh(screenGeom, multiplyMaterial);
    screenMesh.material.depthTest = false;

    me.effectScene.add(screenMesh);

    me.render = function(target)
    {
        me.effectScene.overrideMaterial = multiplyMaterial;

        //renderer.render(me.effectScene, me.effectCamera);
        if (typeof target !== 'undefined')
        {
            renderer.render(me.effectScene, me.effectCamera, target, true);
        }
        else
        {
            renderer.render(me.effectScene, me.effectCamera);
        }

        me.effectScene.overrideMaterial = null;
    }
}

//ssao

function ContoursFilter()
{
    var me = this;

    var objectScene;
    var objectCamera;
    var renderer;

    var depthPass = new DepthPass();
    var depthTarget = new THREE.WebGLRenderTarget(1000, 800, {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter});

    var contoursPass = new ContoursPass(depthTarget.texture);
    var contoursTarget = new THREE.WebGLRenderTarget(1000, 800, {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter});

    var overlayPass = new OverlayPass(contoursTarget);

    me.setSize = function(width, height)
    {
        depthTarget.setSize(width, height);
        contoursPass.setSize(width, height);
        contoursTarget.setSize(width, height);
    };

    me.render = function(target)
    {
        depthPass.render(depthTarget);

        contoursPass.render(contoursTarget);

        overlayPass.render(target);
    };

    me.setComponents = function(scene, camera, rend)
    {
        objectScene = scene;

        objectCamera = camera;

        renderer = rend;

        //---

        contoursPass.renderer = rend;
        overlayPass.renderer = rend;

        depthPass.setComponents(scene, camera, rend);
    };

    me.setInsideColor = function(r, g, b, o)
    {
        contoursPass.setInsideColor(r, g, b, o);
    };

    me.setOutsideColor = function(r, g, b, o)
    {
        contoursPass.setOutsideColor(r, g, b, o);
    };

    me.setStrokeColor = function(r, g, b, o)
    {
        contoursPass.setStrokeColor(r, g, b, o);
    };

    me.setDepthDelta = function(d)
    {
        contoursPass.setDepthDelta(d);
    }
}


function ContoursPass(depthMap)
{
    var me = this;

    me.effectScene = new THREE.Scene();

    me.effectCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
    me.effectCamera.position.set(0, 0, 1);
    me.effectCamera.lookAt(new THREE.Vector3(0, 0, 0));

    var screenGeom = new THREE.PlaneBufferGeometry(2, 2);

    me.vertShader =
        ' varying vec2 vUV;                         ' +

        ' void main()                               ' +
        ' {                                         ' +
        '     vUV = uv;                             ' +
        '     gl_Position = vec4(position, 1.0);    ' +
        ' } ';

    me.fragShader =
        ' varying vec2 vUV;                         ' +
        ' uniform sampler2D textureDepth;           ' +

        ' uniform float stepX;                      ' +
        ' uniform float stepY;                      ' +
        ' uniform float d;                      ' +

        ' uniform vec4 insideColor;             ' +
        ' uniform vec4 outsideColor;            ' +
        ' uniform vec4 strokeColor;             ' +

        ' const vec4 bit_shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); ' +

    //    'float depthToDist(const in float z)            ' +
    //    '{                                              ' +
    //    '    return -(camNear * camFar) / ((camFar - camNear) * z - camFar);' +
    //    '} ' +

        'float unpackDepth(const in vec4 rgba_depth)    ' +
        '{                                              ' +
        '    float depth = dot(rgba_depth, bit_shift);  ' +
        '    return depth;                              ' +
        '}                                              ' +

        'void main()                                    ' +
        '{                                              ' +
        '    float depth0 = unpackDepth(texture2D(textureDepth, vUV));  ' +

        '    if (vUV.y <= stepY || vUV.y >= 1.0 - stepY || vUV.x <= stepX || vUV.x >= 1.0 - stepX) ' +
        '    {                                                          ' +
        '        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.0);               ' +
        '        return;                                                ' +
        '    }                                                          ' +

    //    '    gl_FragColor = vec4(depth0, depth0, depth0, 1.0);               ' +
    //    '    return;                                                ' +


        '    float neibourDepth[4]; ' +
        '    neibourDepth[0] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y))); ' +
        '    neibourDepth[1] = unpackDepth(texture2D(textureDepth, vec2(vUV.x, vUV.y + stepY))); ' +
        '    neibourDepth[2] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y))); ' +
        '    neibourDepth[3] = unpackDepth(texture2D(textureDepth, vec2(vUV.x, vUV.y - stepY))); ' +
        '    if (vUV.x + stepX > 1.0) neibourDepth[0] = -1.0;           ' +
        '    if (vUV.y + stepY > 1.0) neibourDepth[1] = -1.0;           ' +
        '    if (vUV.x - stepX < 0.0) neibourDepth[2] = -1.0;           ' +
        '    if (vUV.y - stepY < 0.0) neibourDepth[3] = -1.0;           ' +

        '    float diagDepth[4]; ' +
        '    diagDepth[0] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y + stepY))); ' +
        '    diagDepth[1] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y + stepY))); ' +
        '    diagDepth[2] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y - stepY))); ' +
        '    diagDepth[3] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y - stepY))); ' +
        '    if (vUV.x + stepX > 1.0 && vUV.y + stepY > 1.0) diagDepth[0] = -1.0;           ' +
        '    if (vUV.x - stepX < 0.0 && vUV.y + stepY > 1.0) diagDepth[1] = -1.0;           ' +
        '    if (vUV.x - stepX < 0.0 && vUV.y - stepY < 0.0) diagDepth[2] = -1.0;           ' +
        '    if (vUV.x + stepX > 1.0 && vUV.y - stepY < 1.0) diagDepth[3] = -1.0;           ' +

        '    int pos = 0; ' +
        '    if (depth0 < 1.0)          ' +
        '    {                          ' +
        '        int neighbs = 0;   ' +
        '        if (neibourDepth[0] - depth0 > d) neighbs += 1;      ' +
        '        if (neibourDepth[1] - depth0 > d) neighbs += 1;      ' +
        '        if (neibourDepth[2] - depth0 > d) neighbs += 1;      ' +
        '        if (neibourDepth[3] - depth0 > d) neighbs += 1;      ' +

        '        if (diagDepth[0] - depth0 > d) neighbs += 1;      ' +
        '        if (diagDepth[1] - depth0 > d) neighbs += 1;      ' +
        '        if (diagDepth[2] - depth0 > d) neighbs += 1;      ' +
        '        if (diagDepth[3] - depth0 > d) neighbs += 1;      ' +

        '        float k = 0.0;  ' +
        '        if (neighbs == 3 || neighbs == 2)' +
        '        {' +
        '            k = 1.0;' +
        '        }' +
        '        else if (neighbs == 0)' +
        '        {' +
        '            k = 0.0;' +
        '        }' +
        '        else' +
        '        {' +
        '            k = 0.3;' +
        '        }' +

        '        float l = 1.0 - k;' +
        '        gl_FragColor = vec4(k * strokeColor.x + l * insideColor.x, k * strokeColor.y + l * insideColor.y, k * strokeColor.z + l * insideColor.z, k * strokeColor.w + l * insideColor.w);    ' +
    //    '        if (neighbs > 0) gl_FragColor = vec4(strokeColor.x, strokeColor.y, strokeColor.z, strokeColor.w);    ' +
    //    '        if (neighbs == 0) gl_FragColor = vec4(insideColor.x, insideColor.y, insideColor.z, insideColor.w);    ' +
        '    } ' +
        '    else ' +
        '    { ' +
        '        gl_FragColor = vec4(outsideColor.x, outsideColor.y, outsideColor.z, outsideColor.w);    ' +
        '    } ' +
        '} ';

    me.ssaoMaterial = new THREE.ShaderMaterial({
        uniforms:
        {
            textureDepth: {type: 't', value: depthMap},
            stepX:        {type: 'f', value: 1 / 1000},
            stepY:        {type: 'f', value: 1 / 800},
            d:            {type: 'f', value: 0.005},
            insideColor:  {type: 'v4', value: new THREE.Vector4(1.0, 0.5, 0.5, 1.0)},
            outsideColor: {type: 'v4', value: new THREE.Vector4(0.5, 1.0, 0.5, 0.0)},
            strokeColor:  {type: 'v4', value: new THREE.Vector4(0.0, 0.0, 0.0, 1.0)}
        },
        vertexShader: me.vertShader,
        fragmentShader: me.fragShader
    });

    me.setInsideColor = function(r, g, b, o)
    {
        me.ssaoMaterial.uniforms.insideColor.value = new THREE.Vector4(r, g, b, o);
    };

    me.setOutsideColor = function(r, g, b, o)
    {
        me.ssaoMaterial.uniforms.outsideColor.value = new THREE.Vector4(r, g, b, o);
    };

    me.setStrokeColor = function(r, g, b, o)
    {
        me.ssaoMaterial.uniforms.strokeColor.value = new THREE.Vector4(r, g, b, o);
    };

    var screenMesh = new THREE.Mesh(screenGeom, me.ssaoMaterial);
    me.effectScene.add(screenMesh);

    me.render = function(target)
    {
        me.effectScene.overrideMaterial = me.ssaoMaterial;
        if (typeof target !== 'undefined')
        {
           // me.renderer.render(me.effectScene, me.effectCamera, target, true);

            me.renderer.setRenderTarget(target);
            me.renderer.clear();
            me.renderer.render(me.effectScene, me.effectCamera);
            me.renderer.setRenderTarget(null);
        }
        else
        {
            me.renderer.render(me.effectScene, me.effectCamera);
        }

        me.effectScene.overrideMaterial = null;
    };

    me.setSize = function(w, h)
    {
        me.ssaoMaterial.uniforms.stepX.value = 1 / w;
        me.ssaoMaterial.uniforms.stepY.value = 1 / h;
    };

    me.setDepthDelta = function(d)
    {
        me.ssaoMaterial.uniforms.d.value = d;
    }
}


//ssao

function OutlineFilter()
{
    var me = this;

    var objectScene;
    var objectCamera;
    var renderer;

    var depthPass = new DepthPass();
    var depthTarget = new THREE.WebGLRenderTarget(1000, 800, {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter});

    var contoursPass = new OutlinePass(depthTarget.texture);
    var contoursTarget = new THREE.WebGLRenderTarget(1000, 800, {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter});

    var overlayPass = new OverlayPass(contoursTarget);

    me.setSize = function(width, height)
    {
        depthTarget.setSize(width, height);
        contoursPass.setSize(width, height);
        contoursTarget.setSize(width, height);
    };

    me.render = function(target)
    {
        depthPass.render(depthTarget);

        contoursPass.render(contoursTarget);

        overlayPass.render(target);
    };

    me.setComponents = function(scene, camera, rend)
    {
        objectScene = scene;

        objectCamera = camera;

        renderer = rend;

        //---

        contoursPass.renderer = rend;
        overlayPass.renderer = rend;

        depthPass.setComponents(scene, camera, rend);
    };

    me.setInsideColor = function(r, g, b, o)
    {
        contoursPass.setInsideColor(r, g, b, o);
    };

    me.setOutsideColor = function(r, g, b, o)
    {
        contoursPass.setOutsideColor(r, g, b, o);
    };

    me.setStrokeColor = function(r, g, b, o)
    {
        contoursPass.setStrokeColor(r, g, b, o);
    };
}


function OutlinePass(depthMap)
{
    var me = this;

    me.effectScene = new THREE.Scene();

    me.effectCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
    me.effectCamera.position.set(0, 0, 1);
    me.effectCamera.lookAt(new THREE.Vector3(0, 0, 0));

    var screenGeom = new THREE.PlaneBufferGeometry(2, 2);

    me.vertShader =
        ' varying vec2 vUV;                         ' +

        ' void main()                               ' +
        ' {                                         ' +
        '     vUV = uv;                             ' +
        '     gl_Position = vec4(position, 1.0);    ' +
        ' } ';

    me.fragShader =
        ' varying vec2 vUV;                         ' +
        ' uniform sampler2D textureDepth;           ' +

        ' uniform float stepX;                      ' +
        ' uniform float stepY;                      ' +

        ' uniform vec4 insideColor;             ' +
        ' uniform vec4 outsideColor;            ' +
        ' uniform vec4 strokeColor;             ' +

        ' const vec4 bit_shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); ' +
        ' const int num = 16;                       ' +

        'float unpackDepth(const in vec4 rgba_depth)    ' + // This is not depth, but it works
        '{                                              ' +
        '    float depth = (rgba_depth.x + rgba_depth.y + rgba_depth.z + rgba_depth.w) / 4.0;  ' +
        '    return depth;                              ' +
        '}                                              ' +

        'void main()                                    ' +
        '{                                              ' +
        '    float depth0 = unpackDepth(texture2D(textureDepth, vUV));  ' +

        '    if (vUV.y <= stepY || vUV.y >= 1.0 - stepY || vUV.x <= stepX || vUV.x >= 1.0 - stepX) ' +
        '    {                                                          ' +
        '        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.0);               ' +
        '        return;                                                ' +
        '    }                                                          ' +

        '    float d = 0.01;' +

        '    float neibourDepth[4]; ' +
        '    neibourDepth[0] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y))); ' +
        '    neibourDepth[1] = unpackDepth(texture2D(textureDepth, vec2(vUV.x, vUV.y + stepY))); ' +
        '    neibourDepth[2] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y))); ' +
        '    neibourDepth[3] = unpackDepth(texture2D(textureDepth, vec2(vUV.x, vUV.y - stepY))); ' +

        '    float diagDepth[4]; ' +
        '    diagDepth[0] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y + stepY))); ' +
        '    diagDepth[1] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y + stepY))); ' +
        '    diagDepth[2] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y - stepY))); ' +
        '    diagDepth[3] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y - stepY))); ' +

        '    float perpDepth[4]; ' +
        '    perpDepth[0] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + 2.0 * stepX, vUV.y))); ' +
        '    perpDepth[1] = unpackDepth(texture2D(textureDepth, vec2(vUV.x, vUV.y + 2.0 * stepY))); ' +
        '    perpDepth[2] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - 2.0 * stepX, vUV.y))); ' +
        '    perpDepth[3] = unpackDepth(texture2D(textureDepth, vec2(vUV.x, vUV.y - 2.0 * stepY))); ' +

        '    float farDepth[8]; ' +
        '    farDepth[0] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + 2.0 * stepX, vUV.y + stepY))); ' +
        '    farDepth[1] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + 2.0 * stepX, vUV.y - stepY))); ' +
        '    farDepth[2] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y + 2.0 * stepY))); ' +
        '    farDepth[3] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y + 2.0 * stepY))); ' +
        '    farDepth[4] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - 2.0 * stepX, vUV.y + stepY))); ' +
        '    farDepth[5] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - 2.0 * stepX, vUV.y - stepY))); ' +
        '    farDepth[6] = unpackDepth(texture2D(textureDepth, vec2(vUV.x + stepX, vUV.y - 2.0 * stepY))); ' +
        '    farDepth[7] = unpackDepth(texture2D(textureDepth, vec2(vUV.x - stepX, vUV.y - 2.0 * stepY))); ' +

        '    if (depth0 < 1.0)   ' +
        '    {                   ' +
        '        gl_FragColor = vec4(insideColor.x, insideColor.y, insideColor.z, insideColor.w);   ' +
        '        return;         ' +
        '    }                   ' +

        '    int neighbs = 0;   ' +
        '    if (neibourDepth[0] < 1.0) neighbs += 1;      ' +
        '    if (neibourDepth[1] < 1.0) neighbs += 1;      ' +
        '    if (neibourDepth[2] < 1.0) neighbs += 1;      ' +
        '    if (neibourDepth[3] < 1.0) neighbs += 1;      ' +

        '    if (diagDepth[0] < 1.0) neighbs += 1;      ' +
        '    if (diagDepth[1] < 1.0) neighbs += 1;      ' +
        '    if (diagDepth[2] < 1.0) neighbs += 1;      ' +
        '    if (diagDepth[3] < 1.0) neighbs += 1;      ' +

        '    if (perpDepth[0] < 1.0) neighbs += 1;      ' +
        '    if (perpDepth[1] < 1.0) neighbs += 1;      ' +
        '    if (perpDepth[2] < 1.0) neighbs += 1;      ' +
        '    if (perpDepth[3] < 1.0) neighbs += 1;      ' +

        '    if (farDepth[0] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[1] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[2] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[3] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[4] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[5] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[6] < 1.0) neighbs += 1;      ' +
        '    if (farDepth[7] < 1.0) neighbs += 1;      ' +

        '    float k = 0.0; ' +
        '    if (neighbs == 1) k = 0.2; ' +
        '    if (neighbs == 2) k = 0.4; ' +
        '    if (neighbs >= 3) k = 1.0; ' +
        '    float l = 1.0 - k;' +

        '    gl_FragColor = vec4(k * strokeColor.x + l * insideColor.x, k * strokeColor.y + l * insideColor.y, k * strokeColor.z + l * insideColor.z, k * strokeColor.w + l * insideColor.w);    ' +
        '} ';

    me.ssaoMaterial = new THREE.ShaderMaterial({
        uniforms:
        {
            textureDepth: {type: 't', value: depthMap},
            stepX:        {type: 'f', value: 1 / 1000},
            stepY:        {type: 'f', value: 1 / 800},
            insideColor:  {type: 'v4', value: new THREE.Vector4(1.0, 0.5, 0.5, 1.0)},
            outsideColor: {type: 'v4', value: new THREE.Vector4(0.5, 1.0, 0.5, 0.0)},
            strokeColor:  {type: 'v4', value: new THREE.Vector4(0.0, 0.0, 0.0, 1.0)}
        },
        vertexShader: me.vertShader,
        fragmentShader: me.fragShader
    });

    me.setInsideColor = function(r, g, b, o)
    {
        me.ssaoMaterial.uniforms.insideColor.value = new THREE.Vector4(r, g, b, o);
    };

    me.setOutsideColor = function(r, g, b, o)
    {
        me.ssaoMaterial.uniforms.outsideColor.value = new THREE.Vector4(r, g, b, o);
    };

    me.setStrokeColor = function(r, g, b, o)
    {
        me.ssaoMaterial.uniforms.strokeColor.value = new THREE.Vector4(r, g, b, o);
    };

    var screenMesh = new THREE.Mesh(screenGeom, me.ssaoMaterial);
    me.effectScene.add(screenMesh);

    me.render = function(target)
    {
        me.effectScene.overrideMaterial = me.ssaoMaterial;
        if (typeof target !== 'undefined')
        {
            me.renderer.setRenderTarget(target);
            me.renderer.clear();
            me.renderer.render(me.effectScene, me.effectCamera);
            me.renderer.setRenderTarget(null);
        }
        else
        {
            me.renderer.render(me.effectScene, me.effectCamera);
        }

        me.effectScene.overrideMaterial = null;
    };

    me.setSize = function(w, h)
    {
        me.ssaoMaterial.uniforms.stepX.value = 1 / w;
        me.ssaoMaterial.uniforms.stepY.value = 1 / h;
    };
}



//ui

R2D.ImageUrlLoader = function() {
    EventDispatcher.call(this);

    var scope = this;
    var imageUrl = null;
    var xhr = null;
    var arrayBuffer = null;
    var bytes8 = null;
    var blob = null;
    var fileReader = null;
    var imageSource = null;
    var image = null;
    var errorMessage = null;

    function imageEventHandler(event) {
        if ( event.type == 'error' ) {
            errorMessage = "Error load image's data to image element!";
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        } else {
            scope.dispatchEvent(new Event(Event.COMPLETE, scope));
        }
        removeImageLoader();
    }
    function removeImageLoader() {
        if ( image == null ) return;

        image.removeEventListener('load', imageEventHandler);
        image.removeEventListener('error', imageEventHandler);
        image = null;
    }

    function fileReaderEventHandler(event) {
        if ( event.type == 'error' ) {
            errorMessage = "Error reading data!";
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        } else {
            image = document.createElement('img');

            image.addEventListener('load', imageEventHandler);
            image.addEventListener('error', imageEventHandler);
            image.src = fileReader.result;
        }

        removeFileReader();
    }
    function removeFileReader() {
        if ( fileReader == null ) return;

        fileReader.removeEventListener('load', fileReaderEventHandler);
        fileReader.removeEventListener('error', fileReaderEventHandler);
        try {
            fileReader.abort();
        } catch ( error ) {
            //-
        }

        fileReader = null;
    }

    function makeImageData() {
        bytes8 = new Uint8Array(arrayBuffer);
        blob = new Blob([bytes8]);
        fileReader = new FileReader();

        fileReader.addEventListener('load', fileReaderEventHandler);
        fileReader.addEventListener('error', fileReaderEventHandler);
        fileReader.readAsDataURL(blob);
    }
    function xhrEventHandler(event) {


        if ( event.type == 'error' || xhr.status != 200 ) {
            errorMessage = "Error load image by the url: " + imageUrl;
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        } else {
            arrayBuffer = xhr.response;
            makeImageData();
        }

        removeXHRLoader();
    }
    function removeXHRLoader() {
        if ( xhr == null ) return;

        xhr.removeEventListener('load', xhrEventHandler);
        xhr.removeEventListener('error', xhrEventHandler);
        xhr.abort();
        xhr = null;
    }

    scope.getErrorMessage = function() {
        return errorMessage;
    };
    scope.getImageSrc = function() {
        return image.src;
    };
    scope.getImage = function() {
        return image;
    };
    scope.getImageSource = function() {
        return imageSource;
    };
    scope.close = function() {
        removeXHRLoader();
        removeFileReader();
        removeImageLoader();

        imageUrl = null;
        arrayBuffer = null;
        bytes8 = null;
        blob = null;
        imageSource = null;
        image = null;
        errorMessage = null;
    };
    scope.load = function(url) {
        imageUrl = url;
        xhr = new XMLHttpRequest();

        xhr.withCredentials = true;

        try {
            xhr.open('GET', imageUrl, true);
            xhr.responseType = "arraybuffer";
            xhr.addEventListener('load', xhrEventHandler);
            xhr.addEventListener('error', xhrEventHandler);
            xhr.send();
        } catch ( error ) {
            errorMessage = "Error load image by the url: " + imageUrl;
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }
    };
};

R2D.extend(R2D.ImageUrlLoader, EventDispatcher);
//ui

R2D.ImagesLoader = function() {
    EventDispatcher.call(this);

    var scope = this;
    var images = [];
    var loading = false;
    var countLoaded = 0;
    var total = 0;

    function completeLoad() {
        scope.dispatchEvent(new Event(Event.COMPLETE, images));
    }
    function clearImage(image) {
        image.removeEventListener('load', imageEventHandler);
        image.removeEventListener('error', imageEventHandler);
    }
    function imageEventHandler(event) {
        clearImage(event.currentTarget);

        countLoaded += 1;

        if ( countLoaded == total ) {
            loading = false;
            completeLoad();
        }
    }

    scope.getImages = function() {
        return images;
    };
    scope.load = function(urls) {
        total = urls.length;

        if ( total == 0 ) {
            completeLoad();
        } else {
            images = new Array(total);

            for ( var i = 0; i < total; i++ ) {
                var image = document.createElement('img');

                image.addEventListener('load', imageEventHandler);
                image.addEventListener('error', imageEventHandler);
                image.src = urls[i];

                images[i] = image;
            }

            loading = true;
        }
    };
    scope.close = function() {
        if ( loading ) {
            for ( var i = 0; i < total; i++ ) {
                clearImage(images[i]);
            }

            loading = false;
        }

        images = null;
    };
};

R2D.extend(R2D.ImagesLoader, EventDispatcher);
//ui

/**
 * Returns an array with src images data
 * @param {String} src source of an image
 * @param {Array} colors an array of needs colors
 * @param {String} mode mode of overlay
 * @constructor
 */
R2D.ImageColorChanging = function(src, colors, mode) {
    EventDispatcher.call(this);

    var scope = this;
    var imageLoader = null;
    var image = null;
    var imageWidth = 0;
    var imageHeight = 0;
    var canvas = null;
    var context = null;
    var imageData = null;
    var imagePixels = null;
    var images = [];

    function generate() {
        imageWidth = image.width;
        imageHeight = image.height;
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');

        canvas.width = imageWidth;
        canvas.height = imageHeight;

        context?.drawImage(image, 0, 0);

        imageData = context.getImageData(0, 0, imageWidth, imageHeight);
        imagePixels = imageData.data;

        for ( var c = 0, cl = colors.length; c < cl; c++ ) {
            var color = R2D.ImageColorChanging.getColorChannels(colors[c]);
            var r = color.red;
            var g = color.green;
            var b = color.blue;

            if (mode == R2D.ImageColorChanging.MODE_MULTIPLY)
            {
                for ( var p = 0, pl = imagePixels.length; p < pl; p += 4 ) {

                    if (imagePixels[p] > 200 || imagePixels[p + 1] > 200 || imagePixels[p + 2] > 200)
                    {
                        imagePixels[p] = r;
                        imagePixels[p + 1] = g;
                        imagePixels[p + 2] = b;
                    }

                    //imagePixels[p] = Math.floor(imagePixels[p] * r / 256);
                    //imagePixels[p + 1] = Math.floor(imagePixels[p + 1] * g / 256);
                    //imagePixels[p + 2] = Math.floor(imagePixels[p + 2] * b / 256);
                }
            }
            else
            {
                for (p = 0, pl = imagePixels.length; p < pl; p += 4 ) {
                    imagePixels[p] = r;
                    imagePixels[p + 1] = g;
                    imagePixels[p + 2] = b;
                }
            }

            context.putImageData(imageData, 0, 0);
            images.push(canvas.toDataURL());
        }
    }
    function removeLoader() {
        if ( imageLoader == null ) return;

        imageLoader.removeEventListener(Event.COMPLETE, loadEventHandler);
        imageLoader.removeEventListener(Event.ERROR, loadEventHandler);
        imageLoader.close();
        imageLoader = null;
    }
    function loadEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            image = imageLoader.getImage();

            generate();
            removeLoader();
            scope.dispatchEvent(new Event(Event.COMPLETE, images));
        } else {
            removeLoader();
            scope.dispatchEvent(new Event(Event.ERROR, null));
        }
    }

    scope.getImages = function() {
        return images;
    };
    scope.generate = function () {
        imageLoader = new R2D.ImageUrlLoader();

        imageLoader.addEventListener(Event.COMPLETE, loadEventHandler);
        imageLoader.addEventListener(Event.ERROR, loadEventHandler);
        imageLoader.load(src);
    };
    scope.dispose = function() {
        removeLoader();

        canvas = null;
        context = null;
        imageData = null;
        imagePixels = null;
        images = null;
    };
};

R2D.extend(R2D.ImageColorChanging, EventDispatcher);

R2D.ImageColorChanging.getColorChannels = function(color) {
    var r, g, b;

    if ( String(color)[0] == '#' ) {
        r = parseInt('0x' + String(color).substring(1, 3));
        g = parseInt('0x' + String(color).substring(3, 5));
        b = parseInt('0x' + String(color).substring(5, 7));

        return {red:r, green:g, blue:b };
    } else {
        color = parseInt(color);
        r = (color >> 16) & 255;
        g = (color >> 8) & 255;
        b = color & 255;

        return {red:r, green:g, blue:b };
    }
};

R2D.ImageColorChanging.MODE_MULTIPLY = 'modeMultiply';
R2D.ImageColorChanging.MODE_REPLACE = 'modeReplace';
// ui

R2D.ImageColorChangingAndLoader = function(src, colors, mode) {
    EventDispatcher.call(this);

    var scope = this;
    var changer = new R2D.ImageColorChanging(src, colors, mode);
    var loader = null;
    var images = null;

    function removeLoader() {
        if ( loader == null ) return;

        loader.removeEventListener(Event.COMPLETE, imagesLoaderComplete);
        loader.removeEventListener(Event.ERROR, imagesLoaderComplete);
        loader.close();
        loader = null;
    }
    function imagesLoaderComplete(event) {
        if ( event.type == Event.COMPLETE ) {
            images = loader.getImages();
            scope.dispatchEvent(new Event(Event.COMPLETE, scope));
        } else {
            console.log("Load generated images error!");
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        removeLoader();
    }

    function removeChanger() {
        if ( changer == null ) return;

        changer.removeEventListener(Event.COMPLETE, changerEventHandler);
        changer.removeEventListener(Event.ERROR, changerEventHandler);
        changer.dispose();
        changer = null;
    }
    function changerEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            loader = new R2D.ImagesLoader();

            loader.addEventListener(Event.COMPLETE, imagesLoaderComplete);
            loader.addEventListener(Event.ERROR, imagesLoaderComplete);
            loader.load(changer.getImages());
        } else {
            console.log("Load or generate images error!");
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        removeChanger();
    }

    scope.getImages = function() {
        return images;
    };
    scope.dispose = function() {
        removeChanger();
        removeLoader();
    };
    scope.generate = function() {
        changer.addEventListener(Event.COMPLETE, changerEventHandler);
        changer.addEventListener(Event.ERROR, changerEventHandler);
        changer.generate();
    };
};

R2D.extend(R2D.ImageColorChangingAndLoader, EventDispatcher);
// ui

R2D.Layout = function() {
    throw "Error! Use static method!";
};

R2D.Layout.getSizes = function(elements) {
    if ( elements.length == 0 ) return null;

    var minWidth = elements[0].getWidth();
    var minHeight = elements[0].getHeight();
    var maxWidth = minWidth;
    var maxHeight = minHeight;

    for ( var i = 1, l = elements.length; i < l; i++ ) {
        if ( elements[i].getWidth() < minWidth ) minWidth = elements[i].getWidth();
        else if ( elements[i].getWidth() > maxWidth ) maxWidth = elements[i].getWidth();

        if ( elements[i].getHeight() < minHeight ) minHeight = elements[i].getHeight();
        else if ( elements[i].getHeight() > maxHeight ) maxHeight = elements[i].getHeight();
    }

    return {
        minWidth:minWidth,
        minHeight:minHeight,
        maxWidth:maxWidth,
        maxHeight:maxHeight
    }
};

R2D.Layout.LEFT = 'left';
R2D.Layout.CENTER = 'center';
R2D.Layout.RIGHT = 'right';
/**
 *
 * @param {Array} elements - an array od dom elements
 * @param {int} cols
 * @param {int} shiftX
 * @param {int} shiftY
 * @param {int} width
 * @param {int} indentY
 * @param {String} align
 */
R2D.Layout.asVerticalGrid = function(elements, cols, shiftX, shiftY, width, indentY, align) {
    var i, px, py, l;
    var element, elementWidth;
    var sizes = R2D.Layout.getSizes(elements);
    var sideWidth = width / cols;

    for ( i = 0, px = 0, py = 0, l = elements.length; i < l; ) {
        element = elements[i];
        elementWidth = element.getWidth();

        switch ( align ) {
            case R2D.Layout.LEFT:
                element.setPosition(
                    Math.floor(shiftX + px * sideWidth),
                    Math.floor(shiftY + py * (sizes.maxHeight + indentY))
                );
                break;

            case R2D.Layout.RIGHT:
                element.setPosition(
                    Math.floor(shiftX + px * sideWidth + (sideWidth - elementWidth)),
                    Math.floor(shiftY + py * (sizes.maxHeight + indentY))
                );
                break;

            case R2D.Layout.CENTER:
            default:
                element.setPosition(
                    Math.floor(shiftX + px * sideWidth + (sideWidth - elementWidth) / 2),
                    Math.floor(shiftY + py * (sizes.maxHeight + indentY))
                );
        }

        i += 1;
        px = i % cols;
        py = Math.floor(i / cols);
    }
};

R2D.Layout.copyPositions = function(source, target) {
    if ( source.length != target.length ) return;

    for ( var i = 0, l = source.length; i < l; i++ ) {
        target[i].setPosition(source[i].getX(), source[i].getY());
    }
};
// ui

R2D.ProductHint = function() {
    R2D.DomElement.call(this);

    var scope = this;
    var body = scope.getDomElement();
    var hint = new R2D.ProductHint.Complex();

    scope.show = function(productId, positionX, positionY) {
        var visible = hint.updateProduct(productId);
        if (visible)
        {
            hint.setPosition(positionX, positionY);
            body.appendChild(hint.getDomElement());
        }
    };
    scope.hide = function() {
        if ( hint.getDomElement().parentNode ) body.removeChild(hint.getDomElement());
    };

    body.className = 'product-hint-stage';
};

R2D.extend(R2D.ProductHint, R2D.DomElement);

/**************************/
R2D.ProductHint.ImageSizeCreator = function() {
    EventDispatcher.call(this);

    var scope = this;
    var resultImageSrc = null;
    var imageLoader = null;
    var image = null;
    var contour = null;
    var pointsBounding = null;
    var canvas = null;
    var context = null;
    var srcImage = null;
    var srcContour = null;
    var ratioSizes = 0.23;

    function createImage() {
        var maxHeight = 0;
        var indent = 5;

        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');

        contour = GEOM.Point.contourFromString(srcContour);
        contour = GEOM.Point.scalePoints(ratioSizes, ratioSizes, contour);
        pointsBounding = GEOM.Point.getPointsBounding(contour);
        maxHeight = Math.max(pointsBounding.height, image.height);
        contour =  GEOM.Point.shiftPoints(new GEOM.Point(-pointsBounding.left, -pointsBounding.top + (maxHeight - pointsBounding.height)), contour);

        canvas.width = pointsBounding.width + indent + image.width;
        canvas.height = maxHeight;

        //draw points
        context.fillStyle = R2D.STYLE.PRODUCT_HINT_COLOR_SHAPE;
        context.beginPath();
        context.moveTo(contour[0].x, contour[0].y);

        for ( var pi = 1, pil = contour.length; pi < pil; pi++ ) {
            context.lineTo(contour[pi].x, contour[pi].y);
        }

        context.fill();

        //draw image
        context.drawImage(image, pointsBounding.width + indent, maxHeight - image.height);

        resultImageSrc = canvas.toDataURL('image/png');

        scope.dispatchEvent(new Event(Event.COMPLETE, scope));
    }
    function disposeImageLoader() {
        if ( imageLoader == null ) return;

        imageLoader.removeEventListener(Event.COMPLETE, imageLoaderEventHandler);
        imageLoader.removeEventListener(Event.ERROR, imageLoaderEventHandler);
        imageLoader.dispose();

        imageLoader = null;
    }
    function imageLoaderEventHandler(event) {
        if ( event.type == Event.COMPLETE ) {
            image = imageLoader.getImages()[0];

            createImage();
        } else {
            console.error('Error load an image!');
            scope.dispatchEvent(new Event(Event.ERROR, scope));
        }

        disposeImageLoader();
    }
    function loadImage() {
        imageLoader = new R2D.ImageColorChangingAndLoader(srcImage, ["#444444"]);

        imageLoader.addEventListener(Event.COMPLETE, imageLoaderEventHandler);
        imageLoader.addEventListener(Event.ERROR, imageLoaderEventHandler);
        imageLoader.generate();
    }

    scope.getResultImageSrc = function() {
        return resultImageSrc;
    };
    scope.create = function(contourSrc, imageSrc) {
        srcContour = contourSrc;
        srcImage = imageSrc;

        loadImage();
    };
    scope.dispose = function() {
        srcContour = null;
        srcImage = null;
        resultImageSrc = null;

        disposeImageLoader();
    };
};

R2D.extend(R2D.ProductHint.ImageSizeCreator, EventDispatcher);

/****************/
R2D.ProductHint.Content = function() {
    R2D.DomElement.call(this);

    var scope = this;
    var body = scope.getDomElement();
    var title = new R2D.TextField('Title', 'product-hint-content-title');
    var imageSize = null;
    var imageSizeCreator = null;
    var superSetWidth = scope.setWidth;
    var superSetHeight = scope.setHeight;
    var superSetSize = scope.setSize;

    function reposition() {
        var minWidth = 130;
        var maxWidth = 0;
        var borderH = 30;
        var borderV = 15;
        var indentV = 10;

        if ( imageSize ) {
            maxWidth = Math.max(title.getWidth() + borderH, imageSize.width + borderH, minWidth);

            title.setPosition(Math.round((maxWidth - title.getWidth()) / 2), borderV);

            imageSize.style.left = Math.round((maxWidth - imageSize.width) / 2).toString() + 'px';
            imageSize.style.top = Math.round(title.getY() + title.getHeight() + indentV).toString() + 'px';

            superSetSize(maxWidth, borderV + title.getHeight() + indentV + imageSize.height + borderV);
        } else {
            maxWidth = Math.max(title.getWidth() + borderH, minWidth);

            title.setPosition(Math.round((maxWidth - title.getWidth()) / 2), borderV);

            superSetSize(maxWidth, borderV + title.getHeight() + borderV);
        }

        scope.dispatchEvent(new Event(Event.RESIZE, scope));
    }
    function disposeImageSizeCreator() {
        if ( imageSizeCreator == null ) return;

        imageSizeCreator.removeEventListener(Event.COMPLETE, imageSizeCreatorEventHandler);
        imageSizeCreator.removeEventListener(Event.ERROR, imageSizeCreatorEventHandler);
        imageSizeCreator.dispose();

        imageSizeCreator = null;
    }
    function imageSizeEventHandler(event) {
        imageSize.removeEventListener('load', imageSizeEventHandler);
        imageSize.removeEventListener('error', imageSizeEventHandler);

        reposition();
    }
    function imageSizeCreatorEventHandler(event) {
        imageSize = document.createElement('img');

        imageSize.addEventListener('load', imageSizeEventHandler);
        imageSize.addEventListener('error', imageSizeEventHandler);
        imageSize.setAttribute('class', 'product-hint-content-image-size');
        imageSize.setAttribute('src', imageSizeCreator.getResultImageSrc());

        body.appendChild(imageSize);

        disposeImageSizeCreator();
    }

    scope.setWidth = function(value) {
        //-
    };
    scope.setHeight = function(value) {
        //-
    };
    scope.setSize = function(w, h) {
        //-
    };
    scope.updateData = function(productName, productContour) {
        disposeImageSizeCreator();

        if ( imageSize ) {
            body.removeChild(imageSize);

            imageSize.removeEventListener('load', imageSizeEventHandler);
            imageSize.removeEventListener('error', imageSizeEventHandler);

            imageSize = null;
        }

        title.setText(productName);

        if ( productContour ) {
            imageSizeCreator = new R2D.ProductHint.ImageSizeCreator();

            imageSizeCreator.addEventListener(Event.COMPLETE, imageSizeCreatorEventHandler);
            imageSizeCreator.addEventListener(Event.ERROR, imageSizeCreatorEventHandler);
            imageSizeCreator.create(productContour, R2D.ProductHint.Content.getPerson());
        }

        reposition();
    };

    body.className = 'product-hint-complex-body';

    body.appendChild(title.getDomElement());
};
R2D.extend(R2D.ProductHint.Content, R2D.DomElement);

R2D.ProductHint.Content.PEOPLE = ["/src_designer/images/people/manForSize.png", "/src_designer/images/people/womanForSize.png"];
R2D.ProductHint.Content.getPerson = function() {
    return R2D.ProductHint.Content.PEOPLE[Math.floor(R2D.ProductHint.Content.PEOPLE.length * Math.random())];
};

/***************/
R2D.ProductHint.Background = function() {
    var scope = this;
    var width = 100;
    var height = 50;
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    var svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    var svgPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');

    var cornerWidth = 8;
    var cornerHeight = 15;

    function resize() {
        var boxWidth = width - cornerWidth;
        var points = '0,0';

        points += ' ' + boxWidth.toString() + ',0';
        points += ' ' + boxWidth.toString() + ',' + Math.floor(height / 2 - cornerHeight / 2).toString();
        points += ' ' + width + ',' + Math.floor(height / 2).toString();
        points += ' ' + boxWidth.toString() + ',' + Math.floor(height / 2 + cornerHeight / 2).toString();
        points += ' ' + boxWidth.toString() + ',' + height.toString();
        points += ' 0,' + height.toString();

        svgPolygon.setAttribute('points', points);
        svg.setAttribute('width', Number(width + 1).toString());
        svg.setAttribute('height', Number(height + 1).toString());
    }

    scope.getWidth = function() {
        return width;
    };
    scope.getHeight = function() {
        return height;
    };
    scope.setPosition = function(x, y) {
        svg.style.left = x + 'px';
        svg.style.top = y + 'px';
    };
    scope.setSize = function(w, h) {
        width = w;
        height = h;

        resize();
    };
    scope.getDomElement = function () {
        return svg;
    };

    svg.setAttribute('class', 'product-hint-content-background');

    svgPolygon.setAttribute('transform', 'translate(0.5, 0.5)');
    svgPolygon.setAttribute('style', 'fill:' + R2D.STYLE.PRODUCT_HINT_COLOR_BACK + ';stroke:' + R2D.STYLE.PRODUCT_HINT_COLOR_BORDER);

    svg.appendChild(svgGroup);
    svgGroup.appendChild(svgPolygon);
};

/******************************/
R2D.ProductHint.Complex = function() {
    R2D.DomElement.call(this);

    var scope = this;
    var body = scope.getDomElement();
    var background = new R2D.ProductHint.Background();
    var content = new R2D.ProductHint.Content();

    var superSetWidth = scope.setWidth;
    var superSetHeight = scope.setHeight;
    var superSetSize = scope.setSize;

    function resize() {
        content.setPosition(-content.getWidth(), -Math.floor(content.getHeight() / 2));

        background.setPosition(-content.getWidth(), -Math.floor(content.getHeight() / 2));
        background.setSize(content.getWidth(), content.getHeight());
    }

    function contentResizeEventHandler(event) {
        resize();
    }

    scope.setWidth = function(value) {
        //-
    };
    scope.setHeight = function(value) {
        //-
    };
    scope.setSize = function(w, h) {
        //-
    };
    scope.updateProduct = function(productId) {
        var productData = R2D.Pool.getProductData(productId);
        var productName = null;
        var productContour = null;

        if ( !productData ) {
            //console.error('Product data is null!');
            return;
        }

        productName = productData['name'];
        productContour = productData['source']['body']['contourCut'];

        if ( parseInt(productData.type) == R2D.ProductType.MATERIAL ) {
            productContour = null;
        }

        if (productName == 'Temp title') productName = '';

        content.updateData(productName, productContour);

        return productContour || productName != '';
    };

    body.className = 'product-hint-complex-body';

    content.addEventListener(Event.RESIZE, contentResizeEventHandler);

    body.appendChild(background.getDomElement());
    body.appendChild(content.getDomElement());
};

R2D.extend(R2D.ProductHint.Complex, R2D.DomElement);
// ui

R2D.ProductTransform2DButton = function() {
    var scope = this;
    var px = 0;
    var py = 0;
    var angle = 0;
    var size = 7;

    var div = document.createElement('div');

    function updateSize() {
        div.style.width = size + 'px';
        div.style.height = size + 'px';
    }
    function update() {
        div.style.left = Number(px - size / 2).toString() + 'px';
        div.style.top = Number(py - size / 2).toString() + 'px';
        div.style.transform = 'rotate(' + angle + 'rad)';
    }

    scope.getX = function() {
        return px;
    };
    scope.getY = function() {
        return py;
    };
    scope.getSize = function() {
        return size;
    };
    scope.setPosition = function(x, y) {
        px = x;
        py = y;
        update();
    };
    scope.setAngle = function(a) {
        angle = a;
        update();
    };
    scope.getDomElement = function () {
        return div;
    };
    scope.update = function(x, y, a) {
        px = x;
        py = y;
        angle = a;
        update();
    };
    scope.setSize = function(s) {
        size = s;
        updateSize();
    };

    div.className = 'tool-transform-2d-button';

    updateSize();
};

/*
R2D.ProductTransform2DButton = function() {
    var scope = this;
    var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    var isOver = false;
    var isDown = false;
    var px = 0;
    var py = 0;
    var angle = 0;
    var size = 10;

    function stateDown() {
        polygon.setAttribute('fill', '#33A40C');
        polygon.setAttribute('stroke', '#444444');
    }
    function stateOver() {
        polygon.setAttribute('fill', '#E6DA1E');
        polygon.setAttribute('stroke', '#444444');
    }
    function stateUp() {
        polygon.setAttribute('fill', '#ffffff');
        polygon.setAttribute('stroke', '#444444');
    }

    function mouseOut(event) {
        isOver = false;

        if ( !isDown ) stateUp();
    }
    function mouseOver(event) {
        isOver = true;

        if ( !isDown ) stateOver();
    }
    function mouseUp(event) {
        isDown = false;

        if ( isOver ) stateOver();
        else stateUp();

        R2D.MEC.removeListener(polygon, window, R2D.MEC.LEFT_MOUSE_UP, mouseUp);
        R2D.MEC.addListener(polygon, polygon, R2D.MEC.LEFT_MOUSE_DOWN, mouseDown);
    }
    function mouseDown(event) {
        isDown = true;

        stateDown();

        R2D.MEC.removeListener(polygon, polygon, R2D.MEC.LEFT_MOUSE_DOWN, mouseDown);
        R2D.MEC.addListener(polygon, window, R2D.MEC.LEFT_MOUSE_UP, mouseUp);
    }

    function update() {
        polygon.setAttribute('points', R2D.ProductTransform2DButton.makePolygon(px, py, angle, size));
    }

    scope.getX = function() {
        return px;
    };
    scope.getY = function() {
        return py;
    };
    scope.getSize = function() {
        return size;
    };
    scope.setPosition = function(x, y) {
        px = x;
        py = y;
        update();
    };
    scope.setAngle = function(a) {
        angle = a;
        update();
    };
    scope.update = function(x, y, a) {
        px = x;
        py = y;
        angle = a;
        update();
    };
    scope.setSize = function(s) {
        size = s;
        update();
    };
    scope.getDomElement = function() {
        return polygon;
    };

    R2D.MEC.addListener(polygon, polygon, R2D.MEC.LEFT_MOUSE_DOWN, mouseDown);
    R2D.MEC.addListener(polygon, polygon, R2D.MEC.MOUSE_OVER, mouseOver);
    R2D.MEC.addListener(polygon, polygon, R2D.MEC.MOUSE_OUT, mouseOut);

    polygon.setAttribute('class', 'tool-transform-2d-button');

    update();
    stateUp();
};

R2D.ProductTransform2DButton.makePolygon = function(x, y, angle, size) {
    angle += Math.PI / 4;

    var hs = size / 2;
    var ltx = x + Math.cos(angle + Math.PI) * hs;
    var lty = y + Math.sin(angle + Math.PI) * hs;
    var rtx = x + Math.cos(angle - Math.PI / 2) * hs;
    var rty = y + Math.sin(angle - Math.PI / 2) * hs;
    var rbx = x + Math.cos(angle) * hs;
    var rby = y + Math.sin(angle) * hs;
    var lbx = x + Math.cos(angle + Math.PI / 2) * hs;
    var lby = y + Math.sin(angle + Math.PI / 2) * hs;

    return ltx + ',' + lty + ' ' + rtx + ',' + rty + ' ' + rbx + ',' + rby + ' ' + lbx + ',' + lby;
};*/

//ui

R2D.ProductTransform2D = function() {
    EventDispatcher.call(this);

    var scope = this;
    var width = 800;
    var height = 600;

    var body = document.createElement('div');

    var buttonR = new R2D.ProductTransform2DButton();
    var buttonB = new R2D.ProductTransform2DButton();
    var buttonL = new R2D.ProductTransform2DButton();
    var buttonT = new R2D.ProductTransform2DButton();

    var objectX = 0;
    var objectY = 0;
    var objectWidth = 0;
    var objectHeight = 0;
    var objectRotation = 0;

    var minRealSize = 2;
    var minPixSize = 2;

    scope.updateScale = function(scale)
    {
        minPixSize = minRealSize * scale;
    };

    scope.updateButtons = () => {
        var w2 = objectWidth / 2;
        var h2 = objectHeight / 2;

        buttonR.update(objectX + Math.cos(objectRotation) * w2, objectY + Math.sin(objectRotation) * w2, objectRotation);
        buttonB.update(objectX + Math.cos(objectRotation + Math.PI / 2) * h2, objectY + Math.sin(objectRotation + Math.PI / 2) * h2, objectRotation);
        buttonL.update(objectX + Math.cos(objectRotation + Math.PI) * w2, objectY + Math.sin(objectRotation + Math.PI) * w2, objectRotation);
        buttonT.update(objectX + Math.cos(objectRotation - Math.PI / 2) * h2, objectY + Math.sin(objectRotation - Math.PI / 2) * h2, objectRotation);
    }

    function leftMouseMove(event) {
        var deltaX, deltaY;
        var lineAngle;
        var lineDistance, correctLineDistance;

        switch ( event.currentTarget ) {
            case buttonR:
                deltaX = event.clientX - buttonL.getX();
                deltaY = event.clientY - buttonL.getY();
                lineAngle = GEOM.angleAtan(deltaX, deltaY, true);
                lineDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                correctLineDistance = lineDistance * Math.cos(lineAngle - objectRotation);
                if (correctLineDistance < minPixSize) correctLineDistance = minPixSize;
                objectX = objectX + (correctLineDistance - objectWidth) / 2 * Math.cos(objectRotation);
                objectY = objectY + (correctLineDistance - objectWidth) / 2 * Math.sin(objectRotation);
                objectWidth = correctLineDistance;
                break;

            case buttonL:
                deltaX = event.clientX - buttonR.getX();
                deltaY = event.clientY - buttonR.getY();
                lineAngle = GEOM.angleAtan(deltaX, deltaY, true) - Math.PI;
                lineDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                correctLineDistance = lineDistance * Math.cos(lineAngle - objectRotation);
                if (correctLineDistance < minPixSize) correctLineDistance = minPixSize;
                objectX = objectX - (correctLineDistance - objectWidth) / 2 * Math.cos(objectRotation);
                objectY = objectY - (correctLineDistance - objectWidth) / 2 * Math.sin(objectRotation);
                objectWidth = correctLineDistance;

                break;

            case buttonB:
                deltaX = event.clientX - buttonT.getX();
                deltaY = event.clientY - buttonT.getY();
                lineAngle = GEOM.angleAtan(deltaX, deltaY, true) - Math.PI / 2;
                lineDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                correctLineDistance = lineDistance * Math.cos(lineAngle - objectRotation);
                if (correctLineDistance < minPixSize) correctLineDistance = minPixSize;
                objectX = objectX + (correctLineDistance - objectHeight) / 2 * Math.cos(objectRotation + Math.PI / 2);
                objectY = objectY + (correctLineDistance - objectHeight) / 2 * Math.sin(objectRotation + Math.PI / 2);
                objectHeight = correctLineDistance;
                break;

            case buttonT:
                deltaX = event.clientX - buttonB.getX();
                deltaY = event.clientY - buttonB.getY();
                lineAngle = GEOM.angleAtan(deltaX, deltaY, true) + Math.PI / 2;
                lineDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                correctLineDistance = lineDistance * Math.cos(lineAngle - objectRotation);
                if (correctLineDistance < minPixSize) correctLineDistance = minPixSize;
                objectX = objectX + (correctLineDistance - objectHeight) / 2 * Math.cos(objectRotation - Math.PI / 2);
                objectY = objectY + (correctLineDistance - objectHeight) / 2 * Math.sin(objectRotation - Math.PI / 2);
                objectHeight = correctLineDistance;
                break;

            default:
                throw "Error! Unknown button!";
        }

        scope.updateButtons();

        scope.dispatchEvent(new Event(R2D.ProductTransform2D.ACTION_PROGRESS, scope));
    }
    function leftMouseUp(event) {
        R2D.MEC.remove(event.currentTarget, window, R2D.MEC.MOUSE_MOVE, leftMouseMove);
        R2D.MEC.remove(event.currentTarget, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUp);

        scope.dispatchEvent(new Event(R2D.ProductTransform2D.ACTION_FINISH, scope));
    }
    function downOnButton(event) {
        R2D.MEC.add(event.currentTarget, window, R2D.MEC.MOUSE_MOVE, leftMouseMove);
        R2D.MEC.add(event.currentTarget, window, R2D.MEC.LEFT_MOUSE_UP, leftMouseUp);

        scope.dispatchEvent(new Event(R2D.ProductTransform2D.ACTION_START, scope));
    }

    function mouseWheelOnButton(event) {
        if ( event.deltaWheel == 0 ) return;

        let x = event.offsetX == undefined ? event.layerX : event.offsetX;
        let y = event.offsetY == undefined ? event.layerY : event.offsetY;

        R2D.mouseInteractionHelper._mouseController.dispatchEvent(new Event(Event.UPDATE, {
            type: R2D.MouseController.ZOOM,
            delta:event.deltaWheel,
            x,
            y
        }));
    }

    scope.useButtons = function(right, bottom, left, top) {
        if ( right && buttonR.getDomElement().parentNode == null ) {
            body.appendChild(buttonR.getDomElement());
        } else if ( !right && buttonR.getDomElement().parentNode != null ) {
            body.removeChild(buttonR.getDomElement());
        }
        if ( bottom && buttonB.getDomElement().parentNode == null ) {
            body.appendChild(buttonB.getDomElement());
        } else if ( !bottom && buttonB.getDomElement().parentNode != null ) {
            body.removeChild(buttonB.getDomElement());
        }
        if ( left && buttonL.getDomElement().parentNode == null ) {
            body.appendChild(buttonL.getDomElement());
        } else if ( !left && buttonL.getDomElement().parentNode != null ) {
            body.removeChild(buttonL.getDomElement());
        }
        if ( top && buttonT.getDomElement().parentNode == null ) {
            body.appendChild(buttonT.getDomElement());
        } else if ( !top && buttonT.getDomElement().parentNode != null ) {
            body.removeChild(buttonT.getDomElement());
        }
    };
    scope.getObjectX = function() {
        return objectX;
    };
    scope.getObjectY = function() {
        return objectY;
    };
    scope.getObjectWidth = function() {
        return objectWidth;
    };
    scope.getObjectHeight = function() {
        return objectHeight;
    };
    scope.getObjectRotation = function() {
        return objectRotation;
    };
    scope.setObjectData = function(x, y, w, h, r) {
        objectX = x;
        objectY = y;
        objectWidth = w;
        objectHeight = h;
        objectRotation = r;

        scope.updateButtons();
    };
    scope.getWidth = function() {
        return width;
    };
    scope.getHeight = function() {
        return height;
    };
    scope.setWidth = function(value) {
        if ( value == width ) return;

        width = value;
        body.style.width = width + 'px';
    };
    scope.setHeight = function(value) {
        if ( value == height ) return;

        height = value;
        body.style.height = width + 'px';
    };
    scope.setSize = function(w, h) {
        if ( w == width && h == height ) return;

        width = w;
        height = h;
        body.style.width = width + 'px';
        body.style.height = height + 'px';
    };
    scope.getDomElement = function() {
        return body;
    };

    body.className = 'tool-transform-2d-svg';

    R2D.MEC.addListener(buttonR, buttonR.getDomElement(), R2D.MEC.LEFT_MOUSE_DOWN, downOnButton);
    R2D.MEC.addListener(buttonB, buttonB.getDomElement(), R2D.MEC.LEFT_MOUSE_DOWN, downOnButton);
    R2D.MEC.addListener(buttonL, buttonL.getDomElement(), R2D.MEC.LEFT_MOUSE_DOWN, downOnButton);
    R2D.MEC.addListener(buttonT, buttonT.getDomElement(), R2D.MEC.LEFT_MOUSE_DOWN, downOnButton);

    R2D.MEC.addListener(buttonR, buttonR.getDomElement(), R2D.MEC.MOUSE_WHEEL, mouseWheelOnButton);
    R2D.MEC.addListener(buttonB, buttonB.getDomElement(), R2D.MEC.MOUSE_WHEEL, mouseWheelOnButton);
    R2D.MEC.addListener(buttonL, buttonL.getDomElement(), R2D.MEC.MOUSE_WHEEL, mouseWheelOnButton);
    R2D.MEC.addListener(buttonT, buttonT.getDomElement(), R2D.MEC.MOUSE_WHEEL, mouseWheelOnButton);

    scope.updateButtons();
};

R2D.extend(R2D.ProductTransform2D, EventDispatcher);

R2D.ProductTransform2D.ACTION_START = 'actionStart';
R2D.ProductTransform2D.ACTION_PROGRESS = 'actionProgress';
R2D.ProductTransform2D.ACTION_FINISH = 'actionFinish';

TConf = {};

TConf.DONE = 'TConfDone';
TConf.CLEAR = 'TConfClear';
TConf.UNDO = 'TConfUndo';
TConf.REDO = 'TConfRedo';
TConf.SPLIT_HOR = 'TConfSplitHor';
TConf.SPLIT_VER = 'TConfSplitVer';

TConf.TileConfig = function()
{
    //R2D.DialogStage.WindowBase.call(this);

    var me = this;

    var field = new TConf.Field();
    var editor = new TConf.Editor(field);
    var rPanel = null;//new TConf.RightPanel();
    var rPage = null;
    var lPanel = null;
    var tPanel = null;

    var contDiv = document.createElement('div');
    contDiv.classList.add('TConfMain');

    contDiv.appendChild(editor.getDomElement());

    //parentDiv.innerHTML = '';
    //parentDiv.appendChild(contDiv);

    init();

    function init()
    {
        // var productHint = new R2D.ProductHint();
        // rPanel = new R2D.RightPanel(productHint);
        // rPanel.addEventListener(R2D.RightPanel.HIDE, rPanelListener);
        // rPanel.addEventListener(R2D.RightPanel.SHOW, rPanelListener);
        // rPanel.getDomElement().addEventListener('wheel', function(event){
        //     event.stopPropagation();
        //     event.preventDefault();
        // }, false);

        // contDiv.appendChild(rPanel.getDomElement());

        // rPage = new TConf.RightPage();
        // rPanel.addPage(rPage);
        // rPanel.getNavigation().setActiveBack(true);
        // rPanel.getNavigation().setCustomBackAction(doneListener);

        // rPage.addEventListener(TConf.DONE, doneListener);
        // rPage.addEventListener(TConf.CLEAR, clearListener);
        // rPage.addEventListener(TConf.SPLIT_VER, splitVertListener);
        // rPage.addEventListener(TConf.SPLIT_HOR, splitHorListener);

        // lPanel = new R2D.LeftPanel();
        // var zoomIn = new R2D.LeftPanel.Element(R2D.STYLE.LP_ICON_ZOOM_IN);
        // var zoomOut = new R2D.LeftPanel.Element(R2D.STYLE.LP_ICON_ZOOM_OUT);
        // lPanel.addElement(zoomIn);
        // lPanel.addElement(zoomOut);
        // contDiv.appendChild(lPanel.getDomElement());

        // zoomIn.setHint('HINT_BUTTON_ZOOM_PLUS');
        // zoomOut.setHint('HINT_BUTTON_ZOOM_MINUS');

        // zoomIn.addLeftMouseClickListener(zoomInListener);
        // zoomOut.addLeftMouseClickListener(zoomOutListener);

        // tPanel = new TConf.TopPanel();
        // contDiv.appendChild(tPanel.getDomElement());
        // tPanel.addEventListener(TConf.UNDO, tPanelUndoListener);
        // tPanel.addEventListener(TConf.REDO, tPanelRedoListener);
        // tPanel.addEventListener(Event.CHANGE, tPanelChangeListener);
        editor.history.addEventListener(TConf.History.CHANGED, historyChangedListener);
    }

    function tPanelUndoListener()
    {
        if (editor.history.canUndo()) editor.history.undo();
        editor.draw();
    }

    function tPanelRedoListener()
    {
        if (editor.history.canRedo()) editor.history.redo();
        editor.draw();
    }

    function tPanelChangeListener()
    {
        editor.draw();
    }

    function historyChangedListener()
    {
        tPanel.setUndoActive(editor.history.canUndo());
        tPanel.setRedoActive(editor.history.canRedo());
    }

    function zoomInListener()
    {
        editor.zoom(editor.canvasWidth / 2, editor.canvasHeight / 2, 2);
    }

    function zoomOutListener()
    {
        editor.zoom(editor.canvasWidth / 2, editor.canvasHeight / 2, -2);
    }

    function doneListener()
    {
        me.dispatchEvent(new Event(TConf.TILE_CONFIG_DONE));
    }

    me.clearListener = () =>
    {
        editor.field.clearAll();
        editor.history.save();
        editor.draw();
    }

    function cancel()
    {
        editor.history.toFirstState();
        doneListener();
    }

    me.splitVertListener = () =>
    {
        editor.field.splitArea(editor.field.activeArea, TConf.Delimiter.VER);
        editor.history.save();
        editor.draw();
    }

    me.splitHorListener = () =>
    {
        editor.field.splitArea(editor.field.activeArea, TConf.Delimiter.HOR);
        editor.history.save();
        editor.draw();
    }

    function rPanelListener(event) {
        switch ( event.type ) {
            case R2D.RightPanel.SHOW:
            case R2D.RightPanel.HIDE:
                resizeListener();
                break;
        }
    }

    me.getDomElement = function()
    {
        return contDiv;
    };

    me.setSize = function(width, height)
    {
        let rightPanelWidth = window.innerWidth < 1000 ? 200 : 270;

        contDiv.style.width = width + 'px';
        contDiv.style.height = height + 'px';

        // rPanel.setX(rPanel.isShow ? width - rightPanelWidth : width);
        // rPanel.setSize(rightPanelWidth, height);

        // lPanel.setX(0);
        // lPanel.setY(height / 2 - 25);

        editor.setSize(width - rightPanelWidth, height);
        editor.draw();
    };

    me.setWallSize = function(width, height)
    {
        editor.setWallSize(width, height);
        editor.draw();
    };

    me.getData = function()
    {
        return field.getData();
    };

    me.getTiles = function(h, w, faceRight)
    {
        return field.getTiles(h, w, faceRight);
    };

    me.setDefaultMaterial = function(matID, addMatID)
    {
        field.setDefaultMaterial(matID, addMatID);
    };

    me.setData = function(data)
    {
        field.setData(data);
        editor.draw();
        editor.history.clear();
        editor.history.save();
    };

    me.destroy = function()
    {
        editor.destroy();
        window.removeEventListener('resize', resizeListener);
    };

    window.addEventListener('resize', resizeListener);

    function resizeListener(e)
    {
        me.setSize(document.body.clientWidth, document.body.clientHeight);
    }

    me.getTileEditor = () => editor;

    field.calcAreas();
    me.setSize(document.body.clientWidth, document.body.clientHeight);
};

// R2D.extend(TConf.TileConfig, R2D.DialogStage.WindowBase);

TConf.TILE_CONFIG_DONE = 'TileConfigDone';
TConf.Field = function()
{
    let me = this;
    EventDispatcher.call(this);

    me.width = 400;
    me.height = 250;
    me.areas = [];
    me.activeArea = null;
    me.delimiters = [];

    me.clearAll = function()
    {
        let ar1 = new TConf.Area();
        me.areas = [ar1];
        me.activeArea = ar1;
        me.delimiters = [];
        me.calcAreas();
    };

    me.setSize = function(width, height)
    {
        me.width = width;
        me.height = height;

        me.calcAreas();

        let L = me.delimiters.length;
        for (let i = 0; i < L; i++)
        {
            let d = me.delimiters[i];

            if (d.type == TConf.Delimiter.HOR)
            {
                if (d.pos >= height || (d.parent1 && d.parent1.pos >= width)) {
                    me.delimiters.splice(i, 1);
                    if (d.parent1) d.parent1.children.splice(d.parent1.children.indexOf(d), 1);
                    if (d.parent2) d.parent2.children.splice(d.parent2.children.indexOf(d), 1);
                    i--;
                    L--;
                    continue
                }

                if (d.parent2 && d.parent2.pos >= width) {
                    d.parent2 = null;
                }
            }
            else // d.type == TConf.Delimiter.VER
            {
                if (d.pos >= width || (d.parent1 && d.parent1.pos >= height)) {
                    me.delimiters.splice(i, 1);
                    if (d.parent1) d.parent1.children.splice(d.parent1.children.indexOf(d), 1);
                    if (d.parent2) d.parent2.children.splice(d.parent2.children.indexOf(d), 1);
                    i--;
                    L--;
                    continue
                }

                if (d.parent2 && d.parent2.pos >= height) {
                    d.parent2 = null;
                }
            }
        }

        L = me.areas.length;
        for (i = 0; i < L; i++)
        {
            let area = me.areas[i];
            if (area.minX > width || area.minY > height)
            {
                me.areas.splice(i, 1);
                i--;
                L--;
                continue;
            }

            if (me.delimiters.indexOf(area.delimiters.right) < 0) area.delimiters.right = null;
            if (me.delimiters.indexOf(area.delimiters.bottom) < 0) area.delimiters.bottom = null;
        }

        me.calcAreas();

        for (i = 0; i < me.areas.length; i++)
        {
            removeOutsideTiles(me.areas[i]);
        }
    };

    function removeOutsideTiles(area)
    {
        let L = area.tiles.length;
        for (let j = 0; j < L; j++)
        {
            let tile = area.tiles[j];
            let mat = tile.material;

            let A = me.areaToReal(new TConf.Point(tile.x - mat.width / 2, tile.y - mat.height / 2), area);
            let B = me.areaToReal(new TConf.Point(tile.x + mat.width / 2, tile.y - mat.height / 2), area);
            let C = me.areaToReal(new TConf.Point(tile.x + mat.width / 2, tile.y + mat.height / 2), area);
            let D = me.areaToReal(new TConf.Point(tile.x - mat.width / 2, tile.y + mat.height / 2), area);

            let tileMinX = Math.min(A.x, B.x, C.x, D.x);
            let tileMaxX = Math.max(A.x, B.x, C.x, D.x);
            let tileMinY = Math.min(A.y, B.y, C.y, D.y);
            let tileMaxY = Math.max(A.y, B.y, C.y, D.y);

            if (tileMaxX < area.minX || tileMinX > area.maxX || tileMaxY < area.minY || tileMinY > area.maxY)
            {
                area.tiles.splice(j, 1);
                L--;
                j--;
            }
        }
    }

    me.calcAreas = function()
    {
        for (let i = 0; i < me.areas.length; i++)
        {
            let area = me.areas[i];
            let l = 0;
            let r = me.width;
            let t = 0;
            let b = me.height;

            if (area.delimiters.left) l = area.delimiters.left.pos;
            if (area.delimiters.right) r = area.delimiters.right.pos;
            if (area.delimiters.top) t = area.delimiters.top.pos;
            if (area.delimiters.bottom) b = area.delimiters.bottom.pos;

            area.contour = [new TR.Point(l, t), new TR.Point(r, t),
                            new TR.Point(r, b), new TR.Point(l, b)];

            area.minX = l;
            area.maxX = r;
            area.minY = t;
            area.maxY = b;
        }
        
    };

    me.createTile = function(material, x, y)
    {
        let t = new TConf.Tile();
        t.material = material;
        t.x = x;
        t.y = y;
        me.activeArea.tiles.push(t);

        me.dispatchEvent(new Event(TConf.FIELD_CHANGED));
    };

    me.clearArea = function(area)
    {
        area.removeAllTiles();
        me.dispatchEvent(new Event(TConf.FIELD_CHANGED));
    };

    me.autoFillAll = function()
    {
        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].defMaterial) me.autoFill(me.areas[i]);
        }
    };

    me.autoFill = function(area, mat)
    {
        let material = mat;
        if (! material) material = area.defMaterial;

        area.defMaterial = material;

        if (material)
        {
            let P1 = me.realToArea(new TConf.Point(area.minX, area.minY), area);
            let P2 = me.realToArea(new TConf.Point(area.minX, area.maxY), area);
            let P3 = me.realToArea(new TConf.Point(area.maxX, area.maxY), area);
            let P4 = me.realToArea(new TConf.Point(area.maxX, area.minY), area);

            let minX = Math.min(P1.x, P2.x, P3.x, P4.x);
            let maxX = Math.max(P1.x, P2.x, P3.x, P4.x);
            let minY = Math.min(P1.y, P2.y, P3.y, P4.y);
            let maxY = Math.max(P1.y, P2.y, P3.y, P4.y);

            let stepX = material.width + area.margin;
            let stepY = material.height + area.margin;

            minX = Math.round(minX / stepX) * stepX;
            maxX = Math.round(maxX / stepX) * stepX;
            minY = Math.round(minY / stepY) * stepY;
            maxY = Math.round(maxY / stepY) * stepY;

            let xn = (maxX - minX) / (stepX) + 1;
            let yn = (maxY - minY) / (stepY) + 1;

            area.removeAllTiles();

            for (let i = -xn - 2; i < xn + 2; i++)
            {
                for (let j = -yn - 2; j < yn + 2; j++)
                {
                    let t = new TConf.Tile();
                    t.material = material;
                    t.x = minX + (material.width + area.margin) * i;
                    t.y = minY + (material.height + area.margin) * j;
                    area.tiles.push(t);
                }
            }

            removeOutsideTiles(area);
        }

        if (area.random) area.randomRotate();

        me.dispatchEvent(new Event(TConf.FIELD_CHANGED));
    };

    me.getTiles = function(h, w, faceRight)
    {
        let groupByMat = {};
        let res = [];
        for (let i = 0; i < me.areas.length; i++)
        {
            let areaCont;
            if (faceRight)
            {
                areaCont = TR.flipPoints(me.areas[i].contour, false, true, 0, h);
            }
            else
            {
                areaCont = TR.flipPoints(me.areas[i].contour, true, true, w, h);
            }
            let tileContours = [];

            for (let j = 0; j < me.areas[i].tiles.length; j++)
            {
                let tile = me.areas[i].tiles[j];
                let mat = tile.material;
                if (! (mat.id in groupByMat)) groupByMat[mat.id] = [];

                let A = me.areaToReal(new TConf.Point(tile.x - mat.width / 2, tile.y - mat.height / 2), me.areas[i]);
                let B = me.areaToReal(new TConf.Point(tile.x + mat.width / 2, tile.y - mat.height / 2), me.areas[i]);
                let C = me.areaToReal(new TConf.Point(tile.x + mat.width / 2, tile.y + mat.height / 2), me.areas[i]);
                let D = me.areaToReal(new TConf.Point(tile.x - mat.width / 2, tile.y + mat.height / 2), me.areas[i]);

                let tileCont;
                if (faceRight)
                {
                    tileCont = TR.flipPoints([A, B, C, D], false, true, 0, h);
                }
                else
                {
                    tileCont = TR.flipPoints([A, B, C, D], true, true, w, h);
                }

                tileContours.push(tileCont);

                let dataTile = {outerContours: [tileCont],
                                innerContours: [],
                                boundContours: [areaCont],
                                materialID: mat.id,
                                addMaterialID: mat.addId || mat.addMatId,
                                //color: null,
                                rotation: tile.rotation,/*-me.areas[i].angle + tile.rotation*/
                                flip: tile.flip,
                                fixUV: true,
                                id: 'disable',
                                isTile: true}; // == shift

                groupByMat[mat.id].push(dataTile);
            }

            let partID = me.areas[i].id;
            if (me.areas[i].tiles.length > 0) partID = 'disable';

            let matID = me.areas[i].matID;
            if (! matID || matID == '' || matID == 0 || matID == '0') matID = me.areas[i].color;
            let addMatID = me.areas[i].addMatID;
            let dataExceptTile = {outerContours: [areaCont], //+ type, +rotation
                                  innerContours: [], //tileContours,
                                  boundContours: [],
                                  //materialID: me.areas[i].matID,
                                  //color: me.areas[i].color,
                                  materialID: matID,
                                  addMaterialID: addMatID,
                                  rotation: me.areas[i].matRotation,
                                  materialX: me.areas[i].shiftX,
                                  materialY: me.areas[i].shiftY,
                                  centerX: (me.areas[i].maxX + me.areas[i].minX) / 2,
                                  centerY: me.height - (me.areas[i].maxY + me.areas[i].minY) / 2,
                                  fixUV: false,
                                  id: partID,
                                  isTile: false};

            res.push([dataExceptTile]);
        }

        for (let km in groupByMat)
        {
            res.push(groupByMat[km]);
        }
        return res;
    };

    me.getEstimateTotal = function()
    {
        let groupByMat = {};
        for (let i = 0; i < me.areas.length; i++)
        {
            for (let j = 0; j < me.areas[i].tiles.length; j++)
            {
                let mat = me.areas[i].tiles[j].material;
                if (mat.id in groupByMat)
                {
                    groupByMat[mat.id] += 1;
                }
                else
                {
                    groupByMat[mat.id] = 1;
                }
            }
        }

        return groupByMat;
    };

    me.getEstimateActive = function()
    {
        let groupByMat = {};

        for (let j = 0; j < me.activeArea.tiles.length; j++)
        {
            let mat = me.activeArea.tiles[j].material;
            if (mat.id in groupByMat)
            {
                groupByMat[mat.id] += 1;
            }
            else
            {
                groupByMat[mat.id] = 1;
            }
        }

        return groupByMat;
    };

    me.getTilesInContour = function(contour)
    {
        let area = me.activeArea;
        let res = [];
        for (let i = 0; i < area.tiles.length; i++)
        {
            let tile = area.tiles[i];
            let mat = tile.material;

            let inContour = TR.pointInContour(new TConf.Point(tile.x - mat.width / 2, tile.y - mat.height / 2), contour) ||
                            TR.pointInContour(new TConf.Point(tile.x + mat.width / 2, tile.y - mat.height / 2), contour) ||
                            TR.pointInContour(new TConf.Point(tile.x + mat.width / 2, tile.y + mat.height / 2), contour) ||
                            TR.pointInContour(new TConf.Point(tile.x - mat.width / 2, tile.y + mat.height / 2), contour) ||
                    TR.pointInContour(contour[0], [new TConf.Point(tile.x - mat.width / 2, tile.y - mat.height / 2),
                                                   new TConf.Point(tile.x + mat.width / 2, tile.y - mat.height / 2),
                                                   new TConf.Point(tile.x + mat.width / 2, tile.y + mat.height / 2),
                                                   new TConf.Point(tile.x - mat.width / 2, tile.y + mat.height / 2)]);

            if (inContour) res.push(tile);
        }
        return res;
    };

    me.removeTiles = function(tiles)
    {
        for (let i = 0; i < tiles.length; i++)
        {
            for (let j = 0; j < me.areas.length; j++)
            {
                let arr = me.areas[j];
                let ind = arr.tiles.indexOf(tiles[i]);
                if (ind >= 0) arr.tiles.splice(ind, 1);
            }
        }

        me.dispatchEvent(new Event(TConf.FIELD_CHANGED));
    };

    me.getAreaByPoint = function(P)
    {
        for (let i = 0; i < me.areas.length; i++)
        {
            let a = me.areas[i];
            if (P.x >= a.minX && P.x <= a.maxX && P.y >= a.minY && P.y <= a.maxY) return a;
        }
        return null;
    };

    function init()
    {
        let ar1 = new TConf.Area();
        me.areas = [ar1];
        me.activeArea = ar1;
    }

    init();

    me.setActiveArea = function(area)
    {
        me.activeArea = area;
        me.dispatchEvent(new Event(TConf.FIELD_CHANGED));
    };

    me.setData = function(data)
    {
        let dataClone = data.getData();
        me.areas = dataClone.areas;
        me.delimiters = dataClone.delimiters;
        me.activeArea = me.areas[0];

        me.calcAreas();
    };

    me.setDefaultMaterial = function(matID, addMatID)
    {
        if (matID && matID.length > 0)
        {
            if (matID.startsWith('#'))
            {
                me.areas[0].color = matID;
            }
            else
            {
                me.areas[0].matID = matID;
            }
        }
        else
        {
            me.areas[0].matID = '2013';
        }
        if(addMatID) {
            me.areas[0].addMatID = addMatID;
        }
        else {
            me.areas[0].addMatID = "";
        }
    };

    function resetIDs()
    {
        let n = 1;
        for (let i = 0; i < me.delimiters.length; i++)
        {
            me.delimiters[i].id = String(n);
            n += 1;
        }

        n = 1;
        for (i = 0; i < me.areas.length; i++)
        {
            me.areas[i].id = String(n);
            n += 1;
        }
    }

    me.getData = function()
    {
        
        resetIDs();
        let res = new TConf.Field();
        let orig;
        let twin;
        res.areas = new Array(me.areas.length);
        res.delimiters = new Array(me.delimiters.length);
        res.width = me.width;
        res.height = me.height;

        for (let i = 0; i < me.delimiters.length; i++)
        {
            let delimiterCopy = me.delimiters[i].clone();
            res.delimiters[i] = delimiterCopy;
            me.delimiters[i].twin = delimiterCopy;
        }

        for (let i = 0; i < res.delimiters.length; i++)
        {
            orig = me.delimiters[i];
            twin = res.delimiters[i];
            if (orig.parent1) twin.parent1 = orig.parent1.twin;
            if (orig.parent2) twin.parent2 = orig.parent2.twin;
            twin.children = new Array(orig.children.length);

            for (let j = 0; j < orig.children.length; j++)
            {
                twin.children[j] = orig.children[j].twin;
            }
        }

        for (let i = 0; i < me.areas.length; i++)
        {
            
            orig = me.areas[i];
            twin = orig.clone();
            res.areas[i] = twin;
            res.areas[i].addMatID = me.areas[i].addMatID;
            if (orig.delimiters.top) twin.delimiters.top = orig.delimiters.top.twin;
            if (orig.delimiters.bottom) twin.delimiters.bottom = orig.delimiters.bottom.twin;
            if (orig.delimiters.left) twin.delimiters.left = orig.delimiters.left.twin;
            if (orig.delimiters.right) twin.delimiters.right = orig.delimiters.right.twin;
        }
        
        return res;
        
    };

    me.areaToReal = function(P, area)
    {
        let transformed = TR.rotateXY(P.x, P.y, -area.angle);
        return new TConf.Point(transformed[0] - area.shiftX, transformed[1] - area.shiftY);
    };

    me.realToArea = function(P, area)
    {
        let transformed = TR.rotateXY(P.x + area.shiftX, P.y + area.shiftY, area.angle);
        return new TConf.Point(transformed[0], transformed[1]);
    };

    function delimEndsPos(delim)
    {
        let start = 0;
        let end = 0;
        if (delim.type == TConf.Delimiter.VER)
        {
            end = me.height;
        }
        else
        {
            end = me.width;
        }

        if (delim.parent1) start = delim.parent1.pos;
        if (delim.parent2) end = delim.parent2.pos;

        return [start, end];
    }

    function delimOverlay(d1, d2) // d1 in bounds of d2
    {
        let bounds = delimEndsPos(d2);
        if (d1.type == d2.type)
        {
            let endsOf1 = delimEndsPos(d1);
            if (endsOf1[0] < bounds[1] && endsOf1[1] > bounds[0]) return true;
        }
        else
        {
            return false;
        }
    }

    me.getDelimiterBounds = function(delim)
    {
        let min = 0;
        let max = 0;
        if (delim.type == TConf.Delimiter.VER)
        {
            max = me.width;
        }
        else
        {
            max = me.height;
        }

        for (let i = 0; i < me.delimiters.length; i++)
        {
            let d = me.delimiters[i];
            if (d == delim) continue;
            if (delimOverlay(d, delim))
            {
                if (d.pos < delim.pos && d.pos > min) min = d.pos;
                if (d.pos > delim.pos && d.pos < max) max = d.pos;
            }
        }

        return [min, max];
    };

    me.mergeAreas = function(delimiter)
    {
        let delimitersToRemove = [];
        let areasToRemove = [];
        function addToRemove(delim)
        {
            delimitersToRemove.push(delim);
            for (let i = 0; i < delim.children.length; i++)
            {
                addToRemove(delim.children[i]);
            }
        }

        addToRemove(delimiter);

        for (let i = 0; i < me.areas.length; i++)
        {
            let a = me.areas[i];
            if (delimitersToRemove.includes(a.delimiters.left) ||
                delimitersToRemove.includes(a.delimiters.right) ||
                delimitersToRemove.includes(a.delimiters.top) ||
                delimitersToRemove.includes(a.delimiters.bottom))
            {
                areasToRemove.push(a);
            }
        }

        let newArea = new TConf.Area();
        newArea.color = areasToRemove[0].color;
        newArea.matID = areasToRemove[0].matID;
        newArea.addMatID = areasToRemove[0].addMatID;

        let bordersLR = []; // == [[pos, delimiter], [0, null] ...]
        let bordersTB = [];
        for (i = 0; i < areasToRemove.length; i++)
        {
            a = areasToRemove[i];
            if (! a.delimiters.left)
            {
                bordersLR.push([0, null]);
            }
            else if (! delimitersToRemove.includes(a.delimiters.left))
            {
                bordersLR.push([a.delimiters.left.pos, a.delimiters.left]);
            }

            if (! a.delimiters.right)
            {
                bordersLR.push([me.width, null]);
            }
            else if (! delimitersToRemove.includes(a.delimiters.right))
            {
                bordersLR.push([a.delimiters.right.pos, a.delimiters.right]);
            }

            if (! a.delimiters.top)
            {
                bordersTB.push([0, null]);
            }
            else if (! delimitersToRemove.includes(a.delimiters.top))
            {
                bordersTB.push([a.delimiters.top.pos, a.delimiters.top]);
            }

            if (! a.delimiters.bottom)
            {
                bordersTB.push([me.height, null]);
            }
            else if (! delimitersToRemove.includes(a.delimiters.bottom))
            {
                bordersTB.push([a.delimiters.bottom.pos, a.delimiters.bottom]);
            }
        }

        let bl = bordersLR[0];
        let br = bordersLR[0];
        let bt = bordersTB[0];
        let bb = bordersTB[0];

        for (i = 0; i < bordersLR.length; i++)
        {
            let b = bordersLR[i];
            if (b[0] < bl[0]) bl = b;
            if (b[0] > br[0]) br = b;
        }

        for (i = 0; i < bordersTB.length; i++)
        {
            b = bordersTB[i];
            if (b[0] < bt[0]) bt = b;
            if (b[0] > bb[0]) bb = b;
        }

        newArea.delimiters.left = bl[1];
        newArea.delimiters.right = br[1];
        newArea.delimiters.top = bt[1];
        newArea.delimiters.bottom = bb[1];

        let L = me.areas.length;
        for (i = 0; i < L; i++)
        {
            if (areasToRemove.includes(me.areas[i]))
            {
                me.areas.splice(i, 1);
                i--;
                L--;
            }
        }

        L = me.delimiters.length;
        for (i = 0; i < L; i++)
        {
            if (delimitersToRemove.includes(me.delimiters[i]))
            {
                me.delimiters.splice(i, 1);
                i--;
                L--;
            }
        }

        for (i = 0; i < me.delimiters.length; i++)
        {
            let ch = me.delimiters[i].children;

            L = ch.length;
            for (let j = 0; j < L; j++)
            {
                if (delimitersToRemove.includes(ch[j]))
                {
                    ch.splice(j, 1);
                    j--;
                    L--;
                }
            }
        }

        me.areas.push(newArea);
        me.activeArea = newArea;
        me.calcAreas();
    };

    me.splitArea = function(area, how)
    {
        let newArea = new TConf.Area();
        newArea.matID = matIDs[matIndex];
        
        newArea.addMatID = R2D.default.getDefaultAddMaterialByKey("cap");
        matIndex = (matIndex + 1) % matIDs.length;

        if (how == TConf.Delimiter.HOR)
        {
            if (area.maxX - area.minX <= 5) return;

            let newDelim = new TConf.Delimiter(TConf.Delimiter.VER, (area.minX + area.maxX) / 2);

            if (area.delimiters.top)
            {
                newArea.delimiters.top = area.delimiters.top;
                newDelim.parent1 = area.delimiters.top;
                area.delimiters.top.children.push(newDelim);
            }
            if (area.delimiters.bottom)
            {
                newArea.delimiters.bottom = area.delimiters.bottom;
                newDelim.parent2 = area.delimiters.bottom;
                area.delimiters.bottom.children.push(newDelim);
            }

            newArea.delimiters.right = area.delimiters.right;
            area.delimiters.right = newDelim;
            newArea.delimiters.left = newDelim;

            me.areas.push(newArea);
            me.delimiters.push(newDelim);
        }
        else if (how == TConf.Delimiter.VER)
        {
            if (area.maxY - area.minY <= 5) return;

            newDelim = new TConf.Delimiter(TConf.Delimiter.HOR, (area.minY + area.maxY) / 2);

            if (area.delimiters.left)
            {
                newArea.delimiters.left = area.delimiters.left;
                newDelim.parent1 = area.delimiters.left;
                area.delimiters.left.children.push(newDelim);
            }
            if (area.delimiters.right)
            {
                newArea.delimiters.right = area.delimiters.right;
                newDelim.parent2 = area.delimiters.right;
                area.delimiters.right.children.push(newDelim);
            }

            newArea.delimiters.bottom = area.delimiters.bottom;
            area.delimiters.bottom = newDelim;
            newArea.delimiters.top = newDelim;

            me.areas.push(newArea);
            me.delimiters.push(newDelim);
        }
        
        me.calcAreas();
        
    };

    me.setMaterialByID = function(matID, partID)
    {
        if (partID == 'disable') return false;

        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                me.areas[i].matID = matID;
                return true;
            }
        }

        return false;
    };

    me.setAddMaterialByID = function(addMatID, partID)
    {
        if (partID == 'disable') return false;

        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                me.areas[i].addMatID = addMatID;
                return true;
            }
        }

        return false;
    };

    me.getMaterialByID = function(partID)
    {
        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                let matID = me.areas[i].matID ? me.areas[i].matID : me.areas[i].color ? me.areas[i].color : "";
                return matID;
            }
        }

        return false;
    };
    me.getAddMaterialByID = function(partID)
    {
        
        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                return me.areas[i].addMatID;
            }
        }

        return false;
    };

    me.getRotationByID = function(partID)
    {
        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                return me.areas[i].matRotation
            }
        }
    };

    me.getShiftByID = function(partID)
    {
        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                return [me.areas[i].shiftX, me.areas[i].shiftY];
            }
        }
    };

    me.setRotationByID = function(r, partID)
    {
        if (partID == 'disable') return false;

        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                //me.areas[i].shiftX = (me.areas[i].minX + me.areas[i].maxX) / 2;
                //me.areas[i].shiftY = me.height - (me.areas[i].minY + me.areas[i].maxY) / 2;
                me.areas[i].matRotation = r;
                return true;
            }
        }

        return false;
    };

    me.setShiftByID = function(shift, partID)
    {
        if (partID == 'disable') return false;

        for (let i = 0; i < me.areas.length; i++)
        {
            if (me.areas[i].id == partID)
            {
                me.areas[i].shiftX = shift[0];
                me.areas[i].shiftY = shift[1];
                return true;
            }
        }

        return false;
    };

    me.toData = function()
    {
        resetIDs();

        let struct = {
            w: me.width,
            h: me.height,
            areas: [],
            delimiters: []
        };

        for (let i = 0; i < me.areas.length; i++)
        {
            let area = me.areas[i];
            let dataArea = area.toStruct();
            if (area.delimiters.left) dataArea.delimiters.l = area.delimiters.left.id;
            if (area.delimiters.right) dataArea.delimiters.r = area.delimiters.right.id;
            if (area.delimiters.top) dataArea.delimiters.t = area.delimiters.top.id;
            if (area.delimiters.bottom) dataArea.delimiters.b = area.delimiters.bottom.id;
            dataArea.addM = me.areas[i].addMatID;
            struct.areas.push(dataArea);
        }

        for (i = 0; i < me.delimiters.length; i++)
        {
            let delimiter = me.delimiters[i];
            let dataDel = delimiter.toStruct();
            dataDel.id = delimiter.id;
            if (delimiter.parent1) dataDel.pr1 = delimiter.parent1.id;
            if (delimiter.parent2) dataDel.pr2 = delimiter.parent2.id;

            for (let j = 0; j < delimiter.children.length; j++) dataDel.ch.push(delimiter.children[j].id);
            struct.delimiters.push(dataDel);
        }

        return struct;
    };

    me.fromData = function(struct)
    {
        me.areas = [];
        me.delimiters = [];

        let delimDict = {};
        for (let i = 0; i < struct.delimiters.length; i++)
        {
            let delim = new TConf.Delimiter();
            delim.fromStruct(struct.delimiters[i]);
            me.delimiters.push(delim);
            delimDict[struct.delimiters[i].id] = delim;
        }

        for (i = 0; i < me.delimiters.length; i++)
        {
            delim = me.delimiters[i];
            let dd = struct.delimiters[i];
            if (dd.pr1 > 0) delim.parent1 = delimDict[dd.pr1];
            if (dd.pr2 > 0) delim.parent2 = delimDict[dd.pr2];

            for (let j = 0; j < dd.ch.length; j++)
            {
                delim.children.push(delimDict[dd.ch[j]]);
            }
        }

        for (i = 0; i < struct.areas.length; i++)
        {
            let da = struct.areas[i];
            let area = new TConf.Area();
            area.fromStruct(da);
            if (da.delimiters.l > 0) area.delimiters.left = delimDict[da.delimiters.l];
            if (da.delimiters.r > 0) area.delimiters.right = delimDict[da.delimiters.r];
            if (da.delimiters.t > 0) area.delimiters.top = delimDict[da.delimiters.t];
            if (da.delimiters.b > 0) area.delimiters.bottom = delimDict[da.delimiters.b];

            me.areas.push(area);
        }
        me.calcAreas();

        me.autoFillAll();

        me.setSize(struct.w, struct.h);
    };

    let matIDs = ['#ececec', '#e4e4e4', '#dcdcdc', '#d4d4d4',
                  '#e8e8e8', '#e0e0e0', '#d8d8d8', '#d0d0d0'];
    //let matIDs = ['1186', '1187', '1064', '1066', '1189', '3197', '3207'];
    let matIndex = 0;
};

TConf.Field.prototype = Object.create(EventDispatcher.prototype);
TConf.Field.prototype.constructor = TConf.Field;

TConf.FIELD_CHANGED = 'FieldChanged';

TConf.Material = function(id, path, width, height)
{
    var me = this;

    me.id = id;
    me.width = width;
    me.height = height;
    me.ready = false;

    me.image = new Image;
    me.image.onload = function()
    {
        findTransformations();
        me.ready = true;
    };
    me.image.src = path;

    var img0 = document.createElement('canvas');
    var img90 = document.createElement('canvas');
    var img180 = document.createElement('canvas');
    var img270 = document.createElement('canvas');
    var imgF = document.createElement('canvas');
    var img90F = document.createElement('canvas');
    var img180F = document.createElement('canvas');
    var img270F = document.createElement('canvas');

    function findTransformations()
    {
        var w = me.image.width;
        var h = me.image.height;

        img0.width = w;
        img0.height = h;
        img90.width = w;
        img90.height = h;
        img180.width = w;
        img180.height = h;
        img270.width = w;
        img270.height = h;
        imgF.width = w;
        imgF.height = h;
        img90F.width = w;
        img90F.height = h;
        img180F.width = w;
        img180F.height = h;
        img270F.width = w;
        img270F.height = h;

        var context = img0.getContext('2d');
        //context.globalAlpha = 0.4;
        context.drawImage(me.image, 0, 0);
        //context.globalAlpha = 1;
        //context.drawImage(me.image, -4, -4);

        context = img90.getContext('2d');
        context.translate(w, 0);
        context.rotate(Math.PI / 2);
        context.drawImage(me.image, 0, 0);

        context = img180.getContext('2d');
        context.translate(w, h);
        context.rotate(Math.PI);
        context.drawImage(me.image, 0, 0);

        context = img270.getContext('2d');
        context.translate(0, h);
        context.rotate(Math.PI * 3 / 2);
        context.drawImage(me.image, 0, 0);

        context = imgF.getContext('2d');
        context.translate(w, 0);
        context.scale(-1, 1);
        context.drawImage(me.image, 0, 0);

        context = img90F.getContext('2d');
        context.translate(w, h);
        context.rotate(Math.PI / 2);
        context.scale(-1, 1);
        context.drawImage(me.image, 0, 0);

        context = img180F.getContext('2d');
        context.translate(0, h);
        context.rotate(Math.PI);
        context.scale(-1, 1);
        context.drawImage(me.image, 0, 0);

        context = img270F.getContext('2d');
        context.rotate(Math.PI * 3 / 2);
        context.scale(-1, 1);
        context.drawImage(me.image, 0, 0);


        //context = img0.getContext('2d');
        //var pixel = context.getImageData(0, 0, 1, 1);
        //console.log(pixel.data);


    }

    me.getImage = function(rotation, flipped)
    {
        if (! flipped)
        {
            switch (rotation)
            {
                case 0:
                    return img0;
                case Math.PI / 2:
                    return img90;
                case Math.PI:
                    return img180;
                case Math.PI * 3 / 2:
                    return img270;
            }
        }
        else
        {
            switch (rotation)
            {
                case 0:
                    return imgF;
                case Math.PI / 2:
                    return img90F;
                case Math.PI:
                    return img180F;
                case Math.PI * 3 / 2:
                    return img270F;
            }
        }
    };
};

TConf.History = function(field)
{
    var me = this;
    EventDispatcher.call(this);
    var stack = [];
    var pointer = -1;

    me.save = function()
    {
        //    console.log('save');

        if (pointer < stack.length - 1) stack.splice(pointer + 1);
        stack.push(field.getData());
        pointer = stack.length - 1;

        //me.dispatchEvent(new Event(TConf.History.CHANGED));
    };

    me.save();

    me.undo = function()
    {
        if (pointer < 1) return;
        pointer--;
        field.setData(stack[pointer]);

        //me.dispatchEvent(new Event(TConf.History.CHANGED));
    };

    me.redo = function()
    {
        if (pointer >= stack.length - 1) return;
        pointer++;
        field.setData(stack[pointer]);

        //me.dispatchEvent(new Event(TConf.History.CHANGED));
    };

    me.canUndo = function()
    {
        return pointer >= 1;
    };

    me.canRedo = function()
    {
        return pointer < stack.length - 1;
    };

    me.toFirstState = function()
    {
        if (pointer >= 0)
        {
            pointer = 0;
            field.setData(stack[pointer]);
            me.dispatchEvent(new Event(TConf.History.CHANGED));
        }
    };

    me.printStack = function()
    {
        console.log('- stack -');
        for (var i = 0; i < stack.length; i++)
        {
            var obj = stack[i];
            var str =   'Points: ' + obj.roomPoints.length + ', ' +
                'rooms: ' + obj.arrRooms.length + ', ' +
                'areas: ' + obj.arrAreas.length;
            if (pointer == i) str += '  <<<';
            console.log(str);
        }

        console.log('---------');
    };

    me.clear = function()
    {
        stack = [];
        pointer = -1;
    }
};

TConf.History.prototype = Object.create(EventDispatcher.prototype);
TConf.History.prototype.constructor = TConf.History;

TConf.History.CHANGED = 'HISTORY_CHANGED';

TConf.Area = function()
{
    var me = this;

    me.id = '';
    me.matID = '';
    me.addMatID = '';
    me.color = '#ffffff';
    me.matRotation = 0;
    me.contour = [];
    me.tiles = [];
    me.margin = 0.5;
    me.angle = 0;
    me.shiftX = 0;
    me.shiftY = 0;
    me.defMaterial = null;
    me.random = false;

    me.delimiters = {
        top: null,
        bottom: null,
        left: null,
        right: null
    };

    me.minX = 0;
    me.maxX = 0;
    me.minY = 0;
    me.maxY = 0;

    me.randomRotate = function()
    {
        me.random = true;
        for (var i = 0; i < me.tiles.length; i++)
        {
            me.tiles[i].randomRotate();
        }
    };

    me.removeAllTiles = function()
    {
        me.tiles = [];
    };

    me.clear = function()
    {
        me.matID = '';
        me.color = '#ffffff';
        me.matRotation = 0;
        me.tiles = [];
        me.margin = 0.5;
        me.angle = 0;
        me.shiftX = 0;
        me.shiftY = 0;
        me.defMaterial = null;
        me.random = false;
    };

    me.clone = function() // No links copy
    {
        var res = new TConf.Area();
        res.id = me.id;
        res.matID = me.matID;
        res.addMatID = me.addMatID;
        res.color = me.color;
        res.matRotation = me.matRotation;
        res.contour = [].concat(me.contour);
        res.margin = me.margin;
        res.angle = me.angle;
        res.shiftX = me.shiftX;
        res.shiftY = me.shiftY;
        res.defMaterial = me.defMaterial;
        res.random = me.random;
        for (var i = 0; i < me.tiles.length; i++)
        {
            res.tiles.push(me.tiles[i].clone());
        }
        return res;
    };

    me.toStruct = function()
    {
        var struct = {
            id: me.id,
            m: me.matID,
            addM: me.addMatID,
            //c: me.color,
            mr: me.matRotation,
            ma: me.margin,
            //a: me.angle,
            sx: me.shiftX,
            sy: me.shiftY,
            delimiters: {
                t: '',
                b: '',
                l: '',
                r: ''
            }
        };

        //if (me.defMaterial) struct.dm = me.defMaterial.id;

        if (me.matID == '') struct['m'] = me.color;

        return struct;
    };

    me.fromStruct = function(struct)
    {
        me.id = struct.id;
        me.matID = struct.m;
        me.addMatID = struct.addM;
        me.matRotation = struct.mr;
        me.margin = struct.ma;
        //me.angle = struct.a;
        me.shiftX = struct.sx;
        me.shiftY = struct.sy;

        if (!me.matID) {
            me.matID = R2D.default.getDefaultMaterialByKey("wall");
            me.addMatID = R2D.default.getDefaultAddMaterialByKey("wall");
        }

        //if (me.matID.startsWith('#'))
        //{
        //    me.color = me.matID;
        //    me.matID = '';
        //}
    }
};

TConf.Tile = function()
{
    var me = this;

    me.material = null;
    me.rotation = 0;
    me.flip = false;
    me.x = 0;
    me.y = 0;

    me.clear = function()
    {
        me.material = null;
        me.rotation = 0;
        me.flip = false;
    };

    me.clone = function()
    {
        var tile = new TConf.Tile();
        tile.material = me.material;
        tile.rotation = me.rotation;
        tile.flip = me.flip;
        tile.x = me.x;
        tile.y = me.y;

        return tile;
    };

    me.randomRotate = function()
    {
        var isSquare = (me.material.width == me.material.height);
        var r = Math.floor(Math.random() * 4);
        switch (r)
        {
            case 0:
                me.rotation = 0;
                break;
            case 1:
                if (isSquare)
                {
                    me.rotation = Math.PI / 2;
                }
                else
                {
                    me.rotation = 0;
                }
                break;
            case 2:
                me.rotation = Math.PI;
                break;
            case 3:
                if (isSquare)
                {
                    me.rotation = Math.PI * 3 / 2;
                }
                else
                {
                    me.rotation = Math.PI;
                }
                break;
        }

        me.flip = Math.random() < 0.5;
    }
};

TConf.Delimiter = function(type, pos)
{
    var me = this;

    me.type = type;
    me.pos = pos;
    me.parent1 = null;
    me.parent2 = null;
    me.children = [];

    me.clone = function()
    {
        return new TConf.Delimiter(me.type, me.pos); // No links copy!
    };

    me.toStruct = function()
    {
        return {
            id: '',
            t: me.type,
            pos: me.pos,
            pr1: 0,
            pr2: 0,
            ch: []
        }
    };

    me.fromStruct = function(struct)
    {
        me.type = struct.t;
        me.pos = struct.pos;
    }
};

TConf.Delimiter.HOR = 'h';
TConf.Delimiter.VER = 'v';

TConf.Editor = function(field)
{
    EventDispatcher.call(this);

    var me = this;

    me.history = new TConf.History(field);

    var contDiv = document.createElement('div');
    contDiv.classList.add('TConfEditor');
    me.getDomElement = function()
    {
        return contDiv;
    };

    me.field = field;
    var canvas = document.createElement('canvas');
    canvas.classList.add('TConfCanvas');
    me.context = canvas.getContext('2d');
    contDiv.appendChild(canvas);

    me.snap = new TConf.Snap(field, me);

    me.shiftX = 0;
    me.shiftY = 0;
    me.scale = 1.5;
    me.canvasWidth = canvas.width;
    me.canvasHeight = canvas.height;

    me.viewPos = null;
    me.realPos = null;
    me.areaPos = null;
    me.leftDown = false;
    me.rightDown = false;

    me.stateEditing = new TConf.StateEditing(me);
    me.stateMakingTiles = new TConf.StateMakingTiles(me);
    me.stateSelecting = new TConf.StateSelecting(me);
    me.stateSelected = new TConf.StateSelected(me);
    me.stateDraggingCanvas = new TConf.StateDraggingCanvas(me);
    me.stateDraggingDelimiter = new TConf.StateDraggingDelimiter(me);
    me.stateSelectedDelimiter = new TConf.StateSelectedDelimiter(me);
    me.stateShiftingArea = new TConf.StateShiftingArea(me);
    me.stateDraggingMaterial = new TConf.StateDraggingMaterial(me);
    me.state = me.stateEditing;
    me.prevState = null;

    var scaleValues = [0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.3, 2.6, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.6, 7.2, 8.0, 9.0, 10.0, 12, 14, 16, 20];
    var scalePointer = 4;
    me.maxScale = scaleValues[scaleValues.length - 1];

    addListeners();

    me.destroy = function()
    {
        removeListeners();
    };

    me.setSize = function(width, height)
    {
        contDiv.style.width = width + 'px';
        contDiv.style.height = height + 'px';

        canvas.width = width;
        canvas.height = height;
        me.canvasWidth = width;
        me.canvasHeight = height;
    };

    me.setWallSize = function(width, height)
    {
        me.field.setSize(width, height);

        me.toCenter();
    };

    me.toCenter = function()
    {
        me.shiftX = - (canvas.width - me.field.width) / 2 / me.scale;
        me.shiftY = - (canvas.height - me.field.height) / 2 / me.scale;
    };

    function addListeners()
    {
        // canvas.addEventListener('mousedown', onCanvasMouseDown, false);
        // canvas.addEventListener('mouseup', onCanvasMouseUp, false);     // document.mouseUp?
        //canvas.addEventListener('mousemove', onCanvasMouseMove, false);
        canvas.addEventListener('wheel', onCanvasWheel, false);
        contDiv.addEventListener('contextmenu', function (e) { e.preventDefault(); });
        document.addEventListener('keydown', keyDownListener, false);
    }

    function removeListeners()
    {
        // canvas.removeEventListener('mousedown', onCanvasMouseDown, false);
        // canvas.removeEventListener('mouseup', onCanvasMouseUp, false);
        // canvas.removeEventListener('mousemove', onCanvasMouseMove, false);
        canvas.removeEventListener('wheel', onCanvasWheel, false);
        contDiv.removeEventListener('contextmenu', function (e) { e.preventDefault(); });
        document.removeEventListener('keydown', keyDownListener, false);
    }

    me.mousedown = e => {
        var x = e.offsetX == undefined ? e.layerX : e.offsetX;
        var y = e.offsetY == undefined ? e.layerY : e.offsetY;
        me.viewPos = new TConf.Point(x, y);
        me.realPos = me.viewToReal(me.viewPos);
        me.areaPos = me.viewToReal(me.viewPos, me.field.activeArea);

        if (e.button == 0)
        {
            me.leftDown = true;
            me.state.mouseDown(me.realPos.x, me.realPos.y);
        }
        else if (e.button == 2)
        {
            me.rightDown = true;
            me.state.mouseRDown(x, y);
        }
    }

    me.mouseup = e =>
    {
        
        var x = e.offsetX == undefined ? e.layerX : e.offsetX;
        var y = e.offsetY == undefined ? e.layerY : e.offsetY;
        me.viewPos = new TConf.Point(x, y);
        me.realPos = me.viewToReal(me.viewPos);
        me.areaPos = me.viewToReal(me.viewPos, me.field.activeArea);

        if (e.button == 0)
        {
            me.leftDown = false;
            return me.state.mouseUp(me.realPos.x, me.realPos.y);
        }
        else if (e.button == 2)
        {
            me.rightDown = false;
            return me.state.mouseRUp(x, y);
        }
    }

    me.mousemove = e =>
    {
        var x = e.offsetX == undefined ? e.layerX : e.offsetX;
        var y = e.offsetY == undefined ? e.layerY : e.offsetY;

        me.viewPos = new TConf.Point(x, y);
        me.realPos = me.viewToReal(me.viewPos);
        me.areaPos = me.viewToReal(me.viewPos, me.field.activeArea);

        return me.state.mouseMove(me.realPos.x, me.realPos.y);
        me.state.mouseRMove(me.viewPos.x, me.viewPos.y);
    }

    function onCanvasWheel(e)
    {
        var x = e.offsetX == undefined ? e.layerX : e.offsetX;
        var y = e.offsetY == undefined ? e.layerY : e.offsetY;

        me.zoom(x, y, -e.deltaY || -e.detail || e.wheelDelta);

        me.state.mouseWheel();
    }

    var saved = null;

    function keyDownListener(e)
    {
        me.state.keyDown(e);

        if (! saved)
        {
            saved = field.toData();
        }
        else
        {
            field.fromData(saved);
            saved = null;
        }

        me.draw();
    }

    me.changeState = function(newState)
    {
        me.prevState = me.state;

        me.state.stop();

        me.state = newState;

        let resultStart = me.state.start();

        //me.state.setParams(params);
        //me.dispatchEvent(new Event(WC.EDITOR_CHANGE_STATE, me));
        //me.dispatchHistoryState();
        if(resultStart) return resultStart;
    };

    var pushedState = null;

    me.pushState = function(newState)
    {
        me.state.pause();
        pushedState = me.state;
        me.state = newState;
        me.state.start();
    };

    me.popState = function()
    {
        me.state.stop();
        me.state = pushedState;
        pushedState = null;
        me.state.restore();
    };

    me.zoom = function(x, y, dir)
    {
        var shX, shY, oldScale;

        if (dir > 0)
        {
            scalePointer += 1;
            if (scalePointer >= scaleValues.length) scalePointer = scaleValues.length - 1;
            oldScale = me.scale;
            me.scale = scaleValues[scalePointer];

            shX = (x + me.shiftX) * (me.scale / oldScale - 1);
            shY = (y + me.shiftY) * (me.scale / oldScale - 1);

            me.shiftX += shX;
            me.shiftY += shY;
        }
        else
        {
            scalePointer -= 1;
            if (scalePointer < 0) scalePointer = 0;
            oldScale = me.scale;
            me.scale = scaleValues[scalePointer];

            shX = (x + me.shiftX) * (me.scale / oldScale - 1);
            shY = (y + me.shiftY) * (me.scale / oldScale - 1);

            me.shiftX += shX;
            me.shiftY += shY;
        }

        me.draw();
    };

    me.draw = function()
    {
        me.state.draw();
    };

    me.realToView = function(P, area)
    {
        if (! P)
        {
            console.log('error');
        }

        if (area)
        {
            var real = me.field.areaToReal(P, area);
            return new TConf.Point(Math.round(real.x * me.scale - me.shiftX) + 0.5, Math.round(real.y * me.scale - me.shiftY) + 0.5);
        }
        else
        {
            return new TConf.Point(Math.round(P.x * me.scale - me.shiftX) + 0.5, Math.round(P.y * me.scale - me.shiftY) + 0.5);
        }
    };

    me.viewToReal = function(P, area)
    {
        var real = new TConf.Point((P.x + me.shiftX) / me.scale, (P.y + me.shiftY) / me.scale);

        if (area)
        {
            return me.field.realToArea(real, area);
        }
        else
        {
            return real;
        }
    };
};

R2D.extend(TConf.Editor, EventDispatcher);

TConf.Snap = function(field)
{
    var me = this;

    me.getSnapPoint = function(x, y, w, h, snapDist)
    {
        var toBorder = snapToBorder(x, y, w, h, snapDist);
        if (toBorder)
        {
            var toNeighbour = snapToNeighbour(toBorder.x, toBorder.y, w, h, snapDist);
            if (toNeighbour)
            {
                return snapToNeighbour(toNeighbour.x, toNeighbour.y, w, h, snapDist);
            }
            else
            {
                return snapToNeighbour(x, y, w, h, snapDist);
            }
        }
        else
        {
            return null;
        }
    };

    function snapToBorder(x, y, w, h, snapDist)
    {
        var m = field.activeArea.margin;

        var P1 = field.areaToReal(new TConf.Point(x - w / 2 - m / 2, y - h / 2 - m / 2), field.activeArea);
        var P2 = field.areaToReal(new TConf.Point(x + w / 2 + m / 2, y - h / 2 - m / 2), field.activeArea);
        var P3 = field.areaToReal(new TConf.Point(x + w / 2 + m / 2, y + h / 2 + m / 2), field.activeArea);
        var P4 = field.areaToReal(new TConf.Point(x - w / 2 - m / 2, y + h / 2 + m / 2), field.activeArea);

        var minX = Math.min(P1.x, P2.x, P3.x, P4.x);
        var maxX = Math.max(P1.x, P2.x, P3.x, P4.x);
        var minY = Math.min(P1.y, P2.y, P3.y, P4.y);
        var maxY = Math.max(P1.y, P2.y, P3.y, P4.y);

        if (maxX < field.activeArea.minX + m + TR.B_EPS) return null;
        if (minX > field.activeArea.maxX - m - TR.B_EPS) return null;
        if (maxY < field.activeArea.minY + m + TR.B_EPS) return null;
        if (minY > field.activeArea.maxY - m - TR.B_EPS) return null;

        var minDistX = Number.POSITIVE_INFINITY;
        var dx1 = field.activeArea.minX - minX;
        var dx2 = field.activeArea.maxX - maxX;
        if (Math.abs(dx1) < Math.abs(minDistX)) minDistX = dx1;
        if (Math.abs(dx2) < Math.abs(minDistX)) minDistX = dx2;

        var minDistY = Number.POSITIVE_INFINITY;
        var dy1 = field.activeArea.minY - minY;
        var dy2 = field.activeArea.maxY - maxY;
        if (Math.abs(dy1) < Math.abs(minDistY)) minDistY = dy1;
        if (Math.abs(dy2) < Math.abs(minDistY)) minDistY = dy2;

        var snapPos = field.areaToReal(new TConf.Point(x, y), field.activeArea);
        if (Math.abs(minDistX) < snapDist) snapPos.x += minDistX;
        if (Math.abs(minDistY) < snapDist) snapPos.y += minDistY;

        return field.realToArea(snapPos, field.activeArea);
    }

    function snapToNeighbour(x, y, w, h, snapDist)
    {
        var m = field.activeArea.margin;

        var minDistX = Number.POSITIVE_INFINITY;
        var minDistY = Number.POSITIVE_INFINITY;

        var overlayNotSnapped = false;
        var overlaySnapped = false;

        for (var i = 0; i < field.activeArea.tiles.length; i++)
        {
            var t = field.activeArea.tiles[i];

            var dx1 = t.x + t.material.width / 2 + m - x + w / 2;
            var dx2 = t.x + t.material.width / 2 - x - w / 2;
            var dx3 = t.x - t.material.width / 2 - x + w / 2;
            var dx4 = t.x - t.material.width / 2 - m - x - w / 2;

            var overlayX = dx1 > TR.B_EPS && dx4 < -TR.B_EPS;

            if (Math.abs(dx1) < Math.abs(minDistX)) minDistX = dx1;
            if (Math.abs(dx2) < Math.abs(minDistX)) minDistX = dx2;
            if (Math.abs(dx3) < Math.abs(minDistX)) minDistX = dx3;
            if (Math.abs(dx4) < Math.abs(minDistX)) minDistX = dx4;

            var dy1 = t.y + t.material.height / 2 + m - y + h / 2;
            var dy2 = t.y + t.material.height / 2 - y - h / 2;
            var dy3 = t.y - t.material.height / 2 - y + h / 2;
            var dy4 = t.y - t.material.height / 2 - m - y - h / 2;

            if (Math.abs(dy1) < Math.abs(minDistY)) minDistY = dy1;
            if (Math.abs(dy2) < Math.abs(minDistY)) minDistY = dy2;
            if (Math.abs(dy3) < Math.abs(minDistY)) minDistY = dy3;
            if (Math.abs(dy4) < Math.abs(minDistY)) minDistY = dy4;

            var overlayY = dy1 > TR.B_EPS && dy4 < -TR.B_EPS;

            if (overlayX && overlayY) overlayNotSnapped = true;
        }

        var snapPos = new TConf.Point(x, y);
        if (Math.abs(minDistX) < snapDist) snapPos.x += minDistX;
        if (Math.abs(minDistY) < snapDist) snapPos.y += minDistY;

        for (i = 0; i < field.activeArea.tiles.length; i++)
        {
            t = field.activeArea.tiles[i];

            dx1 = t.x + t.material.width / 2 + m - snapPos.x + w / 2;
            dx2 = t.x + t.material.width / 2 - snapPos.x - w / 2;
            dx3 = t.x - t.material.width / 2 - snapPos.x + w / 2;
            dx4 = t.x - t.material.width / 2 - m - snapPos.x - w / 2;

            overlayX = dx1 > TR.B_EPS && dx4 < -TR.B_EPS;

            if (Math.abs(dx1) < Math.abs(minDistX)) minDistX = dx1;
            if (Math.abs(dx2) < Math.abs(minDistX)) minDistX = dx2;
            if (Math.abs(dx3) < Math.abs(minDistX)) minDistX = dx3;
            if (Math.abs(dx4) < Math.abs(minDistX)) minDistX = dx4;

            dy1 = t.y + t.material.height / 2 + m - snapPos.y + h / 2;
            dy2 = t.y + t.material.height / 2 - snapPos.y - h / 2;
            dy3 = t.y - t.material.height / 2 - snapPos.y + h / 2;
            dy4 = t.y - t.material.height / 2 - m - snapPos.y - h / 2;

            if (Math.abs(dy1) < Math.abs(minDistY)) minDistY = dy1;
            if (Math.abs(dy2) < Math.abs(minDistY)) minDistY = dy2;
            if (Math.abs(dy3) < Math.abs(minDistY)) minDistY = dy3;
            if (Math.abs(dy4) < Math.abs(minDistY)) minDistY = dy4;

            overlayY = dy1 > TR.B_EPS && dy4 < -TR.B_EPS;

            if (overlayX && overlayY) overlaySnapped = true;
        }

        if (! overlaySnapped) return snapPos;
        if (! overlayNotSnapped) return new TConf.Point(x, y);
        return null;
    }
};
TConf.Point = function(x, y)
{
    var me = this;
    me.x = x;
    me.y = y;
};

TConf.BaseState = function(editor)
{
    let me = this;
    me.editor = editor;
    let materials = {};

    me.start = function()
    {

    };

    me.stop = function()
    {

    };

    me.pause = function()
    {

    };

    me.restore = function()
    {
        me.draw();
    };

    me.mouseRDown = function(e)
    {
        me.editor.stateDraggingCanvas.dragX = me.editor.viewPos.x;
        me.editor.stateDraggingCanvas.dragY = me.editor.viewPos.y;

        me.editor.pushState(me.editor.stateDraggingCanvas);
        me.draw();
    };

    me.mouseRMove = function(e)
    {

    };

    me.mouseRUp = function(e)
    {
        
    };

    me.mouseDown = function(x, y)
    {

    };

    me.mouseMove = function(x, y)
    {

    };

    me.mouseUp = function(x, y)
    {

    };

    me.mouseWheel = function()
    {

    };

    me.keyDown = function(e)
    {
        switch (e.keyCode)
        {
/*
            case 78: // n
                if (me.currentMaterial)
                {
                    me.editor.field.autoFill(me.editor.field.activeArea, me.currentMaterial);
                    me.editor.history.save();
                    me.draw();
                }
                break;

                if (e.ctrlKey && e.altKey)
                {
                    if (! me.editor.field.activeArea)
                    {
                        me.editor.field.setActiveArea(me.editor.field.areas[0]);
                    }
                    else
                    {
                        let i = me.editor.field.areas.indexOf(me.editor.field.activeArea);
                        i = (i + 1) % me.editor.field.areas.length;
                        me.editor.field.setActiveArea(me.editor.field.areas[i]);
                    }

                    me.draw();
                }
                break;

            case 77: // m

                if (e.ctrlKey && e.altKey)
                {
                    if (me.editor.state == me.editor.stateShiftingArea)
                    {
                        me.editor.changeState(me.editor.stateEditing);
                    }
                    else
                    {
                        me.editor.changeState(me.editor.stateShiftingArea);
                    }

                    me.draw();
                }
                break;
*/

            case 65: // a
                if (e.ctrlKey && e.altKey)
                {
                    me.editor.field.clearArea(me.editor.field.activeArea);
                    me.editor.field.activeArea.angle += Math.PI / 4;
                    me.editor.history.save();
                    me.draw();
                }
                break;
        }
    };

    me.undo = function()
    {

    };

    me.redo = function()
    {

    };

    me.canUndo = function()
    {

    };

    me.canRedo = function()
    {

    };

    me.dblClick = function()
    {

    };

    me.draw = function()
    {
        //me.drawTiles();

        me.editor.context.clearRect(0, 0, me.editor.canvasWidth, me.editor.canvasHeight);
        me.drawFrame();
        me.drawSizes();
    };

    me.drawTiles = function()
    {
        let n = 1;
        let bigCanvas = document.createElement('canvas');
        bigCanvas.width = me.editor.canvasWidth * n * 2;
        bigCanvas.height = me.editor.canvasHeight * n * 2;
        let bigContext = bigCanvas.getContext('2d');
        bigContext.clearRect(0, 0, bigCanvas.width, bigCanvas.height);
        bigContext.fillStyle = '#ff0000';
        bigContext.fillRect(0, 0, bigCanvas.width, bigCanvas.height);
        let cornerMin = me.editor.realToView(new TConf.Point(0, 0));
        let cornerMax = me.editor.realToView(new TConf.Point(me.editor.field.width, me.editor.field.height));


        let ctx = me.editor.context;
        ctx.clearRect(0, 0, me.editor.canvasWidth, me.editor.canvasHeight);
        for (let i = 0; i < me.editor.field.areas.length; i++)
        {
            let area = me.editor.field.areas[i];

            let minP = me.editor.realToView(new TConf.Point(area.minX, area.minY));
            let maxP = me.editor.realToView(new TConf.Point(area.maxX, area.maxY));
            ctx.fillStyle = '#ffffff'; //area.color;
            ctx.fillRect(minP.x * n, minP.y * n, maxP.x * n - minP.x * n, maxP.y * n - minP.y * n);

            ctx.save();
            let P = me.editor.realToView(area.contour[area.contour.length - 1]);
            ctx.beginPath();
            ctx.moveTo(P.x * n, P.y * n);
            for (let j = 0; j < area.contour.length; j++)
            {
                P = me.editor.realToView(area.contour[j]);
                ctx.lineTo(P.x * n, P.y * n);
            }
            ctx.clip();

            if (area.matID != '' && ! (area.matID in materials))
            {
                let productData = R2D.Pool.getProductData(area.matID);

                let w = productData.property.sizes.width;
                let h = productData.property.sizes.height;
                materials[area.matID] = new TConf.Material(productData.id, R2D.makeURL(R2D.URL.DOMAIN, productData.source.images.preview), w, h);
            }

            if (area.matID in materials && materials[area.matID].ready)
            {
                let img = materials[area.matID].image;
                let kx = 1 / img.width * materials[area.matID].width * 100 / 512;
                let ky = 1 / img.height * materials[area.matID].height * 100 / 512;
                let resW = me.editor.canvasWidth * me.editor.scale * kx * 2;
                let resH = me.editor.canvasHeight * me.editor.scale * ky * 2;
                let pattern = bigContext.createPattern(materials[area.matID].image, 'repeat');
                bigContext.fillStyle = pattern;
                bigContext.fillRect(0, 0, bigCanvas.width, bigCanvas.height);
                ctx.drawImage(bigCanvas, cornerMin.x, cornerMin.y, resW, resH);
            }

            ctx.restore();
        }
    };

    me.drawFrame = function()
    {
        let ctx = me.editor.context;
        for (let i = 0; i < me.editor.field.areas.length; i++)
        {
            let area = me.editor.field.areas[i];
            if (area == me.editor.field.activeArea) continue;

            let P = me.editor.realToView(area.contour[area.contour.length - 1]);
            ctx.beginPath();
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 1;
            ctx.moveTo(P.x, P.y);
            for (let j = 0; j < area.contour.length; j++)
            {
                P = me.editor.realToView(area.contour[j]);
                ctx.lineTo(P.x, P.y);
            }
            me.editor.context.stroke();
            me.editor.context.closePath();
        }

        area = me.editor.field.activeArea;

        P = me.editor.realToView(area.contour[area.contour.length - 1]);
        ctx.beginPath();
        ctx.strokeStyle = '#00cc00';
        ctx.lineWidth = 1;
        ctx.moveTo(P.x, P.y);
        for (let j = 0; j < area.contour.length; j++)
        {
            P = me.editor.realToView(area.contour[j]);
            ctx.lineTo(P.x, P.y);
        }
        me.editor.context.stroke();
        me.editor.context.closePath();
    };

    me.drawDelimiter = function(delim)
    {
        if (! delim) return;

        let ctx = me.editor.context;
        let pos = delim.pos;
        let start = 0;
        let end = me.editor.field.width;
        if (delim.type == TConf.Delimiter.VER) end = me.editor.field.height;
        if (delim.parent1) start = delim.parent1.pos;
        if (delim.parent2) end = delim.parent2.pos;

        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00cc00';

        let ptStart;
        let ptEnd;

        if (delim.type == TConf.Delimiter.HOR)
        {
            ptStart = me.editor.realToView(new TConf.Point(start, pos));
            ptEnd = me.editor.realToView(new TConf.Point(end, pos));
        }
        else
        {
            ptStart = me.editor.realToView(new TConf.Point(pos, start));
            ptEnd = me.editor.realToView(new TConf.Point(pos, end));
        }

        ctx.moveTo(ptStart.x, ptStart.y);
        ctx.lineTo(ptEnd.x, ptEnd.y);
        ctx.stroke();
        ctx.closePath();
    };

    me.drawDelimiters = function(activeDelim)
    {
        let ctx = me.editor.context;

        for (let i = 0; i < me.editor.field.delimiters.length; i++)
        {
            let delim = me.editor.field.delimiters[i];
            let pos = delim.pos;
            let start = 0;
            let end = me.editor.field.width;
            if (delim.type == TConf.Delimiter.VER) end = me.editor.field.height;
            if (delim.parent1) start = delim.parent1.pos;
            if (delim.parent2) end = delim.parent2.pos;

            ctx.beginPath();
            if (delim == activeDelim)
            {
                ctx.lineWidth = 2;
            }
            else
            {
                ctx.lineWidth = 1;
            }
            ctx.strokeStyle = '#000000';

            let ptStart;
            let ptEnd;

            if (delim.type == TConf.Delimiter.HOR)
            {
                ptStart = me.editor.realToView(new TConf.Point(start, pos));
                ptEnd = me.editor.realToView(new TConf.Point(end, pos));
            }
            else
            {
                ptStart = me.editor.realToView(new TConf.Point(pos, start));
                ptEnd = me.editor.realToView(new TConf.Point(pos, end));
            }

            ctx.moveTo(ptStart.x, ptStart.y);
            ctx.lineTo(ptEnd.x, ptEnd.y);
            ctx.stroke();
            ctx.closePath();
        }
    };

    me.drawSizes = function()
    {
        let ctx = me.editor.context;

        for (let i = 0; i < me.editor.field.areas.length; i++)
        {
            let area = me.editor.field.areas[i];

            let ptLB = new TConf.Point(area.minX, area.maxY);
            let ptRB = new TConf.Point(area.maxX, area.maxY);
            let ptRT = new TConf.Point(area.maxX, area.minY);

            let viewLB = me.editor.realToView(ptLB);
            let viewRB = me.editor.realToView(ptRB);
            let viewRT = me.editor.realToView(ptRT);

            if (viewLB.x < 0) viewLB.x = 0;
            if (viewRT.y < 0) viewRT.y = 0;
            let rightHidden = false;
            let bottomHidden = false;
            if (viewRT.x > me.editor.canvasWidth)
            {
                viewRT.x = me.editor.canvasWidth;
                viewRB.x = me.editor.canvasWidth;
                rightHidden = true;
            }
            if (viewLB.y > me.editor.canvasHeight)
            {
                viewLB.y = me.editor.canvasHeight;
                viewRB.y = me.editor.canvasHeight;

                bottomHidden = true;
            }

            let width = String((ptRB.x - ptLB.x).toFixed(1));
            let height = String((ptRB.y - ptRT.y).toFixed(1));

            let viewWidth = viewRB.x - viewLB.x;
            let viewHeight = viewRB.y - viewRT.y;

            let txtW = R2D.DimensionSystem.toString(width);
            if (R2D.DimensionSystem.isMetric()) txtW = txtW + ' ' + R2D.DimensionSystem.getName();
            let txtH = R2D.DimensionSystem.toString(height);
            if (R2D.DimensionSystem.isMetric()) txtH = txtH + ' ' + R2D.DimensionSystem.getName();

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "10pt Arial";
            ctx.lineWidth = 1;
            ctx.fillStyle = '#666666';

            if (! bottomHidden && (me.editor.scale == me.editor.maxScale || (viewWidth > ctx.measureText(txtW).width + 20 && viewHeight > 20)))
            {
                let tx = (viewLB.x + viewRB.x) / 2;
                let ty = viewLB.y - 10;

                ctx.fillText(txtW, tx, ty);
            }

            if (! rightHidden && (me.editor.scale == me.editor.maxScale || (viewWidth > 20 && viewHeight > ctx.measureText(txtH).width + 20)))
            {
                tx = viewRT.x - 10;
                ty = (viewRT.y + viewRB.y) / 2;

                ctx.save();
                ctx.translate(tx, ty);
                ctx.rotate(- Math.PI / 2);
                ctx.fillText(txtH, 0, 0);
                ctx.restore();
            }
        }
    }
};

TConf.StateDraggingCanvas = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateDraggingCanvas';

    me.dragX = 0;
    me.dragY = 0;
    me.startShX = 0;
    me.startShY = 0;

    me.start = function()
    {
        me.startShX = me.editor.shiftX;
        me.startShY = me.editor.shiftY;

        me.draw();
    };

    me.stop = function()
    {

    };

    me.mouseRUp = function(viewX, viewY)
    {
        me.editor.popState();
    };

    me.mouseRDown = function(viewX, viewY)
    {

    };

    me.mouseMove = function(viewX, viewY)
    {
        //WC.framePointLT = WC.wallsEditor.viewToReal(new TR.Point(0, 0));
        //WC.framePointRB = WC.wallsEditor.viewToReal(new TR.Point(WC.canvasWidth, WC.canvasHeight));
    };

    me.mouseRMove = function(viewX, viewY)
    {
        var dx = viewX - me.dragX;
        var dy = viewY - me.dragY;

        //    console.log(viewX, me.dragX);

        me.editor.shiftX = me.startShX - dx;
        me.editor.shiftY = me.startShY - dy;

        //WC.wallsEditor.drawObjLayer();
        //WC.wallsEditor.pushedStateDraw();
        //    me.draw();
        me.editor.draw();
    };

};

TConf.StateDraggingCanvas.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateDraggingCanvas.prototype.constructor = TConf.StateDraggingCanvas;


TConf.StateDraggingDelimiter = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateDraggingDelimiter';

    me.delimiter = null;
    me.startCoord = null;
    me.startPos = 0;

    var bounds;

    me.start = function()
    {
        bounds = editor.field.getDelimiterBounds(me.delimiter);
        bounds[0] += 2;
        bounds[1] -= 2;

        me.startCoord = editor.realPos;
        me.startPos = me.delimiter.pos;
        me.draw();
    };

    me.stop = function()
    {
        me.editor.field.autoFillAll();
        me.editor.history.save();
    };

    me.mouseMove = function()
    {
        if (me.delimiter.type == TConf.Delimiter.HOR)
        {
            var newPos = roundSnap(me.startPos, me.editor.realPos.y);

            if (newPos >= bounds[0] && newPos <= bounds[1])
            {
                me.delimiter.pos = newPos;
            }
        }
        else
        {
            newPos = roundSnap(me.startPos, me.editor.realPos.x);

            if (newPos >= bounds[0] && newPos <= bounds[1])
            {
                me.delimiter.pos = newPos;
            }
        }

        me.editor.field.calcAreas();
        me.draw();
    };

    me.mouseUp = function()
    {
        me.editor.changeState(editor.stateEditing);
    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

        me.drawDelimiter(me.delimiter);
    };

    function roundSnap(oldVal, val)
    {
        var step;
        if (editor.scale <= 1)
        {
            step = 10;
        }
        else if (editor.scale <= 2)
        {
            step = 5;
        }
        else if (editor.scale <= 3)
        {
            step = 2;
        }
        else if (editor.scale <= 8)
        {
            step = 1;
        }
        else
        {
            step = 0.1
        }


        var shift = Math.round((val - oldVal) / step) * step;

        return oldVal + shift;
    }
};

TConf.StateDraggingDelimiter.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateDraggingDelimiter.prototype.constructor = TConf.StateDraggingDelimiter;
TConf.StateSelectedDelimiter = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateSelectedDelimiter';

    me.delimiter = null;

    // var quickPanel = new R2D.QuickPanel();
    // var btnDelete = R2D.QuickPanel.getButtonDelete();
    // quickPanel.add(btnDelete);
    // btnDelete.addLeftMouseClickListener(btnDeleteListener);

    me.start = function()
    {
        return {state: 'stateSelectedDelimetr', quickPanel: {x: editor.viewPos.x, y: editor.viewPos.y - 30}};
        //showDelButton();
    };

    me.stop = function()
    {
        //hideDelButton();
        me.draw();
    };

    me.mouseMove = function()
    {

    };

    me.mouseUp = function()
    {
        editor.changeState(editor.stateEditing);
    };

    function showDelButton(x, y)
    {
        quickPanel.setPosition(x, y);
        if (! quickPanel.getDomElement().parentNode)
        {
            editor.getDomElement().appendChild(quickPanel.getDomElement());
        }
    }

    function hideDelButton()
    {
        if (quickPanel.getDomElement().parentNode)
        {
            editor.getDomElement().removeChild(quickPanel.getDomElement());
        }
    }

    me.btnDeleteListener = () => {
        //hideDelButton();
        editor.field.mergeAreas(me.delimiter);
        me.editor.changeState(me.editor.stateEditing);
        me.editor.draw();
    }
};

TConf.StateEditing = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateEditing';

    var delimUnderMouse = null;
    var delimPress = false;
    var downX = 0;
    var downY = 0;

    me.start = function()
    {
        me.draw();
    };

    me.stop = function()
    {
        delimUnderMouse = null;
        delimPress = false;
    };

    me.mouseDown = function()
    {
        if (delimUnderMouse)
        {
            delimPress = true;
            downX = me.editor.viewPos.x;
            downY = me.editor.viewPos.y;
        }
        /*
        if (delimUnderMouse)
        {
            editor.stateDraggingDelimiter.delimiter = delimUnderMouse;
            editor.changeState(editor.stateDraggingDelimiter);
        }
        else
        {
            var area = editor.field.getAreaByPoint(editor.realPos);
            if (! area) return;
            editor.field.activeArea = area;
            if (! editor.field.activeArea) return;
            editor.stateShiftingArea.startCoord = me.editor.realPos;
            editor.stateShiftingArea.startShiftX = me.editor.field.activeArea.shiftX;
            editor.stateShiftingArea.startShiftY = me.editor.field.activeArea.shiftY;
            editor.changeState(editor.stateShiftingArea);
        }
        */
    };

    me.mouseUp = function()
    {

        
        //let result = null;

        
        
        if (delimPress)
        {
            editor.stateSelectedDelimiter.delimiter = delimUnderMouse;
            return editor.changeState(editor.stateSelectedDelimiter);
        }
        else
        {
            
            var area = editor.field.getAreaByPoint(editor.realPos);
            if (area)
            {
                me.editor.field.setActiveArea(area);
                me.draw();
            }
        }

        delimPress = false;

        //return result;
    };

    me.mouseMove = function(x, y)
    {
        if (delimPress)
        {
            
            if (TR.manhDist(downX, downY, me.editor.viewPos.x, me.editor.viewPos.y) > 2)
            {
                editor.stateDraggingDelimiter.delimiter = delimUnderMouse;
                editor.changeState(editor.stateDraggingDelimiter);
            }
        }
        else
        {
            
            findDelimiterUnderMouse();
            me.draw();
        }


    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

        me.drawDelimiter(delimUnderMouse);
    };

/*
    me.draw = function()
    {
        me.drawTiles();
        me.drawDelimiters(delimUnderMouse);
        me.drawFrame();
        me.drawSizes();
    };
*/
    function findDelimiterUnderMouse()
    {
        if (! me.editor.realPos) return;

        var nearestDelim = null;
        var minDist = Number.POSITIVE_INFINITY;

        for (var i = 0; i < me.editor.field.delimiters.length; i++)
        {
            var delim = me.editor.field.delimiters[i];
            var d;
            if (delim.type == TConf.Delimiter.HOR)
            {
                var start = 0;
                var end = me.editor.field.width;
                if (delim.parent1) start = delim.parent1.pos;
                if (delim.parent2) end = delim.parent2.pos;

                if (me.editor.realPos.x < start || me.editor.realPos.x > end) continue;

                d = Math.abs(delim.pos - editor.realPos.y);
            }
            else
            {
                start = 0;
                end = me.editor.field.height;
                if (delim.parent1) start = delim.parent1.pos;
                if (delim.parent2) end = delim.parent2.pos;

                if (me.editor.realPos.y < start || me.editor.realPos.y > end) continue;

                d = Math.abs(delim.pos - editor.realPos.x);
            }

            if (d < minDist)
            {
                minDist = d;
                nearestDelim = delim;
            }
        }
        if (minDist < 5 / me.editor.scale)
        {
            
            delimUnderMouse = nearestDelim;
        }
        else
        {
            
            delimUnderMouse = null;
        }

    }
};

TConf.StateEditing.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateEditing.prototype.constructor = TConf.StateEditing;

TConf.StateMakingTiles = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateMakingTiles';

    me.currentMaterial = null;
    me.snappedPos = null;

    me.start = function()
    {

    };

    me.mouseMove = function()
    {
        if (me.currentMaterial)
        {
            me.snappedPos = me.editor.snap.getSnapPoint(me.editor.areaPos.x, me.editor.areaPos.y,
                                                        me.currentMaterial.width, me.currentMaterial.height,
                                                        10 / me.editor.scale);
        }

        me.draw();
    };

    me.mouseDown = function()
    {
        if (me.snappedPos)
        {
            me.editor.field.createTile(me.currentMaterial, me.snappedPos.x, me.snappedPos.y);
            me.editor.history.save();
        }

        me.draw();
    };

    me.mouseUp = function()
    {

    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

        var pos = me.snappedPos;
        if (! me.snappedPos) pos = me.editor.areaPos;

        var mat = me.currentMaterial;
        var img = mat.image;
        //pos = new TConf.Point(pos.x - mat.width / 2, pos.y - mat.height / 2);
        var viewPos = me.editor.realToView(pos, me.editor.field.activeArea);

        var ctx = me.editor.context;
        me.editor.context.globalAlpha = 0.3;

        var w = mat.width * me.editor.scale;
        var h = mat.height * me.editor.scale;
        var cx = viewPos.x;// + w / 2;
        var cy = viewPos.y;// + h / 2;
        ctx.translate(cx, cy);
        ctx.rotate(-me.editor.field.activeArea.angle);
        ctx.drawImage(img, -w / 2, -h / 2, w, h);
        ctx.rotate(me.editor.field.activeArea.angle);
        ctx.translate(-cx, -cy);

        me.editor.context.globalAlpha = 1.0;

        if (! me.snappedPos)
        {
            me.editor.context.beginPath();
            me.editor.context.strokeStyle = '#ff0000';
            me.editor.context.lineWidth = 1;
            me.editor.context.moveTo(viewPos.x - 5, viewPos.y - 5);
            me.editor.context.lineTo(viewPos.x + 5, viewPos.y + 5);
            me.editor.context.moveTo(viewPos.x - 5, viewPos.y + 5);
            me.editor.context.lineTo(viewPos.x + 5, viewPos.y - 5);
            me.editor.context.stroke();
            me.editor.context.closePath();
        }
    };

};

TConf.StateMakingTiles.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateMakingTiles.prototype.constructor = TConf.StateMakingTiles;

TConf.StateSelecting = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateSelecting';

    me.startViewCoord = null;
    me.endViewCoord = null;

    me.start = function()
    {
        me.startViewCoord = editor.viewPos;
        me.endViewCoord = editor.viewPos;
        me.draw();
    };

    me.stop = function()
    {

    };

    me.mouseMove = function()
    {
        me.endViewCoord = editor.viewPos;
        me.draw();
    };

    me.mouseUp = function()
    {
        var dist = TR.euclDistP(me.startViewCoord, me.endViewCoord);

        if (me.startViewCoord && me.endViewCoord)
        {
            var selectedTiles = findSelectedTiles();

            if (selectedTiles.length > 0)
            {
                editor.stateSelected.startCoord = me.startCoord;
                editor.stateSelected.currentCoord = me.currentCoord;
                editor.stateSelected.selectedTiles = selectedTiles;

                editor.changeState(editor.stateSelected);
            }
            else
            {
                if (dist < 5)
                {
                    var area = editor.field.getAreaByPoint(editor.realPos);
                    if (area) me.editor.field.setActiveArea(area);
                }
                editor.changeState(editor.stateEditing);
            }
        }
        else
        {
            if (dist < 5)
            {
                area = editor.field.getAreaByPoint(editor.realPos);
                if (area) me.editor.field.setActiveArea(area);
            }
            editor.changeState(editor.stateEditing);
        }
    };

    function findSelectedTiles()
    {
        var A = me.editor.viewToReal(new TConf.Point(me.startViewCoord.x, me.startViewCoord.y), me.editor.field.activeArea);
        var B = me.editor.viewToReal(new TConf.Point(me.startViewCoord.x, me.endViewCoord.y), me.editor.field.activeArea);
        var C = me.editor.viewToReal(new TConf.Point(me.endViewCoord.x, me.endViewCoord.y), me.editor.field.activeArea);
        var D = me.editor.viewToReal(new TConf.Point(me.endViewCoord.x, me.startViewCoord.y), me.editor.field.activeArea);

        return me.editor.field.getTilesInContour([A, B, C, D]);
    }

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        drawSelection()
    };

    function drawSelection()
    {
        var ctx = me.editor.context;

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.rect(me.startViewCoord.x, me.startViewCoord.y, me.endViewCoord.x - me.startViewCoord.x, me.endViewCoord.y - me.startViewCoord.y);
        ctx.stroke();
        ctx.closePath();

        ctx.strokeStyle = '#00aa00';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.rect(me.startViewCoord.x, me.startViewCoord.y, me.endViewCoord.x - me.startViewCoord.x, me.endViewCoord.y - me.startViewCoord.y);
        ctx.stroke();
        ctx.closePath();
        ctx.setLineDash([]);
    }
};

TConf.StateSelecting.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateSelecting.prototype.constructor = TConf.StateSelecting;

TConf.StateSelected = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateSelected';

    me.startCoord = null;
    me.currentCoord = null;
    me.selectedTiles = [];

    me.start = function()
    {
        me.draw();
    };

    me.stop = function()
    {

    };

    me.mouseUp = function()
    {
        editor.changeState(editor.stateEditing);
    };

    function randomRotateSelected()
    {
        for (var i = 0; i < me.selectedTiles.length; i++)
        {
            me.selectedTiles[i].randomRotate();
        }
        me.editor.history.save();
    }

    function clearSelected()
    {
        me.editor.field.removeTiles(me.selectedTiles);
        me.selectedTiles = [];
        editor.changeState(editor.stateEditing);
        me.editor.history.save();
    }

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();
        drawSelection()
    };

    function drawSelection()
    {
        var ctx = me.editor.context;

        for (var i = 0; i < me.selectedTiles.length; i++)
        {
            var tile = me.selectedTiles[i];
            var mat = tile.material;

            var w = mat.width;
            var h = mat.height;
            var A = me.editor.realToView(new TConf.Point(tile.x - w / 2, tile.y - h / 2), me.editor.field.activeArea);
            var B = me.editor.realToView(new TConf.Point(tile.x - w / 2, tile.y + h / 2), me.editor.field.activeArea);
            var C = me.editor.realToView(new TConf.Point(tile.x + w / 2, tile.y + h / 2), me.editor.field.activeArea);
            var D = me.editor.realToView(new TConf.Point(tile.x + w / 2, tile.y - h / 2), me.editor.field.activeArea);

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            me.editor.context.beginPath();
            me.editor.context.moveTo(A.x, A.y);
            me.editor.context.lineTo(B.x, B.y);
            me.editor.context.lineTo(C.x, C.y);
            me.editor.context.lineTo(D.x, D.y);
            me.editor.context.lineTo(A.x, A.y);
            me.editor.context.stroke();
            me.editor.context.closePath();

            ctx.strokeStyle = '#00aa00';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            me.editor.context.beginPath();
            me.editor.context.moveTo(A.x, A.y);
            me.editor.context.lineTo(B.x, B.y);
            me.editor.context.lineTo(C.x, C.y);
            me.editor.context.lineTo(D.x, D.y);
            me.editor.context.lineTo(A.x, A.y);
            me.editor.context.stroke();
            me.editor.context.closePath();
            ctx.setLineDash([]);
        }
    }

    me.keyDown = function(e)
    {
        switch (e.keyCode)
        {
            case 82: // r

            if (e.ctrlKey && e.altKey)
            {
                randomRotateSelected();
                me.draw();
            }
            break;

            case 46: // del
                clearSelected();
                me.draw();
            break;
        }
    }
};

TConf.StateSelected.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateSelected.prototype.constructor = TConf.StateSelected;

TConf.StateShiftingArea = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateShiftingArea';

    me.startCoord = null;
    me.startShiftX = 0;
    me.startShiftY = 0;

    var currentArea = null;

    me.start = function()
    {
        currentArea = editor.field.getAreaByPoint(editor.realPos);
    };

    me.stop = function()
    {
        //me.editor.field.autoFillAll();
        me.editor.history.save();
    };

    me.mouseDown = function ()
    {

    };

    me.mouseMove = function()
    {
        var dx = me.editor.realPos.x - me.startCoord.x;
        var dy = me.editor.realPos.y - me.startCoord.y;
        me.editor.field.activeArea.shiftX = me.startShiftX - dx;
        me.editor.field.activeArea.shiftY = me.startShiftY - dy;

        me.draw();
    };

    me.mouseUp = function()
    {
        if (currentArea)
        {
            var d = TR.euclDist(me.startCoord.x, me.startCoord.y, me.editor.realPos.x, me.editor.realPos.y);
            if (d > 0) me.editor.field.autoFill(currentArea);
            //me.editor.field.setActiveArea(area);
        }

        editor.changeState(editor.stateEditing);
    };
};

TConf.StateShiftingArea.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateShiftingArea.prototype.constructor = TConf.StateShiftingArea;


TConf.StateDraggingMaterial = function(editor)
{
    var me = this;
    TConf.BaseState.call(this);
    me.editor = editor;
    me.name = 'stateDraggingMaterial';

    me.material = null;

    me.start = function()
    {

    };

    me.stop = function()
    {

    };

    me.mouseMove = function()
    {

    };

    me.mouseUp = function()
    {
        var area = editor.field.getAreaByPoint(editor.realPos);
        if (area)
        {
            editor.field.activeArea = area;
            me.editor.field.autoFill(area, me.material);
            me.editor.history.save();
            me.draw();
        }

        editor.changeState(editor.stateEditing);
    };

    var superDraw = me.draw;

    me.draw = function()
    {
        superDraw();

    };
};

TConf.StateDraggingMaterial.prototype = Object.create(TConf.BaseState.prototype);
TConf.StateDraggingMaterial.prototype.constructor = TConf.StateDraggingMaterial;

TConf.TopPanel = function()
{
    var me = this;
    var panel = new R2D.TopLeftPanel();

    var btnUndo = R2D.TopLeftPanel.Button.makeButtonIcon(R2D.STYLE.TLP_ICON_HISTORY_UNDO);
    var btnRedo = R2D.TopLeftPanel.Button.makeButtonIcon(R2D.STYLE.TLP_ICON_HISTORY_REDO);

    btnUndo.addLeftMouseClickListener(undoListener);
    btnRedo.addLeftMouseClickListener(redoListener);

    var elemUndo = new R2D.TopLeftPanel.Element(30, true, [btnUndo]);
    var elemRedo = new R2D.TopLeftPanel.Element(30, true, [btnRedo]);

    panel.add(elemUndo, 1);
    panel.add(elemRedo, 1);

    var btnCM = R2D.TopLeftPanel.Button.makeButtonText('cm');
    var btnFT = R2D.TopLeftPanel.Button.makeButtonText('ft');
    var btnM = R2D.TopLeftPanel.Button.makeButtonText('m');
    var btnMM = R2D.TopLeftPanel.Button.makeButtonText('mm');
    var buttons = [btnCM, btnFT, btnM, btnMM];

    var system = R2D.DimensionSystem.getSystem();
    if (system == R2D.DimensionSystem.METRIC_CM)  buttons = [btnCM, btnFT, btnM, btnMM];
    if (system == R2D.DimensionSystem.METRIC_MM)  buttons = [btnMM, btnCM, btnFT, btnM];
    if (system == R2D.DimensionSystem.METRIC_M)   buttons = [btnM, btnCM, btnFT, btnMM];
    if (system == R2D.DimensionSystem.IMPERIAL_FT)buttons = [btnFT, btnCM, btnM, btnMM];

    btnCM.addLeftMouseClickListener(clickOnDimensionListener);
    btnFT.addLeftMouseClickListener(clickOnDimensionListener);
    btnM.addLeftMouseClickListener(clickOnDimensionListener);
    btnMM.addLeftMouseClickListener(clickOnDimensionListener);

    var dimensions = new R2D.TopLeftPanel.Element(5, false, buttons);
    panel.add(dimensions, 2);

    elemUndo.setActive(false);
    elemRedo.setActive(false);

    elemUndo.setHint('HINT_BUTTON_UNDO');
    elemRedo.setHint('HINT_BUTTON_REDO');

    function clickOnDimensionListener(event)
    {
        var dimensionButton = event.currentTarget;
        var index = buttons.indexOf(dimensionButton);

        if ( index < 0 ) {
            console.warn('Unknown button of dimension!');
            return;
        }
        if ( index == 0 ) {
            return;
        }

        buttons.splice(index, 1);
        buttons.unshift(dimensionButton);

        switch ( dimensionButton ) {
            case btnCM:
                R2D.DimensionSystem.setSystem(R2D.DimensionSystem.METRIC_CM);
                R2D.Behavior.click('Dimension', 'Cm');
                break;

            case btnFT:
                R2D.DimensionSystem.setSystem(R2D.DimensionSystem.IMPERIAL_FT);
                R2D.Behavior.click('Dimension', 'Ft');
                break;

            case btnM:
                R2D.DimensionSystem.setSystem(R2D.DimensionSystem.METRIC_M);
                R2D.Behavior.click('Dimension', 'M');
                break;

            case btnMM:
                R2D.DimensionSystem.setSystem(R2D.DimensionSystem.METRIC_MM);
                R2D.Behavior.click('Dimension', 'Mm');
                break;
        }

        dimensions.updateButtons(buttons);

        panel.dispatchEvent(new Event(Event.CHANGE));
    }

    function undoListener(e)
    {
        panel.dispatchEvent(new Event(TConf.UNDO));
    }

    function redoListener(e)
    {
        panel.dispatchEvent(new Event(TConf.REDO));
    }

    me.setUndoActive = function(active)
    {
        elemUndo.setActive(active);
    };

    me.setRedoActive = function(active)
    {
        elemRedo.setActive(active);
    };

    me.getDomElement = function()
    {
        return panel.getDomElement()
    };

    me.addEventListener = function(type, listener)
    {
        panel.addEventListener(type, listener);
    };

    me.removeEventListener = function(type, listener)
    {
        panel.removeEventListener(type, listener);
    }
};

TConf.TopPanel.UNDO = 'TopPanelUndo';
TConf.TopPanel.REDO = 'TopPanelRedo';
TConf.RightPage = function () {
    R2D.RightPanel.Page.call(this, document.createElement('div'), false, true, false, true);

    var scope = this;
    var body = scope.getDomContent();
    var superSetWidth = scope.setWidth;
    var superSetHeight = scope.setHeight;
    var superSetSize = scope.setSize;

    var btnHelpClear = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({url:R2D.STYLE.TLP_ICON_HELP_SQUARE}, '');
    var btnHelpSave = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({url:R2D.STYLE.TLP_ICON_HELP_SQUARE}, '');
    var btnHelpSplitVert = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({url:R2D.STYLE.TLP_ICON_HELP_SQUARE}, '');
    var btnHelpSplitHor = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({url:R2D.STYLE.TLP_ICON_HELP_SQUARE}, '');

    btnHelpClear.setSize(14, 14);
    btnHelpSave.setSize(14, 14);
    btnHelpSplitVert.setSize(14, 14);
    btnHelpSplitHor.setSize(14, 14);

    //btnHelpClear.addLeftMouseClickListener(function(){R2D.tut.showHelpForButton(R2D.Tutorial.HELP_BUTTON_WALL)});
    //btnHelpSave.addLeftMouseClickListener(function(){R2D.tut.showHelpForButton(R2D.Tutorial.HELP_BUTTON_FLOOR)});
    //btnHelpSplitVert.addLeftMouseClickListener(function(){R2D.tut.showHelpForButton(R2D.Tutorial.HELP_BUTTON_FILL)});
    //btnHelpSplitHor.addLeftMouseClickListener(function(){R2D.tut.showHelpForButton(R2D.Tutorial.HELP_BUTTON_FILL_CUT)});

    var btnClear = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({
        url:R2D.STYLE.TILE_CONFIG_CLEAR
    }, R2D.TRANSLATION.TILE_CONFIG_CLEAR_ALL, true);
    var btnSave = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({
        url:R2D.STYLE.CONSTR_PAGE_ICON_SAVE
    }, R2D.TRANSLATION.TILE_CONFIG_SAVE, true);
    var btnSplitVert = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({
        url:R2D.STYLE.TILE_CONFIG_SPLIT_VERTICAL
    }, R2D.TRANSLATION.TILE_CONFIG_SPLIT_VERTICAL, true);
    var btnSplitHor = new R2D.RightPanel.PageConstruction.ConstructionButtonSquare({
        url:R2D.STYLE.TILE_CONFIG_SPLIT_HORIZONTAL
    }, R2D.TRANSLATION.TILE_CONFIG_SPLIT_HORIZONTAL, true);

    function reposition() {

        var firstLayout = [
            btnSave,
            btnClear,
            btnSplitVert,
            btnSplitHor
        ];
        var thirdLayout = [
            btnHelpClear,
            btnHelpSave,
            btnHelpSplitVert,
            btnHelpSplitHor
        ];

        R2D.Layout.asVerticalGrid(firstLayout, 2, 5, 10, scope.getWidth() - 10, 10);
        R2D.Layout.copyPositions(firstLayout, thirdLayout);

        var d = btnClear.getWidth() - btnHelpClear.getWidth();
        for (var i = 0; i < thirdLayout.length; i++)
        {
            var elem = thirdLayout[i];
            elem.getDomElement().style.left = parseInt(elem.getDomElement().style.left) + d + 'px';
        }

        body.style.width = scope.getWidth() + 'px';
        body.style.height = scope.getHeight() + 'px';
    }

    function translationUpdateEventHandler(event) {
        btnClear.setLabel(R2D.TRANSLATION.TEXT_BUTTON_DRAW_WALL);
        btnSave.setLabel(R2D.TRANSLATION.TEXT_BUTTON_DRAW_ROOM);
        btnSplitVert.setLabel(R2D.TRANSLATION.TEXT_BUTTON_DRAW_FILL);
        btnSplitHor.setLabel(R2D.TRANSLATION.TEXT_BUTTON_CUT_FILL);

        reposition();
    }

    scope.setWidth = function(value) {
        superSetWidth(value);
        reposition();
    };
    scope.setHeight = function(value) {
        superSetHeight(value);
        reposition();
    };
    scope.setSize = function(w, h) {
        superSetSize(w, h);
        reposition();
    };

    body.className = 'rp-page-content';

    reposition();

    body.appendChild(btnClear.getDomElement());
    body.appendChild(btnSave.getDomElement());
    body.appendChild(btnSplitVert.getDomElement());
    body.appendChild(btnSplitHor.getDomElement());

    // Help buttons
    //body.appendChild(btnHelpWall.getDomElement());
    //body.appendChild(btnHelpRoom.getDomElement());
    //body.appendChild(btnHelpFill.getDomElement());
    //body.appendChild(btnHelpFillCut.getDomElement());
    //body.appendChild(btnHelpFloor.getDomElement());
    //body.appendChild(btnHelpFloorCut.getDomElement());
    //body.appendChild(btnHelpDrawing.getDomElement());
    //body.appendChild(btnHelpLow.getDomElement());


    btnClear.addLeftMouseClickListener(clear);
    btnSave.addLeftMouseClickListener(save);
    btnSplitVert.addLeftMouseClickListener(splitVert);
    btnSplitHor.addLeftMouseClickListener(splitHor);

    function clear()
    {
        scope.dispatchEvent(new Event(TConf.CLEAR));
    }

    function save()
    {
        scope.dispatchEvent(new Event(TConf.DONE));
    }

    function splitVert()
    {
        scope.dispatchEvent(new Event(TConf.SPLIT_VER));
    }

    function splitHor()
    {
        scope.dispatchEvent(new Event(TConf.SPLIT_HOR));
    }


    R2D.Translation.addEventListener(Event.UPDATE, translationUpdateEventHandler);
};

// R2D.extend(TConf.RightPage, R2D.RightPanel.Page);
